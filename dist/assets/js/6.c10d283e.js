(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{206:function(_,v,e){"use strict";e.r(v);var t=e(0),l=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"tensorflow2-开篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tensorflow2-开篇"}},[_._v("#")]),_._v(" Tensorflow2-开篇")]),_._v(" "),e("h2",{attrs:{id:"理论部分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理论部分"}},[_._v("#")]),_._v(" 理论部分")]),_._v(" "),e("blockquote",[e("p",[_._v("Tf-keras是什么?")])]),_._v(" "),e("ul",[e("li",[_._v("Tensorflow对keras API规范的实现")]),_._v(" "),e("li",[_._v("相对于以tensorflow为后端的keras,tensorflow-keras与Tensorflow结合更加紧密")]),_._v(" "),e("li",[_._v("实现在tf.keras空间下")])]),_._v(" "),e("blockquote",[e("p",[_._v("Tf-keras和keras联系")])]),_._v(" "),e("ul",[e("li",[_._v("基于同一套API")]),_._v(" "),e("li",[_._v("keras程序可以通过改导入方式轻松转为tf.keras程序")]),_._v(" "),e("li",[_._v("反之不可能")]),_._v(" "),e("li",[_._v("相同的JSON和HDF5模型序列化格式和语义")])]),_._v(" "),e("blockquote",[e("p",[_._v("区别")])]),_._v(" "),e("ul",[e("li",[_._v("Tf-keras 全面支持eager mode")]),_._v(" "),e("li",[_._v("只是用keras.Sequential和keras.Model无影响")]),_._v(" "),e("li",[_._v("自定义Model内部运算逻辑有影响\n- tf底层api可以通过使用keras的model.fit等抽象\n- 适合研究人员")]),_._v(" "),e("li",[_._v("支持基于tf.data的模型训练")]),_._v(" "),e("li",[_._v("支持TPU训练")]),_._v(" "),e("li",[_._v("支持tf.distribution中的分布策略")]),_._v(" "),e("li",[_._v("其他特性")]),_._v(" "),e("li",[_._v("TF.keras可以与Tf中的estimator集成")]),_._v(" "),e("li",[_._v("可以用tf.save")])]),_._v(" "),e("h3",{attrs:{id:"分类问题与回归问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分类问题与回归问题"}},[_._v("#")]),_._v(" 分类问题与回归问题")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("分类问题预测的是类别,模型输出的是概率分布")]),_._v(" "),e("ul",[e("li",[_._v("三分类问题输出例子 : [0.2,0.7,0.1]")])])]),_._v(" "),e("li",[e("p",[_._v("回归问题预测的是值,模型的输出是一个实数值")])])]),_._v(" "),e("h4",{attrs:{id:"目标函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#目标函数"}},[_._v("#")]),_._v(" 目标函数")]),_._v(" "),e("blockquote",[e("p",[_._v("为什么需要目标函数?")])]),_._v(" "),e("ul",[e("li",[_._v("参数是逐步调整的")]),_._v(" "),e("li",[_._v("目标函数可以帮助衡量模型的好坏\n"),e("ul",[e("li",[_._v("Model A: [0.1,0.4,0.5]")]),_._v(" "),e("li",[_._v("Modle B: [0.1,0.2,0.7]")])])])]),_._v(" "),e("p",[_._v("       如上面两组结果,模型A与模型B都可以得出第三组数据为最终的结果,但这两组模型的效果是不同的,如第二组和第三组的概率差别较大,所以,当我们为了衡量魔性的好坏时,我们就需要用到目标函数.")]),_._v(" "),e("hr"),_._v(" "),e("blockquote",[e("p",[_._v("分类问题的目标函数")])]),_._v(" "),e("hr"),_._v(" "),e("ol",[e("li",[_._v("需要衡量目标类别与当前预测的差距")])]),_._v(" "),e("ul",[e("li",[_._v("三分类问题输出例子: [0.2,0.7,0.1]")]),_._v(" "),e("li",[_._v("三分类真是类别: 2 -> one_hot -> [0,0,1]")])]),_._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[_._v("one_hot,字面意思,某一个值为热点,即答案时,将其置位1,琦玉均为0.即真实值的分布.")]),_._v(" "),e("li",[_._v("通过损失函数(目标函数)来判断真实值与模型输出值得差距.")])]),_._v(" "),e("p",[e("code",[_._v("Tip: MarkdownPad上配置的Latex只能使用equation")]),_._v(" "),e("code",[_._v("下面损失函数中 y 均为真实值, Model(x)为预测值")])]),_._v(" "),e("p",[e("strong",[_._v("平方均差损失函数")])]),_._v(" "),e("p",[_._v("\\begin{equation}\n\\frac{1}{n} \\sum_{x,y} \\frac{1}{2}(y-Model(x))^2\n\\end{equation}")]),_._v(" "),e("p",[e("strong",[_._v("交叉熵损失函数")])]),_._v(" "),e("p",[_._v("\\begin{equation}\n\\frac{1}{n} \\sum_{x,y} y \\ln{(Model(x))}\n\\end{equation}")]),_._v(" "),e("hr"),_._v(" "),e("blockquote",[e("p",[_._v("回归问题的目标函数")])]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("       因为回归问题输入输出均为值,所以只需要判断其预测值与真实值的差异即可.")]),_._v(" "),e("ul",[e("li",[_._v("预测值与真实值的差异")]),_._v(" "),e("li",[_._v("平方差损失")]),_._v(" "),e("li",[_._v("绝对值损失")])]),_._v(" "),e("p",[e("strong",[_._v("模型的训练就是通过调整参数,使损失(目标)函数的值逐渐缩小的过程.")])])])}),[],!1,null,null,null);v.default=l.exports}}]);