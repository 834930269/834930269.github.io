(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{221:function(_,v,t){"use strict";t.r(v);var a=t(0),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#_1-动态规划四大组成部分"}},[_._v("1. 动态规划四大组成部分")]),t("ul",[t("li",[t("a",{attrs:{href:"#_1-确定状态"}},[_._v("1. 确定状态")])])])]),t("li",[t("a",{attrs:{href:"#_2-划分式动态规划"}},[_._v("2. 划分式动态规划")]),t("ul",[t("li",[t("a",{attrs:{href:"#举栗子"}},[_._v("举栗子")])]),t("li",[t("a",{attrs:{href:"#降维"}},[_._v("降维")])])])])])]),t("p"),_._v(" "),t("h1",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[_._v("#")]),_._v(" 动态规划")]),_._v(" "),t("h2",{attrs:{id:"_1-动态规划四大组成部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-动态规划四大组成部分"}},[_._v("#")]),_._v(" 1. 动态规划四大组成部分")]),_._v(" "),t("h3",{attrs:{id:"_1-确定状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-确定状态"}},[_._v("#")]),_._v(" 1. 确定状态")]),_._v(" "),t("ul",[t("li",[_._v("状态在动态规划中的作用属于定海神针")]),_._v(" "),t("li",[_._v("简单地说,解决动态规划的时候需要开一个数组,数组的每个元素f[i]或者f[i][j]代表什么")]),_._v(" "),t("li",[_._v("类似于解数学题中,X,Y,Z代表什么")])]),_._v(" "),t("blockquote",[t("p",[_._v("那么依赖什么来确定状态呢?")]),_._v(" "),t("blockquote",[t("ol",[t("li",[_._v("最后一步")]),_._v(" "),t("li",[_._v("子问题")])])])]),_._v(" "),t("p",[t("font",{attrs:{color:"#d1e"}},[_._v("so.什么是最后一步?")])],1),_._v(" "),t("p",[_._v("       🤞举个栗子:")]),_._v(" "),t("ul",[t("li",[_._v("虽然我们不知道最优策略是什么,但是最优策略肯定是K枚硬币a1,a2...ak面值加起来为27")]),_._v(" "),t("li",[_._v("所以一定会有最后一枚硬币ak")]),_._v(" "),t("li",[_._v("除掉这枚硬币,前面的硬币的面值加起来是27-ak")]),_._v(" "),t("li",[_._v("...")])]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[_._v("关键点:")]),_._v(" "),t("ul",[t("li",[_._v("我们并不关心K-1枚硬币是怎么拼出27-ak的.我们甚至不知道ak和K.但是我们知道前面的硬币一定拼出了27-ak")]),_._v(" "),t("li",[_._v("因为是最优策略,所以27-ak的硬币数一定是最少的")])]),_._v(" "),t("p",[t("font",{attrs:{color:"#f28"}},[_._v("所以我们可以这样来做: 最少用多少枚硬币可以拼出27-ak")])],1),_._v(" "),t("ul",[t("li",[_._v("故原问题转换成了一个子问题("),t("code",[_._v("规模缩小")]),_._v("): 27-ak")]),_._v(" "),t("li",[_._v("为了简化定义,我们设状态f(X) = 最少用多少枚硬币拼出X")])])]),_._v(" "),t("p",[_._v("       🎃"),t("font",{attrs:{color:"red"}},[_._v("但我们始终还不知道ak是啥???")])],1),_._v(" "),t("ul",[t("li",[_._v("最后那枚硬币只可能是2,5,7")]),_._v(" "),t("li",[_._v("若是2,则f(27) = f(27-2) + 1")]),_._v(" "),t("li",[_._v("若是5,则f(27) = f(27-5) + 1")]),_._v(" "),t("li",[_._v("若是7,则f(27) = f(27-7) + 1")]),_._v(" "),t("li",[_._v("最少的硬币数,则 "),t("code",[_._v("f(27) = min{上面三个}")])])]),_._v(" "),t("p",[_._v("       这道题如果用递归解法,会出现一个问题,即同样的子问题被计算了多次,所以为了解决这个问题,引入了记忆数组这玩意来剪枝.")]),_._v(" "),t("h2",{attrs:{id:"_2-划分式动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-划分式动态规划"}},[_._v("#")]),_._v(" 2. 划分式动态规划")]),_._v(" "),t("h3",{attrs:{id:"举栗子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#举栗子"}},[_._v("#")]),_._v(" 举栗子")]),_._v(" "),t("p",[t("code",[_._v("LintCode 512. Decode Ways")])]),_._v(" "),t("center",[t("strong",[_._v("解码方法")])]),_._v(" "),t("p",[_._v("       题目:")]),_._v(" "),t("pre",[t("code",[_._v("有一个消息包含A-Z通过以下规则编码\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n\n现在给你一个加密过后的消息，问有几种解码的方式\n")])]),_._v(" "),t("p",[_._v("       样例:")]),_._v(" "),t("pre",[t("code",[_._v('样例 1:\n\n输入: "12"\n输出: 2\n解释: 它可以被解码为 AB (1 2) 或 L (12).\n\n样例 2:\n\n输入: "10"\n输出: 1\n')])]),_._v(" "),t("blockquote",[t("p",[_._v("这道题问的是有多少种解码方式,但其实他的划分比较少")]),_._v(" "),t("blockquote",[t("p",[_._v("观察题干,发现最多两个数字组成一个字母.所以连续两个最多划分成两个子集")])])]),_._v(" "),t("p",[_._v("       那么我们考虑:")]),_._v(" "),t("center",[_._v("\n0 1 2 5 8 7 ... 5 4 3 `8`\n"),t("p",[_._v("0 1 2 5 8 7 ... 5 4 "),t("code",[_._v("3 8")])])]),_._v(" "),t("p",[_._v("       这两种情况,第一串将"),t("code",[_._v("8")]),_._v("作为一种解密方式,则结果就是前面所有的解密方式+1")]),_._v(" "),t("p",[_._v("       第二种情况将"),t("code",[_._v("38")]),_._v("看做一体,但发现"),t("code",[_._v("38")]),_._v("不能组成字母,所以无效.如果可以的话,结果就是前面的解密方式+1")]),_._v(" "),t("p",[_._v("       最后的答案就是这两种解密方式的和.")]),_._v(" "),t("blockquote",[t("p",[_._v("状态转移方程(f[i][j]代表第i位置上的方案,0为取一个,1为取两个):")]),_._v(" "),t("blockquote",[t("p",[_._v("ans = f[n][0] + f[n][1]\nf[n][0] = (可以解密)f[n-1][0]+f[n-1][1]+1\nf[n][1] = (能解密的话)f[n-1][0]\nf[n][1] = f[n][0] = (不能解密) 0")])])]),_._v(" "),t("blockquote",[t("p",[_._v("代码放在题解中")])]),_._v(" "),t("h3",{attrs:{id:"降维"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#降维"}},[_._v("#")]),_._v(" 降维")]),_._v(" "),t("blockquote",[t("p",[_._v("我们发现每次计算的时候如果是前两个数字组合的话是 往前两位的所有可能性+1,故可以降维")])]),_._v(" "),t("blockquote",[t("p",[_._v("转移方程: f[i] = f[i-1] | S(i-1)对应一个字母 + f[i-2] | S(i-1)S(i-2)对应一个字母")])])],1)}),[],!1,null,null,null);v.default=e.exports}}]);