(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{218:function(_,v,t){"use strict";t.r(v);var a=t(0),l=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#_1-动态规划四大组成部分"}},[_._v("1. 动态规划四大组成部分")]),t("ul",[t("li",[t("a",{attrs:{href:"#_1-确定状态"}},[_._v("1. 确定状态")])])])])])]),t("p"),_._v(" "),t("h1",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[_._v("#")]),_._v(" 动态规划")]),_._v(" "),t("h2",{attrs:{id:"_1-动态规划四大组成部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-动态规划四大组成部分"}},[_._v("#")]),_._v(" 1. 动态规划四大组成部分")]),_._v(" "),t("h3",{attrs:{id:"_1-确定状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-确定状态"}},[_._v("#")]),_._v(" 1. 确定状态")]),_._v(" "),t("ul",[t("li",[_._v("状态在动态规划中的作用属于定海神针")]),_._v(" "),t("li",[_._v("简单地说,解决动态规划的时候需要开一个数组,数组的每个元素f[i]或者f[i][j]代表什么")]),_._v(" "),t("li",[_._v("类似于解数学题中,X,Y,Z代表什么")])]),_._v(" "),t("blockquote",[t("p",[_._v("那么依赖什么来确定状态呢?")]),_._v(" "),t("blockquote",[t("ol",[t("li",[_._v("最后一步")]),_._v(" "),t("li",[_._v("子问题")])])])]),_._v(" "),t("p",[t("font",{attrs:{color:"#d1e"}},[_._v("so.什么是最后一步?")])],1),_._v(" "),t("p",[_._v("       🤞举个栗子:")]),_._v(" "),t("ul",[t("li",[_._v("虽然我们不知道最优策略是什么,但是最优策略肯定是K枚硬币a1,a2...ak面值加起来为27")]),_._v(" "),t("li",[_._v("所以一定会有最后一枚硬币ak")]),_._v(" "),t("li",[_._v("除掉这枚硬币,前面的硬币的面值加起来是27-ak")]),_._v(" "),t("li",[_._v("...")])]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[_._v("关键点:")]),_._v(" "),t("ul",[t("li",[_._v("我们并不关心K-1枚硬币是怎么拼出27-ak的.我们甚至不知道ak和K.但是我们知道前面的硬币一定拼出了27-ak")]),_._v(" "),t("li",[_._v("因为是最优策略,所以27-ak的硬币数一定是最少的")])]),_._v(" "),t("p",[t("font",{attrs:{color:"#f28"}},[_._v("所以我们可以这样来做: 最少用多少枚硬币可以拼出27-ak")])],1),_._v(" "),t("ul",[t("li",[_._v("故原问题转换成了一个子问题("),t("code",[_._v("规模缩小")]),_._v("): 27-ak")]),_._v(" "),t("li",[_._v("为了简化定义,我们设状态f(X) = 最少用多少枚硬币拼出X")])])]),_._v(" "),t("p",[_._v("       🎃"),t("font",{attrs:{color:"red"}},[_._v("但我们始终还不知道ak是啥???")])],1),_._v(" "),t("ul",[t("li",[_._v("最后那枚硬币只可能是2,5,7")]),_._v(" "),t("li",[_._v("若是2,则f(27) = f(27-2) + 1")]),_._v(" "),t("li",[_._v("若是5,则f(27) = f(27-5) + 1")]),_._v(" "),t("li",[_._v("若是7,则f(27) = f(27-7) + 1")]),_._v(" "),t("li",[_._v("最少的硬币数,则 "),t("code",[_._v("f(27) = min{上面三个}")])])]),_._v(" "),t("p",[_._v("       这道题如果用递归解法,会出现一个问题,即同样的子问题被计算了多次,所以为了解决这个问题,引入了记忆数组这玩意来剪枝.")])])}),[],!1,null,null,null);v.default=l.exports}}]);