(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{597:function(t,e,s){"use strict";s.r(e);var a=s(0),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#eventsystem-unity事件系统"}},[t._v("EventSystem (Unity事件系统)")]),s("ul",[s("li",[s("a",{attrs:{href:"#描述"}},[t._v("描述")])])])])])]),s("p"),t._v(" "),s("h1",{attrs:{id:"vr开发日记-2020-8-10"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vr开发日记-2020-8-10"}},[t._v("#")]),t._v(" VR开发日记 2020-8-10")]),t._v(" "),s("p",[t._v("今天做自动门,一段距离内感应到人后自动打开,走出这段距离则自动关上,并且对碰撞体做了黑屏处理(就是尽量避免玩家穿模)")]),t._v(" "),s("p",[t._v("但是出现了一个问题,找了好久好久,就是之前的EventSystem组件是跟随者Canvas的,但是添加了黑屏处理后,Canvas就不能使用了,找了好久好久都没有定位到问题究竟在哪,最后一直瞎试,发现EventSystem必须脱离Canvas,直接放到全局里,这样就可以了,所以我思考是否是因为VRTK的黑屏处理组件也需要依赖EventSystem(一个游戏里只能有一个),所以才需要将EventSystem放到全局.")]),t._v(" "),s("p",[t._v("既然这样的话,就稍微学下EventSystem到底是什么东西吧")]),t._v(" "),s("h2",{attrs:{id:"eventsystem-unity事件系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eventsystem-unity事件系统"}},[t._v("#")]),t._v(" EventSystem (Unity事件系统)")]),t._v(" "),s("h3",{attrs:{id:"描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),s("p",[t._v("处理输入、射线和发送事件。")]),t._v(" "),s("p",[t._v("在Unity场景中EventSystem主要负责加工和处理事件。一个场景只能含有一个EventSystem。")]),t._v(" "),s("p",[t._v("EventSystem基于Input，可以对键盘，鼠标，触摸，以及自定义输入进行处理。"),s("br"),t._v("\nEventSystem本身是一个管理控制器，核心功能依赖InputModule和Raycaster模块。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("InputModule用来处理Input数据，管理事件状态，和发送事件给GameObject。\n\nRaycaster用来捕获哪些GameObject需要执行事件处理：\n    Graphic Raycaster     用于UI元素就是继承自Graphic的对象;\n    Physics2D Raycaster   用于2D物理碰撞元素，依赖于Collider2D;\n    Physics Raycaster     用于3D物理碰撞元素，依赖于Collider;\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("有上述描述可以不难发现,对于Canvas的触发事件,完全会交由EventSystem来截取,以及碰撞事件.所以这就从侧面说明了为什么VRTK的这两个功能模块会需要用到EventSystem组件")]),t._v(" "),s("p",[t._v("总体从输入到事件系统的流程图:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img2018.cnblogs.com/blog/1362861/202001/1362861-20200119234451783-978761266.png",alt:""}})]),t._v(" "),s("p",[t._v("两篇文章:")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/blueberryzzz/p/12216045.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/blueberryzzz/p/12216045.html"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.jianshu.com/p/2058eeee001a",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.jianshu.com/p/2058eeee001a"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);