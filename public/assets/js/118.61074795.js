(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{597:function(t,e,n){"use strict";n.r(e);var i=n(0),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p"),n("div",{staticClass:"table-of-contents"},[n("ul",[n("li",[n("a",{attrs:{href:"#vrtk-uicanvas"}},[t._v("VRTK_UICanvas")]),n("ul",[n("li",[n("a",{attrs:{href:"#译"}},[t._v("译")])])])]),n("li",[n("a",{attrs:{href:"#vrtk-uipointer"}},[t._v("VRTK_UIPointer")]),n("ul",[n("li",[n("a",{attrs:{href:"#译"}},[t._v("译")])])])])])]),n("p"),t._v(" "),n("h1",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),n("blockquote",[n("p",[t._v("VRTK/Scripts/UI")])]),t._v(" "),n("p",[t._v("一个关于与Unity UI交互的脚本集")]),t._v(" "),n("h2",{attrs:{id:"vrtk-uicanvas"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vrtk-uicanvas"}},[t._v("#")]),t._v(" VRTK_UICanvas")]),t._v(" "),n("p",[t._v("Overview")]),t._v(" "),n("p",[t._v("Denotes a Unity World UI Canvas can be interacted with a UIPointer script.")]),t._v(" "),n("p",[t._v("Script Usage:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Place the VRTK_UICanvas script on the Unity World UI Canvas to allow UIPointer interactions with.\n")])])]),n("p",[t._v("Script Dependencies:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("A UI Pointer attached to another GameObject (e.g. controller script alias) to interact with the UICanvas script.\n")])])]),n("p",[t._v("Inspector Parameters")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Click On Pointer Collision: Determines if a UI Click action should happen when a UI Pointer game object collides with this canvas.\nAuto Activate Within Distance: Determines if a UI Pointer will be auto activated if a UI Pointer game object comes within the given distance of this canvas. If a value of 0 is given then no auto activation will occur.\n")])])]),n("p",[t._v("Example")]),t._v(" "),n("p",[t._v("VRTK/Examples/034_Controls_InteractingWithUnityUI uses the VRTK_UICanvas script on two of the canvases to show how the UI Pointer can interact with them.")]),t._v(" "),n("h3",{attrs:{id:"译"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#译"}},[t._v("#")]),t._v(" 译")]),t._v(" "),n("p",[t._v("总览:"),n("br"),t._v("\n可以使Unity世界中的UICanvas与VRTK的UIPointer进行交互的脚本集.")]),t._v(" "),n("p",[t._v("脚本用例:"),n("br"),t._v("\n将"),n("code",[t._v("VRTK_UICanvas")]),t._v("脚本挂载在Unity世界的UICanvas上,则该UICanvas就可以与VRTK的UIPointer进行交互")]),t._v(" "),n("p",[t._v("参数:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("Click On Pointer Collision")]),t._v(": 决定UI是否允许发生点击事件当UIPointer与canvas发生碰撞的时候.")]),t._v(" "),n("li",[n("code",[t._v("Auto Activate Within Distance")]),t._v(": 决定是否在一定距离内自动触发UIPoniter(与Canvas的距离),如果值=0则代表不触发.")])]),t._v(" "),n("p",[t._v("示例:"),n("br"),t._v(" "),n("code",[t._v("VRTK/Examples/034_Controls_InteractingWithUnityUI")])]),t._v(" "),n("h2",{attrs:{id:"vrtk-uipointer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vrtk-uipointer"}},[t._v("#")]),t._v(" VRTK_UIPointer")]),t._v(" "),n("p",[t._v("Overview")]),t._v(" "),n("p",[t._v("Provides the ability to interact with UICanvas elements and the contained Unity UI elements within.")]),t._v(" "),n("p",[t._v("Optional Components:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("VRTK_ControllerEvents - The events component to listen for the button presses on. This must be applied on the same GameObject as this script if one is not provided via the Controller parameter.\n")])])]),n("p",[t._v("Script Usage:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Place the VRTK_UIPointer script on either:\n    The controller script alias GameObject of the controller to emit the UIPointer from (e.g. Right Controller Script Alias).\n    Any other scene GameObject and provide a valid Transform component to the Pointer Origin Transform parameter of this script. This does not have to be a controller and can be any GameObject that will emit the UIPointer.\n")])])]),n("p",[t._v("Script Dependencies:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("A UI Canvas attached to a Unity World UI Canvas.\n")])])]),n("p",[t._v("Inspector Parameters")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Activation Button: The button used to activate/deactivate the UI raycast for the pointer.\nActivation Mode: Determines when the UI pointer should be active.\nSelection Button: The button used to execute the select action at the pointer's target position.\nClick Method: Determines when the UI Click event action should happen.\nAttempt Click On Deactivate: Determines whether the UI click action should be triggered when the pointer is deactivated. If the pointer is hovering over a clickable element then it will invoke the click action on that element. Note: Only works with Click Method = Click_On_Button_Up\nClick After Hover Duration: The amount of time the pointer can be over the same UI element before it automatically attempts to click it. 0f means no click attempt will be made.\nMaximum Length: The maximum length the UI Raycast will reach.\nAttached To: An optional GameObject that determines what the pointer is to be attached to. If this is left blank then the GameObject the script is on will be used.\nController Events: The Controller Events that will be used to toggle the pointer. If the script is being applied onto a controller then this parameter can be left blank as it will be auto populated by the controller the script is on at runtime.\nCustom Origin: A custom transform to use as the origin of the pointer. If no pointer origin transform is provided then the transform the script is attached to is used.\n")])])]),n("p",[t._v("Class Variables")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public enum ActivationMethods - Methods of activation.\n    HoldButton - Only activates the UI Pointer when the Pointer button on the controller is pressed and held down.\n    ToggleButton - Activates the UI Pointer on the first click of the Pointer button on the controller and it stays active until the Pointer button is clicked again.\n    AlwaysOn - The UI Pointer is always active regardless of whether the Pointer button on the controller is pressed or not.\npublic enum ClickMethods - Methods of when to consider a UI Click action\n    ClickOnButtonUp - Consider a UI Click action has happened when the UI Click alias button is released.\n    ClickOnButtonDown - Consider a UI Click action has happened when the UI Click alias button is pressed.\npublic GameObject autoActivatingCanvas - The GameObject of the front trigger activator of the canvas currently being activated by this pointer. Default: null\npublic bool collisionClick - Determines if the UI Pointer has collided with a valid canvas that has collision click turned on. Default: false\n")])])]),n("p",[t._v("Class Events")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("ActivationButtonPressed - Emitted when the UI activation button is pressed.\nActivationButtonReleased - Emitted when the UI activation button is released.\nSelectionButtonPressed - Emitted when the UI selection button is pressed.\nSelectionButtonReleased - Emitted when the UI selection button is released.\nUIPointerElementEnter - Emitted when the UI Pointer is colliding with a valid UI element.\nUIPointerElementExit - Emitted when the UI Pointer is no longer colliding with any valid UI elements.\nUIPointerElementClick - Emitted when the UI Pointer has clicked the currently collided UI element.\nUIPointerElementDragStart - Emitted when the UI Pointer begins dragging a valid UI element.\nUIPointerElementDragEnd - Emitted when the UI Pointer stops dragging a valid UI element.\n")])])]),n("p",[t._v("Unity Events")]),t._v(" "),n("p",[t._v("Adding the VRTK_UIPointer_UnityEvents component to VRTK_UIPointer object allows access to UnityEvents that will react identically to the Class Events.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("All C# delegate events are mapped to a Unity Event with the On prefix. e.g. MyEvent -> OnMyEvent.\n")])])]),n("p",[t._v("Event Payload")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("VRTK_ControllerReference controllerReference - The reference to the controller that was used.\nbool isActive - The state of whether the UI Pointer is currently active or not.\nGameObject currentTarget - The current UI element that the pointer is colliding with.\nGameObject previousTarget - The previous UI element that the pointer was colliding with.\nRaycastResult raycastResult - The raw raycast result of the UI ray collision.\n")])])]),n("p",[t._v("Class Methods\nGetPointerLength/1")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public static float GetPointerLength(int pointerId)\n\nParameters\n    int pointerId - The pointer ID for the UI Pointer to recieve the length for.\nReturns\n    float - The maximum length the UI Pointer will cast to.\n")])])]),n("p",[t._v("The GetPointerLength method retrieves the maximum UI Pointer length for the given pointer ID.\nSetEventSystem/1")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual VRTK_VRInputModule SetEventSystem(EventSystem eventSystem)\n\nParameters\n    EventSystem eventSystem - The global Unity event system to be used by the UI pointers.\nReturns\n    VRTK_VRInputModule - A custom input module that is used to detect input from VR pointers.\n")])])]),n("p",[t._v("The SetEventSystem method is used to set up the global Unity event system for the UI pointer. It also handles disabling the existing Standalone Input Module that exists on the EventSystem and adds a custom VRTK Event System VR Input component that is required for interacting with the UI with VR inputs.\nRemoveEventSystem/0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual void RemoveEventSystem()\n\nParameters\n    none\nReturns\n    none\n")])])]),n("p",[t._v("The RemoveEventSystem resets the Unity EventSystem back to the original state before the VRTK_VRInputModule was swapped for it.\nPointerActive/0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual bool PointerActive()\n\nParameters\n    none\nReturns\n    bool - Returns true if the ui pointer should be currently active.\n")])])]),n("p",[t._v("The PointerActive method determines if the ui pointer beam should be active based on whether the pointer alias is being held and whether the Hold Button To Use parameter is checked.\nIsActivationButtonPressed/0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual bool IsActivationButtonPressed()\n\nParameters\n    none\nReturns\n    bool - Returns true if the activation button is active.\n")])])]),n("p",[t._v("The IsActivationButtonPressed method is used to determine if the configured activation button is currently in the active state.\nIsSelectionButtonPressed/0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual bool IsSelectionButtonPressed()\n\nParameters\n    none\nReturns\n    bool - Returns true if the selection button is active.\n")])])]),n("p",[t._v("The IsSelectionButtonPressed method is used to determine if the configured selection button is currently in the active state.\nValidClick/2")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)\n\nParameters\n    bool checkLastClick - If this is true then the last frame's state of the UI Click button is also checked to see if a valid click has happened.\n    bool lastClickState - This determines what the last frame's state of the UI Click button should be in for it to be a valid click.\nReturns\n    bool - Returns true if the UI Click button is in a valid state to action a click, returns false if it is not in a valid state.\n")])])]),n("p",[t._v("The ValidClick method determines if the UI Click button is in a valid state to register a click action.\nGetOriginPosition/0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual Vector3 GetOriginPosition()\n\nParameters\n    none\nReturns\n    Vector3 - A Vector3 of the pointer transform position\n")])])]),n("p",[t._v("The GetOriginPosition method returns the relevant transform position for the pointer based on whether the pointerOriginTransform variable is valid.\nGetOriginForward/0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public virtual Vector3 GetOriginForward()\n\nParameters\n    none\nReturns\n    Vector3 - A Vector3 of the pointer transform forward\n")])])]),n("p",[t._v("The GetOriginPosition method returns the relevant transform forward for the pointer based on whether the pointerOriginTransform variable is valid.\nExample")]),t._v(" "),n("p",[t._v("VRTK/Examples/034_Controls_InteractingWithUnityUI uses the VRTK_UIPointer script on the right Controller to allow for the interaction with Unity UI elements using a Simple Pointer beam. The left Controller controls a Simple Pointer on the headset to demonstrate gaze interaction with Unity UI elements.")]),t._v(" "),n("h3",{attrs:{id:"译-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#译-2"}},[t._v("#")]),t._v(" 译")]),t._v(" "),n("p",[t._v("概述:"),n("br"),t._v("\n提供了一个与UICanvas交互能力的组件")]),t._v(" "),n("p",[t._v("配置组件:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("VRTK_ControllerEvents")]),t._v(": 该事件组件监听按钮被按下,该组件必须与Controller在同一个GameObject下")])]),t._v(" "),n("p",[t._v("示例:")]),t._v(" "),n("ul",[n("li",[t._v("挂载"),n("code",[t._v("VRTK_UIPointer")]),t._v("脚本:\n"),n("ul",[n("li",[t._v("该脚本挂载的GameObject可以发出UIPointer")]),t._v(" "),n("li",[t._v("场景中任何提供了"),n("code",[t._v("Transfrom")]),t._v("的组件给该组件的参数"),n("code",[t._v("Pointer Origin Transform")]),t._v(".想要触发"),n("code",[t._v("UIPointer")]),t._v("不需要必须是"),n("code",[t._v("Controller")]),t._v(",它可以是任何GameObject.")])])])]),t._v(" "),n("p",[t._v("主要参数:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("Activation Button")]),t._v(": 这个按钮被用于激活指针的UI raycast")]),t._v(" "),n("li",[n("code",[t._v("Activation Mode")]),t._v(": 决定UIPointer是否会被激活")]),t._v(" "),n("li",[n("code",[t._v("Selection Button")]),t._v(": 该按钮被用于执行指针所指位置的选择行为.")]),t._v(" "),n("li",[n("code",[t._v("Click Method")]),t._v(": 决定当UIClick事件发生时触发的事件")]),t._v(" "),n("li",[n("code",[t._v("Attemp Click On Deactivate")]),t._v(": 决定是否会触发UI点击事件当指针被停用.如果指针停留在"),n("code",[t._v("可点击元素")]),t._v("上将会引导至该元素的点击事件.提示: 只有当"),n("code",[t._v("Clicke Method=Click_On_Button_Up")]),t._v("时才会触发.")]),t._v(" "),n("li",[n("code",[t._v("Click After Hover Duration")]),t._v(": 当指针在UI元素上停留一段时间后触发点击事件")]),t._v(" "),n("li",[n("code",[t._v("Maximum Length")]),t._v(": 指针与Canvas的最长距离")]),t._v(" "),n("li",[n("code",[t._v("Attach To")]),t._v(": 一个可选的游戏对象,用于确定指针附着在哪个对象上,如果此项留空,则使用该脚本所在的游戏对象.")]),t._v(" "),n("li",[n("code",[t._v("Controller Events")]),t._v(": 这个事件将会被触发在Poniter被切换的时候,如果留空,则会在运行时被自动填充.")]),t._v(" "),n("li",[n("code",[t._v("Custom Origin")]),t._v(": 用作指针的自定义,不填充则使用圆形.")])]),t._v(" "),n("p",[t._v("--2020/8/5--")])])}),[],!1,null,null,null);e.default=a.exports}}]);