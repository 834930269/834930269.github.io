{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"Hello World","slug":"hello-world","date":"2019-07-03T12:04:42.190Z","updated":"2019-07-03T12:04:42.190Z","comments":true,"path":"api/articles/hello-world.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"Record","slug":"record","date":"2019-04-12T03:48:37.000Z","updated":"2019-07-03T14:10:40.145Z","comments":true,"path":"api/articles/record.json","excerpt":"<p>2019/4/12 - 奥克诺斯 <img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%A5%A5%E5%85%8B%E8%AF%BA%E6%96%AF.png\" alt> </p>","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%A5%A5%E5%85%8B%E8%AF%BA%E6%96%AF.png","content":null,"text":"2019/4/12 - 奥克诺斯  [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"JeffE-3-1-递归起源","slug":"jeffe-3-1-dporigin","date":"2019-04-08T13:08:05.000Z","updated":"2019-07-03T13:51:36.870Z","comments":true,"path":"api/articles/jeffe-3-1-dporigin.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2019/04/QQ%E6%88%AA%E5%9B%BE20190408205641.png","content":"<p>[TOC]</p>\n<h1 id=\"3-1-matra-vrtta\"><a href=\"#3-1-matra-vrtta\" class=\"headerlink\" title=\"3.1 matra-vrtta\"></a>3.1 matra-vrtta</h1><hr>\n<p>关于<code>递归方法</code>最早的例子之一是出现在距今2000多年前的<code>古印度</code>时期关于诗词韵律(arose)或者诗体韵律的学习中.古典梵语诗集(Classical Sanskrit poetry)有别于音节(syllables)的两种类型: 明亮和沉重.在一组韵律中(In one class of meters),韵律丰富的被叫做[matravrtta]或者[matrameru]或[matrachanda],诗的每一行都有固定个数的”beats”,如亮音节最后会有一个beat,而重音节最后会有两个beat.正规的matra-vrtta的学习要追溯到 Chandahsastra,出自Pingala学者(Scholar),公元前600年和200年间,Pingala发现 5-4节拍: –，-··，·-·，··-，····。（这里每个”-“代表了一个常寅杰,每个”·”代表了一个短音节.） 尽管Pingala的文章给计数音节一个系统化的<code>提示</code>了,这项规定仍花了大约一千年的时间才得以明确表述。【it took about,他花费了大约】在公元前七世纪,另一个印度学者Virahanka书写了一篇Pingala著作的评注,其中(in which)，他观察到n拍的节拍(meter)数是（n-2）拍的节拍数和（n-1）拍的节拍数之和。</p>\n<blockquote>\n<p>用更现代的符号表示,Virahanka的研究发现了总会出现一个循环当n-beat节拍的节拍总数M(n)满足</p>\n</blockquote>\n<p><code>M(n)=M(n-2)+M(n-1)</code> 不难看出<code>M(0)=1</code> (只存在一个空节拍)和<code>M(1)=1</code>(唯一的一个节拍由一个单独的短音节组成). 同样的循环结论出现在欧洲大约在Virahanka500年前,在Leonardo Pisano(莱昂纳多·比萨诺)的1202论文<code>Liber Abaci</code>中,这个欧洲最早关于”算法”的论文中,使用Virahanka的循环,用现代的<code>Fibonacci number</code> 定义了这一现象: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/QQ截图20190408205641.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/QQ%E6%88%AA%E5%9B%BE20190408205641.png\" alt></a> 即,对于所有的n,我们规定 M(n)=F(n+1)</p>\n<h2 id=\"回溯-Backtracking-很慢\"><a href=\"#回溯-Backtracking-很慢\" class=\"headerlink\" title=\"回溯(Backtracking)很慢\"></a>回溯(Backtracking)很慢</h2><p>这个由递归定义的Fibonacci number 立即给了我们一种用递归处理的算法来解决他们.伪码如下: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码1-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%811-1.png\" alt></a> 不幸的是,这个naive的递归算法是令人窒息的慢.除了递归调用(calls),这整个算法全程只有一个常量,这个变量每轮递归的操作也只有一次: 一次比较或者一次加法运算. 我们让<code>T(n)</code>表示(denote)为RECFIBO的<code>递归调用次数</code>;这个函数满足这个循环: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/recurrence1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/recurrence1.png\" alt></a> 这(which)看起来很像(an awful lot like)斐波那契数列的递归式! 将T(n)的前几个值(the first several)写出来(writing out),就得到了 封闭解(close-form solution,即通解): <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/通解1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E9%80%9A%E8%A7%A31.png\" alt></a> 我们可以通过数学归纳法来证实它.</p>\n<h3 id=\"下面是算法复杂度的\"><a href=\"#下面是算法复杂度的\" class=\"headerlink\" title=\"下面是算法复杂度的\"></a>下面是算法复杂度的</h3><p>所以计算F(n)使用这个算法计算的时间大约是普通递归算法的<code>一半时间</code>左右.还有一种超出了本书范围的方法来衡量时间,即<a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/通解2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E9%80%9A%E8%A7%A32.png\" alt></a>,其中<a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/通解3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E9%80%9A%E8%A7%A33.png\" alt></a>被叫做黄金分割比.简而言之(in short),这个递归算法的运行时间是n的指数倍。<code>[时间复杂度]</code></p>\n<blockquote>\n<p>下面这段翻译不是太好…</p>\n</blockquote>\n<p>我们可以很直接看到指数增长.考虑RECFIBO这个递归树作为一个累加的二叉树,叶子节点上只有0和1,因为最终输出的是F(n),恰好F(n)的叶子结点的值必有1;这些叶子节点表示调用RECRIBO(1).一个简单的归纳表示RECFIBO(0)被调用了F(n-1)次.(如果我们只想得到渐进界限(bound),他足够表明(observe)调用RECFIBO(0)的次数最多是(is at most number of)调用RECFIBO(1)的次数。)因此(thus),这个递归树正好有(has exactly)F(n)+F(n-1)=O(F(n))个叶子节点,因此(and therefore),因为他是满二叉树,所以总共有2F(n+1)-1=O(F(n))个节点. <code>原文:</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/原文1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%8E%9F%E6%96%871.png\" alt></a></p>\n<h2 id=\"记忆化-超忆症-我要记住一切\"><a href=\"#记忆化-超忆症-我要记住一切\" class=\"headerlink\" title=\"记忆化: 超忆症-我要记住一切\"></a>记忆化: 超忆症-我要记住一切</h2><p>关于这个递归算法的效率极其缓慢的一个<code>很明显的原因</code>是计算了相同的Fibonacci numbers 一次一次又一次.调用一次RECFIBO(n)导致(result in)调用了一次RECFIBO(n-1),两次递归的调用RECFIBO(n-2),三次递归的调用了RECFIBO(n-3),五次递归的调用了RECFIBO(n-4),总之(and in general)F(k-1)递归的调用RECFIBO(n-k)的次数是 <code>k∈[0,n]</code> 间的任意整数.每个调用都<code>从头开始(from scratch)</code>重新计算一些Fibonacci number. 我们可以通过记下(writing down)我们之前递归的调用的结果,在需要它们的时候重新查找(looking xx up again)它们来加速(speed up)我们的递归算法. <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/图1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%9B%BE1.png\" alt></a> 这个最优化(optimization)的技术(technique),现在被称为(known as)记忆化,通常认为是唐纳德·米奇1967年写的<code>[把...归功于,credited to]</code>,但实际上同样的技术早在1959年就被 Arthur Samuel提出了. <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%812.png\" alt></a> 记忆化明显的减少了算法的运行时间,但是究竟减少了多少呢?如果我们跟踪(trace through)MEMFIBO的递归调用，我们可以找到F数组是从下到上的填充的: 先是F[2],之后F[3]…直到(up to)F[n].这个模式可以用归纳法证明: 每个F[i]被填充的前提是他的前一个节点F[i-1]被填充.如果我们忽略递归的调用时间的话,计算到F[i]所需要花费的时间仅仅是常数时间.但是若特意的设计一下,这个循环到F[i]估计只需要遍历到n一次.我们推断MEMFIBO只需执行O(n)复杂度的加法,这是一个巨大的改善关于之前那个<code>naive</code>的递归算法! <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/图2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%9B%BE2.png\" alt></a></p>\n<h2 id=\"动态规划-刻意填充-我就是故意的\"><a href=\"#动态规划-刻意填充-我就是故意的\" class=\"headerlink\" title=\"动态规划: 刻意填充-我就是故意的\"></a>动态规划: 刻意填充-我就是故意的</h2><p>一旦我们清楚了F[]数组是如何填充的,我们可以将记忆化算法转换为一个简单的<code>for循环</code>来初始化该数组,以代替那个复杂度递归算法. <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%813.png\" alt></a> 那我们分析一下: ITERFIBO明显只用了O(n)的复杂度以及仅存了O(n)个整数. 这是我们第一个明确的动态规划算法.这个动态规划算法在1950年代中期被当时在RAND公司工作的<code>Richard Bellman</code>正式的推广开来,尽管他远不是第一个使用这种技术的人.尤其的是(In particular)这个Fibonacci number的迭代算法早在12世纪就被Virahanka和后来的Sanskrit提出,并且再一次被Fibonacci在13世纪提出! 事实上在多年之后,Bellman慎重(deliberately)的宣称(claimed)选择将其命名为<code>&quot;动态规划&quot;</code>来向他的军官隐藏其数学特征(mathematical character),这个对所有对凡和数学有关的研究都有敌意的军官. “Programming”这个单词不涉及编程,相反(but rather)的更多代表的是一种计划或者调度.其特色是填表.例如,运动项目和戏剧(theater)项目就是重要的事件(与广告)的时间调度表..(又举了三个例子).反正这些就叫做”Program”,即安排/调度.而”dynamic”这个单词不仅仅涉及多阶段的意思,在Bellman和他的同事(colleagues)尝试(attempt)优化(to optimize)时变过程(time-varying processes)时,这个单词也是XXXXX(专业术语-&gt;resonate with the Futuristic Can-Do Zeitgeist of post-WW II America)的流行词.多亏了(部分原因是-&gt;Thanks in part of)Bellman的劝说(proselytizing)动态规划现在已经成为了经济学,机器人学,控制论,和其他多决策问题的标准工具.</p>\n<h2 id=\"其实俺也不想记住那么多\"><a href=\"#其实俺也不想记住那么多\" class=\"headerlink\" title=\"其实俺也不想记住那么多\"></a>其实俺也不想记住那么多</h2><p>在一些动态规划算法中,不需要在整个计算过程中(entire computation)保留所有中间结果(intermediate results).例如,我们可以明显的削减我们的算法<code>ITERFIBO</code>的必要空间通过维护两个数组中的新变量: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码4.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%814.png\" alt></a> (这个算法使用的非标准但是最终返回的结果一致,即定义F(-1)=1)尽管在实践中节约空间很重要,但本书中并不关注空间问题.</p>\n","text":"[TOC]3.1 matra-vrtta关于递归方法最早的例子之一是出现在距今2000多年前的古印度时期关于诗词韵律(arose)或者诗体韵律的学习中.古典梵语诗集(Classical Sanskrit poetry)有别于音节(syllables)的两种类型: 明亮和沉重.在一","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"Translation","slug":"translation","date":"2019-04-08T12:01:04.000Z","updated":"2019-07-03T13:51:36.870Z","comments":true,"path":"api/articles/translation.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"https://www.showdoc.cc/JeffE2Translation2Doc?page_id=1821482377881177\" target=\"_blank\" rel=\"noopener\">https://www.showdoc.cc/JeffE2Translation2Doc?page_id=1821482377881177</a></p>\n","text":"https://www.showdoc.cc/JeffE2Translation2Doc?page_id=1821482377881177","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"pat备-字符串-sscanf","slug":"patp-sscanf","date":"2019-03-24T12:53:58.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/patp-sscanf.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>sscanf(str,”…”,args) sscanf是用来干什么的呢? 例如我们每行输入的数据不同:</p>\n<blockquote>\n<p>数据有两种方式:</p>\n<blockquote>\n<ol>\n<li>名字:数字</li>\n<li>数字</li>\n</ol>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><code>那么我们该如何用一条语句处理呢?</code> <code>首先,scanf肯定不行</code></p>\n<blockquote>\n<p>所以我们考虑一种方式</p>\n<blockquote>\n<p><code>将数据存到缓冲区中,然后再使用格式化读取.</code></p>\n</blockquote>\n</blockquote>\n<p><code>这里的格式化读取就是sscanf</code></p>\n<blockquote>\n<p>Talk is cheap,show me your code.</p>\n</blockquote>\n<p>样例: 4 ZWT ： 10 250 CXY : 100 66 输出: ZWT:10分 分数线:250分 CXY:100分 分数线:66分 <code>Code</code></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN=100;\nchar Q[MAXN],name[MAXN];\nint score;\nint main(){\n    int N;\n    scanf(&quot;%d&quot;,&amp;N);\n    getchar();\n    for(int i=0;i&lt;N;++i){\n        scanf(&quot;%[^\\n]&quot;,Q);\n        getchar();\n        if(sscanf(Q,&quot;%s : %d&quot;,name,&amp;score)==2){\n            printf(&quot;%s:%d分\\n&quot;,name,score);\n        }else{\n            printf(&quot;分数线:%s分\\n&quot;,Q);\n        }\n    }\n    return 0;\n}</code></pre>","text":"sscanf(str,”…”,args) sscanf是用来干什么的呢? 例如我们每行输入的数据不同:数据有两种方式:名字:数字数字那么我们该如何用一条语句处理呢? 首先,scanf肯定不行所以我们考虑一种方式将数据存到缓冲区中,然后再使用格式化读取.这里的格式化读取就是ssca","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"LintCode(12-22)","slug":"lintcode12-22","date":"2019-02-10T06:42:21.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/lintcode12-22.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"12-Min-Stack\"><a href=\"#12-Min-Stack\" class=\"headerlink\" title=\"(12) - Min Stack\"></a>(12) - Min Stack</h1><blockquote>\n<p>一个栈维护最小值,另一个栈存数据</p>\n<blockquote>\n<p>为什么最小值同步插入可行,因为栈的pop只能从栈顶开始，所以:</p>\n<blockquote>\n<p>1.栈顶元素最小,minValue栈顶也是该元素 2.栈顶元素不是最小,minValue中没有该元素</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<pre><code>public class MinStack {\n\n    private Stack&lt;Integer&gt; data;\n    private Stack&lt;Integer&gt; minValue;\n\n    public MinStack() {\n        // do intialization if necessary\n        data=new Stack&lt;&gt;();\n        minValue=new Stack&lt;&gt;();\n        minValue.push(0x3f3f3f3f);\n    }\n\n    /*\n     * @param number: An integer\n     * @return: nothing\n     */\n    public void push(int number) {\n        // write your code here\n        data.push(number);\n        if(number&lt;=minValue.peek()) minValue.push(number);\n    }\n\n    /*\n     * @return: An integer\n     */\n    public int pop() {\n        // write your code here\n        if(data.peek().equals(minValue.peek())) minValue.pop();\n        return data.pop();\n    }\n\n    /*\n     * @return: An integer\n     */\n    public int min() {\n        // write your code here\n        return minValue.peek();\n    }\n}</code></pre><h1 id=\"13-Implement-strStr\"><a href=\"#13-Implement-strStr\" class=\"headerlink\" title=\"(13) - Implement strStr()\"></a>(13) - Implement strStr()</h1><blockquote>\n<p>KMP模板,但是实际面试的时候不需要使用KMP,暴力O(N^2)即可</p>\n</blockquote>\n<pre><code>public class Solution {\n\n    private final int maxn=10000+7;\n    private int Next[];\n\n    private void getNext(String S,String T){\n        int k=-1,len=T.length();\n        int j=0;\n        Next[0]=-1;\n        while(j&lt;len){\n            if(k==-1 || T.charAt(j)==T.charAt(k)) Next[++j]=++k;\n            else k=Next[k];\n        }\n    }\n\n    private int KMP_index(String S,String T){\n        int i=0,j=0,slen=S.length(),tlen=T.length();\n        getNext(S,T);\n        while(i&lt;slen &amp;&amp; j&lt;tlen){\n            if(j==-1 || S.charAt(i)==T.charAt(j)){\n                i++;\n                j++;\n            }else j=Next[j];\n        }\n        if(j==tlen) return i-tlen;\n        else return -1;\n    }\n\n    /**\n     * @param source: \n     * @param target: \n     * @return: return the index\n     */\n    public int strStr(String source, String target) {\n        // Write your code here\n        Next=new int[maxn];\n        return KMP_index(source,target);\n\n    }\n}</code></pre><h1 id=\"14-First-Position-of-Target\"><a href=\"#14-First-Position-of-Target\" class=\"headerlink\" title=\"(14) - First Position of Target\"></a>(14) - First Position of Target</h1><h2 id=\"C-偷懒用二分\"><a href=\"#C-偷懒用二分\" class=\"headerlink\" title=\"C++偷懒用二分\"></a>C++偷懒用二分</h2><pre><code>class Solution {\npublic:\n    /**\n     * @param nums: The integer array.\n     * @param target: Target to find.\n     * @return: The first position of target. Position starts from 0.\n     */\n    int binarySearch(vector&lt;int&gt; &amp;nums, int target) {\n        // write your code here\n        int index=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\n        if(nums[index]!=target)\n            return -1;\n        return index;\n    }\n};</code></pre><h2 id=\"Java-实现二分\"><a href=\"#Java-实现二分\" class=\"headerlink\" title=\"Java 实现二分\"></a>Java 实现二分</h2><pre><code>public class Solution {\n    /**\n     * @param nums: The integer array.\n     * @param target: Target to find.\n     * @return: The first position of target. Position starts from 0.\n     */\n    public int binarySearch(int[] nums, int target) {\n        // write your code here\n\n        int mid=0,l=0,r=nums.length;\n        while(l&lt;=r){\n            mid=((l+r)&gt;&gt;1);\n            if(nums[mid]&lt;target)\n                l=mid+1;\n            else r=mid-1;\n        }\n        if(nums[l]==target) return l;\n        else return -1;\n    }\n}</code></pre><h1 id=\"15-Permutations\"><a href=\"#15-Permutations\" class=\"headerlink\" title=\"(15) - Permutations\"></a>(15) - Permutations</h1><blockquote>\n<p>dfs即可</p>\n</blockquote>\n<pre><code>public class Solution {\n\n    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();\n        boolean[] used = new boolean[nums.length];\n        helper(nums, used, new LinkedList&lt;&gt;(), res);\n        return res;\n    }\n  private void helper(int[] nums, boolean[] used, List&lt;Integer&gt; tmp, List&lt;List&lt;Integer&gt;&gt; res) {\n    if (tmp.size() == nums.length) {\n      res.add(new LinkedList&lt;&gt;(tmp));\n      return;\n    }\n    for (int i = 0; i &lt; nums.length; i++) {\n      if (used[i]) {\n        continue;\n      }\n      used[i] = true;\n      tmp.add(nums[i]);\n      helper(nums, used, tmp, res);\n      used[i] = false;\n      tmp.remove(tmp.size()-1);\n    }\n    return;\n  }\n}</code></pre><h1 id=\"16-Permutations-II\"><a href=\"#16-Permutations-II\" class=\"headerlink\" title=\"(16) - Permutations II\"></a>(16) - Permutations II</h1><blockquote>\n<p>用set集直接映射即可</p>\n</blockquote>\n<pre><code>public class Solution {\n\n    private Set&lt;String&gt; reg;\n\n    private void helper(int[] nums, boolean[] used, List&lt;Integer&gt; tmp, List&lt;List&lt;Integer&gt;&gt; res,StringBuilder str){\n        if (tmp.size() == nums.length) {\n            String ts=str.toString();\n            if(reg.contains(ts)){\n                return;\n            }\n            reg.add(ts);\n            res.add(new LinkedList&lt;&gt;(tmp));\n            return;\n        }\n        for (int i = 0; i &lt; nums.length; i++) {\n            if (used[i]) {\n                continue;\n            }\n            used[i] = true;\n            tmp.add(nums[i]);\n            String nw=String.valueOf(nums[i]);\n            str.append(nw);\n            helper(nums, used, tmp, res,str);\n            used[i] = false;\n            tmp.remove(tmp.size()-1);\n            str.delete(str.length()-nw.length(),str.length());\n        }\n        return;\n    }\n    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();\n        boolean[] used = new boolean[nums.length];\n        reg=new HashSet&lt;String&gt;();\n        helper(nums, used, new LinkedList&lt;&gt;(), res,new StringBuilder());\n        return res;\n    }\n};</code></pre><h1 id=\"17-Subsets\"><a href=\"#17-Subsets\" class=\"headerlink\" title=\"(17) - Subsets\"></a>(17) - Subsets</h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>[[]]] [[1]] [[2],[1,2]] [[3],[1,3],[2,3],[1,2,3]] 合起来就好了</p>\n</blockquote>\n<p>一个小语法</p>\n<blockquote>\n<p>java中的List是引用传递,List套List给出来的是引用对象,所以必须new一个新的ArrayList才行.</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param nums: A set of numbers\n     * @return: A list of lists\n     */\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {\n        // write your code here\n        int len=nums.length;\n        Arrays.sort(nums);\n        List&lt;Integer&gt; init=new ArrayList();\n        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();\n        ans.add(init);\n        for(int i=0;i&lt;len;++i){\n            int size=ans.size();\n            for(int j=0;j&lt;size;++j){\n                List&lt;Integer&gt; reg=new ArrayList&lt;Integer&gt;(ans.get(j));\n                reg.add(nums[i]);\n                ans.add(reg);\n            }\n        }\n        return ans;\n    }\n}</code></pre><h1 id=\"18-Subsets-II\"><a href=\"#18-Subsets-II\" class=\"headerlink\" title=\"(18) - Subsets II\"></a>(18) - Subsets II</h1><blockquote>\n<p>还是用set映射</p>\n</blockquote>\n<pre><code>import java.util.*;\n\npublic class Topic_18 {\n    private static Set&lt;String&gt; dict;\n\n    /**\n     * @param nums: A set of numbers.\n     * @return: A list of lists. All valid subsets.\n     */\n    public static List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {\n        // write your code here\n        dict=new HashSet&lt;String&gt;();\n        int len=nums.length;\n        Arrays.sort(nums);\n        List&lt;Integer&gt; init=new ArrayList();\n        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();\n        ans.add(init);\n        for(int i=0;i&lt;len;++i){\n            int size=ans.size();\n            for(int j=0;j&lt;size;++j){\n                StringBuilder str=new StringBuilder();\n                List&lt;Integer&gt; reg=new ArrayList&lt;Integer&gt;(ans.get(j));\n                reg.add(nums[i]);\n                for(int k=0;k&lt;reg.size();++k){\n                    str.append(String.valueOf(reg.get(k)));\n                }\n                String n=str.toString();\n                if(!dict.contains(n)){\n                    ans.add(reg);\n                    dict.add(n);\n                }\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args){\n        int[] nums={1,2};\n        List&lt;List&lt;Integer&gt;&gt; ans=subsetsWithDup(nums);\n        System.out.println(ans.size());\n    }\n\n}</code></pre>","text":"(12) - Min Stack一个栈维护最小值,另一个栈存数据为什么最小值同步插入可行,因为栈的pop只能从栈顶开始，所以:1.栈顶元素最小,minValue栈顶也是该元素 2.栈顶元素不是最小,minValue中没有该元素public class MinStack {    ","link":"","raw":null,"photos":[],"categories":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/categories/LintCode.json"}],"tags":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/tags/LintCode.json"}]},{"title":"Spring Validation-Spring后台验证框架","slug":"spring-validation-spring","date":"2019-02-09T15:34:46.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-validation-spring.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"JSR-303简介\"><a href=\"#JSR-303简介\" class=\"headerlink\" title=\"JSR-303简介\"></a>JSR-303简介</h1><p>JSR-303 是 JavaEE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator。 此实现与 Hibernate ORM 没有任何关系。JSR-303 用于对 Java Bean 中的字段的值进行验证。 Spring MVC 3.x 之中也大力支持 JSR-303，可以在控制器中使用注解的方式对表单提交的数据方便地验证。 Spring 4.0 开始支持 Bean Validation 功能。</p>\n<h1 id=\"JSR-303-基本的校验规则\"><a href=\"#JSR-303-基本的校验规则\" class=\"headerlink\" title=\"JSR-303 基本的校验规则\"></a>JSR-303 基本的校验规则</h1><p>注解</p>\n<p>作用</p>\n<p>@Null</p>\n<p>验证对象是否为 null</p>\n<p>@NotNull</p>\n<p>验证对象是否不为 null, 无法查检长度为 0 的字符串</p>\n<p>@NotBlank</p>\n<p>检查约束字符串是不是 Null 还有被 Trim 的长度是否大于 0,只对字符串,且会去掉前后空格</p>\n<p>@NotEmpty</p>\n<p>检查约束元素是否为 NULL 或者是 EMPTY</p>\n<p>@AssertTrue</p>\n<p>验证 Boolean 对象是否为 true</p>\n<p>@AssertFalse</p>\n<p>验证 Boolean 对象是否为 false</p>\n<p>@Size(min=, max=)</p>\n<p>验证对象（Array, Collection , Map, String）长度是否在给定的范围之内</p>\n<p>@Length(min=, max=)</p>\n<p>验证字符串长度介于 min 和 max 之间</p>\n<p>@Past</p>\n<p>验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期</p>\n<p>@Future</p>\n<p>验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期</p>\n<p>@Pattern</p>\n<p>验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式</p>\n<p>@Min</p>\n<p>验证 Number 和 String 对象是否大等于指定的值</p>\n<p>@Max</p>\n<p>验证 Number 和 String 对象是否小等于指定的值</p>\n<p>@DecimalMax</p>\n<p>被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过 BigDecimal 定义的最大值的字符串表示 .小数 存在精度</p>\n<p>@DecimalMin</p>\n<p>被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过 BigDecimal 定义的最小值的字符串表示 .小数 存在精度</p>\n<p>@Digits</p>\n<p>验证 Number 和 String 的构成是否合法</p>\n<p>@Digits(integer=,fraction=)</p>\n<p>验证字符串是否是符合指定格式的数字，integer 指定整数精度，fraction 指定小数精度</p>\n<p>@Range(min=, max=)</p>\n<p>被指定的元素必须在合适的范围内@Range(min=10000,max=50000,message=”range.bean.wage”)</p>\n<p>@Valid</p>\n<p>递归的对关联对象进行校验, 如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个 map，则对其中的值部分进行校验.(是否进行递归验证)</p>\n<p>@CreditCardNumber</p>\n<p>信用卡验证</p>\n<p>@Email</p>\n<p>验证是否是邮件地址，如果为 null，不进行验证，算通过验证</p>\n<h1 id=\"粘贴到Spring上\"><a href=\"#粘贴到Spring上\" class=\"headerlink\" title=\"粘贴到Spring上\"></a>粘贴到Spring上</h1><h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n    &lt;version&gt;5.3.4.Final&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><h2 id=\"定义验证工具类\"><a href=\"#定义验证工具类\" class=\"headerlink\" title=\"定义验证工具类\"></a>定义验证工具类</h2><blockquote>\n<p>把所有类型的异常都转换为List&lt;&gt;型异常,然后在出口函数除捕捉异常并打印出来.调用validation的方法即直接调用.</p>\n</blockquote>\n<pre><code>import org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.validation.ConstraintViolation;\nimport javax.validation.ConstraintViolationException;\nimport javax.validation.Validator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * JSR303 Validator(Hibernate Validator)工具类.\n * &lt;p&gt;\n * ConstraintViolation 中包含 propertyPath, message 和 invalidValue 等信息.\n * 提供了各种 convert 方法，适合不同的 i18n 需求:\n * 1. List&lt;String&gt;, String 内容为 message\n * 2. List&lt;String&gt;, String 内容为 propertyPath + separator + message\n * 3. Map&lt;propertyPath, message&gt;\n * &lt;p&gt;\n * 详情见wiki: https://github.com/springside/springside4/wiki/HibernateValidator\n *\n * &lt;p&gt;Title: BeanValidator&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/26 17:21\n */\npublic class BeanValidator {\n\n    @Autowired\n    private static Validator validator;\n\n    public static void setValidator(Validator validator) {\n        BeanValidator.validator = validator;\n    }\n\n    /**\n     * 调用 JSR303 的 validate 方法, 验证失败时抛出 ConstraintViolationException.\n     */\n    private static void validateWithException(Validator validator, Object object, Class&lt;?&gt;... groups) throws ConstraintViolationException {\n        Set constraintViolations = validator.validate(object, groups);\n        if (!constraintViolations.isEmpty()) {\n            throw new ConstraintViolationException(constraintViolations);\n        }\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 中为 List&lt;message&gt;.\n     */\n    private static List&lt;String&gt; extractMessage(ConstraintViolationException e) {\n        return extractMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 List&lt;message&gt;\n     */\n    private static List&lt;String&gt; extractMessage(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        List&lt;String&gt; errorMessages = new ArrayList&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 Map&lt;property, message&gt;.\n     */\n    private static Map&lt;String, String&gt; extractPropertyAndMessage(ConstraintViolationException e) {\n        return extractPropertyAndMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 Map&lt;property, message&gt;.\n     */\n    private static Map&lt;String, String&gt; extractPropertyAndMessage(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        Map&lt;String, String&gt; errorMessages = new HashMap&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.put(violation.getPropertyPath().toString(), violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(ConstraintViolationException e) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), &quot; &quot;);\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        return extractPropertyAndMessageAsList(constraintViolations, &quot; &quot;);\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath + separator + message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(ConstraintViolationException e, String separator) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), separator);\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 List&lt;propertyPath + separator + message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(Set&lt;? extends ConstraintViolation&gt; constraintViolations, String separator) {\n        List&lt;String&gt; errorMessages = new ArrayList&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getPropertyPath() + separator + violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 服务端参数有效性验证\n     *\n     * @param object 验证的实体对象\n     * @param groups 验证组\n     * @return 验证成功：返回 null；验证失败：返回错误信息\n     */\n    public static String validator(Object object, Class&lt;?&gt;... groups) {\n        try {\n            validateWithException(validator, object, groups);\n        } catch (ConstraintViolationException ex) {\n            List&lt;String&gt; list = extractMessage(ex);\n            list.add(0, &quot;数据验证失败：&quot;);\n\n            // 封装错误消息为字符串\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i &lt; list.size(); i++) {\n                String exMsg = list.get(i);\n                if (i != 0 ){\n                    sb.append(String.format(&quot;%s. %s&quot;, i, exMsg)).append(list.size() &gt; 1 ? &quot;&lt;br/&gt;&quot; : &quot;&quot;);\n                } else {\n                    sb.append(exMsg).append(list.size() &gt; 1 ? &quot;&lt;br/&gt;&quot; : &quot;&quot;);\n                }\n            }\n\n            return sb.toString();\n        }\n\n        return null;\n    }\n}</code></pre><h2 id=\"为实体类添加注解\"><a href=\"#为实体类添加注解\" class=\"headerlink\" title=\"为实体类添加注解\"></a>为实体类添加注解</h2><p>(domain,model,Entity)</p>\n<pre><code>@Length(min = 6, max = 20, message = &quot;用户名长度必须介于 6 和 20 之间&quot;)\nprivate String username;\n@Length(min = 6, max = 20, message = &quot;密码长度必须介于 6 和 20 之间&quot;)\nprivate String password;\n@Pattern(regexp = RegexpUtils.PHONE, message = &quot;手机号格式不正确&quot;)\nprivate String phone;\n@Pattern(regexp = RegexpUtils.EMAIL, message = &quot;邮箱格式不正确&quot;)\nprivate String email;</code></pre><h2 id=\"注入工具类\"><a href=\"#注入工具类\" class=\"headerlink\" title=\"注入工具类\"></a>注入工具类</h2><blockquote>\n<p>因为在工具类中,static修饰的对象,无法直接注入,所以需要手工注入</p>\n</blockquote>\n<h3 id=\"直接注入\"><a href=\"#直接注入\" class=\"headerlink\" title=\"直接注入\"></a>直接注入</h3><pre><code>&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;/&gt;</code></pre><h3 id=\"手工注入\"><a href=\"#手工注入\" class=\"headerlink\" title=\"手工注入\"></a>手工注入</h3><blockquote>\n<p>两个都必须有</p>\n</blockquote>\n<pre><code>&lt;!-- 配置 Bean Validator 定义 --&gt;\n&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;/&gt;\n&lt;bean id=&quot;beanValidator&quot; class=&quot;com.funtl.my.shop.commons.validator.BeanValidator&quot;&gt;\n    &lt;property name=&quot;validator&quot; ref=&quot;validator&quot; /&gt;\n&lt;/bean&gt;</code></pre>","text":"JSR-303简介JSR-303 是 JavaEE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator。 此实现与 Hibernate ORM 没有任何关系。JSR-303 用于对 Java Bean 中的字段的值进行","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"Spring","slug":"Java/Spring","count":1,"path":"api/categories/Java/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"},{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"热部署 - (几个字也值得建个文章??","slug":"asdasdas","date":"2019-02-05T14:34:22.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/asdasdas.json","excerpt":"","keywords":null,"cover":null,"content":"<p>IDEA中使用JRebel.</p>\n<blockquote>\n<p>热部署: 即便是修改类也可以在存储后不需重启项目即可完成编译.</p>\n</blockquote>\n","text":"IDEA中使用JRebel.热部署: 即便是修改类也可以在存储后不需重启项目即可完成编译.","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"Spring 注解 @ModelAttribute","slug":"spring-annotation-modelattribute","date":"2019-02-05T09:25:30.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-annotation-modelattribute.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Spring-MVC-表单标签库\"><a href=\"#Spring-MVC-表单标签库\" class=\"headerlink\" title=\"Spring MVC 表单标签库\"></a>Spring MVC 表单标签库</h1><p><a href=\"http://www.funtl.com/zh/spring-mvc/Spring-MVC-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E5%BA%93.html#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%EF%BC%88%E5%A4%9A%E9%80%89%EF%BC%89\" target=\"_blank\" rel=\"noopener\">http://www.funtl.com/zh/spring-mvc/Spring-MVC-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E5%BA%93.html#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%EF%BC%88%E5%A4%9A%E9%80%89%EF%BC%89</a></p>\n<h1 id=\"JQuery-Validation-Bootstrap-前端验证\"><a href=\"#JQuery-Validation-Bootstrap-前端验证\" class=\"headerlink\" title=\"JQuery Validation+Bootstrap(前端验证)\"></a>JQuery Validation+Bootstrap(前端验证)</h1><p><a href=\"http://www.funtl.com/zh/supplement1/jQuery-Validation.html#%E9%A1%B5%E9%9D%A2%E5%BC%95%E7%94%A8\" target=\"_blank\" rel=\"noopener\">http://www.funtl.com/zh/supplement1/jQuery-Validation.html#%E9%A1%B5%E9%9D%A2%E5%BC%95%E7%94%A8</a></p>\n<h1 id=\"JQuery-iCheck-Bootstrap-前端复选框\"><a href=\"#JQuery-iCheck-Bootstrap-前端复选框\" class=\"headerlink\" title=\"JQuery iCheck+Bootstrap(前端复选框)\"></a>JQuery iCheck+Bootstrap(前端复选框)</h1><p><a href=\"http://www.funtl.com/zh/supplement1/jQuery-iCheck.html#%E6%BF%80%E6%B4%BB-icheck\" target=\"_blank\" rel=\"noopener\">http://www.funtl.com/zh/supplement1/jQuery-iCheck.html#%E6%BF%80%E6%B4%BB-icheck</a></p>\n<h1 id=\"什么是-ModelAttribute\"><a href=\"#什么是-ModelAttribute\" class=\"headerlink\" title=\"什么是 @ModelAttribute?\"></a>什么是 @ModelAttribute?</h1><ul>\n<li>绑定请求参数到命令对象：放在功能处理方法的入参上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用</li>\n<li>暴露 @RequestMapping 方法返回值为模型数据：放在功能处理方法的返回值上时，是暴露功能处理方法的返回值为模型数据，用于视图页面展示时使用</li>\n<li>暴露表单引用对象为模型数据：放在处理器的一般方法（非功能处理方法）上时，是为表单准备要展示的表单引用对象，如注册时需要选择的所在城市等，而且在执行功能处理方法（@RequestMapping 注解的方法）之前，自动添加到模型对象中，用于视图页面展示时使用</li>\n</ul>\n<blockquote>\n<p>即简化AOP编程,不使用拦截器在同一Controller下直接进行拦截或者预处理,其属性会继承给每一个RequestMapping的视图层.</p>\n</blockquote>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><pre><code>package com.funtl.my.shop.web.admin.web.controller;\n\nimport com.funtl.my.shop.commons.dto.BaseResult;\nimport com.funtl.my.shop.domain.TbUser;\nimport com.funtl.my.shop.web.admin.service.TbUserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport java.util.List;\n\n@Controller\n@RequestMapping(value=&quot;user&quot;)\npublic class UserController {\n    @Autowired\n    private TbUserService tbUserService;\n\n    @ModelAttribute\n    public TbUser getTbUser(Long id){\n        TbUser tbUser=null;\n        if(id!=null){\n            tbUser=tbUserService.getById(id);\n        }\n\n        else{\n            tbUser=new TbUser();\n        }\n        return tbUser;\n    }\n\n\n    /**\n     * 跳转到用户列表页\n     * @param model\n     * @return\n     */\n    @RequestMapping(value=&quot;list&quot;,method= RequestMethod.GET)\n    public String list(Model model){\n        List&lt;TbUser&gt; tbUsers=tbUserService.selectAll();\n        model.addAttribute(&quot;tbUsers&quot;,tbUsers);\n        return &quot;user_list&quot;;\n    }\n\n    @RequestMapping(value=&quot;form&quot;,method=RequestMethod.GET)\n    public String form(){\n        return &quot;user_form&quot;;\n    }\n\n    @RequestMapping(value=&quot;save&quot;,method=RequestMethod.POST)\n    public String save(TbUser tbUser, Model model,RedirectAttributes redirectAttributes){\n        BaseResult baseResult=tbUserService.save(tbUser);\n        //保存成功\n        if(baseResult.getStatus()==200){\n            redirectAttributes.addFlashAttribute(&quot;baseResult&quot;,baseResult);\n            return &quot;redirect:/user/list&quot;;\n        }\n        //保存失败\n        else{\n            model.addAttribute(&quot;baseResult&quot;,baseResult);\n            return &quot;user_form&quot;;\n        }\n    }\n}</code></pre><blockquote>\n<p>这样操作过后可以很轻松的将 预处理的TbUser绑定到Model上.</p>\n</blockquote>\n","text":"Spring MVC 表单标签库http://www.funtl.com/zh/spring-mvc/Spring-MVC-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E5%BA%93.html#%E5%8D%95%E9%80%89%E6%8C%89","link":"","raw":null,"photos":[],"categories":[{"name":"Spring","slug":"Spring","count":4,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}]},{"title":"Spring 黏合 Mybatis (已整合druid前提下)","slug":"spring-cohesive-mybatis","date":"2019-02-04T02:20:51.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-cohesive-mybatis.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"前提-已经创建好了druid\"><a href=\"#前提-已经创建好了druid\" class=\"headerlink\" title=\"前提,已经创建好了druid\"></a>前提,已经创建好了druid</h1><blockquote>\n<p>且druid的id为datasource,作为mybatis的数据源</p>\n</blockquote>\n<h1 id=\"Document\"><a href=\"#Document\" class=\"headerlink\" title=\"Document\"></a>Document</h1><p><a href=\"http://www.mybatis.org/mybatis-3/zh/index.html\" target=\"_blank\" rel=\"noopener\">http://www.mybatis.org/mybatis-3/zh/index.html</a></p>\n<h1 id=\"创建-mybatis-config-xml\"><a href=\"#创建-mybatis-config-xml\" class=\"headerlink\" title=\"创建 mybatis-config.xml\"></a>创建 mybatis-config.xml</h1><blockquote>\n<p>因为已经整合过了druid,所以数据源为datasource,即不用再设置连接数据库等操作,直接从连接池druid中取出即可.</p>\n<blockquote>\n<p>只需要配置几个setting属性</p>\n</blockquote>\n</blockquote>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;!-- 全局参数 --&gt;\n    &lt;settings&gt;\n        &lt;!-- 打印 SQL 语句 --&gt;\n        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;\n\n        &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;\n        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;\n\n        &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;\n        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;\n        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;\n        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;\n\n        &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;\n        &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;\n\n        &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;\n        &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;\n\n        &lt;!-- 使用驼峰命名法转换字段。 --&gt;\n        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;\n        &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;\n\n        &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;\n        &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;</code></pre><h1 id=\"创建-spring-context-mybatis-xml\"><a href=\"#创建-spring-context-mybatis-xml\" class=\"headerlink\" title=\"创建 spring-context-mybatis.xml\"></a>创建 spring-context-mybatis.xml</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n    &lt;!-- 配置 SqlSession --&gt;\n    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n        &lt;!-- 用于配置对应实体类所在的包，多个 package 之间可以用 &apos;,&apos; 号分割 --&gt;\n        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.funtl.my.shop.domain&quot;/&gt;\n        &lt;!-- 用于配置对象关系映射配置文件所在目录 --&gt;\n        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:/mapper/**/*.xml&quot;/&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:/mybatis-config.xml&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 扫描 Mapper --&gt;\n    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n        &lt;property name=&quot;basePackage&quot; value=&quot;com.funtl.my.shop.web.admin.dao&quot; /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><h1 id=\"然后\"><a href=\"#然后\" class=\"headerlink\" title=\"然后\"></a>然后</h1><blockquote>\n<p>只需要创建Dao接口即可,SQL语句放在Mapper中,Service中调用接口即可. 其中关于mapper.xml的标签和OOP原则都在最上面Document中可以查到.</p>\n</blockquote>\n","text":"前提,已经创建好了druid且druid的id为datasource,作为mybatis的数据源Documenthttp://www.mybatis.org/mybatis-3/zh/index.html创建 mybatis-config.xml因为已经整合过了druid,所以数","link":"","raw":null,"photos":[],"categories":[{"name":"MyBatis","slug":"MyBatis","count":2,"path":"api/categories/MyBatis.json"},{"name":"Spring","slug":"MyBatis/Spring","count":1,"path":"api/categories/MyBatis/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"},{"name":"MyBatis","slug":"MyBatis","count":2,"path":"api/tags/MyBatis.json"}]}]}