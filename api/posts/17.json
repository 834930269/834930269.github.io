{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"Flask 源码解读(一)","slug":"flask-sc1","date":"2017-11-04T08:53:02.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/flask-sc1.json","excerpt":"","keywords":null,"cover":null,"content":"<p>其中<code>Flask</code>用于处理Web应用的路由,request,response等模块的核心是<code>werkzeug</code>. <code>werkzeug</code> 提供了 python web WSGI 开发相关的功能：</p>\n<ul>\n<li>路由处理：怎么根据请求中的 url 找到它的处理函数</li>\n<li>request 和 response 封装：可以更好地读取 request 的数据，也容易生成响应</li>\n<li>一个自带的 WSGI server，可以用来测试环境运行自己的应用</li>\n</ul>\n<p>比如，我们可以使用 <code>werkzeug</code> 编写一个简单的 hello world 的 WSGI app：</p>\n<pre><code>from werkzeug.wrappers import Request,Response\n\ndef application(environ,start_response):\n    request = Request(environ)\n    text = &apos;Hello %s&apos; % request.args.get(&apos;name&apos;,&apos;World&apos;)\n    response = Response(text,mimetype=&apos;text/plain&apos;)\n    return response(environ,start_response)</code></pre><p>除了和 web WSGI 相关的功能，werkzeug 还实现了很多非常有用的数据结构和函数。比如用来处理一个 key 对应多个值的 MultiDict，不支持修改的字典 ImmutableDict ，可以缓存类属性的 cache_property 等等。</p>\n","text":"其中Flask用于处理Web应用的路由,request,response等模块的核心是werkzeug. werkzeug 提供了 python web WSGI 开发相关的功能：路由处理：怎么根据请求中的 url 找到它的处理函数request 和 response 封装：可以","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"flask源码学习","slug":"Flask/flask源码学习","count":1,"path":"api/categories/Flask/flask源码学习.json"},{"name":"Python","slug":"Flask/flask源码学习/Python","count":1,"path":"api/categories/Flask/flask源码学习/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Flask源码学习","slug":"Flask源码学习","count":1,"path":"api/tags/Flask源码学习.json"}]},{"title":"Web Application","slug":"web-application","date":"2017-11-04T08:32:16.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/web-application.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Link <a href=\"http://cizixs.com/2015/09/21/what-is-a-web-framework\" target=\"_blank\" rel=\"noopener\">什么是Web框架</a> 一个简单的可以处理get和post的Web Application, 其中如果80端口不能访问就换成其他端口即可.</p>\n<pre><code>import socket\n\nHOST = &apos;&apos; #localhost\nPORT = 80 #监听80端口,如果不行就换成其他端口\nlisten_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#协议部分\nlisten_socket.bind((HOST,PORT))#只允许迭代类型么？\nlisten_socket.listen(1)\nconnection,address = listen_socket.accept()\nrequest = connection.recv(1024)\nconnection.sendall(b&quot;&quot;&quot;HTTP/1.1 200 OK\nContent-type: text/html\n\n\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;&quot;&quot;)#返回的响应以及data,但必须转一下bytes类型\nconnection.close()</code></pre><p>（如果上面的程序报端口错误，可以把 PORT 的值修改成其他值，比如 8080。） 上面的代码只会接收一个连接和一个请求，不管请求的 URL 是什么，都会返回同样的 HTTP 内容，response code 是 200。（很明显，这不算真正的 web server）。在这个例子，我们告诉客户端，返回的数据格式为 HTML，而不是其他的格式，比如 JSON。</p>\n","text":"Link 什么是Web框架 一个简单的可以处理get和post的Web Application, 其中如果80端口不能访问就换成其他端口即可.import socketHOST = &apos;&apos; #localhostPORT = 80 #监听80端口,如果不行就换成其","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"Web_Application","slug":"Python/Web-Application","count":1,"path":"api/categories/Python/Web-Application.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Web_Application","slug":"Web-Application","count":1,"path":"api/tags/Web-Application.json"}]},{"title":"第一个开源到Github上的Web App cm-Todo","slug":"github-web-app-cm-todo","date":"2017-10-29T05:29:21.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/github-web-app-cm-todo.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"cm-todo\">cm-Todo</span></h1><p>这是一款基于-Flask-Canvas-Mysql-Python3-Bootstrap-的TODO/记事本/交流 的Web App应用 Github地址: <code>点击=&gt;</code> <a href=\"https://github.com/834930269/cm-Todo\" title=\"https://github.com/834930269/cm-Todo\" target=\"_blank\" rel=\"noopener\">https://github.com/834930269/cm-Todo</a> 其中记事本框的CSS和部分JS来自于 <code>点击=&gt;</code> <a href=\"https://github.com/youknowznm/vue-memo\" title=\"youknowznm-vue-memo\" target=\"_blank\" rel=\"noopener\"><code>youknowznm-vue-memo</code></a> 本地使用方法: 先在<code>config.py</code>中的:</p>\n<blockquote>\n<p>DATABASE_USERNAME=<br>DATABASE_PASSWORD=</p>\n</blockquote>\n<p>中输入你Mysql数据库的用户名和密码,并自行创建一个名为notebook的数据库.<br>(这里数据库自行选择,不同数据库的接口配置在<code>config.py</code>中进行)  </p>\n<p>然后在当前目录下的命令行中执行以下命令:  </p>\n<p>python manage.py db init<br>python manage.py db migrate -m ‘first’ python manage.py db upgrade 最后在命令行中执行<code>manage.py</code>并通过<code>localhost:5000</code>进行访问即可. python manage.py runserver 注意,是python3.*,如果您是Linux用户,可能会需要修改以下Mysql数据库的所有编码方式为utf-8. 该App可以轻松集成到到您的Flask Web App中,至于如何集成,这里不再赘述. <code>Demo</code>: <code>点击</code>=&gt; <a href=\"http://be-sunshine.cn:5100/notebooks\" title=\"地平线上的一匹狼-日志\" target=\"_blank\" rel=\"noopener\"><code>地平线上的一匹狼-日志</code></a></p>\n","text":"cm-Todo这是一款基于-Flask-Canvas-Mysql-Python3-Bootstrap-的TODO/记事本/交流 的Web App应用 Github地址: 点击=&gt; https://github.com/834930269/cm-Todo 其中记事本框的CSS","link":"","raw":null,"photos":[],"categories":[{"name":"Bootstrap","slug":"Bootstrap","count":1,"path":"api/categories/Bootstrap.json"},{"name":"Flask","slug":"Bootstrap/Flask","count":1,"path":"api/categories/Bootstrap/Flask.json"},{"name":"Github","slug":"Bootstrap/Flask/Github","count":1,"path":"api/categories/Bootstrap/Flask/Github.json"},{"name":"Mysql","slug":"Bootstrap/Flask/Github/Mysql","count":1,"path":"api/categories/Bootstrap/Flask/Github/Mysql.json"},{"name":"Python","slug":"Bootstrap/Flask/Github/Mysql/Python","count":1,"path":"api/categories/Bootstrap/Flask/Github/Mysql/Python.json"},{"name":"SQL","slug":"Bootstrap/Flask/Github/Mysql/Python/SQL","count":1,"path":"api/categories/Bootstrap/Flask/Github/Mysql/Python/SQL.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Github","slug":"Github","count":2,"path":"api/tags/Github.json"},{"name":"Bootstrap","slug":"Bootstrap","count":1,"path":"api/tags/Bootstrap.json"},{"name":"Mysql","slug":"Mysql","count":2,"path":"api/tags/Mysql.json"},{"name":"SQL","slug":"SQL","count":2,"path":"api/tags/SQL.json"}]},{"title":"关于使用ajax(JavaScript)+Flask(Python)+Canvas 上传画布(Canvas)图片并存储","slug":"ajax-upload-canvas-to-server","date":"2017-10-26T14:31:36.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/ajax-upload-canvas-to-server.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171027191006.png","content":"<p>因为想要做一个todo list的记事本app.其中有一个模块是使用Canvas做涂鸦. <code>其中有两个操作</code>: <code>1.</code>然后上传canvas的画布图片并保存到本地. <code>2.</code>将对应画布的url传给画布,并绘制出来. 首先,Canvas画板的css和js是在Github上淘的一个,链接如下: <code>https://github.com/youknowznm/paint</code><a href=\"https://github.com/youknowznm/paint\" title=\"&lt;code&gt;点击这里&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点击这里</code></a> 首先是<code>index.html</code>的代码,大部分是样式,所以不用太在意,只需要注意<code>canvas的id</code>即可.</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;title&gt;paint&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./paint.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;canvas-wrapper&quot;&gt;\n        &lt;ul class=&quot;doodle-colors&quot;&gt;\n            &lt;li data-color=&quot;black&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;green&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;yellow&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;red&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;white&quot;&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;ul class=&quot;doodle-controllers&quot;&gt;\n            &lt;li class=&quot;undo&quot;&gt;&lt;/li&gt;\n            &lt;li class=&quot;redo&quot;&gt;&lt;/li&gt;\n            &lt;li class=&quot;clear&quot;&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;canvas id=&quot;cv&quot; class=&quot;doodle-content&quot; width=&apos;500&apos; height=&apos;500&apos;&gt;&lt;/canvas&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./paint.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        window.onload = function() {\n            let canvasEle = $(&apos;.doodle-content&apos;)[0];\n            let colorsEle = $(&apos;.doodle-colors&apos;)[0];\n            let controllersEle = $(&apos;.doodle-controllers&apos;)[0];\n            initCanvas(canvasEle, colorsEle, controllersEle, null);\n        }\n        function oc(){\n            let cav=document.getElementById(&apos;cv&apos;);\n            console.log(cav);\n            let data=cav.toDataURL();\n            console.log(data);\n            let img = document.createElement(&apos;img&apos;);\n            img.src = data;\n            document.body.appendChild(img);\n            let image=cav.toDataURL(&apos;image/jpeg&apos;);\n            window.location=image;\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>注意,我在代码中添加了一个<code>JavaScript函数oc()</code>:</p>\n<pre><code>function oc(){\n    let cav=document.getElementById(&apos;cv&apos;);\n    console.log(cav);\n    let data=cav.toDataURL();\n    console.log(data);\n    let img = document.createElement(&apos;img&apos;);\n    img.src = data;\n    document.body.appendChild(img);\n    let image=cav.toDataURL(&apos;image/jpeg&apos;);\n    window.location=image;\n}</code></pre><p>其中<code>cav.toDataURL(&#39;type&#39;)</code>即可以实现提取当前Canvas中的图片流信息. 然后我们尝试向后台发送Canvas图片的<code>用base64加密的数据</code>. 使用一个<code>Button</code>来发送post信息. 添加<code>&lt;button id=&quot;btn&quot; &gt;123&lt;/button&gt;</code> 为<code>button</code>添加click事件:</p>\n<pre><code>$(function(){\n    $(&apos;#btn&apos;).click(function(){\n        let cav=document.getElementById(&apos;cv&apos;);\n        let image=cav.toDataURL(&apos;image/jpeg&apos;);\n        $.post(&apos;/upload&apos;,{&apos;data&apos;:image,&apos;idx&apos;:223},function(result){\n            let canvasEle = $(&apos;.doodle-content&apos;)[0];\n            let colorsEle = $(&apos;.doodle-colors&apos;)[0];\n            let controllersEle = $(&apos;.doodle-controllers&apos;)[0];\n            initCanvas(canvasEle, colorsEle, controllersEle, result);\n        })\n    })\n})</code></pre><p>其中表单中<code>data</code>为图片加密信息,<code>idx</code>为假想当前记事本的id. 实践.发送post内容如下: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ截图20171027191006.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171027191006.png\" alt></a> 注意这里只是介绍了前台代码,让大家看一下发送的表单数据,如果没编写后台接受<code>Post</code>的Route的话是会返回<code>404</code>的. 然后在后台的View视图中添加相应的Route:</p>\n<pre><code>from . import main\nfrom flask import Flask,render_template\nfrom flask import make_response,render_template, session, redirect, url_for, current_app,abort,flash,request\nimport json,os,base64  \n\n@main.route(&apos;/upload&apos;,methods=[&apos;POST&apos;])\ndef upLoad():\n    &quot;&quot;&quot;\n    disturbing by jq\n    this method cannot work\n    &quot;&quot;&quot;\n    files=request.values.get(&apos;data&apos;)\n    f=request.form[&apos;data&apos;][23:]\n    ind=request.form[&apos;idx&apos;]\n    imgdata=base64.b64decode(f)\n    file=open(&apos;app/static/&apos;+ind+&apos;.jpg&apos;,&apos;wb&apos;)\n    file.write(imgdata)\n    file.close()\n    return &apos;/static/&apos;+ind+&apos;.jpg&apos;\n\n@main.route(&apos;/show&apos;,methods=[&apos;GET&apos;])\ndef show():\n    return render_template(&apos;index.html&apos;)</code></pre><p>其中用<code>request.values.get(&#39;key&#39;)</code>来获取对应表单的数据.然后用base64算法对获取到的数据进行解码.之后创建一个空文件<code>idx.jpg</code>,将解码后的数据写进去.得到的即为图片. 我们可以看到<code>获取到的data的头有一段非编码部分</code>:</p>\n<pre><code>data:image/jpeg;base64,/9j/4A</code></pre><p>所以我们需要将前面不属于编码的部分去掉. 后台处理代码中:</p>\n<pre><code>f=request.form[&apos;data&apos;][23:]</code></pre><p>即完成了这一任务. 注意在JavaScript用这种方式获取Canvas的时候,开启管道时<code>背景如果是透明</code>,它会在转换成base64时自动补成<code>#fff</code>(纯黑色). 所以我们需要在创建Canvas时将背景染成纯白色<code>#000</code>. 我们在Paint.js中初始化context中加入下面两句:</p>\n<pre><code>// 初始化 context\nvar ctx = canvasEle.getContext(&apos;2d&apos;);\nctx.fillStyle=&quot;#fff&quot;;\nctx.fillRect(0, 0, 500, 500);</code></pre><p>OK,我们获取图片后即为原图了! 至于如何在Canvas中将图片画出来.直接用<code>paint.js</code>中的 <code>initCanvas(canvasEle, colorsEle, controllersEle, result);</code> 即可.result为对应图片的地址<code>一般是发布网站的相对地址</code>. 上传结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ截图20171027193747.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171027193747.png\" alt></a> 最后一个问题: <code>当我们试图读取图片的url时,浏览器多半会返回对应url的缓存图片文件,如何解决这个问题呢?</code> 我们只需要在<code>URL</code>中随便加入一个参数即可,保证每次的url不相同即可,比如:</p>\n<pre><code>URL=URL+&apos;?t=&apos;+Math.random();</code></pre><p>OK,日志本的第一个难题攻关!</p>\n","text":"因为想要做一个todo list的记事本app.其中有一个模块是使用Canvas做涂鸦. 其中有两个操作: 1.然后上传canvas的画布图片并保存到本地. 2.将对应画布的url传给画布,并绘制出来. 首先,Canvas画板的css和js是在Github上淘的一个,链接如下: ","link":"","raw":null,"photos":[],"categories":[{"name":"ajax","slug":"ajax","count":4,"path":"api/categories/ajax.json"},{"name":"Flask","slug":"ajax/Flask","count":1,"path":"api/categories/ajax/Flask.json"},{"name":"Python","slug":"ajax/Flask/Python","count":1,"path":"api/categories/ajax/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"ajax","slug":"ajax","count":4,"path":"api/tags/ajax.json"}]},{"title":"索引","slug":"index","date":"2017-10-25T02:46:53.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/index.json","excerpt":"","keywords":null,"cover":null,"content":"<p>就相当于加速查找是一个道理,比如c++的map,B树.B+树,平衡搜索树等,为表建立索引也是加快查找速度的一个方法.在数据数量很大的情况下,对用户的体验更友好吧. 在Oracle主要存在以下几种索引:</p>\n<pre><code>B树索引:\ncreate index hir_index on emp(hiredate);\n\nselect index_name,index_type,table_owner,table_name from user_indexes;\n\nselect * from USER_IND_COLUMNS where index_name=&apos;hir_index&apos;;\n\n位图索引(必须建在B树索引之上):\ncreate bitmap index 索引名 on 表名(列名 [ASC|DESC])\n\ncreate bitmap index deptno_index on emp(deptno);\nBITMAP(有几列即几个bit,每个数据集的bit result 与对应位进行|即可以判断是否在表中)\n\n基于函数的索引:\n\n方向键索引(rebuild):\n\n唯一索引:\nCreate unique index\ncreate unique index index_emp_empno on emp();\n\n数据表更新了以后重建索引 rebuild</code></pre>","text":"就相当于加速查找是一个道理,比如c++的map,B树.B+树,平衡搜索树等,为表建立索引也是加快查找速度的一个方法.在数据数量很大的情况下,对用户的体验更友好吧. 在Oracle主要存在以下几种索引:B树索引:create index hir_index on emp(hired","link":"","raw":null,"photos":[],"categories":[{"name":"Oracle","slug":"Oracle","count":2,"path":"api/categories/Oracle.json"}],"tags":[{"name":"Oracle","slug":"Oracle","count":2,"path":"api/tags/Oracle.json"}]},{"title":"2017/10/24 更新了部分布局","slug":"20171024-as","date":"2017-10-24T04:27:00.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/20171024-as.json","excerpt":"","keywords":null,"cover":null,"content":"<p>基于Flask+Python+Bootstrap的个人小站. <a href=\"http://wolf.be-sunshine.cn\" title=\"wolf.be-sunshine.cn\" target=\"_blank\" rel=\"noopener\"><code>wolf.be-sunshine.cn</code></a> Stupid is stupid does.</p>\n","text":"基于Flask+Python+Bootstrap的个人小站. wolf.be-sunshine.cn Stupid is stupid does.","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 富文本添加支持格式的以及Attributes的方法","slug":"python-flask-attribute","date":"2017-10-20T14:49:40.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-attribute.json","excerpt":"","keywords":null,"cover":null,"content":"<p>通过设置<code>attributes</code>和<code>tags</code>如:</p>\n<pre><code>#将Markdown转换为HTML\n@staticmethod\ndef on_change_body(target,value,oldvalue,initiator):\n    attrs = {\n        &apos;*&apos;: [&apos;class&apos;,&apos;style&apos;,&apos;width&apos;,&apos;height&apos;],\n        &apos;a&apos;: [&apos;href&apos;, &apos;rel&apos;],\n         &apos;img&apos;: [&apos;src&apos;, &apos;alt&apos;],\n    }\n    #允许的标签类型\n    allowed_tags = [&apos;a&apos;,&apos;abbr&apos;,&apos;acronym&apos;,&apos;b&apos;,&apos;blockquote&apos;,&apos;code&apos;,\n                    &apos;em&apos;,&apos;i&apos;,&apos;li&apos;,&apos;ol&apos;,&apos;pre&apos;,&apos;strong&apos;,&apos;ul&apos;,\n                    &apos;h1&apos;,&apos;h2&apos;,&apos;h3&apos;,&apos;p&apos;,&apos;img&apos;]\n    target.body_html = bleach.linkify(bleach.clean(\n        markdown(value,output_format=&apos;html&apos;),\n        tags=allowed_tags, attributes=attrs,strip=True))</code></pre><p>最近先把这个博客做好… 之后再看情况写部分重点= =. 最近眼有点难受.</p>\n","text":"通过设置attributes和tags如:#将Markdown转换为HTML@staticmethoddef on_change_body(target,value,oldvalue,initiator):    attrs = {        &apos;*&apos;: [","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"在茫茫的雪地中找到一个朋友是什么感觉?","slug":"in-snow-find-a-firend","date":"2017-10-19T05:09:04.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/in-snow-find-a-firend.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"a-fox-and-a-mouse\">A Fox And A Mouse</span></h1>","text":"A Fox And A Mouse","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"Python Flask 番外 1 可以随鼠标移动的背景图片","slug":"python-flask-1-onmouse","date":"2017-10-18T13:32:57.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-1-onmouse.json","excerpt":"","keywords":null,"cover":null,"content":"<p>通过和大佬的交流学会了一点黑科技… <code>1.</code>因为<code>body的高度</code>和内容挂钩的,所以<code>鼠标可以到达</code>的body区域只有body的高度而已,如果<code>内容高度</code>没填满整个屏幕的话,就会出现下面有一部分无法响应鼠标移动事件,自然无法更新背景图片的<code>position</code>. 然后一个老司机告诉我:想要<code>简单粗暴一点</code>.可以用(<code>css3</code>):</p>\n<pre><code>height:100vh</code></pre><p>卧槽… <code>2.</code>响应函数:</p>\n<pre><code>// 一个小小的视觉效果\n$(&apos;body&apos;).on(&apos;mousemove&apos;, (evt) =&gt; {\n  $(&apos;body&apos;)\n    .css(&apos;background-position-x&apos;, Math.ceil(evt.pageX / 40))\n    .css(&apos;background-position-y&apos;, Math.ceil(evt.pageY / 40));\n});\nwindow.ondeviceorientation = (evt) =&gt; {\n  $(&apos;body&apos;)\n    .css(&apos;background-position-x&apos;, evt.gamma)\n    .css(&apos;background-position-y&apos;, evt.beta);\n};</code></pre>","text":"通过和大佬的交流学会了一点黑科技… 1.因为body的高度和内容挂钩的,所以鼠标可以到达的body区域只有body的高度而已,如果内容高度没填满整个屏幕的话,就会出现下面有一部分无法响应鼠标移动事件,自然无法更新背景图片的position. 然后一个老司机告诉我:想要简单粗暴一点","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 10 用户上传头像","slug":"python-flask-up-fil-to-app-2","date":"2017-10-18T03:54:20.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-up-fil-to-app-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B718.png","content":"<p>借助上节的基础==&gt; <a href=\"http://be-sunshine.cn/index.php/2017/10/17/python-flask-upfile/\" title=\"&lt;code&gt;点我啊!  Python Flask 上传文件&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啊! Python Flask 上传文件</code></a> 这节我们实现一下<code>修改用户头像</code>以及<code>默认头像</code>的功能. 截止目前的项目进度: <a href=\"https://github.com/834930269/Flask_Study/tree/master/flask-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%845-%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F\" title=\"&lt;code&gt;点我啊! Github:flask-大型网站架构5-新增上传头像&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啊! Github:flask-大型网站架构5-新增上传头像</code></a> 最终效果如图: <code>1.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获18.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B718.png\" alt></a> <code>2.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获19.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B719.png\" alt></a> <code>3.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获21.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B721.png\" alt></a> <code>4.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获22.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B722.png\" alt></a></p>\n<h1><span id=\"开始\">开始!</span></h1><h3><span id=\"1\">1:</span></h3><p>因为我们需要对每个用户<code>存下他的头像信息</code>. 这里我们选择<code>直接存储图片url</code>的形式进行存储. 所以我们需要对<code>model层</code>的<code>User</code>添加一个<code>gravatar</code>列,存储头像url. 主要代码如下:</p>\n<pre><code>class User(UserMixin,db.Model):\n    __tablename__ = &apos;users&apos;\n    gravatar = db.Column(db.String(200),default=&apos;/_uploads/photos/default.jpg&apos;)</code></pre><p>其中<code>gravatar</code>的默认值是<code>默认头像相对url</code>.</p>\n<h3><span id=\"2\">2:</span></h3><p>首先我们依然需要<code>先码出</code>上传头像界面的<code>表单(form)</code>. 先配置<code>所要上传的目标地址</code>变量<code>/config.py</code>:</p>\n<pre><code>import os\nUPLOADED_PHOTOS_DEST = os.path.abspath(os.path.join(os.getcwd(),&quot;app/static/Gravatar&quot;))</code></pre><p>我们需要对<code>上传文件</code>进行约束为图片格式,这里我们用一个<code>UploadSet</code>模块,编辑代码<code>/app/__init__.py</code>:</p>\n<pre><code>from flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\n\nphotos = UploadSet(&apos;photos&apos;,IMAGES)</code></pre><p>然后将创建好的<code>photo</code>对象加入已经创建好的<code>app</code>中:</p>\n<pre><code>configure_uploads(app,photos)\npatch_request_class(app)  </code></pre><p>然后编写<code>form表单</code>:</p>\n<pre><code>from flask_wtf.file import FileField, FileRequired, FileAllowed\nfrom flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\nfrom .. import photos\nfrom flask_wtf import FlaskForm\n\nclass UploadForm(FlaskForm):\n    photo = FileField(validators=[\n        FileAllowed(photos, u&apos;只能上传图片！&apos;), \n        FileRequired(u&apos;请选择一个头像吧！&apos;)])\n    submit = SubmitField(u&apos;确认上传&apos;,render_kw={&quot;class&quot;:&quot;btn btn-primary&quot;})</code></pre><p>其中<code>render_kw</code>是一个<code>dict</code>类型,作用是<code>渲染对应表单的css</code>. <code>FileAllowed</code>用来检测上传文件类型,不对的的话返回<code>第二个参数</code>. <code>FileRequired</code>和<code>Required</code>作用近似,即<code>非空判断</code>.</p>\n<h3><span id=\"3\">3:</span></h3><p>接下来我们就要开始编写<code>view层</code>了. 这里我们将编辑头像页面的<code>url</code>设为<code>/edit-gravatar</code> 所以我们需要码一个有<code>GET</code>和<code>POST</code>的视图函数.</p>\n<pre><code>from flask_login import  current_user\nfrom flask_login import login_user,login_required,logout_user\nfrom .forms import UploadForm\nfrom flask import render_template, session, redirect, url_for, current_app,abort,flash\nfrom .. import db,photos\n\n@main.route(&apos;/edit-gravatar&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\n@login_required\ndef edit_gravatar():\n    form = UploadForm()\n    if form.validate_on_submit():\n        filename = photos.save(form.photo.data)\n        file_url = photos.url(filename)\n        current_user.gravatar = file_url\n        db.session.add(current_user)\n        flash(&apos;修改成功!&apos;)\n        return redirect(url_for(&apos;.user&apos;,username=current_user.username,file_url=file_url))\n\n    return render_template(&apos;edit_gravatar.html&apos;,form=form,file_url=current_user.gravatar)</code></pre><p>注意我们所上传的头像文件<code>即使名字相同也不会覆盖掉之前的头像文件的</code>..(所以还是以二进制存到数据库中更好一点么).</p>\n<h3><span id=\"4\">4:</span></h3><p>接下来我们需要编写<code>前台界面</code>了: 首先,由于如果我们直接用<code>quick_form</code>创建表单的话,表单的<code>css</code>就不好改了.所以我们把每个表单分开放入<code>form type=file</code>中,并且通过<code>传参</code>或者<code>重叠覆盖</code>修改表单控件的<code>样式</code>. 其中,修改<code>input type=file</code>样式的通用方法是<code>将opacity设为0</code>,然后用一个<code>a</code>标签将<code>input和a组合</code>到一起,这样修改<code>a</code>的样式便相当于修改<code>input</code>的样式. 对应的几部分代码如下:</p>\n<pre><code>/*CSS*/\n.upload{\n    padding: 5px 10px;\n    height: 40px;\n    line-height: 30px;\n    position: relative;\n    border: 1px solid #999;\n    text-decoration: none;\n    text-align:center;\n    color: #fff;\n}\n.change{\n    position: absolute;\n    overflow: hidden;\n    right: 0;\n    top: 0;\n    opacity: 0;\n}\n\n\n&lt;a class=&quot;btn btn-success upload&quot; placeholder=&quot;上传头像&quot; &gt;\n    &lt;p id=&quot;show_gt&quot;&gt;选择您要上传的头像~&lt;/p&gt;\n    { { form.photo(class=&quot;change&quot;,placeholder=&quot;上传头像&quot;,onchange=&quot;c()&quot;) }}\n&lt;/a&gt;</code></pre><p>然后在<code>css</code>中修改<code>upload</code>样式即可. 其中<code>btn btn-xxx</code>是<code>bootstrap</code>样式. 但是到这里还需要考虑一个问题,就是当<code>选中图片以后,并不会显示到页面上,必选点击提交以后</code>才会修改,下次访问这个页面才会变成新图片. 所以我们需要一种方法使<code>选中图片的同时将图片显示在页面上</code>,并和之前的头像对比. 这里我们使用直接<code>通过JavaScript在本地显示</code>: 对应JS代码如下:</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function c () {\n        var gt=document.getElementById(&apos;show_gt&apos;);\n        gt.innerText = &apos;已选中图片~&apos;\n        var r= new FileReader();\n        f=document.getElementById(&apos;photo&apos;).files[0];\n        r.readAsDataURL(f);\n        r.onload=function  (e) {\n            document.getElementById(&apos;show&apos;).src=this.result;\n        };\n    }\n&lt;/script&gt;</code></pre><p>因为<code>FlaskForm</code>生成的表单的<code>id</code>和类中对应<code>表单实例的名字</code>是一样的,所以这里的<code>id</code>是photo. 获取<code>图片对象(object) f</code>. 把这个File对象传给FileReader对象的读取方法，就能读取文件了。 连接: <a href=\"http://blog.csdn.net/oscar999/article/details/37499743/\" title=\"&lt;code&gt;[JS进阶] HTML5 之文件操作(file)&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啦! [JS进阶] HTML5 之文件操作(file)</code></a> 最后的<code>r.result</code>即为对应图片的<code>二进制数据</code>. 然后就是修改一下排版即可:</p>\n<pre><code>&lt;!-- edit_gravatar.html --&gt;\n{% extends \"base.html\" %}\n{% import \"bootstrap/wtf.html\" as wtf %}\n{% block title %}编辑个人头像{% endblock %}\n    {% block page_content %}\n    <form method=\"POST\" enctype=\"multipart/form-data\">\n         { { form.hidden_tag() }}\n         <div class=\"page-header\"><h2><span id=\"展览板~\">展览板~</span></h2></div>\n         <a class=\"btn btn-success upload\" placeholder=\"上传头像\"><p id=\"show_gt\">选择您要上传的头像~</p>\n            { { form.photo(class=\"change\",placeholder=\"上传头像\",onchange=\"c()\") }}\n         </a><br>\n         {% for error in form.photo.errors %}\n             <span style=\"color: red;\">{ { error }}</span>\n         {% endfor %}\n         {% if file_url %}\n         <br><img src=\"{ { file_url }}\" width=\"256\" height=\"256\">\n         {% endif %}\n         <a class=\"btn btn-success\"><-之前 之后-></-之前></a>\n         <img src=\"{ { file_url }}\" id=\"show\" width=\"256\" height=\"256\"><br><br>\n         { { form.submit }}\n    </form>\n    <script type=\"text/javascript\">\n        function c () {\n            var gt=document.getElementById('show_gt');\n            gt.innerText = '已选中图片~'\n            var r= new FileReader();\n            f=document.getElementById('photo').files[0];\n            r.readAsDataURL(f);\n            r.onload=function  (e) {\n                document.getElementById('show').src=this.result;\n            };\n        }\n    </script>\n    {% endblock %}</code></pre><h3><span id=\"done\">Done</span></h3>","text":"借助上节的基础==&gt; 点我啊! Python Flask 上传文件 这节我们实现一下修改用户头像以及默认头像的功能. 截止目前的项目进度: 点我啊! Github:flask-大型网站架构5-新增上传头像 最终效果如图: 1.  [Figure]          { { ","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"JS","slug":"Flask/JS","count":1,"path":"api/categories/Flask/JS.json"},{"name":"Python","slug":"Flask/JS/Python","count":1,"path":"api/categories/Flask/JS/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]}]}