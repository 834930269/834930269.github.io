{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"运维相关Cron定时重启","slug":"cron","date":"2018-02-26T02:37:44.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/cron.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>起因于Apache经常因为爆内存关闭mysql,然后就想着每天晚上重启一下. 于是用了cron crontab -l</p>\n<blockquote>\n<p>查询脚本</p>\n</blockquote>\n<p>crontab -e</p>\n<blockquote>\n<p>进入脚本编辑</p>\n</blockquote>\n<p>Vim</p>\n<blockquote>\n<p>Q:编辑模式 ESC:退出编辑模式 Shift+:+wq:保存并退出</p>\n</blockquote>\n</blockquote>\n","text":"起因于Apache经常因为爆内存关闭mysql,然后就想着每天晚上重启一下. 于是用了cron crontab -l查询脚本crontab -e进入脚本编辑VimQ:编辑模式 ESC:退出编辑模式 Shift+:+wq:保存并退出","link":"","raw":null,"photos":[],"categories":[{"name":"运维","slug":"运维","count":1,"path":"api/categories/运维.json"}],"tags":[{"name":"运维","slug":"运维","count":1,"path":"api/tags/运维.json"}]},{"title":"技巧论 QAQ","slug":"jql-qaq","date":"2018-02-25T15:49:18.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/jql-qaq.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>凡事要讲究技巧,无技不成巧,先将遇到的技巧记录下来..</p>\n<blockquote>\n<p>对的…这特么就是一个远古巨坑</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"中途相遇法又称折半枚举双向搜索\">中途相遇法(又称折半枚举,双向搜索)</span></h1><h2><span id=\"思想论\">思想论</span></h2><blockquote>\n<p>如果纬度特别高时,比如数据量为N,总情况数为N^4,全部遍历一遍是肯定不可以的,不过可以将它们折半成AB和CD再考虑,就可以快速解决了.</p>\n<blockquote>\n<p>从两个数列中考虑的话,就只剩下N^2种情况了,因此对两半枚举完以后排一下序,就可以用二分搜索了.</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"例题山东第一届省赛-d\">例题:山东第一届省赛 D</span></h2><blockquote>\n<p>右侧标签云中找一下第一节山东省塞即可</p>\n</blockquote>\n<h1><span id=\"爬梯法\">爬梯法</span></h1><h1><span id=\"尺取法\">尺取法</span></h1><blockquote>\n<p>思想:</p>\n<blockquote>\n<p>规定那个两个点,先固定左端点,如果小于答案,则右端点向右走,否则左端点向左走 POJ 3061</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"分块法\">分块法</span></h1><blockquote>\n<p>51nod 1225</p>\n</blockquote>\n<h1><span id=\"倍增算法\">倍增算法</span></h1><h1><span id=\"康托展开\">康托展开</span></h1>","text":"凡事要讲究技巧,无技不成巧,先将遇到的技巧记录下来..对的…这特么就是一个远古巨坑中途相遇法(又称折半枚举,双向搜索)思想论如果纬度特别高时,比如数据量为N,总情况数为N^4,全部遍历一遍是肯定不可以的,不过可以将它们折半成AB和CD再考虑,就可以快速解决了.从两个数列中考虑的话","link":"","raw":null,"photos":[],"categories":[{"name":"中途相遇法","slug":"中途相遇法","count":1,"path":"api/categories/中途相遇法.json"},{"name":"二分搜索","slug":"中途相遇法/二分搜索","count":1,"path":"api/categories/中途相遇法/二分搜索.json"}],"tags":[{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"中途相遇法","slug":"中途相遇法","count":2,"path":"api/tags/中途相遇法.json"}]},{"title":"山东省第一届省赛","slug":"1stshandongacm","date":"2018-02-25T14:00:45.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/1stshandongacm.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"a-可水可trietrie解法\">A: 可水可Trie,Trie解法</span></h1><blockquote>\n<p>数据不大,因为题目没有给出字符串的大小,害怕暴力超时,所以用Trie写的.</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int CHARSET=10,BASE=&apos;0&apos;,MAX_NODE=10100;\nstruct Trie{\n    int tot,root,child[MAX_NODE][CHARSET];\n    bool flag[MAX_NODE];\n    bool has_prefix;\n    bool is_root[MAX_NODE][CHARSET];\n    Trie(){\n        //printf(&quot;New Trie\\n&quot;);\n        memset(child[1],0,sizeof(child[1]));\n        memset(is_root,false,sizeof(is_root));\n        flag[1]=false;\n        has_prefix=false;\n        root=tot=1;\n    }\n    void insert(const char *str){\n        int *cur=&amp;root;\n        char last_char;\n        for(const char *p=str;*p;++p){\n            cur=&amp;child[*cur][*p-BASE];\n            last_char=*p;\n            if(is_root[*cur][last_char])has_prefix=true;\n            if(*cur==0){\n                *cur=++tot;\n                memset(child[tot],0,sizeof(child[tot]));\n                flag[tot]=false;\n            }\n        }\n        flag[*cur]=true;\n        is_root[*cur][last_char]=true;\n    }\n\n};\nint main(){\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        Trie te;\n        char str[10000];\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            if(!te.has_prefix){\n                te.insert(str);\n            }\n        }\n        if(te.has_prefix){\n            printf(&quot;NO\\n&quot;);\n        }else{\n            printf(&quot;YES\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre><h1><span id=\"b思路比较清晰就是写的时间长我写了两份代码\">B:思路比较清晰,就是写的时间长,我写了两份代码</span></h1><h2><span id=\"单树map套结构体point重载lt二分-内存小时间长\">单树(map)套结构体Point重载&lt;+二分: 内存小,时间长</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\nstruct Point{\n    int x,y;\n    bool operator &lt; (const Point&amp; a)const{\n        if(x&lt;a.x) return true;\n        else if(x==a.x &amp;&amp; y&lt;a.y) return true;\n        return false;\n    }\n    bool operator == (const Point&amp; a)const{\n        if(x==a.x &amp;&amp; y==a.y) return true;\n        return false;\n    }\n\n};\nint N,kase=1;\n\nint xx,yy;\nchar opt[10];\n\nmap&lt;Point,bool&gt; G;//x点集0,true为未删除,false为删除\nmap&lt;Point,bool&gt;::iterator it;\n\nvoid init(){\n    G.clear();\n}\n\nbool cmp(Point a,Point b){\n    if(a.x&lt;b.x &amp;&amp; a.y&lt;b.y)\n        return true;\n    return false;\n}\n\nvoid add(){\n    G[(Point){xx,yy}]=true;\n}\n\nvoid find_(int a,int b){\n    it=G.upper_bound((Point){a,b});\n    if(it==G.end()){\n        printf(&quot;-1\\n&quot;);\n        return;\n    }\n    Point nw=it-&gt;first;\n    if(it-&gt;second &amp;&amp; nw.x&gt;xx &amp;&amp; nw.y&gt;yy){\n        printf(&quot;%d %d\\n&quot;,nw.x,nw.y);\n    }else{\n        do{\n            it++;\n            if(it==G.end()){printf(&quot;-1\\n&quot;);return;}\n            if(it-&gt;second &amp;&amp; (it-&gt;first).x&gt;xx &amp;&amp; (it-&gt;first).y&gt;yy){\n                printf(&quot;%d %d\\n&quot;,(it-&gt;first).x, (it-&gt;first).y);\n                return;\n            }\n        }while(1);\n    }\n}\n\nvoid remove_(){\n    G[(Point){xx,yy}]=false;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s %d %d&quot;,opt,&amp;xx,&amp;yy);\n            if(opt[0]==&apos;a&apos;){\n                add();\n            }else if(opt[0]==&apos;f&apos;){\n                find_(xx,yy);\n            }else{\n                remove_();\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 904ms\nTake Memory: 5752KB\nSubmit time: 2018-02-27 17:08:24\n****************************************************/</code></pre><h2><span id=\"树map二分套树map二分代码少时间短内存大\">树(map)+二分套树(map)+二分,代码少,时间短,内存大</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\n\nint N,kase=1;\n\nint xx,yy;\nchar opt[10];\n\nmap&lt;int,map&lt;int,bool&gt; &gt; G;//x点集0,true为未删除,false为删除\nmap&lt;int,bool&gt;::iterator ity;\nmap&lt;int,map&lt;int,bool&gt; &gt;::iterator itx;\n\nvoid init(){\n    G.clear();\n}\n\nvoid add(){\n    (G[xx])[yy]=true;\n}\n\nvoid find_(){\n    itx=G.upper_bound(xx);\n    while(1){\n        if(itx!=G.end()){\n            ity=(itx-&gt;second).upper_bound(yy);\n            if(ity!=(itx-&gt;second).end() &amp;&amp; ity-&gt;second){\n                printf(&quot;%d %d\\n&quot;,itx-&gt;first,ity-&gt;first);\n                return;\n            }\n            if(ity!=(itx-&gt;second).end()){\n                for(ity++;ity!=(itx-&gt;second).end();ity++){\n                    if(ity-&gt;second){\n                        printf(&quot;%d %d\\n&quot;,itx-&gt;first,ity-&gt;first);\n                        return;\n                    }\n                }\n            }\n        }else break;\n        itx++;\n    }\n    printf(&quot;-1\\n&quot;);\n}\n\nvoid remove_(){\n    (G[xx])[yy]=false;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s %d %d&quot;,opt,&amp;xx,&amp;yy);\n            if(opt[0]==&apos;a&apos;){\n                add();\n            }else if(opt[0]==&apos;f&apos;){\n                find_();\n            }else{\n                remove_();\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 516ms\nTake Memory: 12712KB\nSubmit time: 2018-02-27 17:24:44\n****************************************************/</code></pre><h2><span id=\"然后我百度一下原题发现set直接删除就好还是stl不太熟内存小用时也少不过没第二份少\">然后我百度一下原题,发现set直接删除就好…还是STL不太熟,内存小,用时也少,不过没第二份少</span></h2><pre><code>#include &lt;iostream&gt;  \n#include &lt;stdio.h&gt;  \n#include &lt;algorithm&gt;  \n#include &lt;set&gt;  \n#include &lt;string&gt;  \nusing namespace std;  \n\nint main()  \n{  \n    pair&lt;int,int&gt;p;  \n    int n;char str[10];  \n    int c=1;  \n    while(cin&gt;&gt;n&amp;&amp;n)  \n    {  \n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;:&quot;&lt;&lt;endl;  \n        set&lt; pair&lt;int,int&gt; &gt;s;  \n        while(n--)  \n        {  \n            scanf(&quot;%s&quot;,str);  \n            scanf(&quot;%d%d&quot;,&amp;p.first,&amp;p.second);  \n            if(str[0]==&apos;a&apos;)  \n                s.insert(p);  \n            else if(str[0]==&apos;r&apos;)  \n                s.erase(p);  \n            else if(str[0]==&apos;f&apos;)  \n            {  \n                set&lt; pair&lt;int,int&gt; &gt;::iterator it;  \n                it=s.lower_bound(p);//找到set中第一个比p大的元素的位置，找不到则为s.end()  \n                for(;it!=s.end();it++)  \n                {  \n                    if(it-&gt;first&gt;p.first&amp;&amp;it-&gt;second&gt;p.second)//都大于才符合题意  \n                    {  \n                        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;  \n                        break;  \n                    }  \n                }  \n                if(it==s.end())//找不到  \n                    cout&lt;&lt;-1&lt;&lt;endl;  \n            }  \n        }  \n        cout&lt;&lt;endl;  \n    }  \n    return 0;  \n}  </code></pre><h2><span id=\"貌似还可以用线段树优化\">貌似还可以用线段树优化..</span></h2><h3><span id=\"fk\">F**k</span></h3><h1><span id=\"c排序水过别问我为啥写的那么麻烦因为我半截才想到懒得改了\">C:排序水过,别问我为啥写的那么麻烦…因为我半截才想到,懒得改了</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\nstruct Query{\n    int s,t;\n};\nint N,kase=1;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; G[maxn];\n        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; it;\n        vector&lt;Query&gt; Q;\n        for(int i=1;i&lt;=N;++i){\n            int s,t;\n            scanf(&quot;%d%d&quot;,&amp;s,&amp;t);\n            G[s].push(t);\n            Q.push_back((Query){s,t});\n        }\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;Q.size();++i){\n            int s=Q[i].s,t=Q[i].t;\n            bool has_ans=false;\n            for(int j=s+1;j&lt;=309 &amp;&amp; !has_ans;++j){\n                it=G[j];\n                while(!it.empty()){\n                    int nw=it.top();it.pop();\n                    if(nw&gt;t){\n                        has_ans=true;\n                        printf(&quot;%d %d\\n&quot;,j,nw);\n                        break;\n                    }\n                }\n            }\n            if(!has_ans){\n                printf(&quot;-1 -1\\n&quot;);\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><h1><span id=\"d中途相遇法负值二分\">D:中途相遇法+负值二分</span></h1><blockquote>\n<p>因为内置的lower_bound只能查找第一个大于等于的,而我们需要的是小于等于的,所以将所有的值变成负数插入到vector中即可. 这道题N^4肯定是不可行的.所以我们考虑用中途相遇法,</p>\n<blockquote>\n<p>即先处理出任意两个值的和,然后遍历和数组,在原数组中查找是否存在一个值和当前和相加&lt;=M,如果等于M,break即可.</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2000;\nint N,M,KASE=1;\nint arr[maxn];\nvector&lt;int&gt; first;\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M) &amp;&amp; N+M){\n        first.clear();\n        int ans=0;\n        for(int i=0;i&lt;N;++i) scanf(&quot;%d&quot;,&amp;arr[i]);\n        for(int i=0;i&lt;N;++i){\n            for(int j=i;j&lt;N;++j){\n                first.push_back(-(arr[i]+arr[j]));\n            }\n        }\n        sort(first.begin(),first.end());\n        for(int i=0;i&lt;first.size();++i){\n            int need=M+first[i];\n            if(need&lt;=0) continue;\n            else{\n                int id=lower_bound(first.begin(),first.end(),-need)-first.begin();\n                int nw=-(first[i]+first[id]);\n                if(nw&lt;=M) ans=max(ans,nw);\n            }\n            if(ans==M)break;\n        }\n        printf(&quot;Case %d: %d\\n\\n&quot;,KASE++,ans);\n    }\n    return 0;\n}</code></pre><h1><span id=\"g排序水过\">G:排序水过</span></h1><blockquote>\n<p>一开始没读懂题意时最难受的</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100100;\nint Dist[maxn],N;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;Dist[i]);\n        }\n        sort(Dist,Dist+N);\n        LL ans=0ll;\n        for(int i=1;i&lt;N;++i){\n            ans+=((Dist[i]-Dist[i-1])&lt;&lt;1);\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><h1><span id=\"i分别进行两个dfs即可四方向和八方向\">I:分别进行两个dfs即可,四方向和八方向</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint move1[4][2]={ {0,-1},{0,1},{-1,0},{1,0}};\nint move2[8][2]={ {0,-1},{0,1},{-1,0},{1,0},\n                 {1,-1},{1,1},{-1,-1},{-1,1}};\nchar mp[110][110];\nint N,kase=1;\nint vis1[110][110],vis2[110][110];\n\nvoid init(){\n    memset(vis1,0,sizeof(vis1));\n    memset(vis2,0,sizeof(vis2));\n}\n\nbool check(int x,int y){\n    if(x&gt;=N || y&gt;=N || x&lt;0 || y&lt;0 || mp[x][y]==&apos;0&apos;)\n        return false;\n    return true;\n}\n\nvoid dfs4(int x,int y){\n    if(!check(x,y) || vis1[x][y]) return;\n    vis1[x][y]=1;\n    for(int i=0;i&lt;4;++i){\n        int nx=x+move1[i][0],ny=y+move1[i][1];\n        dfs4(nx,ny);\n    }\n}\n\nvoid dfs8(int x,int y){\n    if(!check(x,y) || vis2[x][y]) return;\n    vis2[x][y]=1;\n    for(int i=0;i&lt;8;++i){\n        int nx=x+move2[i][0],ny=y+move2[i][1];\n        dfs8(nx,ny);\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,mp[i]);\n        }\n        int ans4=0,ans8=0;\n        for(int i=0;i&lt;N;++i){\n            for(int j=0;j&lt;N;++j){\n                if(mp[i][j]==&apos;1&apos; &amp;&amp; !vis1[i][j]){\n                    ans4++,dfs4(i,j);\n                }\n                if(mp[i][j]==&apos;1&apos; &amp;&amp; !vis2[i][j]){\n                    ans8++,dfs8(i,j);\n                }\n            }\n        }\n        printf(&quot;Case %d: %d %d\\n\\n&quot;,kase++,ans4,ans8);\n    }\n    return 0;\n}</code></pre><h1><span id=\"e大模拟\">E:大模拟</span></h1><p>大模拟</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long LL;\nconst int maxn=35;\nint N,kase=1;\nchar mp[maxn][maxn];\nint vis[maxn][maxn][maxn][maxn][5];\n///EWSN东西南北\nint dis[4][2]={ {0,1},{0,-1},{1,0},{-1,0}};\n///saya更喜欢EWNS\nint nt[4][2]={ {0,1},{0,-1},{-1,0},{1,0}};\n\nbool check(int x,int y){\n    if(x&lt;0||y&lt;0||x&gt;=N||y&gt;=N)return false;\n    return true;\n}\n///返回当前的朝向在,数组为dis\nint now_dir(int x,int y,int t){\n    char str=mp[x][y];\n    int in=0;\n    if(str==&apos;E&apos;) in=0;\n    else if(str==&apos;W&apos;) in=1;\n    else if(str==&apos;S&apos;) in=2;\n    else in=3;\n    in+=t;\n    return in%4;\n}\n\nint dist(int x,int y,int tx,int ty){\n    return (x-tx)*(x-tx)+(y-ty)*(y-ty);\n}\n\nint query_dir(int x,int y,int tx,int ty){\n    int mind=INF,dir_=-1;\n    for(int i=0;i&lt;4;++i){\n        int xx=x+nt[i][0],yy=y+nt[i][1];\n        if(!check(xx,yy)) continue;\n        int d=dist(xx,yy,tx,ty);\n        if(mind&gt;d){\n            mind=d;\n            dir_=i;\n        }\n    }\n    ///返回第一个想走的方向\n    return dir_;\n}\n\nint main(){\n    while(scanf(&quot;%d&quot;,&amp;N)!=EOF &amp;&amp; N!=0){\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,&amp;mp[i]);\n        }\n        int x=0,y=0,tx=N-1,ty=N-1,step=0;\n        int xx,yy,txx,tyy;\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        while(1){\n            if(step&gt;=100){\n                printf(&quot;Not sure.\\n&quot;);\n                break;\n            }\n            if(tx==x&amp;&amp;ty==y){\n                printf(&quot;Get the treasure! At step %d.\\n&quot;,step);\n                break;\n            }\n            ///saya第一步\n            int saya=now_dir(x,y,step);\n            xx=x+dis[saya][0],yy=y+dis[saya][1];\n            if(check(xx,yy)){\n                x=xx,y=yy;\n            }\n            ///saya第二步\n            if(!(x==tx&amp;&amp;y==ty)){\n                int goal=query_dir(x,y,tx,ty);\n                xx=x+nt[goal][0],yy=y+nt[goal][1];\n                if(check(xx,yy)){\n                    x=xx,y=yy;\n                }\n            }\n            ///宝藏走\n            int tres=now_dir(tx,ty,step);\n            txx=tx+dis[tres][0],tyy=ty+dis[tres][1];\n            if(check(txx,tyy)){\n                tx=txx,ty=tyy;\n            }\n\n            if(vis[x][y][tx][ty][step%4]){\n                printf(&quot;Impossible. At step %d.\\n&quot;,step);\n                break;\n            }else{\n                vis[x][y][tx][ty][step%4]=1;\n            }\n            step+=1;\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"A: 可水可Trie,Trie解法数据不大,因为题目没有给出字符串的大小,害怕暴力超时,所以用Trie写的.#include&lt;bits/stdc++.h&gt;using namespace std;const int CHARSET=10,BASE=&apos;0&apo","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"STL","slug":"Sdut/STL","count":2,"path":"api/categories/Sdut/STL.json"},{"name":"Trie","slug":"Sdut/STL/Trie","count":1,"path":"api/categories/Sdut/STL/Trie.json"},{"name":"中途相遇法","slug":"Sdut/STL/Trie/中途相遇法","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法.json"},{"name":"二分搜索","slug":"Sdut/STL/Trie/中途相遇法/二分搜索","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索.json"},{"name":"数据结构","slug":"Sdut/STL/Trie/中途相遇法/二分搜索/数据结构","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索/数据结构.json"},{"name":"第一届ACM山东省塞","slug":"Sdut/STL/Trie/中途相遇法/二分搜索/数据结构/第一届ACM山东省塞","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索/数据结构/第一届ACM山东省塞.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"中途相遇法","slug":"中途相遇法","count":2,"path":"api/tags/中途相遇法.json"},{"name":"Trie","slug":"Trie","count":1,"path":"api/tags/Trie.json"},{"name":"第一届ACM山东省塞","slug":"第一届ACM山东省塞","count":1,"path":"api/tags/第一届ACM山东省塞.json"}]},{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） G 斐波那契博弈","slug":"20185-g","date":"2018-02-25T10:49:05.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/20185-g.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>斐波那契博弈模板题,我凑…</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000;\nset&lt;int&gt; st;\nint FB[maxn];\nint n;\ninline void init(){\n    FB[1]=1ll;FB[0]=1ll;\n    int i;\n    for(i=2;FB[i-1]&lt;=1e9+7;++i){\n        FB[i]=FB[i-1]+FB[i-2];\n        st.insert(FB[i]);\n    }\n}\n\nint main(){\n    init();\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(st.find(n)!=st.end()){\n            cout&lt;&lt;&quot;Sha&quot;&lt;&lt;endl;\n        }else{\n            cout&lt;&lt;&quot;Xian&quot;&lt;&lt;endl;\n        }\n    }\n    return 0;\n}</code></pre>","text":"斐波那契博弈模板题,我凑…#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000;set&lt;int&gt; st;int FB[maxn];int n;inline void init(){  ","link":"","raw":null,"photos":[],"categories":[{"name":"博弈论","slug":"博弈论","count":3,"path":"api/categories/博弈论.json"},{"name":"斐波那契博弈","slug":"博弈论/斐波那契博弈","count":1,"path":"api/categories/博弈论/斐波那契博弈.json"},{"name":"牛客练习赛","slug":"博弈论/斐波那契博弈/牛客练习赛","count":1,"path":"api/categories/博弈论/斐波那契博弈/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"斐波那契博弈","slug":"斐波那契博弈","count":1,"path":"api/tags/斐波那契博弈.json"}]},{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） H,F,B","slug":"2018-5-h","date":"2018-02-25T10:46:49.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/2018-5-h.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>H,和B是树状数组.F是水题,其实前两个也算水(模板)了.</p>\n<blockquote>\n<p>需要提的是,H用的是树状数组的区间更新和区间查询.</p>\n</blockquote>\n</blockquote>\n<p>H<br>=</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define lowbit(i) (i &amp; (-i))\n\nusing namespace std;\ntypedef long long LL;\nconst int Nmax = 100100;\nint N,Q;\nLL delta[Nmax];//delta的前缀和\nLL deltai[Nmax];//delta*i的前缀和\nLL sum[Nmax];//原始前缀和\n\nLL query(LL *arr,int pos){\n    LL temp=0ll;\n    while(pos&gt;0){\n        temp+=arr[pos];\n        pos-=lowbit(pos);\n    }\n    return temp;\n}\n\nvoid update(LL *arr,int pos,int x){\n    while(pos&lt;=N){\n        arr[pos]+=x;\n        pos+=lowbit(pos);\n    }\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n    LL nw;\n    char opt;\n    for(int i=1;i&lt;=N;++i){\n        scanf(&quot;%lld&quot;,&amp;nw);\n        sum[i]=sum[i-1]+nw;\n    }\n    while(Q--){\n        getchar();\n        scanf(&quot;%c&quot;,&amp;opt);\n        if(opt==&apos;C&apos;){\n            int l,r,x;\n            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x);\n            update(delta, l, x);\n            update(delta, r+1, -x);\n            update(deltai, l, x * l);\n            update(deltai, r+1, -x * (r+1));\n        }else{\n            int l,r;\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            LL suml = sum[l - 1] + l * query(delta, l - 1) - query(deltai, l - 1);\n            LL sumr = sum[r] + (r + 1) * query(delta, r) - query(deltai, r);\n            printf(&quot;%lld\\n&quot;, sumr - suml);\n        }\n    }\n    return 0;\n}</code></pre><p>B<br>=</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define lowbit(i) (i&amp;(-i))\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100100;\nLL Tree[maxn];\n\nvoid add(int x,int value){\n    for(int i=x;i&lt;=maxn;i+=lowbit(i)){\n        Tree[i]+=value;\n    }\n}\n\nLL get(int x){\n    LL sum=0ll;\n    for(int i=x;i;i-=lowbit(i)){\n        sum+=Tree[i];\n    }\n    return sum;\n}\n\nint main(){\n    int n,m;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;++i){\n        LL q;\n        scanf(&quot;%lld&quot;,&amp;q);\n        add(i,q);\n    }\n    for(int i=0;i&lt;m;++i){\n        int ck;\n        scanf(&quot;%d&quot;,&amp;ck);\n        if(ck==1){\n            int x,k;\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;k);\n            add(x,k);\n        }else{\n            int l,r;\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            printf(&quot;%lld\\n&quot;,get(r)-get(l-1));\n        }\n    }\n    return 0;\n}</code></pre><p>F<br>=</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint n;\nint main(){\n    while(cin&gt;&gt;n){\n        while(n/10){\n            int nn=0;\n            while(n&gt;0){\n                nn+=(n%10);\n                n/=10;\n            }\n            n=nn;\n        }\n        cout&lt;&lt;n&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"H,和B是树状数组.F是水题,其实前两个也算水(模板)了.需要提的是,H用的是树状数组的区间更新和区间查询.H<br>=#include&lt;bits/stdc++.h&gt;#define lowbit(i) (i &amp; (-i))using namespace std","link":"","raw":null,"photos":[],"categories":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/categories/树状数组.json"},{"name":"牛客练习赛","slug":"树状数组/牛客练习赛","count":2,"path":"api/categories/树状数组/牛客练习赛.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"}]},{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） A 逆序数","slug":"2018-5-a","date":"2018-02-25T10:40:31.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/2018-5-a.json","excerpt":"","keywords":null,"cover":null,"content":"<p>链接：<a href=\"https://www.nowcoder.com/acm/contest/77/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/77/A</a> 来源：牛客网</p>\n<h1><span id=\"题目描述\">题目描述</span></h1><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。比如一个序列为4 5 1 3 2， 那么这个序列的逆序数为7，逆序对分别为(4, 1), (4, 3), (4, 2), (5, 1), (5, 3), (5, 2),(3, 2)。</p>\n<h1><span id=\"输入描述\">输入描述:</span></h1><p>第一行有一个整数n(1 &lt;= n &lt;= 100000), 然后第二行跟着n个整数，对于第i个数a[i]，(0 &lt;= a[i] &lt;= 100000)。</p>\n<h1><span id=\"输出描述\">输出描述:</span></h1><p>输出这个序列中的逆序数</p>\n<h1><span id=\"示例1\">示例1</span></h1><h2><span id=\"输入\">输入</span></h2><p>5 4 5 1 3 2</p>\n<h2><span id=\"输出\">输出</span></h2><p>7</p>\n<h1><span id=\"两种方法求逆序数\">两种方法求逆序数</span></h1><h2><span id=\"归并排序\">归并排序</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100010;\n\nint seq[maxn],N;\nint temp[maxn];\nLL cnt;\n//归并排序求逆序数\nvoid merge_sort(int arr[],int l,int r){\n    if(l==r)return;\n    int mid=((l+r)&gt;&gt;1);\n    merge_sort(arr,l,mid);\n    merge_sort(arr,mid+1,r);\n    int i=l,j=mid+1;\n    for(int k=l;k&lt;=r;++k){\n        if(j&gt;r || (i&lt;=mid &amp;&amp; arr[i]&lt;arr[j]))temp[k]=arr[i++];\n        else temp[k]=arr[j++],cnt+=mid-i+1;\n        //如果a[i]&gt;a[j]则逆序数加上mid+1-i,即剩下的前面个数\n    }\n    for(i=l;i&lt;=r;++i)arr[i]=temp[i];\n}\n\nint main(){\n    cin&gt;&gt;N;\n    for(int i=0;i&lt;N;++i){\n        cin&gt;&gt;seq[i];\n    }\n    cnt=0;\n    merge_sort(seq,0,N-1);\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n}</code></pre><h2><span id=\"树状数组\">树状数组</span></h2>","text":"链接：https://www.nowcoder.com/acm/contest/77/A 来源：牛客网题目描述在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。比如一个序列为4 5 1 3","link":"","raw":null,"photos":[],"categories":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/categories/树状数组.json"},{"name":"牛客练习赛","slug":"树状数组/牛客练习赛","count":2,"path":"api/categories/树状数组/牛客练习赛.json"},{"name":"逆序数","slug":"树状数组/牛客练习赛/逆序数","count":1,"path":"api/categories/树状数组/牛客练习赛/逆序数.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"逆序数","slug":"逆序数","count":2,"path":"api/tags/逆序数.json"}]},{"title":"POJ 1961","slug":"poj-1961","date":"2018-02-25T05:26:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-1961.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVALive-3026\" title=\"https://vjudge.net/problem/UVALive-3026\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-3026</a></p>\n<h1><span id=\"type-kmp-next数组\">Type: KMP-Next数组</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><h2><span id=\"前置\">前置</span></h2><h3><span id=\"关于next数组\">关于Next数组</span></h3><blockquote>\n<p>(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符进行再次匹配. (2) j=Next[k]表示第 j 个字符和第 k 个字符一样. (3) j=Next[k]表示前 j 个字符和后 j 个字符一样</p>\n<blockquote>\n<p>即 1<del>j-1 和 k-j+1</del>k 这两个子串相等</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"正文\">正文</span></h2><blockquote>\n<p>即我们求出该字符串的Next数组后我们可以判断当前 (i-Next[i]) 是否能被 i 整除.</p>\n<blockquote>\n<p>即 i%(i-Next[i]) 是否等于0.</p>\n<blockquote>\n<p>i-Next[i]为该子串的长度,如果可以整除则证明该子串为循环节,循环节长度为 i-Next[i] ,循环次数为 i/(i-Next[i]).</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nchar ts[maxn];\nint n,kase=1;\nint Next[maxn];\nvoid getNext(){\n    int j=0,k=-1;\n    Next[0]=-1;\n    while(j&lt;n){\n        if(k==-1 || ts[j]==ts[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\nvoid print(){\n    for(int i=1;i&lt;=n;++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(!n)break;\n        scanf(&quot;%s&quot;,ts);\n        getNext();\n        //print();\n        printf(&quot;Test case #%d\\n&quot;,kase++);\n        for(int i=2;i&lt;=n;++i){\n            if(Next[i]&lt;=0) continue;\n            if(i%(i-Next[i])==0){\n                printf(&quot;%d %d\\n&quot;,i,i/(i-Next[i]));\n            }\n        }\n        printf(&quot;\\n&quot;);\n        getchar();\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVALive-3026Type: KMP-Next数组题意给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度题解前置关于Next数组(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"LA","slug":"KMP/LA","count":1,"path":"api/categories/KMP/LA.json"},{"name":"POJ","slug":"KMP/LA/POJ","count":1,"path":"api/categories/KMP/LA/POJ.json"},{"name":"字符串处理","slug":"KMP/LA/POJ/字符串处理","count":1,"path":"api/categories/KMP/LA/POJ/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"字符串算法","slug":"charset-algorithm","date":"2018-02-24T10:32:39.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/charset-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png","content":"<h1><span id=\"trie\">Trie</span></h1><blockquote>\n<p>这个…不想写了</p>\n</blockquote>\n<h1><span id=\"kmp\">KMP</span></h1><blockquote>\n<p>朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)</p>\n</blockquote>\n<h2><span id=\"next数组\">Next数组</span></h2><blockquote>\n<p>对于KMP而言最重要的莫过于这个Next数组了.</p>\n<blockquote>\n<p>Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.</p>\n</blockquote>\n<p>构造方法:</p>\n<blockquote>\n<p>Next[i]=max{j | j\\&lt;i 且N[1..j]=N[i-j+1..i]}</p>\n<blockquote>\n<p>即Next[i]球的试串P[1..i]的一个最长的前缀P[1..j],这个前缀同时也是他的后缀。当这个前缀找不到的时候,Next[i]=0</p>\n</blockquote>\n</blockquote>\n<p>例如:</p>\n<blockquote>\n<p>模式串 P = ababc</p>\n<blockquote>\n<p>则Next[4]=2,因为ab不仅是abab的前缀,也是他的后缀. 而Next[5]=0，因为无法找到ababc(P[1..5])的一个前缀同时又是他的后缀.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3><span id=\"附上一张图\">附上一张图</span></h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" alt></a></p>\n<h2><span id=\"匹配时逻辑\">匹配时逻辑</span></h2><blockquote>\n<p>KMP 在匹配时同时维护两个下标 i 和 j ,表示当前模式串 P 的前 j 个字符与主串 T 在位置 i 前的 j 个字符匹配,即 P[1..j]=T[i-j..i-1]。 当算法尝试对 T[i] 和 P[j+1] 匹配中遇到不相同的字符,就会通过Next数组进行跳跃。</p>\n</blockquote>\n<h2><span id=\"算法实现\">算法实现</span></h2><h3><span id=\"next数组\">Next数组</span></h3><h4><span id=\"代码\">代码</span></h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(cin&gt;&gt;T){\n        getNext();\n        print();\n    }\n    return 0;\n}</code></pre><h4><span id=\"几组数据\">几组数据</span></h4><pre><code>ababc\nNext: -1 0 0 1 2\n\nabcdef\nNext: -1 0 0 0 0 0\n\nabcdabce\nNext: -1 0 0 0 0 1 2 3\n\nabcabcabc\nNext: -1 0 0 0 1 2 3 4 5\n\nabcdabcabcd\nNext: -1 0 0 0 0 1 2 3 1 2 3</code></pre><h3><span id=\"kmp-返回第一个匹配的下标\">KMP - 返回第一个匹配的下标</span></h3><h4><span id=\"主程\">主程</span></h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint KMP_index(){\n    int i=0,j=0,slen=S.length(),tlen=T.length();\n    getNext();\n    while(i&lt;slen &amp;&amp; j&lt;tlen){\n        if(j==-1 || S[i]==T[j]){\n            i++;\n            j++;\n        }else j=Next[j];\n    }\n    if(j==tlen) return i-tlen;\n    else return -1;\n}\n\nint main(){\n    while(cin&gt;&gt;S&gt;&gt;T){\n        int ans=KMP_index();\n        if(ans==-1) cout&lt;&lt;&quot;Failed!&quot;&lt;&lt;endl;\n        else cout&lt;&lt;&quot;Succesed!String T was matched in index &quot;&lt;&lt;ans&lt;&lt;&quot;.&quot;&lt;&lt;endl;\n        print();\n    }\n    return 0;\n}</code></pre><h4><span id=\"两组数据\">两组数据</span></h4><pre><code>IN[0]: jashdjashdjabababcabcsdas\nIN[1]: abcabc\nOUT[0]: Succesed!String T was matched in index 15.\nOUT[1]: -1 0 0 0 1 2\nIN[2]: jashdjashdjabababcabcsdas\nIN[3]: abcabcd\nOUT[2]: Failed!\nOUT[3]: -1 0 0 0 1 2 3</code></pre><h1><span id=\"ac-corasick-自动机\">AC-Corasick 自动机</span></h1><blockquote>\n<p>思想是KMP+Trie,在Trie上建立失配指针.</p>\n<blockquote>\n<p>常用于主串匹配多个字符串</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"尾节点记录字符串下标的ac自动机\">尾节点记录字符串下标的AC自动机</span></h2><blockquote>\n<p>优点是可以直接输出字符串.</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2><span id=\"尾节点记录可重复子串在总串中出现次数\">尾节点记录可重复子串在总串中出现次数</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    int ch[maxn][sigma_size];\n    int f[maxn],last[maxn];\n    int cnt[maxn],val[maxn];\n    int siz;\n\n    int ans;\n\n    void init(){\n        siz=ans=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///表示以第u棵节点为字符串最后一个字符节点的个数\n       ///如果想存储该节点代表的是哪个字符串.即存储该字符串的下标\n       ///val[u]=v;(v是下标)\n       ///但是这样存储就会出现无法统计之前有多少个重复字符串\n       ///比如这道题如果输入\n       ///3\n       ///sha\n       ///sha\n       ///sha\n       ///shashasha\n       ///则用第一种方法最后结果是3\n       ///但用第二种方法只能匹配一次sha\n       val[u]++;\n    }\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        if(u){\n            if(!cnt[u]) ans+=val[u],cnt[u]=1;\n            add(last[u]);\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i]);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2><span id=\"失配函数优化\">失配函数优化</span></h2><blockquote>\n<p>接下来都基于第一个代码进行优化,可以复刻到第二个代码上</p>\n<blockquote>\n<p>即将失配记录转变成 一条确定的边连到Trie中(这样应该就不能被称之为树了)</p>\n</blockquote>\n<p>if(!u) continue; =&gt;</p>\n<blockquote>\n<p>if(!u) {ch[k][c]=ch[f[k]][c];continue;} 删掉适配函数BFS中的 while()</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) {ch[k][c]=ch[f[k]][c];continue;}\n                Q.push(u);\n                int v=f[k];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2><span id=\"mle和tle优化内存优化\">MLE和TLE优化–内存优化</span></h2><blockquote>\n<p>听说之前网络赛的时候就有道AC自动机的题,然后普通的模板总是MLE. 少了一半的时间,一半的内存</p>\n<blockquote>\n<p>意在每次不全初始化,每多一个节点初始化一次</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组fail,last\n    int f[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数,根节点编号\n    int siz,root;\n\n    int ans;\n\n    int newNode(){\n        memset(ch[siz],0,sizeof(ch[siz]));\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        ans=0;siz=0;root=newNode();\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    //Fail树,build\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2><span id=\"但是以上自动机识别形如aababcabcd这类子串会出问题在刷题时发现的下面重新用新的方法来解决这个问题建议用下面的ac自动机\">但是以上自动机识别形如a,ab,abc,abcd这类子串会出问题,在刷题时发现的,下面重新用新的方法来解决这个问题,建议用下面的AC自动机</span></h2><h3><span id=\"hdu-2222上面的那些题修改\">HDU 2222，上面的那些题,修改</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root,ans;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n        ans=0;\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        gets(str);\n        tot_len=strlen(str);\n        aho.Find(str);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h3><span id=\"hdu-5880青岛区域赛网赛\">HDU 5880,青岛区域赛网赛</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            if(!isalpha(s[i])){\n                u=0;\n                continue;\n            }\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            /*\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                p=f[p];\n            }\n            */\n            add(u,i);\n        }\n    }\n\n    void print(){\n        for(int i=0;i&lt;tot_len;++i){\n            if(cle[i]) putchar(&apos;*&apos;);\n            else putchar(str[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str,i+1);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(str);\n        tot_len=strlen(str);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(str);\n        aho.print();\n    }\n    return 0;\n}</code></pre><h1><span id=\"后缀数组\">后缀数组</span></h1><h1><span id=\"后缀自动机\">后缀自动机</span></h1>","text":"Trie这个…不想写了KMP朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)Next数组对于KMP而言最重要的莫过于这个Next数组了.Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.构","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"KMP","slug":"AC自动机/KMP","count":1,"path":"api/categories/AC自动机/KMP.json"},{"name":"字符串处理","slug":"AC自动机/KMP/字符串处理","count":1,"path":"api/categories/AC自动机/KMP/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]},{"title":"山东省第八届ACM省赛 fireworks","slug":"fireworks","date":"2018-02-18T12:54:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/fireworks.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>迟来的祝福,新年快乐.</p>\n</blockquote>\n<h1><span id=\"link\">Link</span></h1><blockquote>\n<p>要登录</p>\n</blockquote>\n<p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" title=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html</a></p>\n<h1><span id=\"type-杨辉三角lt-组合数学逆元\">Type: 杨辉三角&lt;-组合数学,逆元</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>假设x位置有一个烟花,则每秒烟花都会分裂到x+1与x-1这两个位置. 给你n个烟花的初始位置xi和个数ci,问你T秒后,位置w上的烟花个数有多少个.</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>画一下样例的图会发现很像杨辉三角,我们可以将每个初始点分开计算,最后的结果就是所有初始点分裂后落在目标点的烟花个数和. 但我们发现它们的初始值大小与杨辉三角不同,并且比杨辉三角多了许多0, 然后我们考虑如何解决这两个情况.</p>\n<blockquote>\n<p>(1) 初始值ci,因为只有一个初始点,这点和杨辉三角一样.所以答案是</p>\n<blockquote>\n<p>ans(原杨辉三角在该位置的结果)*ci</p>\n</blockquote>\n<p>(2) 中间有0,这点好想,我们只需要通过推导公式将实际坐标转换为逻辑坐标即可.</p>\n</blockquote>\n<p>然后我们分情况讨论,我们在图上可以发现</p>\n<blockquote>\n<p>(1) 当 <code>分裂次数</code> 与 <code>目标位置和原位置的距离差</code> 同奇偶时该位置结果为0. (2) 当距离大于T+1时(即杨辉三角第T行值的个数),永远不可能分裂到.</p>\n</blockquote>\n<p>因为只需要考虑最后一次分裂的结果,所以只需要计算杨辉三角第T行即可,即 C(T,0<del>T) 预处理组合公式我们用 <code>组合数学</code> 性质4那个公式. 所以我们需要预处理一下1</del>1e5的逆元,将除法转换为乘法. 最后答案就是</p>\n<blockquote>\n<p>ans=Sigma(i=1~n,c*C[实际位置] | 根据情况忽略i)</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int MOD = 1e9+7;\nconst int maxn = 1e5+7;\n\nLL C[maxn];\n///逆元\nLL inv[maxn];\nvoid init_(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(MOD-MOD/i)*1ll*inv[MOD%i]%MOD;\n    }\n}\n\n///快速幂模求逆元,调动方式quick_mod(i,MOD-2)\n//这里我们用预处理.\nLL quick_mod(LL x, int n){\n    LL ret = 1;\n    while(n){\n        if(n &amp; 1) ret = ret * x % MOD;\n        x = x * x %MOD;\n        n &gt;&gt;= 1;\n    }\n    return ret;\n}\n\nvoid init(int t){\n    C[0]=1;\n    for(int i=1;i&lt;=t;++i){\n        C[i]=C[i-1]*(t-i+1)*1ll%MOD*inv[i]%MOD;\n        //printf(&quot;Num: %d %lld, INV: %lld\\n&quot;,i,C[i],inv[i]);\n    }\n}\n//判断是否同奇同偶\nbool same(int x,int y){\n    if((x&amp;1)^(y&amp;1)) return false;\n    return true;\n}\n\nint query(int t,int d){\n    if(t&amp;1){\n        return t/2-d/2;\n    }\n    return t/2+(d-1)/2;\n}\n\nint main(){\n    init_();\n    int n,T,w;\n    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;T,&amp;w)){\n        init(T);\n        LL ans=0;\n        for(int i=1;i&lt;=n;++i){\n            int x,c;\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;c);\n            int dist=abs(x-w);\n            if(!same(T+1,dist) &amp;&amp; dist&lt;T+1){\n                ans=(ans+c*C[query(T+1,dist)]%MOD)%MOD;\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n\n    return 0;\n}</code></pre>","text":"迟来的祝福,新年快乐.Link要登录http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.htmlType: 杨辉三角&lt;-组合数学,逆元题意假设x位置有一个烟花,则每秒","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"二项式定理","slug":"Sdut/二项式定理","count":1,"path":"api/categories/Sdut/二项式定理.json"},{"name":"数论","slug":"Sdut/二项式定理/数论","count":1,"path":"api/categories/Sdut/二项式定理/数论.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛.json"},{"name":"组合数学","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"数据结构补充","slug":"datastruct-add","date":"2018-02-13T13:12:07.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/datastruct-add.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…</p>\n<blockquote>\n<p>注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"并查集\">并查集</span></h1><h2><span id=\"要领\">要领</span></h2><blockquote>\n<p>以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.</p>\n<blockquote>\n<p>并查集是不可能分割的,即只能合并,不可分割.</p>\n<blockquote>\n<p>在牛客上听大佬讲课貌似存在可分割并查集,带权并查集.</p>\n</blockquote>\n</blockquote>\n<p>现在拓宽下,并查集常用于判断加入一个点后是否会在原图上形成环. 或者判断有几个连通分量(通常是无向图),然后问你这些节点全部关联起来至少需要添加几条边.</p>\n</blockquote>\n<h2><span id=\"实现前奏\">实现前奏</span></h2><blockquote>\n<p>首先是逻辑,并查集实现规则是一个点一个点入图时进行合并,即join,然后在合并时进行find,查找根节点是否相同,不同则将浅的树合并到深的树上,判断深浅通过每次合并时对rank进行操作,然后在一个优化是路径压缩,即如果a节点的最高根节点是c,则直接将a记录为c即可.</p>\n<blockquote>\n<p>以上实现的前提是我们只需要逻辑上正确即可.</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"以题为马\">以题为马</span></h2><blockquote>\n<p>HDU 1232 判断有多少个连通块,然后答案就是ans-1</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nstruct DisjointSet{\n    vector&lt;int&gt; father,rank;\n    int Num;\n    DisjointSet(int n):father(n),rank(n),Num(n){\n        for(int i=1;i&lt;n;++i){\n            father[i]=i;\n        }\n    }\n\n    int find(int v){\n        return father[v]=father[v]==v?v:find(father[v]);\n    }\n\n    void merge(int x,int y){\n        int a=find(x),b=find(y);\n        if(rank[a]&lt;rank[b]){\n            father[a]=b;\n        }else{\n            father[b]=a;\n            if(rank[a]==rank[b]){\n                ++rank[a];\n            }\n        }\n    }\n\n    int getCnum(){\n        int ans=0;\n        for(int i=1;i&lt;Num;++i){\n            if(father[i]==i) ans++;\n        }\n        return ans-1;\n    }\n};\n\nint main(){\n    int m,n;\n\n    while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        DisjointSet ds(n+1);\n        int s,t;\n        scanf(&quot;%d&quot;,&amp;m);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d %d&quot;,&amp;s,&amp;t);\n            ds.merge(s,t);\n        }\n        printf(&quot;%d\\n&quot;,ds.getCnum());\n    }\n    return 0;\n}</code></pre><h1><span id=\"单调栈\">单调栈</span></h1><h1><span id=\"线段树区间更新和查询\">线段树区间更新和查询</span></h1><p>POJ 3468</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q;\nLL lazy[maxn];\nLL sum[maxn];\nLL tree[maxn];\nLL a[maxn];\n\nvoid build(int p,int l,int r){\n    if(l==r){tree[p]=a[l];return;}\n    int mid=(l+r)&gt;&gt;1;\n    build(p&lt;&lt;1,l,mid);\n    build(p&lt;&lt;1|1,mid+1,r);\n    tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];\n}\n\nvoid PushDown(int p,int m){\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nLL find(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return tree[p];\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=find(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=find(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n    for(int i=1;i&lt;=N;++i) scanf(&quot;%lld&quot;,&amp;a[i]);\n    build(1,1,N);\n    char op;\n    int l,r,c;\n    while(Q--){\n        cin&gt;&gt;op;\n        if(op==&apos;Q&apos;){\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            printf(&quot;%lld\\n&quot;,Query(1,1,N,l,r)+find(1,1,N,l,r));\n        }else if(op==&apos;C&apos;){\n            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);\n            update(1,1,N,c,l,r);\n        }\n    }\n    return 0;\n}</code></pre>","text":"2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.并查集要领以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.并查集是不可能分割的,即只能合并,不可分割.在牛客上听大","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"并查集","slug":"HDU/并查集","count":1,"path":"api/categories/HDU/并查集.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"}]}]}