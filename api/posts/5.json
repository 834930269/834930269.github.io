{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"加 - 并发编程基础","slug":"corplus","date":"2018-07-02T13:35:18.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/corplus.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/07/cf1e2049ec3ec10bd64b64336c485d03.png","content":"<blockquote>\n<p>并发的一些基础概念</p>\n</blockquote>\n<h1><span id=\"cpu-多级缓存\">CPU 多级缓存</span></h1><p>为了解决CPU与主存间速度不匹配的问题.</p>\n<h2><span id=\"时间局部性\">时间局部性</span></h2><p>数据可能被重复访问</p>\n<h2><span id=\"空间局部性\">空间局部性</span></h2><p>数据周围的一些数据,也可能被访问</p>\n<h2><span id=\"缓存一致性mesi协议\">缓存一致性(MESI协议)</span></h2><p>为了搞定共享数据一致的问题 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/cf1e2049ec3ec10bd64b64336c485d03.png\" alt> M: 已修改,待写回 E: 缓存只被缓存在CPU中,未被修改,修改后转为 M S: 共享态,可能被多个CPU共享 I: 有其他CPU修改了缓存行 lr: 本地读 lw: 本地写 rr: 内存读 rw: 缓存写到主存 状态转换 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/d44fed62558e13367358433f7c2e8bba.png\" alt></p>\n<h1><span id=\"乱序执行优化\">乱序执行优化</span></h1><p>这点与之前JVM对中间代码的优化一致,可能会导致在优化过程中导致的代码乱序执行(如果是并行则对原结果不影响),乱序优化是CPU为了提高执行效率(因为各组件的数量是有限的,为了防止一直等待一个组件而导致的时间浪费进行优化).</p>\n<h2><span id=\"脏数据\">脏数据</span></h2><h1><span id=\"java内存模型jmm\">Java内存模型(JMM)</span></h1><p>之前也聊过. JMM: Java Memory Model (为了屏蔽掉各种硬件和操作系统的访问差异,使一个代码在各平台下都可正常并行) JMM是一个规范模型. 规定一个线程如何和何时可以看到由其他变量修改过后的共享变量的值.以及在必须时如何同步的访问共享变量. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/9a429df8ec619d4952831b979fe0d40d.png\" alt> 堆是在运行时动态分配,存取速度慢. 栈,存取速度快,存储空间一定. 线程在栈上. 对象在堆上,引用在栈上. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/ad5214bd255a2751d0d98015ed3beadd.png\" alt></p>\n<h2><span id=\"高速缓存\">高速缓存</span></h2><p>CPU与主存间的缓存. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/eda78e84cd4268f0ff501ca2b10ef846.png\" alt></p>\n<h3><span id=\"抽象\">抽象</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/efebbee76283df7a42baab3c2557835f.png\" alt> 线程间通讯,必须通过主内存. 故出现问题就是因为主内存中没处理代码同时执行的操作.</p>\n<h1><span id=\"同步的八种操作以及操作规则\">同步的八种操作以及操作规则</span></h1><p>（1）lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态 （2）unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 （3）read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 （4）load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 （5）use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 （6）assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 （7）store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 （8）write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中 如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/67a8e36cfd2b4f7252a3b72a29d1d572.png\" alt> 同步规则分析： 1）不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中 2）一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。 3）一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。 4）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。 5）如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 6）对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>\n","text":"并发的一些基础概念CPU 多级缓存为了解决CPU与主存间速度不匹配的问题.时间局部性数据可能被重复访问空间局部性数据周围的一些数据,也可能被访问缓存一致性(MESI协议)为了搞定共享数据一致的问题  [Figure]  同步规则分析： 1）不允许一个线程无原因地（没有发生过任何a","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"深入分析Java Web技术内幕-第二章","slug":"javaweb-two","date":"2018-06-21T07:28:30.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/javaweb-two.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/1ad8ecc702cf83a89ac412c4e586aed3.png","content":"<h1><span id=\"深入分析java-io机制\">深入分析Java I/O机制</span></h1><h2><span id=\"java-io类库的基础架构\">Java I/O类库的基础架构</span></h2><p>类库大概分为四组:</p>\n<blockquote>\n<p>基于字节操作的I/O接口:InputStream 和 OutputStream 基于字符操作的I/O接口: Writer和Reader 基于磁盘操作的I/O接口: File 基于网络操作的I/O接口: Socket (这尼玛也能划到一起,不过这样好像也行)</p>\n</blockquote>\n<h2><span id=\"基于字节的io操作接口\">基于字节的I/O操作接口</span></h2><blockquote>\n<p>InputStream</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/1ad8ecc702cf83a89ac412c4e586aed3.png\" alt></p>\n<blockquote>\n<p>OutputStream</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/268a47ba3edf2add83c46b8f5a2a5342.png\" alt></p>\n<blockquote>\n<blockquote>\n<p>详见JDK API.</p>\n</blockquote>\n</blockquote>\n<p>Tip: 操作数据可以组合使用-&gt;某流转某流 OutputStream out=new PipeOutputStream(new ObjectOutputStream(new FileOutputStream(“fileName”))); 还有一点是一定要制定流最终要写到哪里</p>\n<h2><span id=\"基于字符的io操作接口\">基于字符的I/O操作接口</span></h2><blockquote>\n<p>I/O接口一般都是字节流,但是为了方便起见,也有字符流.</p>\n</blockquote>\n<p><strong>字符到字节必须经过编码转换,而编码很耗时</strong></p>\n<blockquote>\n<p>写字符接口以及涉及到的类</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d1c5a427e25d73e1ea7d0e04af57c65f.png\" alt> Writer类提供了一个抽象接口:Write(char cbuf[],int off,int len)</p>\n<blockquote>\n<p>读字符</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0b3cd200a1da4d54aaa17d095e16cf42.png\" alt> int Read(char cbuf[],int off,int len) 返回读到的n个字节数 他们只规定了读取和写入的方式,但没有规定读和写到哪里去.</p>\n<h2><span id=\"字节与字符的转化接口\">字节与字符的转化接口</span></h2><blockquote>\n<p>数据持久化或网络传输都是以字节进行的，所以必要有对应的接口</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/8aa6ff0a0ffe1b15ad470370844d78b5.png\" alt> InputStreamReader是<strong>字节到字符</strong>的桥梁,InputStream到Reader的过程<strong>要指定编码字符集</strong>,否则将采用操作系统默认字符集,很可能会出现乱码. StreamDecoder是<strong>字节到字符</strong>解码的实现类. StreamEncoder类似 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f38fb77be5e4351910897b9df42403e3.png\" alt></p>\n<h2><span id=\"磁盘io工作机制\">磁盘I/O工作机制</span></h2><h3><span id=\"应用程序访问文件的几种方式\">应用程序访问文件的几种方式</span></h3><p>read()和write()这两个是系统调用. 系统调用可能会存在内核空间地址和用户空间地址切换的问题,这是操作系统为了保护系统本身的运行安全而将<strong>内核程序运行使用的内存空间和用户活动使用的内核空间隔离</strong>,但是这样虽然保证了内核程序运行的安全性,但是也必然存在<strong>时间耗费的问题</strong> 磁盘I/O非常缓慢,所以操作系统使用了缓存的机制.</p>\n<h4><span id=\"标准访问文件方式\">标准访问文件方式</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6de33c5d864a218b1d3a0fe38565f411.png\" alt></p>\n<h4><span id=\"直接io方式\">直接I/O方式</span></h4><blockquote>\n<p>直接IO就是直接访问磁盘数据,来减少从内和缓冲区到用户活动区的复制.</p>\n<blockquote>\n<p>这种思想常用于 由应用实现的数据库管理系统. 提前将热点数据加入内存,可以加速数据的访问速度.</p>\n</blockquote>\n<p>但操作系统并不知道哪些是热点数据,所以直接I/O也有负面影响.而我们一般将异步IO和直接IO结合使用.</p>\n</blockquote>\n<p>直接IO方式如图(没有穿过高速页缓存): <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/74d178a897ed7f8fd8ba0439ccaceba1.png\" alt></p>\n<h4><span id=\"同步访问文件方式\">同步访问文件方式</span></h4><blockquote>\n<p>即读取与写入都是同步操作的.</p>\n</blockquote>\n<p>但他的标志是:<strong>只有写入完成才是成功的标志</strong> 性能较差</p>\n<h4><span id=\"异步访问文件方式\">异步访问文件方式</span></h4><blockquote>\n<p>异步访问就是,当访问数据的线程发出请求后,线程会继续去处理其它事情,而不是阻塞等待,当请求的数据返回后再继续处理接下来的操作.</p>\n</blockquote>\n<p>这种方式可以明显的提高应用程序的效率,但并不会改变访问文件的效率. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/423d961b94b4779ba7212af4db51017c.png\" alt></p>\n<h4><span id=\"内存映射方式\">内存映射方式</span></h4><blockquote>\n<p>将操作系统某一块区域与磁盘中的文件关联起来,增加缓冲区的个数,减少缓冲区-&gt;用户活动区的复制操作</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/246dcd50203f24f93da00714daae2db3.png\" alt></p>\n<h3><span id=\"java访问磁盘文件\">Java访问磁盘文件</span></h3><p>接下来我们来讨论数据的流向</p>\n<h4><span id=\"数据持久化到磁盘\">数据持久化到磁盘</span></h4><p>数据在磁盘中唯一<strong>最小描述</strong>就是<strong>文件</strong>. 文件也是操作系统和磁盘驱动器交互的<strong>最小单元</strong> Java中的File<strong>并不代表一个真实存在的对象</strong>.而是一个路径和虚拟对象. 因为我们更多关心的是操作,而不是整个文件. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/76a6f5098ea16378295a325a05064602.png\" alt> 从磁盘中读取文件流程: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f6b5aefd246cf978ed0563d0f999191e.png\" alt></p>\n<ul>\n<li>先创建一个FileDescriptor对象</li>\n<li>然后创建FileInputStream</li>\n<li>因为要读取的是字符格式,所以需要StreamDecoder类将byte解码为char格式…</li>\n</ul>\n","text":"深入分析Java I/O机制Java I/O类库的基础架构类库大概分为四组:基于字节操作的I/O接口:InputStream 和 OutputStream 基于字符操作的I/O接口: Writer和Reader 基于磁盘操作的I/O接口: File 基于网络操作的I/O接口: S","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"技术","slug":"Java/技术","count":1,"path":"api/categories/Java/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"},{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Maven","slug":"maven","date":"2018-06-20T15:27:49.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/maven.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>总而言之说下吧,Maven其实就类似于.Net的NuGet和Python-Anaconda 的pip和conda.包的管理工具更贴切?</p>\n</blockquote>\n<h1><span id=\"maven下载地址\">Maven下载地址</span></h1><p><a href=\"http://maven.apache.org/download.cgi\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/download.cgi</a></p>\n<h1><span id=\"基本操作\">基本操作</span></h1><p>mvn -v (查看版本) mvn archetype:generate -DgroupId=com.how2java -DartifactId=j2se -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false -archetype: generate 表示创建个项目 -DgroupId 项目包名: com.how2java -DartifactId 项目名称: j2se -DarchetypeArtifactId 项目类型: maven-archetype-quickstart -DinteractiveMode: false 表示前面参数都给了，就不用一个一个地输入了 mvn package (打包成jar) java -cp target/j2se-1.0-SNAPSHOT.jar com.how2java.App (执行jar) mvn archetype: generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DgroupId=com.how2java -DartifactId=j2ee -DinteractiveMode=false 创建Web App,可以发现其中是maven-archetype-webapp</p>\n<h1><span id=\"仓库\">仓库</span></h1><p>仓库就是来存放项目需要的jar包的。 maven采用一个仓库，多个项目的方式，让多个项目共享一个仓库里的相同jar包。 仓库默认位置: .\\apache-maven-3.5.3\\conf\\settings.xml 第53行</p>\n<pre><code>Default: ${user.home}/.m2/repository</code></pre><h1><span id=\"修改下载路径\">修改下载路径</span></h1><p>这里用阿里的. 这里修改仓库默认地址(随便,好找): D:/Software/maven/repository 然后修改maven的镜像(mirrors)</p>\n<pre><code>&lt;mirrors&gt;\n  &lt;!-- mirror\n   | Specifies a repository mirror site to use instead of a given repository. The repository that\n   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n   | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n   |\n  &lt;mirror&gt;\n    &lt;id&gt;mirrorId&lt;/id&gt;\n    &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;\n    &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;\n    &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;\n  &lt;/mirror&gt;\n   --&gt;\n   &lt;mirror&gt;\n   &lt;id&gt;alimaven&lt;/id&gt;\n       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n       &lt;name&gt;aliyun maven&lt;/name&gt;\n       &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;\n   &lt;mirror&gt;\n&lt;/mirrors&gt;</code></pre><h1><span id=\"maven风格的java项目听说很少用\">Maven风格的Java项目(听说很少用)</span></h1><blockquote>\n<p>莫名其妙的东东,运行jar???多个入口怎么处理啊?迷,不过用来封jar包挺方便的/大概</p>\n</blockquote>\n<p>给个链接:<a href=\"http://how2j.cn/k/maven/maven-create-maven-project/1331.html#nowhere\" target=\"_blank\" rel=\"noopener\">http://how2j.cn/k/maven/maven-create-maven-project/1331.html#nowhere</a></p>\n<h2><span id=\"windows-盘符跳转\">windows 盘符跳转</span></h2><p>cd /d D:\\Java 要在中间加上/d 或者直接 :e</p>\n<h1><span id=\"配置安装以及接下来\">配置安装以及接下来</span></h1><p>配置见how2j 之后再Maven中添加包,直接在pom.xml下的Depen…中点Add 如果无法自动搜索 菜单-&gt;Window-&gt;Show View-&gt;Other-&gt;Maven-&gt;Maven Repositories-&gt;Local Repository-&gt;Rebuild Index 没有run on server 解决办法: <a href=\"https://blog.csdn.net/mr_yzko/article/details/78458873\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/mr_yzko/article/details/78458873</a> 然后可能出现jsp报错:导包即可 <a href=\"http://how2j.cn/k/maven/maven-eclipse-web-project/1334.html\" target=\"_blank\" rel=\"noopener\">http://how2j.cn/k/maven/maven-eclipse-web-project/1334.html</a></p>\n<h1><span id=\"总结一下新建maven-webapp所出现的所有问题\">总结一下新建maven webapp所出现的所有问题</span></h1><ol>\n<li><p>创建项目后的JDK版本错误</p>\n<blockquote>\n<p>右键-&gt;属性-&gt;Build Path-&gt;Libraries-&gt;JRE System…-&gt;Edit-&gt;Default JRE</p>\n</blockquote>\n</li>\n<li><p>无Run on server</p>\n<blockquote>\n<p>右键-&gt;属性-&gt;Project Facets-&gt;点那个蓝条-&gt;选中Dynamic Web Module和Javascript-&gt;OK</p>\n</blockquote>\n</li>\n<li><p>.jsp报错</p>\n<blockquote>\n<p>双击pom.xml-&gt;Dependencies-&gt;Add-&gt;javax.servlet-api</p>\n</blockquote>\n</li>\n<li><p>无法找到web文件夹和主页(初始404)</p>\n<blockquote>\n<p>完成第二步后-&gt;Deployment Assembly-&gt;查看Deploy Path为/的那一条的源路径是否正确-&gt;不正确,删除后修改为index.jsp所在目录-&gt;添加Maven Dependencies-&gt;OK</p>\n</blockquote>\n</li>\n<li><p>完成!</p>\n</li>\n</ol>\n<h1><span id=\"pomxml-基础模板\">pom.xml 基础模板</span></h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;hello-maven&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;1.7.25&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;</code></pre><h1><span id=\"maven统一架构\">Maven统一架构</span></h1><pre><code>├─src\n│  ├─main\n│  │  ├─java\n│  │  ├─resources\n│  │  └─webapp\n│  │      └─WEB-INF\n│  └─test\n│      └─java</code></pre><blockquote>\n<p>src：源码目录</p>\n<blockquote>\n<p>src/main/java：Java 源码目录 src/main/resources：资源文件目录 src/main/webapp：Web 相关目录 src/test：单元测试</p>\n</blockquote>\n</blockquote>\n","text":"总而言之说下吧,Maven其实就类似于.Net的NuGet和Python-Anaconda 的pip和conda.包的管理工具更贴切?Maven下载地址http://maven.apache.org/download.cgi基本操作mvn -v (查看版本) mvn archet","link":"","raw":null,"photos":[],"categories":[{"name":"Maven","slug":"Maven","count":2,"path":"api/categories/Maven.json"},{"name":"技术","slug":"Maven/技术","count":1,"path":"api/categories/Maven/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"},{"name":"Maven","slug":"Maven","count":2,"path":"api/tags/Maven.json"}]},{"title":"深入分析Java Web技术内幕-第一章","slug":"javaweb-first","date":"2018-06-20T09:58:36.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/javaweb-first.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/2713303ae852b2a4f191b57ad8872441.png","content":"<h1><span id=\"cdn架构图\">CDN架构图</span></h1><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2713303ae852b2a4f191b57ad8872441.png\" alt></p>\n<h1><span id=\"发起请求\">发起请求</span></h1><p>一句话,发起一个HTTP请求的过程就是建立一个Socket通信的过程. 既然本质上就是建立一个Socket连接,那么我们完全可以模拟浏览器发出HTTP请求.(比如PostMan) -而HTTP协议的内容之前学过了,不再赘述(详见图灵的那本HTTP)</p>\n<h1><span id=\"http协议解析\">HTTP协议解析</span></h1><h2><span id=\"常见http请求头\">常见HTTP请求头:</span></h2><p>Accept-Charset: 用于指定<strong>客户端接受</strong>的字符集 Accept-Encoding: 用于指定<strong>可接受</strong>的<strong>内容编码</strong>如Accept-Encoding: gzip.deflate Accept-Language: 用于指定一种自然语言如 zh-cn Host: 用于指定被请求资源的主机和端口号 User-Agent: <strong>客户端</strong>将他的操作系统、浏览器和其他属性告诉服务器 Connection: 当前连接是否保持,如:Keep-Alive</p>\n<h2><span id=\"常见的http响应头\">常见的HTTP响应头</span></h2><p>Server: 使用的<strong>服务器</strong>名称,如 Server: Apache/1.3.6(Unix) Content-Type: 用于指定发送给<strong>接受者</strong>的实体正文的媒体类型 如: text/html;charset=GBK Content-Encoding: 与Accept-Encoding对应,告诉服务端采用什么压缩编码 Content-Language: 描述了资源所用的自然语言,与Accept-Language对应 Content-Length: 指明了实体正文长度.用以字节方存储的十进制数字来表示. Keep-Alive: 保持连接的时间,如-Keep-Alive: timeout=5,max=120</p>\n<h2><span id=\"创建http状态码\">创建HTTP状态码</span></h2><p>200 OK 302 临时跳转/缓存 400 请求有语法错误 403 拒绝 404 不存在 500 不可预期错误</p>\n<h2><span id=\"查看http工具\">查看HTTP工具</span></h2><p>F12</p>\n<h2><span id=\"拒绝缓存载入页面\">拒绝缓存载入页面</span></h2><p>Ctrl+F5</p>\n<h2><span id=\"dns域名解析\">DNS域名解析</span></h2><p>分十步进行: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/DNS.png\" alt=\"Aaron\"> 但可能不知这十步,因为name server可能会有多级,或者有一个GTM来负载均衡控制. <strong>nslookup</strong>可以来看域名的解析结果 linux 可以用dig来查询DNS解析过程</p>\n<h2><span id=\"清除缓存的域名\">清除缓存的域名</span></h2><p>windows下: ipconfig /flushdns Linux下: /etc/init.d/nscd restart</p>\n<h2><span id=\"其他的\">其他的</span></h2><p>JVM也会缓存一些DNS,这个缓存是在InetAddress类中完成的. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/68e30bf436883aac699fb1f2dc6a31b4.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/97fed91e3b53394a68b9a38125e2142f.png\" alt></p>\n<h1><span id=\"几种域名解析方式\">几种域名解析方式</span></h1><blockquote>\n<p>有服务器的童鞋一定接触过 A记录</p>\n<blockquote>\n<p>Address,可将多个域名解析到一个地址</p>\n</blockquote>\n<p>MX记录</p>\n<blockquote>\n<p>Mail Exchange,将某域名下的邮件服务器指向自己的Mail Server，DNS会将邮件发向对应的邮件路由</p>\n</blockquote>\n<p>CNAME记录</p>\n<blockquote>\n<p>Canonical Name(别名解析),为一个域名设置一个或多个别名,如,taobao.com解析到xulingbo.net.则xulingbo.net是taobao.net的别名.</p>\n</blockquote>\n<p>NS记录</p>\n<blockquote>\n<p>为某域名指定DNS解析服务器.</p>\n</blockquote>\n<p>TXT记录</p>\n<blockquote>\n<p>为某个主机名或域名设置说明.</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"cdn工作机制\">CDN工作机制</span></h1><blockquote>\n<p>Content Delivery Network,内容分布网络. 将信息发布到最接近用户的”边缘”,使用户可以就近取得所需的内容. CDN=镜像(Mirror)+缓存(Cache)+整体负载均衡(GSLB). CDN可以明显提高Internet中信息流动的效率.</p>\n</blockquote>\n<p>目前CDN都以缓存静态数据为主,如CSS,JS,图片和静态页面等. 淘宝有90%的数据由CDN提供. 通常来说CDN要完成以下几个目标:</p>\n<blockquote>\n<p>可扩展 安全性 可靠性,响应和执行</p>\n</blockquote>\n<h2><span id=\"通常的cdn架构\">通常的CDN架构</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/32a0ba63290137ab8b526df51e354bae.png\" alt></p>\n<h1><span id=\"负载均衡load-balance\">负载均衡(Load Balance)</span></h1><p>负载均衡就是对工作任务进行平衡,分摊到多个操作单元上执行,如图片服务器,应用服务器等,共同完成工作任务。它可以提高服务器响应速度及利用效率. 负载均衡是有DNS解析来完成的. 常用在集群中,分为软件/硬件负载均衡.</p>\n","text":"CDN架构图 [Figure] 负载均衡(Load Balance)负载均衡就是对工作任务进行平衡,分摊到多个操作单元上执行,如图片服务器,应用服务器等,共同完成工作任务。它可以提高服务器响应速度及利用效率. 负载均衡是有DNS解析来完成的. 常用在集群中,分为软件/硬件负载均衡","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善4-设计模式","slug":"design-model","date":"2018-06-20T09:11:49.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/design-model.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Link: 总共23种: <a href=\"http://be-sunshine.cn/index.php/2018/07/09/23-sort-dp/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/07/09/23-sort-dp/</a></p>\n","text":"Link: 总共23种: http://be-sunshine.cn/index.php/2018/07/09/23-sort-dp/","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"},{"name":"设计模式","slug":"技术/设计模式","count":1,"path":"api/categories/技术/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"},{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善3-深入分析Java Web技术内幕-Category","slug":"paln3-category","date":"2018-06-20T01:44:16.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/paln3-category.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>太多了…</p>\n</blockquote>\n<h1><span id=\"第一章-深入web请求过程done\">第一章 - 深入Web请求过程(Done)</span></h1><p><a href=\"http://be-sunshine.cn/index.php/2018/06/20/javaweb-first/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/20/javaweb-first/</a></p>\n<h1><span id=\"第二章-深入分析-java-io的工作机制s\">第二章 - 深入分析 Java I/O的工作机制(S)</span></h1><p><a href=\"http://be-sunshine.cn/index.php/2018/06/21/javaweb-two/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/21/javaweb-two/</a></p>\n<h1><span id=\"第三章-深入分析-javav-web-中的中文编码问题\">第三章 - 深入分析 Javav Web 中的中文编码问题</span></h1><h1><span id=\"第四章-javac编译原理\">第四章 - javac编译原理</span></h1><h1><span id=\"第五章-深入class文件结构\">第五章 - 深入class文件结构</span></h1><h1><span id=\"第六章-深入分析classloader-工作机制\">第六章 - 深入分析ClassLoader 工作机制</span></h1><h1><span id=\"第七章-jvm体系结构与工作方式\">第七章 - JVM体系结构与工作方式</span></h1><h1><span id=\"第八章-jvm内存管理\">第八章 - JVM内存管理</span></h1><h1><span id=\"第九章-servlet工作原理解析\">第九章 - Servlet工作原理解析</span></h1><h1><span id=\"第十章-深入理解seesion与cookie\">第十章 - 深入理解Seesion与Cookie</span></h1><h1><span id=\"第十一章-tomcat的系统架构与-设计模式\">第十一章 - Tomcat的系统架构与 设计模式</span></h1><h1><span id=\"第十二章-jetty的工作原理解析\">第十二章 - Jetty的工作原理解析</span></h1><h1><span id=\"第十三章-spring框架的设计理念与设计模式分析\">第十三章 - Spring框架的设计理念与设计模式分析</span></h1><h1><span id=\"第十四章-spring-mvc-工作机制与设计模式\">第十四章 - Spring MVC 工作机制与设计模式</span></h1><h1><span id=\"第十五章-深入分析ibaits框架之系统-架构与映射原理\">第十五章 - 深入分析Ibaits框架之系统 架构与映射原理</span></h1><h1><span id=\"第十六章-velocity工作原理解析\">第十六章 - Velocity工作原理解析</span></h1><h1><span id=\"第十七章-velocity优化实践\">第十七章 - Velocity优化实践</span></h1>","text":"太多了…第一章 - 深入Web请求过程(Done)http://be-sunshine.cn/index.php/2018/06/20/javaweb-first/第二章 - 深入分析 Java I/O的工作机制(S)http://be-sunshine.cn/index.php","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善2-实战JAVA高并发程序设计-第三章","slug":"plan-three","date":"2018-06-19T01:06:07.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-three.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/482e4b0a1461a4d73d554ac253836c8a.png","content":"<h1><span id=\"jdk并发包\">JDK并发包</span></h1><h2><span id=\"多线程间的团队协作-同步控制\">多线程间的团队协作: 同步控制</span></h2><p>比如之前的synchronized关键字就是一种最简单的控制方法.它决定了一个线程是否可以访问临界资源区. 还有wait和notify.</p>\n<h3><span id=\"synchronized的功能扩展-重入锁\">synchronized的功能扩展: 重入锁</span></h3><p>重入锁可以完全替代synchronized关键字. 重入锁使用 java.util.concurrent.locks.ReentrantLock 类来实现. 例:</p>\n<pre><code>import java.util.concurrent.locks.ReentrantLock;\npublic class p31 implements Runnable{\n\n    public static ReentrantLock lock=new ReentrantLock();\n    public static int i=0;\n    @Override\n    public void run(){\n        for(int j=0;j&lt;10000000;++j){\n            lock.lock();\n            try{\n                i++;\n            }finally{\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        p31 tl=new p31();\n        Thread t1=new Thread(tl);\n        Thread t2=new Thread(tl);\n        t1.start();t2.start();\n        t1.join();t2.join();\n        System.out.println(i);\n    }\n}</code></pre><p>可以看出这段代码是手动加锁的.故重入锁在逻辑控制的灵活性上远高于某关键字. <strong>但一定注意推出临界区要释放锁</strong> 为什么叫重入锁呢?因为允许一个线程获得N个锁,所以叫重入锁. <strong>一个线程获取多个锁后,也必须释放相同次数的锁</strong></p>\n<h4><span id=\"重入锁的中断响应\">重入锁的中断响应</span></h4><p>如果你一个线程一直等待锁,而拿锁的那个线程始终不放开锁,那不就死锁了么. 它提供了一种机制,即通知等待者无须再等待.即时停止工作. isHeldByCurrentThread()方法是返回当前线程是否拥有该锁. lockInterruptibly()方法是获取一个允许中断响应的锁. lock()方法获取的锁不允许中断. 例：</p>\n<pre><code>import java.util.concurrent.locks.ReentrantLock;\n\npublic class p32 implements Runnable {\n    public static ReentrantLock lock1=new ReentrantLock();\n    public static ReentrantLock lock2=new ReentrantLock();\n\n    int lock;\n    /*\n     * 控制加锁顺序,防止死锁\n     */\n    public p32(int lock){\n        this.lock=lock;\n    }\n\n    @Override\n    public void run(){\n        try{\n            if(lock==1){\n                lock1.lockInterruptibly();\n                try{\n                    Thread.sleep(500);\n                }catch(InterruptedException e){}\n                System.out.println(&quot;Lock1 Here IN&quot;);\n                lock2.lockInterruptibly();\n                System.out.println(&quot;Lock1 Here OUT&quot;);\n            }else{\n                lock2.lockInterruptibly();\n                try{\n                    Thread.sleep(500);\n                }catch(InterruptedException e){}\n                System.out.println(&quot;Lock2 Here IN&quot;);\n                lock1.lockInterruptibly();\n                System.out.println(&quot;Lock2 Here OUT&quot;);\n            }\n        }catch(InterruptedException e){\n            e.printStackTrace();\n        }finally{\n            if(lock1.isHeldByCurrentThread())\n                lock1.unlock();\n            if(lock2.isHeldByCurrentThread())\n                lock2.unlock();\n            System.out.println(Thread.currentThread().getId()+&quot;线程退出&quot;);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        p32 r1=new p32(1);\n        p32 r2=new p32(2);\n        Thread t1 = new Thread(r1);\n        Thread t2 = new Thread(r2);\n        t1.start();t2.start();\n        Thread.sleep(1000);\n        t2.interrupt();\n    }\n\n}</code></pre><p>线程启动后,r1先占用lock1,再请求lock2 r2相反,这也就导致了t1和t2互相等待,形成死锁. 而当我们将r2中断以后,r2释放了所有的锁,r1检测到了,故只有r1完全执行完毕,r2则会抛出一个中断异常.</p>\n<h4><span id=\"第二种中断方法\">第二种中断方法</span></h4><blockquote>\n<p>lock.tryLock(5,TimeUnit.SECONDS)</p>\n<blockquote>\n<p>县城在这个锁请求中等待5秒,如果五秒内无法得到锁,则False</p>\n</blockquote>\n</blockquote>\n<h4><span id=\"公平锁\">公平锁</span></h4><blockquote>\n<p>公平锁的效率不高,所以一般不用,因为公平锁需要维护一个优先队列. 公平锁是通过对谁先获得当前资源进行合理的调度来防止死锁的产生. 使用方法: ReentrantLock</p>\n<blockquote>\n<p>性质:</p>\n<blockquote>\n<p>1.原子状态 2.等待队列(没有请求到锁就进入等待队列) 3.阻塞原语pair()与unpair()</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4><span id=\"重入锁好搭档-condition条件\">重入锁好搭档: Condition条件</span></h4><blockquote>\n<p>Condition和wait与notify的用法大致相同</p>\n</blockquote>\n<pre><code>package s;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class p31 implements Runnable {\n\n    public static ReentrantLock lock=new ReentrantLock();\n    public static Condition condition=lock.newCondition();\n\n    @Override\n    public void run(){\n        try{\n            lock.lock();\n            System.out.println(&quot;SD&quot;);\n            condition.await();\n            System.out.println(&quot;This is going on.&quot;);\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally{\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        p31 tl=new p31();\n        Thread t1=new Thread(tl);\n        t1.start();\n        Thread.sleep(2000);\n        ///通知线程t1继续执行\n        lock.lock();\n        condition.signal();\n        System.out.println(&quot;AA&quot;);\n        lock.unlock();\n    }\n\n}</code></pre><blockquote>\n<p>注: Condition只能在lock和unlock保护下才可以解锁. wait 是等待,notify是返回通知开始执行</p>\n</blockquote>\n<h4><span id=\"允许多个线程同时访问-信号量semaphore\">允许多个线程同时访问: 信号量(Semaphore)</span></h4><blockquote>\n<p>构造函数:</p>\n<blockquote>\n<p>public Semaphore(int permits) public Semaphore(int permits,boolean fair) 第二个参数是是否公平</p>\n</blockquote>\n<p>信号量主要逻辑方法</p>\n<blockquote>\n<p>public void acquire() -准入许可,等待 public void acquireUninterruptibly() -不接收中断 public boolean tryAcquire() - 获得许可,不等待 public boolean tryAcquire(long timeout,TimeUnit unit) public void release() - 释放许可</p>\n</blockquote>\n</blockquote>\n<p>例子:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Semaphore;\n\npublic class p33 implements Runnable{\n    final Semaphore semp=new Semaphore(5);\n    public void run(){\n        try{\n            semp.acquire();\n            Thread.sleep(2000);\n            System.out.println(Thread.currentThread().getId()+&quot;:done!&quot;);\n            semp.release();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        ExecutorService exec =Executors.newFixedThreadPool(20);\n        final p33 t1= new p33();\n        for(int i=0;i&lt;20;++i){\n            exec.submit(t1);\n        }\n    }\n\n}</code></pre><p>为信号量传入的5代表线程队列中课同时存在的线程数量的最大值. 开启程序后,你会发现每一瞬间都会有5个线程执行并打印出数据,但在这5个释放占用的信号量后才会继续向下执行.</p>\n<h4><span id=\"readwritelock-读写锁\">ReadWriteLock 读写锁</span></h4><blockquote>\n<p>读操作不会破坏数据完整性,所以当读-读-…操作产生时,不需要加锁即可.这样使得大量读操作的系统会有很明显的效率上的提升. 但写会阻塞读,所以效率由写操作的次数来决定.</p>\n</blockquote>\n<p>锁的创建:</p>\n<pre><code>private static ReentrantReadWriteLock readWriteLock=new RenntrantReadWriteLock();\nprivate static Lock readLock=readWriteLock.readLock();\nprivate static Lock WriteLock=readWriteLock.WriteLock();</code></pre><h4><span id=\"倒计时器-countdownlatch\">倒计时器: CountDownLatch</span></h4><p>它可以让一个线程在倒计时结束后再执行. 执行方式如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/482e4b0a1461a4d73d554ac253836c8a.png\" alt> 必须所有的线程都完成任务后,等待在CountDownLatch上的线程才能继续执行. 例:</p>\n<pre><code>import java.util.Random;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class p34 implements Runnable{\n    static final CountDownLatch end=new CountDownLatch(10);\n\n    static final p34 demo=new p34();\n\n    public void run(){\n        try{\n            Thread.sleep(new Random().nextInt(10)*1000);\n            System.out.println(&quot;check complete&quot;);\n            end.countDown();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    public static class now{\n        public static void print() throws InterruptedException{\n            end.await();\n            System.out.println(&quot;我来了~~~~&quot;);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        final now t1=new now();\n        ExecutorService exec=Executors.newFixedThreadPool(10);\n        for(int i=0;i&lt;10;++i){\n            exec.submit(demo);\n        }\n        t1.print();\n        exec.shutdown();\n    }\n}</code></pre><h4><span id=\"循环栅栏-cyclicbarrier\">循环栅栏： CyclicBarrier</span></h4><blockquote>\n<p>它比上面那个更加复杂和强大</p>\n<blockquote>\n<p>可以将它理解为一种障碍物.它是用来阻止线程继续执行,并且这个计数器可以反复使用,比如,10个执行完以后,再来一遍.</p>\n</blockquote>\n</blockquote>\n<p>例:</p>\n<pre><code>import java.util.Random;\nimport java.util.concurrent.CyclicBarrier;\n\npublic class p35 {\n    public static class Soldier implements Runnable{\n        private String soldier;\n        private final CyclicBarrier cyclic;\n        Soldier(CyclicBarrier cyclic,String s){\n            this.cyclic=cyclic;\n            this.soldier=s;\n        }\n\n        public void run(){\n            try{\n                //等待所有士兵到齐\n                cyclic.await();\n                doWork();\n                //等待所有士兵完成工作\n                cyclic.await();\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n\n        void doWork(){\n            try{\n                Thread.sleep(Math.abs(new Random().nextInt()%10000));\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n            System.out.println(soldier+&quot;任务完成!&quot;);\n        }\n\n    }\n\n    public static class BarrierRun implements Runnable{\n        boolean flag;\n        int N;\n        public BarrierRun(boolean a,int b){\n            this.flag=a;\n            this.N=b;\n        }\n        public void run(){\n            if(flag){\n                System.out.println(&quot;司令:[士兵&quot;+N+&quot;个,任务完成!]&quot;);\n            }else{\n                System.out.println(&quot;司令:[士兵&quot;+N+&quot;个,集合完毕!]&quot;);\n                flag=true;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N=5;\n        Thread[] allSoldier=new Thread[10];\n        boolean flag=false;\n        CyclicBarrier cyclic=new CyclicBarrier(N,new BarrierRun(flag,N));\n        //设置屏障点\n        System.out.println(&quot;集合队伍!&quot;);\n        for(int i=0;i&lt;10;++i){\n            System.out.println(&quot;士兵&quot;+i+&quot;报道!&quot;);\n            allSoldier[i]=new Thread(new Soldier(cyclic,&quot;士兵 &quot;+i));\n            allSoldier[i].start();\n        }\n    }\n\n}</code></pre><p>输出: 集合队伍! 士兵0报道! 士兵1报道! 士兵2报道! 士兵3报道! 士兵4报道! 士兵5报道! 司令:[士兵5个,集合完毕!] 士兵6报道! 士兵7报道! 士兵8报道! 士兵9报道! 司令:[士兵5个,任务完成!] 士兵 8任务完成! 士兵 7任务完成! 士兵 1任务完成! 士兵 0任务完成! 士兵 4任务完成! 司令:[士兵5个,任务完成!] 士兵 5任务完成! 士兵 3任务完成! 士兵 9任务完成! 士兵 2任务完成! 士兵 6任务完成! 司令:[士兵5个,任务完成!] 你会发现是每5个释放一次锁.</p>\n<h4><span id=\"locksupport\">LockSupport</span></h4><blockquote>\n<p>它可以在线程内任意位置让其阻塞 之前suspend和resume时,如果resume在suspend前执行,则一定会出现线程被无限挂起,导致无法正常退出. 我们可以用LockSupport解决这一问题.</p>\n</blockquote>\n<p>因为LockSupport是用信号量来实现的.它为每一个线程准备了一个许可,如果许可可用,则park()函数会立即返回,并且消费许可(变为不可用).如果许可不可用,就会被阻塞. 但和信号量不同的是,许可永远只有一个. LockSupport.park() LockSupport.unpark(Runnable) LockSupport.parkNanos() LockSupport.parkUtil() 此外,如果是用park(Object),则这个阻塞对象会出现在线程Dump中(报错),分析问题就更方便了.</p>\n<h3><span id=\"线程复用-线程池\">线程复用: 线程池</span></h3><blockquote>\n<p>多线程的软件设计方法确实可以最大限度的发挥现代多核处理器的计算能力,提高生产系统的吞吐量和性能。但是,若不加控制和管理的随意使用线程,对系统的性能反而会产生不利影响.</p>\n</blockquote>\n<p>一种极简的处理方法:</p>\n<pre><code>new Thread(new Runnable(){\n    public void run(){\n        //do sth\n    }\n}).start();</code></pre><p>这样的线程在run完后就会自动回收,但线程量过大时,则会耗尽CPU和内存资源. 而且如果为每一个小程序都创建一个线程,就可能出现销毁时间远大于该线程实际工作所消耗的时间. 其次,可能因线程过多而爆栈/堆. 大量的线程回收也会给GC造成很大压力,延长GC的停顿时间.</p>\n<h4><span id=\"什么是线程池\">什么是线程池</span></h4><p>为了避免系统频繁的创建和销毁线程,我们会尽量的让线程复用. <strong>数据库连接池:</strong> 为了避免每次数据库查询都重新建立和销毁数据库连接,我们可以使用数据库连接池保护一些数据库连接,让他们长期在激活状态.当系统需要数据库时,并不是真正创建一个新的连接,而是从连接池中获得一个可用的连接即可.反之,当需要关闭连接时,并不是真的把链接关闭,而是将这个链接还给连接池即可. <strong>线程池</strong>: 线程池中,总有那么几个活跃线程,当你需要时,可以从池子中随便拿一个空闲线程,当完成工作时,并不着急关闭线程,而是将这个线程退回到池子,方便别人使用. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/88267587709716bb6b7d5a183b7bea85.png\" alt> 换言之,创建线程变成了从池子中获得线程,销毁变成了归还.</p>\n<h4><span id=\"jdk内置线程池框架-executor\">JDK内置线程池框架: Executor</span></h4><blockquote>\n<p>框架结构图</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2c1925682e53b6a81146256a57ce2e88.png\" alt> 关于Executor的设计模式: 生产者-消费者模式和工厂方法 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6085df9c51bc40c12d4bee50128f9130.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/25117913abc15c1b6a431d930ac4c390.png\" alt> 例子:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class p36 {\n    public static class MyTask implements Runnable{\n        public void run(){\n            System.out.println(System.currentTimeMillis()+&quot;:Thread ID:&quot;+Thread.currentThread().getId());\n            try{\n                Thread.sleep(1000);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args){\n        // TODO Auto-generated method stub\n        MyTask task=new MyTask();\n        ExecutorService es=Executors.newFixedThreadPool(5);\n        for(int i=0;i&lt;10;++i){\n            es.submit(task);\n        }\n        es.shutdown();\n    }\n\n}</code></pre><p>可能我们之前一直对<strong>为什么我们传入submit的是一个对象,但他们得ID却不同呢?</strong> 这是因为线程的ID与对象并无直接关系,线程的ID是直接分配好的. 我们可以尝试打印出<strong>this.toString()</strong>来查看是否是同一个对象,结果表明确实是同一个对象,如果不想使用用同一个对象来做测试,那就用new MyTask()作为参数就可以了. 但直接new的话,会出现一个很严重的问题,就是new出来的对象的执行顺序可能产生混乱.因为不是同一个对象,所以就不会按照顺序来执行了. 例:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class p36 { \n    public static ReentrantLock lock=new ReentrantLock();\n    public static class MyTask implements Runnable{\n        private int kt=0;\n        public void cal(int t){\n            kt=kt+t;\n        }\n        public void run(){\n            //lock.lock();\n            cal(1);\n            //lock.unlock();\n            //System.out.println(System.currentTimeMillis()+&quot;:Thread ID:&quot;+Thread.currentThread().getId());\n            if(kt&gt;9990)\n                System.out.println(this.toString()+&quot; &quot;+kt);\n            try{\n                Thread.sleep(1);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        MyTask tk=new MyTask(); \n        Thread pk=new Thread(tk);\n        ExecutorService es=Executors.newFixedThreadPool(10);\n\n        for(int i=0;i&lt;10000;++i){\n            es.submit(tk);\n        }\n        es.shutdown();\n        System.out.println(&quot;AAAAAA&quot;+tk.kt);\n    }\n\n}</code></pre><p>打印后会发现,结果并不是正确的,甚至10000的数据前提下9990也不能保证. 当然,加上锁以后就正常了.</p>\n<h4><span id=\"刨根问底-核心线程池的内部实现\">刨根问底: 核心线程池的内部实现</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/7c53caa4fa9b345ab9b03b92bda61465.png\" alt></p>\n<h4><span id=\"拒接策略\">拒接策略</span></h4><p>P108</p>\n<h4><span id=\"扩展线程池\">扩展线程池</span></h4><blockquote>\n<p>ThreadPoolExecutor是一个可扩展的线程池 它为我们提供了三个接口</p>\n<blockquote>\n<p>beforeExecute() afterExecute() terminated()</p>\n</blockquote>\n</blockquote>\n<p>字面意思 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/852095dd0c714bd6f84dfbab510688f6.png\" alt> 我们重写一下试试:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class p37 {\n    public static class MyTask implements Runnable{\n        public String name;\n\n        public MyTask(String name){\n            this.name=name;\n        }\n\n        public void run(){\n            System.out.println(&quot;正在执行&quot;+&quot;:Thread ID:&quot;+Thread.currentThread().getId()+&quot;:Task Name:&quot;+name);\n            try{\n                Thread.sleep(1000);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        ExecutorService es=new ThreadPoolExecutor(5,5,0L,TimeUnit.MILLISECONDS,new LinkedBlockingDeque&lt;Runnable&gt;()){\n            @Override\n            protected void beforeExecute(Thread t,Runnable r){\n                System.out.println(&quot;准备执行: &quot;+((MyTask)r).name);\n            }\n\n            @Override\n            protected void afterExecute(Runnable r,Throwable t){\n                System.out.println(&quot;执行完成: &quot;+((MyTask)r).name);\n            }\n\n            @Override\n            protected void terminated(){\n                System.out.println(&quot;线程池退出&quot;);\n            }\n        };\n        for(int i=0;i&lt;5;++i){\n            MyTask task=new MyTask(&quot;TASK-GEYM-&quot;+i);\n            es.execute(task);\n            Thread.sleep(10);\n        }\n        es.shutdown();\n    }\n}</code></pre><p>注: shutdown方法会等所有的线程执行结束后才关闭线程池.</p>\n<h4><span id=\"合理的选择-优化线程池线程数量\">合理的选择: 优化线程池线程数量</span></h4><p>线程池的大小对系统的性能也有影响.过大或过小都不可以.但也不需要特别精确. 一般来说确定线程池的大小需要考虑CPU的数量,内存大小等因素. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2fdb2eba1f1763034b55e7c321ef1bab.png\" alt></p>\n<h4><span id=\"注线程池可能会吃掉异常\">注:线程池可能会吃掉异常</span></h4><p>而 execute方法会打印出部分异常, 或者修改submit的使用: Future re=pools.submit(new DivTask(100,0)); re.get(); 这样也可以.</p>\n<h4><span id=\"扩展threadpoolexecutor以显示异常\">扩展ThreadPoolExecutor以显示异常</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/be5bdfeba0ba5e3d7cf870cdd78a0747.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ca0feb96b4362f4ca128ce48747e546a.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/bf9c0ac33c3b0339653f64917ef6eb1b.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/bf1b6e3a4fae52e8b048039894cc3cd6.png\" alt></p>\n<h3><span id=\"分而治之-forkjoin框架\">分而治之: Fork/Join框架</span></h3><p>著名的MapReduce也是采用了分而治之的思想,简单来说,如果你要处理1000个数据,但是你并不具备处理1000个数据的能力,那么你可以只处理10个,然后,分阶段处理100个,将100个结果进行合成.就是1000个结果. JDK为我们提供了ForkJoinPool线程池. <strong>Fork/join执行逻辑</strong> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c06d16d76d0568a8e5133f62436d4b68.png\" alt> <strong>互相帮助的线程</strong> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c68c5120e1a1f1e9216f0948c0e543ff.png\" alt> 其中ForkJoinTask有两个重要的子类.关系如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c706a5a90f343ea864742a01af91ca8e.png\" alt> RecursiveTask&lt;&gt; 是实现一个compute函数(返回值要与泛型一致)即可. 例:</p>\n<pre><code>import java.util.ArrayList;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\n\npublic class p38 extends RecursiveTask&lt;Long&gt; {\n    private static final int THRESHOLD = 10000;\n    private long start;\n    private long end;\n\n    public p38(long start,long end){\n        this.start=start;\n        this.end=end;\n    }\n\n    public Long compute(){\n        long sum=0;\n        boolean canCompute=(end-start)&lt;THRESHOLD;\n        if(canCompute){\n            ///如果大于THRESHOLD的话才进行分解,否则直接进行即可\n            for(long i=start;i&lt;=end;++i){\n                sum+=i;\n            }\n        }else{\n            //分成100个小任务(整块)\n            long step=(start+end)/100;\n            ArrayList&lt;p38&gt; subTasks=new ArrayList&lt;p38&gt;();\n            long pos=start;\n            for(int i=0;i&lt;100;++i){\n                long lastOne=pos+step;\n                if(lastOne&gt;end)lastOne=end;\n                p38 subTask=new p38(pos,lastOne);\n                pos+=step+1;\n                subTasks.add(subTask);\n                //使用fork提交子任务\n                subTask.fork();\n            }\n            //所有子任务结束后,再次求和\n            for(p38 t:subTasks){\n                sum+=t.join();\n            }\n        }\n        return sum;\n    }\n\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        ForkJoinPool forkjoinpool=new ForkJoinPool();\n        p38 task=new p38(0,200000L);\n        ForkJoinTask&lt;Long&gt; result=forkjoinpool.submit(task);\n        try{\n            long res=result.get();\n            System.out.println(&quot;sum=&quot;+res);\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n}</code></pre><h4><span id=\"什么时候要加锁\">什么时候要加锁?</span></h4><p>如果只是读操作，没有写操作，则可以不用加锁，此种情形下，变量加上final关键字； 如果有写操作，但是变量的写操作跟当前的值无关联，且与其他的变量也无关联，则可考虑变量加上volatile关键字，同时写操作方法通过synchronized加锁； 如果有写操作，且写操作依赖变量的当前值(如：i++)，则getXXX和写操作方法都要通过synchronized加锁。 线程池是自带锁的.</p>\n<h3><span id=\"jdk-并发容器\">JDK 并发容器</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0096034273dcb98f075add481ae7e975.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/a783c28c5e7b94a1fe4171318ae14cf4.png\" alt> Tip: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2dda3fce55b9b7aac0ae9da17b57d594.png\" alt> 这点有点迷:P128 其中CopyOnWrite是高效的读取,在这个容器中,写入不会阻塞读取.</p>\n<h4><span id=\"跳表\">跳表</span></h4><p>跳表是一种可以快速查找的数据结构,它有点类似于平衡树,它只需要部分锁即可,而跳表的时间复杂度也是O(log n) 更多的数据结构可以见线程那个包 Done</p>\n","text":"JDK并发包多线程间的团队协作: 同步控制比如之前的synchronized关键字就是一种最简单的控制方法.它决定了一个线程是否可以访问临界资源区. 还有wait和notify.synchronized的功能扩展: 重入锁重入锁可以完全替代synchronized关键字. 重入锁","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"LintCode(1-11+114)","slug":"pl2-lintcode","date":"2018-06-17T09:46:21.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/pl2-lintcode.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"2-尾部的零easy\">（2） 尾部的零(Easy)</span></h1><blockquote>\n<p>因为2的数量远大于5,统计5的数量即可</p>\n</blockquote>\n<pre><code>public class Solution {\n    /*\n     * @param n: An integer\n     * @return: An integer, denote the number of trailing zeros in n!\n     */\n\n    public long trailingZeros(long n) {\n        // write your code here, try to do it without arithmetic operators.\n        long cnt=0,k=n;\n\n        while(k&gt;0){\n            cnt+=k/5;\n            k/=5;\n        }\n        return cnt;\n    }\n}</code></pre><h1><span id=\"3-统计数字中等\">（3） 统计数字(中等)</span></h1><blockquote>\n<p>伪数位DP</p>\n</blockquote>\n<pre><code>public class Solution {\n    /*\n     * @param : An integer\n     * @param : An integer\n     * @return: An integer denote the count of digit k in 1..n\n     */\n\n    public int digitCounts(int k, int n) {\n        // write your code here\n        int cnt=0,mt=1,tmp=0;\n        int a=n;\n        if(k==0)tmp=1;\n        while(a&gt;0){\n            int digit=a%10;\n            a/=10;\n            if(digit&gt;k)cnt+=(a+1-tmp)*mt;\n            else if(digit==k) cnt+=(a-tmp)*mt+n%mt+1;\n            else cnt+=a*mt;\n            mt*=10;\n        }\n        cnt+=tmp;\n        return cnt;\n    }\n};</code></pre><h1><span id=\"4-丑数二中等\">（4） 丑数二(中等)</span></h1><h2><span id=\"筛法只能过94\">筛法只能过94%</span></h2><blockquote>\n<p>因为他后面的数据超过10亿!….</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n        int[] ans=new int[767];\n        boolean[] is=new boolean[10000000];  \n        int tot=0;\n\n        void init(int n){\n            for(int i=0;i&lt;10000000;++i) is[i]=false;\n            is[1]=true;\n            ans[tot++]=1;\n            for(int i=1;i&lt;10000000;++i){\n                if(is[i]){\n                    for(int j=i*2;j&lt;10000000;j*=2){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                    for(int j=i*3;j&lt;10000000;j*=3){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                    for(int j=i*5;j&lt;10000000;j*=5){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                }\n            }\n        }\n\n    public int nthUglyNumber(int n) {\n        // write your code here\n            init(n);\n            //ans=IntStream.of(ans).boxed().sorted().mapToInt(Integer::intValue).toArray();\n            Arrays.sort(ans);\n            return ans[n-1];\n    }\n}</code></pre><h2><span id=\"用hashsetdfs-ac\">用HashSet+Dfs AC</span></h2><blockquote>\n<p>因为他给数据了,所以在已知数据是INT_MAX的前提下就好做多了</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n    HashSet&lt;Integer&gt; tSet=new HashSet&lt;&gt;();\n    int[] ans=new int[1665];\n    int tot=0;\n    void dfs(long num){\n        if(num&gt;(long)1898437500)return;\n        if(tSet.size()&gt;=1665) return;\n        if(tSet.contains((int)num)) return;\n        else{\n            tSet.add((int)num);\n            if(tot==1665)return;\n            ans[tot++]=(int)num;\n            dfs(num*2);\n            dfs(num*3);\n            dfs(num*5);\n        }\n    }\n\n    public int nthUglyNumber(int n) {\n        // write your code here\n        dfs(1);\n        Arrays.sort(ans);\n        return ans[n-1];\n    }\n}</code></pre><h2><span id=\"找规律的解法\">找规律的解法</span></h2><blockquote>\n<p>可以发现只需要三个指针指向P1P2P3,同步前移,第n个就是这三个中最小的一个</p>\n</blockquote>\n<pre><code>class Solution {\npublic:\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n    #define min(a,b) ((a)&lt;(b)?(a):(b))\n    #define min3(a,b,c) (min(min(a,b),min(a,c)))\n    int nthUglyNumber(int n) {\n        int i = 1;\n        int p2 = 0;\n        int p3 = 0;\n        int p5 = 0;\n        int uglyNum[6048] = {0};\n        uglyNum[0] = 1;\n        while ( i &lt; n ) {\n            uglyNum[i] = min3(uglyNum[p2] * 2, uglyNum[p3] * 3, uglyNum[p5] * 5);\n            if (uglyNum[i] == uglyNum[p2] * 2) {\n                p2++;\n            }\n            if (uglyNum[i] == uglyNum[p3] * 3) {\n                p3++;\n            }\n            if (uglyNum[i] == uglyNum[p5] * 5) {\n                p5++;\n            }\n            i++;\n        }\n        return uglyNum[n-1];\n    }\n};</code></pre><h1><span id=\"5-第k大中等\">（5） - 第K大(中等)</span></h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>利用快速排序的分块算法(Partition)+二分查找的思想解决即可.</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Topic_5 {\n    public static void main(String[] args){\n        int[] nums=new int[]{9,3,2,4,8};\n        System.out.println(kthLargestElement(3,nums));\n    }\n\n    //用首元素做pivot\n    private static int partition(int l,int r,int[] nums){\n        int pivot=nums[l];\n        int temp=nums[l],low=l,high=r;\n        while(low&lt;high){\n            while(low&lt;high &amp;&amp; nums[high]&lt;=temp){\n                high--;\n            }\n            nums[low]=nums[high];\n            while(low&lt;high &amp;&amp; nums[low]&gt;=temp){\n                low++;\n            }\n            nums[high]=nums[low];\n        }\n        nums[low]=temp;\n        return low;\n    }\n\n    public static int kthLargestElement(int n, int[] nums) {\n        // write your code here\n        int l=0,r=nums.length - 1;\n        while(l&lt;r){\n            int k=partition(l,r,nums);\n            if(k==n-1) break;\n            if(k&lt;n-1) l=k+1;\n            else if(k&gt;n-1) r=k-1;\n        }\n        return nums[n-1];\n    }\n}</code></pre><h1><span id=\"6-合并有序数组简单\">（6） - 合并有序数组(简单)</span></h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>常规合并</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param A: sorted integer array A\n     * @param B: sorted integer array B\n     * @return: A new sorted integer array\n     */\n\n    private int[] solve(int A[],int B[]){\n        int[] res=new int[A.length+B.length];\n        int tagA=0,tagB=0,tot=0;\n        while(tagA&lt;A.length &amp;&amp; tagB&lt;B.length){\n            if(A[tagA]&lt;B[tagB])res[tot++]=A[tagA++];\n            else res[tot++]=B[tagB++];\n        }\n        while(tagA&lt;A.length){\n            res[tot++]=A[tagA++];\n        }\n        while(tagB&lt;B.length){\n            res[tot++]=B[tagB++];\n        }\n        return res;\n    }\n\n    public int[] mergeSortedArray(int[] A, int[] B) {\n        // write your code here\n        return solve(A,B);\n    }\n}</code></pre><h1><span id=\"7-序列化二叉树与反序列化\">（7） - 序列化二叉树与反序列化</span></h1><blockquote>\n<p>注意bfs序列化后最简单的反序列化是for循环. dfs序列化后最简单的反序列是递归. 当然也可以用两序遍历</p>\n</blockquote>\n<pre><code>import sun.reflect.generics.tree.Tree;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class TOPIC_6 {\n    public static class TreeNode {\n        public int val;\n        public TreeNode left, right;\n        public TreeNode(int val) {\n            this.val = val;\n            this.left = this.right = null;\n        }\n    }\n\n    public static void main(String[] args){\n        TreeNode nt=Solution.deserialize(&quot;1,2,3,#,#,#,#,&quot;);\n        System.out.println(Solution.serialize(nt));\n    }\n\n    public static class Solution {\n        /**\n         * This method will be invoked first, you should design your own algorithm\n         * to serialize a binary tree which denote by a root node to a string which\n         * can be easily deserialized by your own &quot;deserialize&quot; method later.\n         */\n\n        public static void dfs(TreeNode root,StringBuilder data){\n            if(root==null){\n                data.append(&quot;#,&quot;);\n            }else{\n                data.append(String.valueOf(root.val)+&quot;,&quot;);\n                dfs(root.left,data);\n                dfs(root.right,data);\n            }\n        }\n\n        public static String serialize(TreeNode root) {\n            // write your code here\n            StringBuilder data=new StringBuilder();\n            dfs(root,data);\n            return data.toString();\n        }\n\n        // Decodes your encoded data to tree.\n        public static TreeNode deserialize(String data) {\n            LinkedList&lt;String&gt; que = new LinkedList&lt;String&gt;();\n            que.addAll(Arrays.asList(data.split(&quot;,&quot;)));\n            return deserial(que);\n        }\n\n        private static TreeNode deserial(LinkedList&lt;String&gt; que){\n            String str = que.pollFirst();\n            if(str.equals(&quot;#&quot;)){\n                return null;\n            }\n            TreeNode root = new TreeNode(Integer.valueOf(str));\n            if(que.size()!=0) {\n                root.left = deserial(que);\n                root.right = deserial(que);\n            }\n            return root;\n        }\n    }\n}</code></pre><h1><span id=\"8-旋转字符串\">（8） 旋转字符串</span></h1><blockquote>\n<p>剑指Offer上的一道题</p>\n<blockquote>\n<p>先整体旋转,然后把offset前后各旋转一次即可</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param str: An array of char\n     * @param offset: An integer\n     * @return: nothing\n     */\n\n    void Reverse(char[] str,int start,int end){\n        while(start&lt;end){\n            if(end-1&lt;=start)break;\n            str[start]^=str[end-1];\n            str[end-1]^=str[start];\n            str[start]^=str[end-1];\n            start++;end--;\n        }\n    } \n\n    public void rotateString(char[] str, int offset) {\n        // write your code here\n        int len=str.length;\n        if(len&lt;=0)return;\n        int fnos=offset%len;\n        Reverse(str,0,len);\n        Reverse(str,0,fnos);\n        Reverse(str,fnos,len);\n    }\n}</code></pre><h1><span id=\"9-嘶嘶\">（9） - 嘶嘶</span></h1><pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: A list of strings.\n     */\n    public List&lt;String&gt; fizzBuzz(int n) {\n        // write your code here\n        List&lt;String&gt; ans=new LinkedList&lt;String&gt;();\n        for(int i=1;i&lt;=n;++i){\n            if(i%3==0 &amp;&amp; i%5==0) ans.add(&quot;fizz buzz&quot;);\n            else if(i%3==0) ans.add(&quot;fizz&quot;);\n            else if(i%5==0) ans.add(&quot;buzz&quot;);\n            else ans.add(String.valueOf(i));\n        }\n        return ans;\n    }\n}</code></pre><h1><span id=\"11-search-range-in-binary-search-tree\">（11） - Search Range in Binary Search Tree</span></h1><blockquote>\n<p>常规dfs,可以剪枝</p>\n</blockquote>\n<pre><code>/**\n * Definition of TreeNode:\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left, right;\n *     public TreeNode(int val) {\n *         this.val = val;\n *         this.left = this.right = null;\n *     }\n * }\n */\n\npublic class Solution {\n\n    private int l;\n    private int r;\n\n    public void dfs(List&lt;Integer&gt; data,TreeNode root){\n        int value=root.val;\n        if(value&gt;=l &amp;&amp; value&lt;= r){\n            data.add(value);\n            if(root.left!=null)\n                dfs(data,root.left);\n            if(root.right!=null)\n                dfs(data,root.right);\n        }else{\n            if(value &gt;= r &amp;&amp; root.left!=null){\n                dfs(data,root.left);\n            }\n            if(value &lt;= l &amp;&amp; root.right!=null){\n                dfs(data,root.right);\n            }\n        }\n    }\n\n\n\n    /**\n     * @param root: param root: The root of the binary search tree\n     * @param k1: An integer\n     * @param k2: An integer\n     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order\n     */\n    public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) {\n        List&lt;Integer&gt; data=new LinkedList&lt;&gt;();\n        if(root==null)return data;\n        this.l=k1;\n        this.r=k2;\n        dfs(data,root);\n        return data;\n    }\n}</code></pre><h1><span id=\"114-不同的路径中等\">（114） 不同的路径(中等)</span></h1><blockquote>\n<p>很明显是杨辉三角,求C(n,m) 当然,也可以用动态规划,dp[i][j]=dp[i-1][j]+dp[i][j-1]</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param m: positive integer (1 &lt;= m &lt;= 100)\n     * @param n: positive integer (1 &lt;= n &lt;= 100)\n     * @return: An integer\n     */\n    public int[][] res=new int[204][204];\n    public void init(){\n        res[0][0]=1;\n        for(int i=1;i&lt;=200;++i){\n            res[i][0]=1;\n            for(int j=1;j&lt;=i;++j){\n                res[i][j]=res[i-1][j-1]+res[i-1][j];\n            }\n        }\n    }\n\n    public int uniquePaths(int m, int n) {\n        // write your code here\n        init();\n        return res[m+n-2][m-1];\n    }\n}</code></pre>","text":"（2） 尾部的零(Easy)因为2的数量远大于5,统计5的数量即可public class Solution {    /*     * @param n: An integer     * @return: An integer, denote the number of tr","link":"","raw":null,"photos":[],"categories":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/categories/LintCode.json"}],"tags":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/tags/LintCode.json"}]},{"title":"计划:技术栈完善2-实战JAVA高并发程序设计-第二章","slug":"plan-two-2","date":"2018-06-17T06:41:01.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-two-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/d705faf4fec8f9026144efa61d6b9b6d.png","content":"<h1><span id=\"java并行程序基础\">Java并行程序基础</span></h1><h2><span id=\"进程process\">进程(Process)</span></h2><p><strong>进程</strong>:</p>\n<blockquote>\n<p>1.是计算机中的程序关于某数据集合上的一次运行活动. 2.是系统进行资源分配和调度的基本单位 3.是操作系统结构的基础 4.早期,进程是程序的基本执行实体 5.当代,进程是线程的容器 6.程序是指令、数据及其组织形式的描述,进程是程序的实体</p>\n</blockquote>\n<p>我们使用多线程而非使用多进程去进行并发程序的设计,是因为线程间的切换和调度的成本<strong>远小于进程</strong>.</p>\n<h2><span id=\"线程的生命周期\">线程的生命周期</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d705faf4fec8f9026144efa61d6b9b6d.png\" alt> Java中的线程就是继承Runnable,故生命周期如上图所示. 以下是<code>Java.lang.Thread</code>中关于State的枚举定义源码:</p>\n<pre><code>public enum State {\n    /**\n     * Thread state for a thread which has not yet started.\n     */\n    NEW,\n\n    /**\n     * Thread state for a runnable thread.  A thread in the runnable\n     * state is executing in the Java virtual machine but it may\n     * be waiting for other resources from the operating system\n     * such as processor.\n     */\n    RUNNABLE,\n\n    /**\n     * Thread state for a thread blocked waiting for a monitor lock.\n     * A thread in the blocked state is waiting for a monitor lock\n     * to enter a synchronized block/method or\n     * reenter a synchronized block/method after calling\n     * {@link Object#wait() Object.wait}.\n     */\n    BLOCKED,\n\n    /**\n     * Thread state for a waiting thread.\n     * A thread is in the waiting state due to calling one of the\n     * following methods:\n     * &lt;ul&gt;\n     *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;\n     * &lt;/ul&gt;\n     *\n     * &lt;p&gt;A thread in the waiting state is waiting for another thread to\n     * perform a particular action.\n     *\n     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;\n     * on an object is waiting for another thread to call\n     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on\n     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;\n     * is waiting for a specified thread to terminate.\n     */\n    WAITING,\n\n    /**\n     * Thread state for a waiting thread with a specified waiting time.\n     * A thread is in the timed waiting state due to calling one of\n     * the following methods with a specified positive waiting time:\n     * &lt;ul&gt;\n     *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;\n     *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;\n     * &lt;/ul&gt;\n     */\n    TIMED_WAITING,\n\n    /**\n     * Thread state for a terminated thread.\n     * The thread has completed execution.\n     */\n    TERMINATED;\n}</code></pre><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/68a53d6f77b170185ae936fc85487b8c.png\" alt></p>\n<h2><span id=\"初始线程-线程的基本操作\">初始线程: 线程的基本操作</span></h2><h3><span id=\"新建线程\">新建线程</span></h3><p>线程启动时的调用顺序 start()-&gt;run() 所以,当我们使用start启动线程时是<code>真正</code>启动了一个线程,而在这个线程中调用run方法. 而如果使用了run(),则代表只是<code>调用了一次run函数</code>.</p>\n<blockquote>\n<p>使用匿名内部类修改run方法,然后启动线程</p>\n</blockquote>\n<pre><code>public class p21 {\n\n    public static void main(String[] args){\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                System.out.println(&quot;Hello, I&apos;m t1&quot;);\n            }\n        };\n        t1.start();\n    }\n}</code></pre><h3><span id=\"使用runnable接口来作为thread的构造参数传入\">使用Runnable接口来作为Thread的构造参数传入</span></h3><p>以下是Runnable接口的源码:</p>\n<pre><code>@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}</code></pre><p>可以发现,我们只需要实现run方法即可. 当我们调用Thread的run方法时,他会先判断下是否有Rannable,如果有,则调用Runnable的run方法.</p>\n<pre><code>@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}</code></pre><p>我们来使用Runnable接口实现线程</p>\n<pre><code>public class p21 implements Runnable {\n\n    public static void main(String[] args){\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                System.out.println(&quot;Hello, I&apos;m t1&quot;);\n            }\n        };\n        t1.start();\n        Thread t2=new Thread(new p21());\n        t2.start();\n    }\n\n    @Override\n    public void run(){\n        System.out.println(&quot;Hello,I&apos;m t2.&quot;);\n    }\n\n}</code></pre><p>这样就避免了重载Thread的run()方法,也是最常用的做法</p>\n<h3><span id=\"终止线程\">终止线程</span></h3><p>当我们在实现某些功能时,可能会让一些线程常驻在内存中. 那么我们该如何停止这些线程呢? Thread内部有一个Stop()的方法,但他已被标注为将废弃,因为该方法太过暴力,很有可能造成数据不一致的问题. 因为stop方法会在结束线程时,直接终止线程,并且释放掉这个线程的所有锁.而这些锁则是为了保证对象的一致性.如果此时,写线程写到一半,被强行终止,那么对象的完整性就可能会被破坏. 而因为锁被释放了,所以另一个线程就顺理成章的读到了这个不完整的对象… <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d4573f33d24bfc236e8d0da6dae4a164.png\" alt></p>\n<h4><span id=\"测试\">测试</span></h4><p>我们用一个程序来模拟下上面说的情况: 具体思路为-&gt;开启读取线程,如果User名字和id不一样,输出-&gt;不停地创建修改线程,修改的id和name一样-&gt;修改完成后stop()-&gt;观察结果</p>\n<pre><code>public class p22 {\n    public static User u=new User();\n    public static class User{\n        private int id;\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        private String name;\n        public User(){\n            id=0;\n            name=&quot;0&quot;;\n        }\n        @Override\n        public String toString(){\n            return &quot;User [id=&quot;+id+&quot;,name=&quot;+name+&quot;]&quot;;\n        }\n    }\n\n    public static class ChangeObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    int v=(int)(System.currentTimeMillis()/1000);\n                    u.setId(v);\n                    //Oh,do sth.else\n                    try{\n                        Thread.sleep(100);\n                    }catch(InterruptedException e){\n                        e.printStackTrace();\n                    }\n                    u.setName(String.valueOf(v));\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static class ReadObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(u.getId()!=Integer.parseInt(u.getName())){\n                        System.out.println(u.toString());\n                    }\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReadObjectThread().start();\n        while(true){\n            Thread t=new ChangeObjectThread();\n            t.start();\n            Thread.sleep(100);\n            t.stop();\n        }\n    }\n}</code></pre><p>输出: … User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] … 我们发现会出现很多如此的错误,为什么呢?和之前一样的原因,指令的顺序在优化中可能被更改,而线程的执行顺序也和调度算法有关,所以就造成了有可能某线程对User数据修改时sleep了一段时间,而这段时间内突然被stop了,其他的线程就拿到了不完整的数据. <strong>当然,如果你将两个sleep都设置为0就不会出现这种错误了.</strong></p>\n<h4><span id=\"自定义线程停止\">自定义线程停止</span></h4><blockquote>\n<p>如何解决这种问题呢?</p>\n</blockquote>\n<p>我们自行决定线程何时退出就可以了。</p>\n<ul>\n<li>volatile关键字 &gt; 添加该关键字的变量是: &gt;&gt; 不同线程访问和修改的变量</li>\n</ul>\n<blockquote>\n<p>即该指令不会因为编译器的优化而忽略,且要求每次直接读值.</p>\n</blockquote>\n<p>我们只需要为ChangeObjectThread添加一个方法stopMe(), 当stopme为true的时候才可以读取,为false的时候就禁止读取.并且直接退出run方法. 这也就保证了不会导致修改中途被撤销.</p>\n<pre><code>public class p22 {\n    public static User u=new User();\n    public static class User{\n        private int id;\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        private String name;\n        public User(){\n            id=0;\n            name=&quot;0&quot;;\n        }\n        @Override\n        public String toString(){\n            return &quot;User [id=&quot;+id+&quot;,name=&quot;+name+&quot;]&quot;;\n        }\n    }\n\n    public static class ChangeObjectThread extends Thread{\n\n        volatile boolean stopme=false;\n\n        public void stopMe(){\n            stopme=true;\n        }\n\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(stopme){\n                        System.out.println(&quot;exit by stop me&quot;);\n                        break;\n                    }\n                    int v=(int)(System.currentTimeMillis()/1000);\n                    u.setId(v);\n                    //Oh,do sth.else\n                    try{\n                        Thread.sleep(100);\n                    }catch(InterruptedException e){\n                        e.printStackTrace();\n                    }\n                    u.setName(String.valueOf(v));\n                }\n                Thread.yield();\n            }\n        }\n\n\n\n    }\n\n    public static class ReadObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(u.getId()!=Integer.parseInt(u.getName())){\n                        System.out.println(u.toString());\n                    }\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReadObjectThread().start();\n        while(true){\n            ChangeObjectThread t=new ChangeObjectThread();\n            t.start();\n            Thread.sleep(100);\n            t.stopMe();\n        }\n    }\n\n}</code></pre><h3><span id=\"线程中断\">线程中断</span></h3><p>为了解决stop可能会导致数据冲突的问题,JDK中提供了三个方法来实现线程中断.</p>\n<blockquote>\n<p>线程中断</p>\n<blockquote>\n<p>即线程中断不会使线程立即退出,而是给线程发一个通知,告知目标线程要中断了,至于如何处理,何时中断,<strong>由目标决定.</strong></p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ec4bce7b33d0b7bbbb972f5ef2404bc2.png\" alt></p>\n<pre><code>public class p23 {\n\n    public static void main(String[] args) throws Exception{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                while(true){\n                    if(Thread.currentThread().isInterrupted()){\n                        System.out.println(&quot;Interruted!&quot;);\n                        break;\n                    }\n                    Thread.yield();\n                }\n            }\n        };\n        t1.start();\n        Thread.sleep(100);\n        t1.interrupt();\n    }\n\n}</code></pre><h4><span id=\"threadsleep函数\">Thread.sleep函数</span></h4><p>他的签名如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b5e83f7565ce436cf16a37f5917f11ad.png\" alt> Thread.sleep()会让当前线程休眠若干时间,他会抛出一个InterruptedException中断异常,这个异常不是运行时异常,也就是说程序必须捕获并处理它,当线程休眠时,如果被中断,该异常就会产生.</p>\n<pre><code>public class p23 {\n\n    public static void main(String[] args) throws Exception{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                while(true){\n                    if(Thread.currentThread().isInterrupted()){\n                        System.out.println(&quot;Interruted!&quot;);\n                        break;\n                    }\n                    try{\n                        Thread.sleep(2000);\n                    }catch(InterruptedException e){\n                        System.out.println(&quot;Interrpted When Sleep&quot;);\n                        Thread.currentThread().interrupt();\n                    }\n                    Thread.yield();\n                }\n            }\n        };\n        t1.start();\n        Thread.sleep(100);\n        t1.interrupt();\n    }\n\n}</code></pre><p>所以我们必须在捕捉该异常的同时再次放出中断异常,这样才能保证该线程被正常中断.</p>\n<h4><span id=\"wait与notify\">wait()与notify()</span></h4><p>为了支持多线程间协作,JDK提供了等待wait()和通知notify()两个方法. 但这两个方法不存在Thread类中,而是输出Object类.这也就意味着任意的对象都可以调用该方法. 两个方法签名如下:</p>\n<pre><code>public final void wait() throws InterruptedException\npublic final native void notify()</code></pre><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/45787c634458f214da51856102ddff30.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b5278147272b76af3b33e061e68201b6.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b6d82ba876ebf51839908d5453046041.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b48a839ed1fa92328e6d7d2b3533f3ac.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/34da980742c79e179903c43f753e473a.png\" alt> 简单的例子:</p>\n<pre><code>public class p24 {\n    final static Object object = new Object();\n    public static class T1 extends Thread{\n        public void run(){\n            synchronized(object){\n                System.out.println(System.currentTimeMillis()+&quot;:T1 start!&quot;);\n                try{\n                    System.out.println(System.currentTimeMillis()+&quot;:T1 wait for object&quot;);\n                    object.wait();\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                }\n                System.out.println(System.currentTimeMillis()+&quot;:T1 end!&quot;);\n            }\n        }\n    }\n    public static class T2 extends Thread{\n        public void run(){\n            synchronized(object){\n                System.out.println(System.currentTimeMillis()+&quot;:T2 start! notify one thread&quot;);\n                object.notify();\n                System.out.println(System.currentTimeMillis()+&quot;:T2 end!&quot;);\n                try{\n                    Thread.sleep(2000);\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread t1=new T1();\n        Thread t2=new T2();\n        t1.start();\n        t2.start();\n    }\n\n}</code></pre><p>结果:</p>\n<pre><code>1529292002347:T1 start!\n1529292002347:T1 wait for object\n1529292002348:T2 start! notify one thread\n1529292002348:T2 end!\n1529292004348:T1 end!</code></pre><p>Tip: wait会释放所有的锁</p>\n<h4><span id=\"挂起suspend和继续执行resume线程\">挂起(suspend)和继续执行(resume)线程</span></h4><p>suspend乍看起来和stop或者wait相似简单的用法,但是,值得注意的是,suspend并不会释放任何资源和锁.所以就会导致其他想要索取资源的线程也被牵连. 而且resume也是存在问题,有可能在suspend前执行,这就会导致当前线程的状态被误判.</p>\n<h4><span id=\"等待线程结束join和谦让yield\">等待线程结束(join)和谦让(yield)</span></h4><p>一个线程需要等待另一个线程的结束才能继续执行(依赖输出)则用join. public final void join() throws InterruptedExcption public final synchronized void join(long millis) throws InterruptedException 第一个表示无限等待,他会一直阻塞线程,直到目标线程执行完毕. 第二个表示如果超过一段时间还没等到,则不等待,继续执行. 例:</p>\n<pre><code>public class p25 {\n    public volatile static int i=0;\n    public static class AddThread extends Thread{\n        @Override\n        public void run(){\n            for(i=0;i&lt;10000000;++i);\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        AddThread at=new AddThread();\n        at.start();\n        at.join();\n        System.out.println(i);\n\n    }\n\n}</code></pre><p>上述主函数中,如果不执行join来等待线程结束,则更多的可能是只会出现在线程结束前输出i的值(比如0)的情况. 如果用join来等待的话,则最终一定会输出1e7. join的本质是让调用线程wait()在当前线程对象实例上. 另一个: yield()方法是让当前线程让出CPU,然后重新加入到资源的争抢当中.如果觉得一个线程不是很重要,又害怕它占用过多的CPU,可以调用yield方法.</p>\n<h4><span id=\"volatile与java内存模型jmm\">volatile与Java内存模型(JMM)</span></h4><p>使用volatitle就表示告诉了虚拟机这个变量很可能被某线程修改. 虚拟机会特别小心的处理这个变量,尤其是当发现修改的顺序是反的时候. volatile可以很大程度上保证变量的完整性,但不保证操作的原子性,比如i++的原子操作完整性(i为32位下的长整型) 此外,volatile也能保证数据的可见性和有序性. 例:</p>\n<pre><code>public class p26 {\n\n    private volatile static boolean ready;\n    private static int number;\n\n    private static class ReaderThread extends Thread{\n        public void run(){\n            while(!ready);\n            System.out.println(number); \n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        new ReaderThread().start();\n        Thread.sleep(1000);\n        number=42;\n        ready=true;\n        Thread.sleep(10000);\n    }\n}</code></pre><p>因为指令的优化,在Server下线程无法”看到”ready”被修改.所以会无限的执行下去,这就是典型的可见性问题. 而加了volatiel修饰后的ready就不会出现这种情况了.</p>\n<h3><span id=\"线程组\">线程组</span></h3><p>一个系统中如果存在过多的线程,而且分工比较明确,就可以将相同功能的线程放置在一个线程组内.这样会使效率更高些.</p>\n<pre><code>public class p27 implements Runnable{\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        ThreadGroup tg=new ThreadGroup(&quot;PrintGroup&quot;);\n        Thread t1=new Thread(tg,new p27(),&quot;T1&quot;);\n        Thread t2=new Thread(tg,new p27(),&quot;T2&quot;);\n        t1.start();\n        t2.start();\n        System.out.println(tg.activeCount());\n        tg.list();\n        //tg.stop();-慎用\n    }\n    @Override\n    public void run(){\n        String groupAndName=Thread.currentThread().getThreadGroup().getName()\n                +&quot;-&quot;+Thread.currentThread().getName();\n        while(true){\n            System.out.println(&quot;I am &quot;+groupAndName);\n            try{\n                Thread.sleep(3000);\n            }catch(InterruptedException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre><h3><span id=\"驻守后台-守护线程daemon\">驻守后台-守护线程(Daemon)</span></h3><p>JVM内部的实现是如果运行的程序只剩下守护线程的话，程序将终止运行，直接结束。所以守护线程是作为辅助线程存在的</p>\n<h3><span id=\"线程优先级\">线程优先级</span></h3><p>Java可以自定义线程的优先级. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d05785fceddb6610ce2c0cf81eb21716.png\" alt> 设置优先级用 (Thread).setPriority(优先级(1~10))</p>\n<h3><span id=\"线程安全概念与synchronized\">线程安全概念与synchronized</span></h3><p>线程安全是并行程序开发的一大重点. 线程安全例子:</p>\n<pre><code>public class p28 implements Runnable{\n    static p28 instance=new p28();\n    static volatile int i=0;\n    public static void increase(){\n        i++;\n    }\n    @Override\n    public void run(){\n        for(int j=0;j&lt;10000000;++j){\n            increase();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(instance);\n        Thread t2=new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();t2.join();\n        System.out.println(i);\n    }\n}</code></pre><p>如果把t1.join()放到t1.start()后面的话,输出就为正常结果.但如上这样子放的话,也就代表了两个线程实际上是一起执行的.但在某一时刻t1.join开启以后t2就暂停执行等待t1执行完再继续. 我们可以使用synchronized关键字来对同步的代码加锁.使得每一次只能有一个线程进入同步块. 代码在书上的-P58,之前写过很多次了.</p>\n<h3><span id=\"并发下的arraylist\">并发下的ArrayList</span></h3><p>ArrayList是线程不安全的,用Vector代替线程不安全的ArrayList即可.</p>\n<h3><span id=\"并发下的hashmap\">并发下的HashMap</span></h3><p>并发下的HashMap可能会出现死循环的现象,为什么?下面来看一段代码 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/7be0b2035576e2b5202c4ba9360fb90d.png\" alt> 这段代码证明HashMap的插入是按照链表的方法插入的.而当死循环时就代表当前的HashMap链表被破坏成了环.也就导致了死循环. (但JDK8已经避免了这种情况的产生)</p>\n<h3><span id=\"jps和jstack工具\">jps和jstack工具</span></h3><p>jps是查看当前所有大线程 jstack是定位到对应的线程以及代码</p>\n<h3><span id=\"integer其实使用工厂方法进行赋值的\">Integer其实使用工厂方法进行赋值的</span></h3><p>如果我们想要给Integer加锁时,我们不能直接在Integer(int)变量上加锁,因为Integer是用工厂方法进行赋值,每次给int赋值时都会重新生成一个Integer对象. 所以我们需要在改变量所在的实例化对象上加锁. 比如: public class k implements Runnable{ int a; public void run(){ Code here. } } 我们就需要在实例化后的k对象上加锁,而不是在a上加锁.</p>\n","text":"Java并行程序基础进程(Process)进程:1.是计算机中的程序关于某数据集合上的一次运行活动. 2.是系统进行资源分配和调度的基本单位 3.是操作系统结构的基础 4.早期,进程是程序的基本执行实体 5.当代,进程是线程的容器 6.程序是指令、数据及其组织形式的描述,进程是程","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善2-实战Java高并发程序设计-Category","slug":"plan-category","date":"2018-06-17T06:38:13.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-category.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>更新到第三章</p>\n</blockquote>\n<h1><span id=\"第一章-done\">第一章 (Done)</span></h1><p><strong>2018/6/16</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/16/plan-two/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第一章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第一章</a></p>\n<h1><span id=\"第二章-done\">第二章 (Done)</span></h1><p><strong>2018/6/17</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/17/plan-two-2/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第一章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第二章</a></p>\n<h1><span id=\"第三章-done\">第三章 (Done)</span></h1><p><strong>2018/6/19</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/19/plan-three/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第三章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第三章</a></p>\n<h1><span id=\"第四章\">第四章</span></h1><h1><span id=\"第五章\">第五章</span></h1><h1><span id=\"第六章\">第六章</span></h1><h1><span id=\"第七章\">第七章</span></h1><h1><span id=\"第八章\">第八章</span></h1>","text":"更新到第三章第一章 (Done)2018/6/16 计划:技术栈完善2-实战JAVA高并发程序设计-第一章第二章 (Done)2018/6/17 计划:技术栈完善2-实战JAVA高并发程序设计-第二章第三章 (Done)2018/6/19 计划:技术栈完善2-实战JAVA高并发程","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]}]}