{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"大二ASP课程设计-个人博客","slug":"twick-asp-reg","date":"2017-06-29T06:10:36.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/twick-asp-reg.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/06/1-e1498717102691.png","content":"<p>怨念深重,第一次一个小组撸的近2000行代码,一个半星期.. 【源代码及数据库】 用的是SQL SERVER 2012 和VS2013 ASP.net 开发的. github仓库:<a href=\"https://github.com/834930269/OurWorld\" target=\"_blank\" rel=\"noopener\">OurWorld On Github</a> 【效果演示】  【效果截图】 <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/1-e1498717102691.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/9-e1498717129393.jpg\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/8-e1498717157154.jpg\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/7.jpg\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/6-1.jpg\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/5.jpg\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/4-1.jpg\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/3.jpg\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/2-1.jpg\" alt></p>\n","text":"怨念深重,第一次一个小组撸的近2000行代码,一个半星期.. 【源代码及数据库】 用的是SQL SERVER 2012 和VS2013 ASP.net 开发的. github仓库:OurWorld On Github 【效果演示】  【效果截图】  [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"ASP.Net","slug":"ASP-Net","count":3,"path":"api/categories/ASP-Net.json"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"}]},{"title":"LA 4329","slug":"la-4329","date":"2017-06-21T04:08:50.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-4329.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-4329\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-4329</a></strong> <strong>【thought】</strong> <strong>考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的.</strong> <strong>那么1 ~ (i-1)中有  (i-sm[i]-1)  个比A[i]能力大的,(i+1) ~ N 中有  (N-i-sl[i])  个比A[i]能力大的.</strong> <strong>根据乘法原理 对于第i个人做裁判有 sl[i]<em>(i-sm[i]-1)+sm[i]</em>(N-i-sl[i]) 中比赛可能,因为每个人做裁判,所以最后结果为每个人做裁判的情况和.</strong> <strong>考虑 T=1_19998+2_19997+3_19996+…+19998_1 爆int,故用long long 存.</strong> <strong>【Type】</strong> <strong>树状数组,lowbit()</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong> <strong>【溢出int测试】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329test.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong></p>\n","text":"【Link】 https://vjudge.net/problem/UVALive-4329 【thought】 考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的. 那么1 ~ (i-1)中有 ","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"树状数组","slug":"LA/树状数组","count":1,"path":"api/categories/LA/树状数组.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"等放暑假了要来波大的更新了","slug":"waitmeamomment","date":"2017-06-13T18:15:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/waitmeamomment.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/04/timg-2.jpg","content":"<h1><span id=\"攒了好久了tat\">攒了好久了TAT!!!</span></h1><h2><span id=\"顺便安利一波youtube上的语c伪动漫不清楚逃-a-shark-puppy-comic\">顺便安利一波YouTuBe上的语C伪动漫(不清楚,逃. —《A Shark puppy comic》</span></h2><h1><span id><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/04/timg-2.jpg\" alt></span></h1>","text":"攒了好久了TAT!!!顺便安利一波YouTuBe上的语C伪动漫(不清楚,逃. —《A Shark puppy comic》 [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"Windows游戏编程(C++)学习记录","slug":"windows-game-cplusplus","date":"2017-06-10T07:48:39.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/windows-game-cplusplus.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/06/1.jpg","content":"<p><strong>nCmdshow 参数:</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/06/1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/1.jpg\" alt></a> <strong>MessageBox uType</strong> <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/2.jpg\" alt></p>\n<hr>\n<p><strong>PlaySound这个函数在winmm中,所以需要:</strong> *<em>#pragma comment(lib, “winmm”)  *</em></p>\n<hr>\n<p><strong>d3dx9依赖库配置:</strong> <strong>包含目录</strong> <strong>D:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include</strong> <strong>库目录 ** **D:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86</strong></p>\n<p><strong>在“Link”即链接器选项下添加附加依赖项lib文件，如下图所示</strong> <strong>添加如下的lib文件</strong> <strong>d3d9.lib ** *<em>d3dx10d.lib *</em> *<em>d3dx9d.lib *</em> *<em>dxerr.lib *</em> *<em>dxguid.lib *</em> *<em>winmm.lib *</em> *<em>comctl32.lib *</em> **添加完成后保存并退出设置页面。</strong></p>\n<hr>\n","text":"nCmdshow 参数:  [Figure] PlaySound这个函数在winmm中,所以需要: *#pragma comment(lib, “winmm”)  *d3dx9依赖库配置: 包含目录 D:\\Program Files (x86)\\Microsoft DirectX","link":"","raw":null,"photos":[],"categories":[{"name":"C++游戏开发","slug":"C-游戏开发","count":1,"path":"api/categories/C-游戏开发.json"}],"tags":[{"name":"C++游戏开发","slug":"C-游戏开发","count":1,"path":"api/tags/C-游戏开发.json"}]},{"title":"Python2 处理数据并绘制三维空间图","slug":"python-dwsg","date":"2017-06-01T05:12:37.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-dwsg.json","excerpt":"","keywords":null,"cover":"https://camo.githubusercontent.com/d4a677e900b6208428a00aab9b3d317064708124/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545352542392542332545382541372538362545352539422542452d312e6a7067","content":"<p><strong>【附件一.骑行数据】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/data1.txt\" target=\"_blank\" rel=\"noopener\">data1.txt</a></strong> <strong>【附件二.骑行数据处理】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/Deal-3D.py\" target=\"_blank\" rel=\"noopener\">Deal-3D.py</a></strong> <strong>处理结果:  <a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/in.txt\" target=\"_blank\" rel=\"noopener\">in.txt</a></strong> <strong>【附件三.数据分析,提取出时空分布信息】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/DealData.cpp\" target=\"_blank\" rel=\"noopener\">DealData.cpp</a></strong> <strong>提取结果:  <a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/out2.txt\" target=\"_blank\" rel=\"noopener\">out2.txt</a> (注:每行三个数据,第一个数据是时间区间编号,第二个数据是区域编号,第三个数据是单车数量)</strong> <strong>【将处理数据绘制成三维图】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/3D-Image.py\" target=\"_blank\" rel=\"noopener\">3D-Image.py</a></strong> <strong>【绘制结果三视图】</strong> <strong>正视图:</strong> <strong><img src=\"https://camo.githubusercontent.com/d4a677e900b6208428a00aab9b3d317064708124/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545352542392542332545382541372538362545352539422542452d312e6a7067\" alt></strong>   <strong>侧视图:</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/%E4%BE%A7%E8%A7%86%E5%9B%BE.jpg\" alt></strong>   <strong>俯视图:</strong> <img src=\"https://camo.githubusercontent.com/9427753fa996288ba471a87588531c11a5a7fdc9/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545342542462541462545382541372538362545352539422542452e6a7067\" alt></p>\n","text":"【附件一.骑行数据】 data1.txt 【附件二.骑行数据处理】 Deal-3D.py 处理结果:  in.txt 【附件三.数据分析,提取出时空分布信息】 DealData.cpp 提取结果:  out2.txt (注:每行三个数据,第一个数据是时间区间编号,第二个数据是区域","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"PTA 朋友圈 并查集","slug":"pta-fiend-ufs","date":"2017-05-27T09:53:06.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/pta-fiend-ufs.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>并查集</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/PAT-/blob/master/pta%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5-25.cpp\" target=\"_blank\" rel=\"noopener\">5-25.cpp</a></strong></p>\n","text":"【类型】 并查集 【Code】 5-25.cpp","link":"","raw":null,"photos":[],"categories":[{"name":"PTA","slug":"PTA","count":1,"path":"api/categories/PTA.json"},{"name":"并查集","slug":"PTA/并查集","count":1,"path":"api/categories/PTA/并查集.json"}],"tags":[{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"pta","slug":"pta","count":2,"path":"api/tags/pta.json"}]},{"title":"Python 爬虫学习记录","slug":"python-buglearning","date":"2017-05-27T05:27:34.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-buglearning.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>代码均上传至github</strong> <strong>【第一节课】</strong> <strong># urllib 的基本用法</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20first/uri.py\" target=\"_blank\" rel=\"noopener\">uri.py</a></strong> <strong>【第二节课】</strong> <strong># urllib 的urlretrieve方法</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20urlretrieve/test.py\" target=\"_blank\" rel=\"noopener\">test.py</a></strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20urlretrieve/test2.py\" target=\"_blank\" rel=\"noopener\">test2.py</a></strong></p>\n","text":"代码均上传至github 【第一节课】 # urllib 的基本用法 uri.py 【第二节课】 # urllib 的urlretrieve方法 test.py test2.py","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"手撸算法","slug":"review-datastructure","date":"2017-05-26T02:55:08.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/review-datastructure.json","excerpt":"","keywords":null,"cover":null,"content":"<p>[toc]</p>\n<blockquote>\n<p>楼教主的男人八题: <a href=\"https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html\" title=\"https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html\" target=\"_blank\" rel=\"noopener\">https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html</a></p>\n</blockquote>\n<p>远离之前的模板代码,从原理上开始手撸数据结构. <strong>代码均上传至github仓库.</strong></p>\n<h1><span id=\"dijsktra-2017526\">【Dijsktra 2017/5/26】</span></h1><p>前向星+优先队列优化+路径回溯 <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Dijsktra/Dijsktra.cpp\" target=\"_blank\" rel=\"noopener\">Dijsktra.cpp</a></strong></p>\n<h1><span id=\"并查集-2017527\">【并查集 2017/5/27】</span></h1><p><strong>路径压缩,启发式rank优化,将rank较小的并到rank大的集合.</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Union-Find-Set/Union-Find.cpp\" target=\"_blank\" rel=\"noopener\">Union-Find-Set.cpp</a></strong></p>\n<h1><span id=\"树状数组-2017621\">【树状数组 2017/6/21】</span></h1><p><strong>lowbit() x&amp;(-x),前缀和,LA 4329</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.cpp\" target=\"_blank\" rel=\"noopener\">树状数组.cpp</a></strong></p>\n<h1><span id=\"快速排序-2017114\">【快速排序 2017/11/4】</span></h1><p><code>java</code></p>\n<pre><code>import java.util.Random;\n\npublic class Quick\n{\n    private static int cnt=0;\n    public static void sort(int[] a){\n        Random rand = new Random();\n        System.out.println(&quot;快排之前:&quot;);\n        for(int i=0;i&lt;20;++i){\n            a[i]=rand.nextInt(100);\n            System.out.print(a[i]+&quot; &quot;);\n        }\n        sort(a,0,a.length - 1);\n    }\n    public static void sort(int[] a,int lo,int hi){\n        if(hi &lt;= lo) return;\n        int j = partition(a,lo,hi);//切分\n        sort(a,lo,j-1);\n        sort(a,j+1,hi);\n    }\n    public static int partition(int[] a,int lo,int hi){\n        //将数组切分为a[lo..i-1],a[i],a[i+1..hi]\n        int i=lo,j=hi+1;//左右扫描指针\n        int pt=a[lo];//切分元素\n        while(true){\n            //扫描左右,检查扫描是否结束并交换元素\n            while(a[++i]&lt;pt)if(i==hi) break;//扫描到最左边都没找到大于等于pt的\n            while(a[--j]&gt;pt)if(j==lo) break;\n            if(i&gt;=j) break;//指针重合\n            swap(a,i,j);//没有问题,交换两值\n        }\n        swap(a,lo,j);//将作为基准的数放回正确的位置,切分为两部分,大于基准,小于基准\n        return j;\n    }\n    public static void swap(int[] a,int x,int y){\n        if(x == y) return;\n        a[x]=a[x]^a[y];\n        a[y]=a[y]^a[x];\n        a[x]=a[x]^a[y];\n        cnt++;\n        System.out.println(&quot;\\n第&quot;+cnt+&quot;次变化 &quot;+x+&quot; to &quot;+y+&quot; : &quot;);\n        for(int item: a){\n            System.out.print(item+&quot; &quot;);\n        }\n    }\n    public static void main(String[] args){\n        int[] a=new int[20];\n        sort(a);\n        System.out.println(&quot;\\n快排之后:&quot;);\n        for(int item: a){\n            System.out.print(item+&quot; &quot;);\n        }\n    }\n}</code></pre><p><code>C++</code></p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\nusing namespace std;\n\nint qpartition(int *a,int lo,int hi){\n    int v=a[lo];\n    int i=lo,j=hi+1;\n    while(true){\n        while(a[++i]&lt;v)if(i==hi)break;\n        while(a[--j]&gt;v)if(j==lo)break;\n        if(i&gt;=j)break;\n        swap(a[i],a[j]);\n    }\n    swap(a[lo],a[j]);\n    return j;\n}\n\nvoid qsort(int *a,int lo,int hi){\n    if(lo&gt;=hi) return;\n    int j=qpartition(a,lo,hi);\n    qsort(a,lo,j-1);\n    qsort(a,j+1,hi);\n}\n\nint main(){\n    srand((unsigned)time(NULL));\n    int a[20];\n    for(int i=0;i&lt;20;++i){\n        a[i]=rand()%100;\n        printf(&quot;%d &quot;,a[i]);\n    }\n    printf(&quot;\\n&quot;);\n    qsort(a,0,19);\n    for(int i=0;i&lt;20;++i){\n        printf(&quot;%d &quot;,a[i]);\n    }\n    return 0;\n}</code></pre><p><strong>Output:</strong></p>\n<pre><code>快排之前:\n29 41 75 80 82 60 0 51 10 57 26 5 84 70 60 78 10 29 11 56 \n第1次变化 1 to 18 : \n29 11 75 80 82 60 0 51 10 57 26 5 84 70 60 78 10 29 41 56 \n第2次变化 2 to 17 : \n29 11 29 80 82 60 0 51 10 57 26 5 84 70 60 78 10 75 41 56 \n第3次变化 3 to 16 : \n29 11 29 10 82 60 0 51 10 57 26 5 84 70 60 78 80 75 41 56 \n第4次变化 4 to 11 : \n29 11 29 10 5 60 0 51 10 57 26 82 84 70 60 78 80 75 41 56 \n第5次变化 5 to 10 : \n29 11 29 10 5 26 0 51 10 57 60 82 84 70 60 78 80 75 41 56 \n第6次变化 7 to 8 : \n29 11 29 10 5 26 0 10 51 57 60 82 84 70 60 78 80 75 41 56 \n第7次变化 0 to 7 : \n10 11 29 10 5 26 0 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第8次变化 1 to 6 : \n10 0 29 10 5 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第9次变化 2 to 4 : \n10 0 5 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第10次变化 0 to 3 : \n10 0 5 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第11次变化 0 to 2 : \n5 0 10 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第12次变化 0 to 1 : \n0 5 10 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第13次变化 4 to 6 : \n0 5 10 10 11 26 29 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第14次变化 9 to 18 : \n0 5 10 10 11 26 29 29 51 41 60 82 84 70 60 78 80 75 57 56 \n第15次变化 8 to 9 : \n0 5 10 10 11 26 29 29 41 51 60 82 84 70 60 78 80 75 57 56 \n第16次变化 11 to 19 : \n0 5 10 10 11 26 29 29 41 51 60 56 84 70 60 78 80 75 57 82 \n第17次变化 12 to 18 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 70 60 78 80 75 84 82 \n第18次变化 13 to 14 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 60 70 78 80 75 84 82 \n第19次变化 10 to 13 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 60 70 78 80 75 84 82 \n第20次变化 10 to 12 : \n0 5 10 10 11 26 29 29 41 51 57 56 60 60 70 78 80 75 84 82 \n第21次变化 10 to 11 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 78 80 75 84 82 \n第22次变化 16 to 17 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 78 75 80 84 82 \n第23次变化 15 to 16 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 84 82 \n第24次变化 18 to 19 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 82 84 \n快排之后:\n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 82 84 </code></pre><h1><span id=\"动态规划-划分数-20171116\">【动态规划-划分数 2017/11/16】</span></h1><p><code>java</code> 动态转移方程： dp[i][j]: j的i划分数 j&gt;=i: dp[i][j]=dp[i-1][j]+dp[i][j-i] i&gt;j: dp[i][j]=dp[i-1][j] 即有一个划分数为0时的目标状态是dp[i-1][j]</p>\n<pre><code>import java.util.*;\npublic class stlin {\n    public static void main(String[] args){\n        Scanner in=new Scanner(System.in);\n        int n,m,M;\n        n=in.nextInt();\n        m=in.nextInt();\n        M=in.nextInt();\n        solve(n,m,M);\n    }\n    public static void solve(int n,int m,int M){\n        int[][] dp=new int[m+1][n+1]; \n        //递推式=&gt;dp[i][j]=dp[i-1][j](ai=0时对应的是i-1划分)+dp[i][j-i]()\n        dp[0][0]=1;\n        for(int i=1;i&lt;=m;++i){\n            for(int j=0;j&lt;=n;++j){\n                if(i&gt;j){\n                    dp[i][j]=dp[i-1][j];\n                }else{\n                    dp[i][j]=(dp[i-1][j]+dp[i][j-i])%M;\n                }\n            }\n        }\n        System.out.println(dp[m][n]);\n    }\n}</code></pre><h1><span id=\"矩阵链乘-20171117\">【矩阵链乘 2017/11/17】</span></h1><blockquote>\n<p>输入保证有效,例:</p>\n<blockquote>\n<p>6 30 35 35 15 15 5 5 10 10 20 20 25 结果: 15125</p>\n</blockquote>\n</blockquote>\n<p>从每隔两个开始计算,即自底向上的动态规划. 仔细想一下吧,计算三个的时候,两个已经计算完成了,计算四个的时候,两个和三个已经计算完成了. 比如求<code>((M1)(M2M3M4M5))</code>,你就不需要再去递归求解<code>M2M3M4M5</code>,直接查表就可以了.</p>\n<pre><code>import java.util.*;\n\npublic class VeDP {\n    public static final int MAXN=100;\n    public static final int INF=0x3f3f3f3f;\n    static int[] p=new int[MAXN+1];\n    static int[][] m=new int[MAXN+1][MAXN+1];\n    public static void main(String args[]){\n        Scanner cin=new Scanner(System.in);\n        int n;\n        n=cin.nextInt();\n        for(int i=1;i&lt;=n;++i){//因为中间肯定相同\n            p[i-1]=cin.nextInt();\n            p[i]=cin.nextInt();\n        }\n        for(int l=2;l&lt;=n;++l){\n            for(int i=1;i&lt;=n-l+1;++i){\n                int j=i+l-1;\n                m[i][j]=INF;\n                for(int k=i;k&lt;=j-1;++k){\n                    m[i][j]=Math.min(m[i][j],m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]);\n                }\n            }\n        }\n        System.out.println(m[1][n]);\n    }\n}</code></pre><h1><span id=\"lis-20171118\">【LIS 2017/11/18】</span></h1><p>O(n^2) java: dp[j]:以c[j]为结尾的最长子序列长度.</p>\n<pre><code>//O(n^2)\nimport java.util.*;\npublic class LIS {\n    private static int[] c=new int[100000+1];\n    private static int[] dp=new int[100000+1];\n    public static void main(String[] args){\n        int n;\n        Scanner cin=new Scanner(System.in);\n        n=cin.nextInt();\n        for(int i=0;i&lt;n;++i){\n            c[i]=cin.nextInt();\n        }\n        /*\n         * dp[j]: 以c[j]为结尾从0...i的LIS \n         */\n        for(int i=1;i&lt;n;++i){\n            for(int j=0;j&lt;i;++j){\n                if(c[i]&gt;=c[j]){\n                    dp[i]=Math.max(dp[i],dp[j]+1);\n                }\n            }\n        }\n        System.out.println(dp[n-1]+1);\n    }\n}</code></pre><p>O(nlgn) c++: 二分搜索+dp 可以过51nod</p>\n<pre><code>//O(NlgN)\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=60000;\n\nint c[maxn],l[maxn];\nint n;\n\nint lis(){\n    l[0]=c[0];\n    int length=1;\n\n    for(int i=1;i&lt;n;++i){\n        if(l[length-1]&lt;c[i]){\n            l[length++]=c[i];\n        }else{\n            *lower_bound(l,l+length,c[i])=c[i];\n        }\n    }\n\n    return length;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%d&quot;,&amp;c[i]);\n    }\n\n    printf(&quot;%d&quot;,lis());\n    return 0;\n}</code></pre><h1><span id=\"20171119-最大正方形\">【2017/11/19 最大正方形】</span></h1><p>原题连接: <a href=\"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_A\" title=\"AOJ-Lagest Square\" target=\"_blank\" rel=\"noopener\">AOJ-Lagest Square</a> dp[i][j]为向左上方扩展最大的边长. dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1 Code C++:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=1500;\n\nint dp[maxn][maxn],G[maxn][maxn];\nint n,m;\n\nint main(){\n    int maxedge=0;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=0;i&lt;n;++i){\n        for(int j=0;j&lt;m;++j){\n            scanf(&quot;%d&quot;,&amp;G[i][j]);\n            if(G[i][j]==1)dp[i][j]=0;\n            else dp[i][j]=1,maxedge=1;\n        }\n    }\n    for(int i=1;i&lt;n;++i){\n        for(int j=1;j&lt;m;++j){\n            if(!G[i][j]){\n                dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;\n                maxedge=max(maxedge,dp[i][j]);\n            }\n        }\n    }\n    printf(&quot;%d\\n&quot;,maxedge*maxedge);\n    return 0;\n}</code></pre><h1><span id=\"20171119-最大子矩阵\">【2017/11/19 最大子矩阵】</span></h1><p>博客内写了题解 Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size,int buffer[]){\n    stack&lt;Rectangle&gt; S;\n    int maxv=0;\n    //通过后一位向前面的计算\n    //这里用到的DP大概是无参数getLargestRectangle里面的预处理\n    //这里用到的更多是思维吧,对每一行进行计算,最后求出最大值.\n    buffer[size]=0;\n\n    for(int i=0;i&lt;=size;++i){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height &lt; rect.height){\n                S.push(rect);\n            }else if(S.top().height &gt; rect.height){\n                int target=i;\n                while(!S.empty() &amp;&amp; S.top().height &gt;= rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    //printf(&quot;\\nmaxv: %d\\n&quot;,maxv);\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    //预处理每个点离他最近的上边未被污染地板的高度\n    for(int j=0;j&lt;W;++j){\n        for(int i=0;i&lt;H;++i){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i&gt;0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    /*\n    例:\n        0 0 1 0 0\n        1 0 0 0 0\n        0 0 0 1 0\n        0 0 0 1 0\n\n    After:\n        1 1 0 1 1\n        0 2 1 2 2\n        1 3 2 0 3\n        2 4 3 0 4\n    */\n    int maxv=0;\n    //传入两个值 W,列数,处理后T[i]第i行的首地址\n    for(int i=0;i&lt;H;++i){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(&quot;%d %d&quot;,&amp;H,&amp;W);\n    for(int i=0;i&lt;H;++i){\n        for(int j=0;j&lt;W;++j){\n            scanf(&quot;%d&quot;,&amp;buffer[i][j]);\n        }\n    }\n\n    printf(&quot;%d\\n&quot;,getLargestRectangle());\n    return 0;\n}</code></pre><h1><span id=\"20171125-筛法求euler\">【2017/11/25 筛法求euler】</span></h1><pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h1><span id=\"201818-开放式散列表\">【2018/1/8 开放式散列表】</span></h1><pre><code>/*\n//alds1_4_c:Dictionary\n//算法:开放地址法散列表\n//Time: 2018/1/8 星期一\n*/\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nconst int M=1000003;\nconst int L=14;\n\nchar H[M][L];\n\n//对于每个字符返回的定义值\nint getChar(char ch){\n    if(ch==&apos;A&apos;) return 1;\n    if(ch==&apos;C&apos;) return 2;\n    if(ch==&apos;D&apos;) return 3;\n    if(ch==&apos;T&apos;) return 4;\n    return 0;\n}\n//对于字符串返回的初始散列值\nlong long getKey(char str[]){\n    long long len=strlen(str),sum=0,p=1;\n    for(int i=0;i&lt;len;++i){\n        sum+=p*getChar(str[i]);\n        //每次获取定义值后p*5,相当于转换成五进制,不会冲突\n        p*=5;\n    }\n    return sum;\n}\n\n//开放式散列值计算式: h(k,i)=(h1(k)+i*h2(k))%M\nint h1(int key){\n    return key%M;\n}\n//为了保证不会递归冲突(即往下算结果始终相同),必须使h2(key)与M互素\n//TLE最好的情况就是改这个函数= =\n//目前可以AC的: 1+(key%(M-1))\n//(1+key)%(M-1)\nint h2(int key){\n    return (1+key)%(M-1);\n}\n\n//查找\n//-1表示找到\n//h表示找到第一个可插入点\nint find(char str[]){\n    long long key=getKey(str),i,h;\n    for(i=0;;++i){\n        h=(h1(key)+i*h2(key))%M;\n        if(strcmp(H[h],str)==0) return -1;\n        else if(strlen(H[h])==0) return h;\n    }\n    return 0;\n}\n\n//插入\nvoid insert(char str[]){\n    int key=find(str);\n    if(key!=-1) strcpy(H[key],str);\n}\n\nint main(){\n    for(int i=0;i&lt;M;++i) H[M][0]=&apos;\\0&apos;;\n    char str[L],com[L];\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%s %s&quot;,com,str);\n\n        if(com[0]==&apos;i&apos;){\n            insert(str);\n        }else{\n            if(find(str)==-1)\n                printf(&quot;yes\\n&quot;);\n            else\n                printf(&quot;no\\n&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre><h1><span id=\"2018117-强连通分量算法-tarjan\">【2018/1/17 强连通分量算法 Tarjan】</span></h1><p>详解Tarjan: <a href=\"http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/\" title=\"http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1><span id=\"201825-排列递推公式容斥-组合数学\">【2018/2/5 排列递推公式+容斥 组合数学】</span></h1><blockquote>\n<p>原题以及题解连接</p>\n<blockquote>\n<p><a href=\"http://be-sunshine.cn/index.php/2018/02/05/uva-11806/\" title=\"UVa 11806\" target=\"_blank\" rel=\"noopener\">UVa 11806</a></p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre><h1><span id=\"201826-on素数筛法-线性筛法\">【2018/2/6 O(n)素数筛法 线性筛法】</span></h1><blockquote>\n<p>一道例题: <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1431\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100001000\nusing namespace std;\n\nbool valid[maxn];\nint prime[maxn];\n/*素数筛法 O(n),对于每个素数只标记一次*/\nvoid getPrime(int n,int &amp;tot,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint main(){\n    clock_t t1 = clock();\n    int tot=0;\n    getPrime(100000000,tot,prime);\n    clock_t t2 = clock();\n\n    cout&lt;&lt;tot&lt;&lt;endl;\n    cout&lt;&lt;prime[5760000]&lt;&lt;endl;\n    cout&lt;&lt;&quot;总运行时间为: &quot;&lt;&lt;(double)(t2-t1)/ CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;&lt;&lt;endl;\n    return 0;\n}</code></pre><h1><span id=\"2018310-逆元\">【2018/3/10 逆元】</span></h1><h2><span id=\"逆元递推式\">逆元递推式</span></h2><blockquote>\n<p>适用于较小数据的情况</p>\n</blockquote>\n<pre><code>LL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}</code></pre><h2><span id=\"欧拉定理求逆元\">欧拉定理求逆元</span></h2><blockquote>\n<p>如果mod p 不是素数时最好用这个,比较少见</p>\n</blockquote>\n<pre><code>long long euler(int p)  \n{  \n    long long ans=p,a=p;  \n    long long i;  \n    for(i=2;i*i&lt;=a;i++)  \n    {  \n        if(a%i==0)  \n        {  \n            ans=ans/i*(i-1);  \n            while(a%i==0)  \n                a/=i;  \n        }  \n    }  \n    if(a&gt;1)  \n        ans=ans/a*(a-1);  \n    return ans;  \n}  \n\nlong long eu=euler(mod)-1;  \n\nlong long inv(long long a)  \n{  \n    return Pow(a,eu);  \n}  </code></pre><h2><span id=\"费马小定理求逆元\">费马小定理求逆元</span></h2><blockquote>\n<p>a^(p-1)≡1(mod p)</p>\n<blockquote>\n<p>a^(p-2)就是 a 关于p的逆元</p>\n<blockquote>\n<p>前提 a与b互素</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<pre><code>long long fast_mod(long long a,long long n,long long Mod){\n    long long ans=1;\n    while(n){\n        if(n&amp;1){\n            ans=(ans*a)%Mod;\n        }\n        a=(a*a)%Mod;\n        n&gt;&gt;=1;\n    }\n    return ans;\n} \n\n/*但p(即MOD)是素数时,inv[a]=fast_mod(a,p-2,p)*/</code></pre><h2><span id=\"扩展欧几里得求逆元\">扩展欧几里得求逆元</span></h2><pre><code>void extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inverse(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}</code></pre><h2><span id=\"费马小预处理阶乘逆元一般用于直接求组合数\">费马小预处理阶乘逆元(一般用于直接求组合数)</span></h2><pre><code>ll inv[maxn+10],fac[maxn+10];\n///预处理N!的逆元\n//费马小定理\n/*\n *假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡1（mod p）\n *根据这个性质我们可以知道 a的逆元为a^(p-2)\n */\nll fast_pow(ll a,ll b)\n{\n    ll ans=1;\n    while(b){\n        if(b&amp;1ll)ans=a*ans%MOD;\n        a=a*a%MOD;\n        b&gt;&gt;=1ll;\n    }\n    return ans;\n}\nvoid pre()\n{\n    inv[0]=1ll;\n    fac[0]=1ll;\n    for(int i=1;i&lt;=maxn;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=fast_pow(fac[i],MOD-2ll);\n    }\n}\nll C(ll a,ll b)\n{\n    return fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}</code></pre>","text":"[toc]楼教主的男人八题: https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html远离之前的模板代码,从原理上开始手撸数据结构. 代码均上传至github仓库.【Dijsktra 2017/5/26】前向星+优先队列","link":"","raw":null,"photos":[],"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"算法学习","slug":"数据结构/算法学习","count":1,"path":"api/categories/数据结构/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]},{"title":"github commit","slug":"github-commit","date":"2017-05-24T10:09:58.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/github-commit.json","excerpt":"","keywords":null,"cover":null,"content":"<p>$git clone (link) $git init $git add . $git commit -m “origin file” 可简写为: git commit -am ‘说明’ $git push origin master or</p>\n<p>git push</p>\n<p>)</p>\n<p>git status (状态) touch .gitignore (创建gitcommit忽略配置)</p>\n","text":"$git clone (link) $git init $git add . $git commit -m “origin file” 可简写为: git commit -am ‘说明’ $git push origin master orgit push)git status ","link":"","raw":null,"photos":[],"categories":[{"name":"Github","slug":"Github","count":1,"path":"api/categories/Github.json"}],"tags":[{"name":"Github","slug":"Github","count":2,"path":"api/tags/Github.json"}]},{"title":"Python list 学习笔记","slug":"python-list-di","date":"2017-05-24T09:46:46.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-list-di.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong>跟随廖雪峰老师学习:</strong> <strong><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316724772904521142196b74a3f8abf93d8e97c6ee6000\" target=\"_blank\" rel=\"noopener\">廖雪峰python-使用list</a></strong> <strong>【Code】</strong> <strong>已上传至github.</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/list/list.py\" target=\"_blank\" rel=\"noopener\">list.py</a></strong> <strong>【总结】</strong> <strong>比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…</strong></p>\n","text":"【Link】 跟随廖雪峰老师学习: 廖雪峰python-使用list 【Code】 已上传至github. list.py 【总结】 比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}]}