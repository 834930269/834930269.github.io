{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"Python list 学习笔记","slug":"python-list-di","date":"2017-05-24T09:46:46.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-list-di.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong>跟随廖雪峰老师学习:</strong> <strong><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316724772904521142196b74a3f8abf93d8e97c6ee6000\" target=\"_blank\" rel=\"noopener\">廖雪峰python-使用list</a></strong> <strong>【Code】</strong> <strong>已上传至github.</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/list/list.py\" target=\"_blank\" rel=\"noopener\">list.py</a></strong> <strong>【总结】</strong> <strong>比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…</strong></p>\n","text":"【Link】 跟随廖雪峰老师学习: 廖雪峰python-使用list 【Code】 已上传至github. list.py 【总结】 比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) F","slug":"youxiabeitwo","date":"2017-05-21T10:01:25.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/youxiabeitwo.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【思路】</strong> <strong>因为时间是个天然的序,所以我们只需要去考虑蚂蚁的朝向和位置即可.而蚂蚁是否被吃也可以通过是否有和他相向而行的蚂蚁来判断.</strong> <strong>用栈来边输入(输入是向右进行的,所以我们就让右行的蚂蚁固定,用左行的蚂蚁来吃与被吃..好残忍= =)边模拟这一过程.(其实只要是链表形式的都可以用来模拟,因为这样会节省时间</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct Star{</strong> **    int A,B;** <strong>};</strong> <strong>stack<star> Inti;</star></strong> <strong>int N,A,B;</strong> <strong>int main(){</strong> **    freopen(“in.txt”, “r”, stdin);** **    freopen(“out.txt”, “w”, stdout);** **    while(~scanf(“%d”,&amp;N)){** **        while(!Inti.empty()){** **            Inti.pop();** **        }** **        rep(i,N){** **            scanf(“%d%d”,&amp;A,&amp;B);** **            //Inti.push_back((Star){A,B,true});** **            if(B==1 || (!Inti.empty() &amp;&amp; Inti.top().B==0)){** **                Inti.push((Star){A,B});** **            }else{** **                int flag=0;** **                while(!Inti.empty()){** **                    if(Inti.top().B==1){** **                        if(Inti.top().A&lt;A){** **                            Inti.pop();** **                        }else{** **                            flag=1;** **                        }** **                        if(flag) break;** **                    }else break;** **                }** **                if(!flag){** **                    Inti.push((Star){A,B});** **                }** **            }** **        }** **        printf(“%d\\n”,Inti.size());** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【输入数据 in.txt】</strong> <strong>12</strong> <strong>8 1</strong> <strong>5 0</strong> <strong>3 1</strong> <strong>6 0</strong> <strong>7 1</strong> <strong>4 0</strong> <strong>1 1</strong> <strong>9 0</strong> <strong>2 1</strong> <strong>13 0</strong> <strong>15 1</strong> <strong>32 0</strong> <strong>5</strong> <strong>4 0</strong> <strong>3 1</strong> <strong>2 0</strong> <strong>1 0</strong> <strong>5 0</strong> <strong>12</strong> <strong>8 0</strong> <strong>5 1</strong> <strong>3 0</strong> <strong>6 1</strong> <strong>7 0</strong> <strong>4 1</strong> <strong>1 0</strong> <strong>9 1</strong> <strong>2 0</strong> <strong>13 1</strong> <strong>15 0</strong> <strong>32 1</strong> <strong>【输出数据】</strong> <strong>3</strong> <strong>2</strong> <strong>4</strong></p>\n","text":"【思路】 因为时间是个天然的序,所以我们只需要去考虑蚂蚁的朝向和位置即可.而蚂蚁是否被吃也可以通过是否有和他相向而行的蚂蚁来判断. 用栈来边输入(输入是向右进行的,所以我们就让右行的蚂蚁固定,用左行的蚂蚁来吃与被吃..好残忍= =)边模拟这一过程.(其实只要是链表形式的都可以用来","link":"","raw":null,"photos":[],"categories":[{"name":"ECNU","slug":"ECNU","count":2,"path":"api/categories/ECNU.json"},{"name":"思维","slug":"ECNU/思维","count":2,"path":"api/categories/ECNU/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"ECNU","slug":"ECNU","count":2,"path":"api/tags/ECNU.json"}]},{"title":"「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A","slug":"ecnucodera","date":"2017-05-21T09:49:16.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/ecnucodera.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题目来源】</strong> <strong><a href=\"http://acm.ecnu.edu.cn/contest/16/problem/A/\" target=\"_blank\" rel=\"noopener\">「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A</a></strong> <strong>【Tip】</strong> <strong>找进位规律找的自己恶心吐了,最后跪在了百位进位时忘了加最后的那几次十进位…(最后也是对拍了一个ACcode才找到了错误的地方</strong> <strong>思维漏洞还是太大了,或者说这种思维方式不太好.</strong> <strong>不过也算是又学会了一点东西.</strong> <strong>【My Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int main(){</strong> **    freopen(“in_2.txt”, “r”, stdin);** **    freopen(“out_2.txt”, “w”, stdout);** **    int T,N,M,B,C,EndN,EndM;** **    while(~scanf(“%d”,&amp;T)){** **        int ca=1;** **        while(T–){** **            int REG1,REG2,D1,D2,ans=-INF,r1[3],r2[3],r11[3],r22[3];** **            D1=D2=0;** **            scanf(“%d%d”,&amp;B,&amp;C);** **            REG1=B;** **            REG2=C;** **            red(i,2,0){** **                r1[i]=REG1%10;REG1/=10;** **                r2[i]=REG2%10;REG2/=10;** **            }** **            scanf(“%d”,&amp;N);** **            rep(i,N+1){//甲得i分,乙得M分** **                int D11,D22,all;** **                D11=D22=0;all=0;** **                M=N-i;** **                EndN=B+i;** **                EndM=C+M;** **                red(i,2,0){** **                    r11[i]=EndN%10;EndN/=10;** **                    r22[i]=EndM%10;EndM/=10;** **                }//百位进位19 十位进位9** **                r11[0]=r11[0]-r1[0];** **                if(r11[0]) {** **                    r11[1]=(r11[0]-1)<em>9+(9-r1[1])+r11[1];*</em> **                    all+=(r11[0]*18+r11[1]*9);** **                }else{** **                    r11[1]=r11[1]-r1[1];** **                    all+=(r11[1]<em>9);*</em> **                }** **                r22[0]=r22[0]-r2[0];** **                if(r22[0]) {** **                    r22[1]=(r22[0]-1)<em>9+(9-r2[1])+r22[1];*</em> **                    all+=(r22[0]*18+r22[1]*9);** **                }else{** **                    r22[1]=r22[1]-r2[1];** **                    all+=(r22[1]<em>9);*</em> **                }** **               // printf(“%d\\n”,all+N);** **                ans=max(ans,all+N);** **            }** **            printf(“Case %d: %d\\n”,ca++,ans);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【效率&amp;直观 code】</strong> <strong>感觉处理方法类似于数位dp</strong></p>\n<blockquote>\n<p>**    #include&lt;bits/stdc++.h&gt;** **    using namespace std;** **    #define maxn 1005** **    int dp[maxn];** **    void init(){** **        for(int i=1;i&lt;=999;i++){** **            if(i%100==0){** **                dp[i]=dp[i-1]+19;** **            }else if(i%10==0)** **                dp[i]=dp[i-1]+10;** **            else** **                dp[i]=dp[i-1]+1;** **        }** **        return;** **    }** **    int main(){** **        freopen(“in_2.txt”, “r”, stdin);** **        freopen(“out_3.txt”, “w”, stdout);** **        int T;** **        cin&gt;&gt;T;** **        init();** **        for(int cas=1;cas&lt;=T;cas++){** **            int a,b,k;** **            cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;** **            int ans=0;** **            int tans=0;** **            for(int i=0;i&lt;=k;i++){** **                tans=dp[a+i]-dp[a]+dp[b+k-i]-dp[b];** **               // printf(“%d\\n”,tans);** **                ans=max(ans,tans);** **            }** **            cout&lt;&lt;”Case “&lt;&lt;cas&lt;&lt;”: “;** **            cout&lt;&lt;ans&lt;&lt;”\\n”;** **        }** **        return 0;** **    }**</p>\n</blockquote>\n<p>【数据 in_2.txt】 13 000 000 1 000 000 10 000 000 100 001 000 109 001 001 109 123 123 89 458 253 500 327 652 200 320 602 58 227 725 63 102 103 37 023 001 900 21 23 5 【输出】 Case 1: 1 Case 2: 19 Case 3: 199 Case 4: 217 Case 5: 217 Case 6: 179 Case 7: 1013 Case 8: 398 Case 9: 112 Case 10: 126 Case 11: 73 Case 12: 1791 Case 13: 5</p>\n","text":"【题目来源】 「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A 【Tip】 找进位规律找的自己恶心吐了,最后跪在了百位进位时忘了加最后的那几次十进位…(最后也是对拍了一个ACcode才找到了错误的地方 思维漏洞还是太大了,或","link":"","raw":null,"photos":[],"categories":[{"name":"ECNU","slug":"ECNU","count":2,"path":"api/categories/ECNU.json"},{"name":"思维","slug":"ECNU/思维","count":2,"path":"api/categories/ECNU/思维.json"},{"name":"数位DP","slug":"ECNU/思维/数位DP","count":1,"path":"api/categories/ECNU/思维/数位DP.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"},{"name":"ECNU","slug":"ECNU","count":2,"path":"api/tags/ECNU.json"}]},{"title":"Python Learnning Record","slug":"python-learnning-record","date":"2017-05-21T03:42:53.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-learnning-record.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/0.png","content":"<p><strong>【Link】</strong> <strong><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"noopener\">廖雪峰的python教程</a></strong> <strong>【直接运行py文件】</strong> <strong>有同学问，能不能像.exe文件那样直接运行<code>.py</code>文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在<code>.py</code>文件的第一行加上一个特殊的注释：</strong></p>\n<p>**`#!/usr/bin/env python3</p>\n<p>print(‘hello, world’)`** </p>\n<p><strong>然后，通过命令给<code>hello.py</code>以执行权限：</strong></p>\n<p><strong><code>$ chmod a+x hello.py</code></strong> </p>\n<p><strong>就可以直接运行<code>hello.py</code>了，比如在Mac下运行：</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/0.png\" alt></strong> <strong>【数据类型和变量】</strong> <strong>Python可以处理任意大小的整数，当然包括负整数. (惊了</strong> <strong>注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在<code>-2147483648</code>-<code>2147483647</code>。</strong> <strong>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</strong> <strong>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</strong></p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a><strong>字符串</strong></h4><p><strong>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</strong> <strong>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\\</code>来标识，比如：</strong></p>\n<p><strong><code>&#39;I\\&#39;m \\&quot;OK\\&quot;!&#39;</code></strong> </p>\n<p><strong>表示的字符串内容是：</strong></p>\n<p><strong><code>I&#39;m &quot;OK&quot;!</code></strong> </p>\n<p><strong>如果字符串里面有很多字符都需要转义，就需要加很多<code>\\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：</strong></p>\n<p>**`&gt;&gt;&gt; print(‘\\\\t\\‘)<br>\\       \\</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>print(r’\\\\t\\‘)<br>\\\\t\\`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果字符串内部有很多换行，用<code>\\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，可以自己试试：</strong></p>\n<p><strong><code>&gt;&gt;&gt; print(&#39;&#39;&#39;line1\n... line2\n... line3&#39;&#39;&#39;)\nline1\nline2\nline3</code></strong> </p>\n<p><strong>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入。如果写成程序，就是：</strong></p>\n<p><strong><code>print(&#39;&#39;&#39;line1\nline2\nline3&#39;&#39;&#39;)</code></strong> </p>\n<p><strong>多行字符串<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>还可以在前面加上<code>r</code>使用，请自行测试。</strong></p>\n<h4 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a><strong>空值</strong></h4><p><strong>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</strong> <strong>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</strong> <strong>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</strong></p>\n<p><strong><code>a = 123 # a是整数\nprint(a)\na = &#39;ABC&#39; # a变为字符串\nprint(a)</code></strong> </p>\n<p><strong>【整数的除法】</strong> <strong>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是<code>/</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 / 3\n3.3333333333333335</code></strong> </p>\n<p><strong><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 9 / 3\n3.0</code></strong> </p>\n<p><strong>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 // 3\n3</code></strong> </p>\n<p><strong>你没有看错，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</strong></p>\n<p><strong>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 % 3\n1</code></strong> </p>\n<p><strong>无论整数做<code>//</code>除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</strong> <strong>【字节】</strong> <strong>最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</strong> <strong>【编码】</strong> <strong>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</strong> <strong>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</strong> <strong>UTF-8:可变长编码.</strong> <strong>Unicode:不可变长全码.</strong> <strong>转换过程:</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/1-1.png\" alt></strong>   <strong>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/2.png\" alt></strong> <strong>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</strong> ** 【python的字符串】** ** 搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。** <strong>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</strong></p>\n<p><strong><code>&gt;&gt;&gt; print(&#39;包含中文的str&#39;)\n包含中文的str</code></strong> </p>\n<p><strong>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</strong></p>\n<p>**`&gt;&gt;&gt; ord(‘A’)<br>65</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>ord(‘中’)<br>20013<br>chr(66)<br>‘B’<br>chr(25991)<br>‘文’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;\\u4e2d\\u6587&#39;\n&#39;中文&#39;</code></strong> </p>\n<p><strong>【网络中文本的比特流传输转换】</strong> <strong>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</strong></p>\n<p><strong><code>x = b&#39;ABC&#39;</code></strong> </p>\n<p><strong>要注意区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</strong></p>\n<p><strong>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</strong></p>\n<p>**`&gt;&gt;&gt; ‘ABC’.encode(‘ascii’)<br>b’ABC’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘中文’.encode(‘utf-8’)<br>b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’<br>‘中文’.encode(‘ascii’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-1: ordinal not in range(128)`** </module></stdin></p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</strong></p>\n<p><strong>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\\x##</code>显示。</strong></p>\n<p><strong>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</strong></p>\n<p>**`&gt;&gt;&gt; b’ABC’.decode(‘ascii’)<br>‘ABC’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’.decode(‘utf-8’)<br>‘中文’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数：</strong></p>\n<p>**`&gt;&gt;&gt; len(‘ABC’)<br>3</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>len(‘中文’)<br>2`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</strong></p>\n<p>**`&gt;&gt;&gt; len(b’ABC’)<br>3</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>len(b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’)<br>6<br>len(‘中文’.encode(‘utf-8’))<br>6`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</strong></p>\n<p><strong>【格式化输入输出】</strong></p>\n<p><strong>最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似<code>&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/3.png\" alt></strong> <strong>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</strong></p>\n<p>**`&gt;&gt;&gt; ‘Hello, %s’ % ‘world’<br>‘Hello, world’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘Hi, %s, you have $%d.’ % (‘Michael’, 1000000)<br>‘Hi, Michael, you have $1000000.’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>你可能猜到了，<code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</strong> <strong>常见的占位符有：</strong></p>\n<p><strong>%d</strong></p>\n<p><strong>整数</strong></p>\n<p><strong>%f</strong></p>\n<p><strong>浮点数</strong></p>\n<p><strong>%s</strong></p>\n<p><strong>字符串</strong></p>\n<p><strong>%x</strong></p>\n<p><strong>十六进制整数</strong></p>\n<p><strong>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</strong></p>\n<p>**`&gt;&gt;&gt; ‘%2d-%02d’ % (3, 1)<br>‘ 3-01’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘%.2f’ % 3.1415926<br>‘3.14’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;Age: %s. Gender: %s&#39; % (25, True)\n&#39;Age: 25. Gender: True&#39;</code></strong> </p>\n<p><strong>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;growth rate: %d %%&#39; % 7\n&#39;growth rate: 7 %&#39;</code></strong> </p>\n<p><strong>【list】</strong> <strong>如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</strong></p>\n<blockquote>\n<p><strong><code>&gt; classmates[-1] &#39;Tracy&#39;</code></strong> <strong><code>往后分块记笔记...</code></strong></p>\n</blockquote>\n<p><strong>【python3学习 模块】</strong> <strong>python3内置模块文档: <a href=\"https://docs.python.org/3/library/functions.html\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/3/library/functions.html</a></strong> <strong>python3自己写模块及使用: <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431845183474e20ee7e7828b47f7b7607f2dc1e90dbb000\" target=\"_blank\" rel=\"noopener\">廖雪峰-使用模块</a></strong> <strong>python3安装第三方模块:</strong> <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186362353505516c5d4e38456fb225c18cc5b54ffb000#0\" target=\"_blank\" rel=\"noopener\"><strong>安装第三方模块</strong></a></p>\n","text":"【Link】 廖雪峰的python教程 【直接运行py文件】 有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：**`#!/usr/bin/env python3","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Javascript入门学习完毕","slug":"javascriptsdy","date":"2017-05-17T02:47:10.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/javascriptsdy.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"http://be-sunshine.cn/study/2/\" target=\"_blank\" rel=\"noopener\">4-1编程挑战在开头</a></p>\n","text":"4-1编程挑战在开头","link":"","raw":null,"photos":[],"categories":[{"name":"Web","slug":"Web","count":3,"path":"api/categories/Web.json"}],"tags":[{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"}]},{"title":"HTML+CSS基础复习完毕","slug":"htmlcss","date":"2017-05-14T07:56:46.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/htmlcss.json","excerpt":"","keywords":null,"cover":null,"content":"<p>准备开JS <a href=\"http://be-sunshine.cn/study/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/study/</a></p>\n","text":"准备开JS http://be-sunshine.cn/study/","link":"","raw":null,"photos":[],"categories":[{"name":"Web","slug":"Web","count":3,"path":"api/categories/Web.json"}],"tags":[{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"}]},{"title":"把大一HTML课撸的网站Copy上来了","slug":"lalaland","date":"2017-05-14T07:49:25.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/lalaland.json","excerpt":"","keywords":null,"cover":null,"content":"<p>…突然感觉大一好像也不是那么差劲…下面的是链接.如果屏幕中间出现绿色加载,刷新一下就好啦. <a href=\"http://be-sunshine.cn/study/other\" target=\"_blank\" rel=\"noopener\">这个Zone在大一</a> 或者直接复制我-&gt;:<a href=\"http://be-sunshine.cn/study/other\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/study/other</a></p>\n","text":"…突然感觉大一好像也不是那么差劲…下面的是链接.如果屏幕中间出现绿色加载,刷新一下就好啦. 这个Zone在大一 或者直接复制我-&gt;:http://be-sunshine.cn/study/other","link":"","raw":null,"photos":[],"categories":[{"name":"Web","slug":"Web","count":3,"path":"api/categories/Web.json"}],"tags":[{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"}]},{"title":"第14届浙江省赛By Tusimple","slug":"14zojby-tusimple","date":"2017-04-22T11:57:29.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/14zojby-tusimple.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【网赛链接】</strong> <strong><a href=\"http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=364\" target=\"_blank\" rel=\"noopener\">第14届浙江省赛By Tusimple</a></strong> <strong>【A】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N,a1,T;</strong> <strong>int Kobayashi[4]={1,0,1,-1},Kscore;</strong> <strong>int Tohru[4]={0,1,1,-1},Tscore;</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        while(N–){** **            SI(T);** **            Kscore=0;** **            Tscore=0;** **            rep(i,T){** **                SI(a1);** **                Kscore+=Kobayashi[a1-1];** **                Tscore+=Tohru[a1-1];** **            }** **            if(Kscore&gt;Tscore)** **                puts(“Kobayashi”);** **            else if(Tscore&gt;Kscore)** **                puts(“Tohru”);** **            else** **                puts(“Draw”);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【B】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>const int maxn=20000+10;</strong> <strong>int T,N,fk,Orz,flag,cnt;</strong> <strong>int score[maxn],scomp[maxn];</strong> <strong>int main(){</strong> **    while(~SI(T)){** **        while(T–){** **            fill(score,score+4000,0);** **            Orz=flag=0;** **            SI(N);** **            if(N&gt;13 || N&lt;10){** **                rep(i,N){** **                    SI(fk);** **                }** **                puts(“No”);continue;** **            }** **            rep(i,N){** **                SI(fk);** **                if(fk&lt;=0){** **                    flag=1;** **                }else{** **                    score[fk]++;** **                }** **                scomp[i]=fk;** **            }** **            if(flag){** **                puts(“No”);** **            }else{** **                if(score[1]&lt;2){** **                    puts(“No”);** **                    continue;** **                }else{** **                    sort(scomp,scomp+N);** **                    rez(i,1,N-2){** **                        if(scomp[i]-scomp[i-1]&gt;2){** **                            puts(“No”);** **                            flag=1;** **                            break;** **                        }** **                    }** **                    if(!flag) puts(“Yes”);** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【C】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int T,n,q,c;</strong> <strong>map&lt;string,int&gt; mp;</strong> <strong>map&lt;string,int&gt;::iterator ite;</strong> <strong>map&lt;int,vector<string> &gt; res;</string></strong> <strong>string st;</strong> <strong>inline int readt(int N){</strong> **    int ans=0,tit;** **    rep(i,N){** **        SI(tit);** **        ans+=(1&lt;&lt;N-i-1) &amp; (tit&lt;&lt;N-i-1);** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        //测试数据可能出现重复的名字和情况,所以要初始化** **        mp.clear();** **        res.clear();** **        SII(n,q);** **        SI(c);** **        rep(i,c){** **            cin&gt;&gt;st;** **            mp[st]=0;** **        }** **        rep(i,q){** **            int nu;** **            SI(nu);** **            rep(j,nu){** **                cin&gt;&gt;st;** **                mp[st]+=(1&lt;&lt;q-i-1);** **            }** **        }** **        for(ite=mp.begin();ite!=mp.end();ite++){** **            res[ite-&gt;second].push_back(ite-&gt;first);** **        }** **        rep(i,n){** **            int index=readt(q);** **            if(res.find(index)==res.end()){** **                puts(“Let’s go to the library!!”);** **            }else{** **                vector<string>&amp; t=res[index];** **                if(t.size()&gt;1){** **                    puts(“Let’s go to the library!!”);** **                }else{** **                    cout&lt;&lt;t[0]&lt;&lt;”\\n”;** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></string></p>\n</blockquote>\n<p><strong>【D】</strong> <strong>因为样例用的是m=3…所以我就一直卡在z&gt;=3……然后比赛结束以后发现了…好亏啊</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct Star{</strong> **    int left,right;** **    bool operator&lt;(const Star MM) const{** **        return left&lt;MM.left;** **    }** <strong>}A[500],B[500];</strong> <strong>int n,m,x,y,T,s,e;</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        SII(n,m);SII(x,y);** **        rep(i,x){** **            SII(s,e);** **            A[i].left=s;** **            A[i].right=e;** **        }** **        rep(i,y){** **            SII(s,e);** **            B[i].left=s;** **            B[i].right=e;** **        }** **        sort(A,A+x);** **        sort(B,B+y);** **        int ans=0;** **        rep(i,x){** **            s=A[i].left;** **            e=A[i].right;** **            int z=0;** **            rep(j,y){** **                if(B[j].left&gt;A[i].right) break;** **                z+=(min(B[j].right,A[i].right)-max(A[i].left,B[j].left)+1);** **                    if(z&gt;=m){** **                        ans+=z-m+1;** **                        z=0;** **                    }else{** **                        z=0;** **                    }** **            }** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【网赛链接】 第14届浙江省赛By Tusimple 【A】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define ","link":"","raw":null,"photos":[],"categories":[{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/categories/ZOJ.json"},{"name":"位操作","slug":"ZOJ/位操作","count":1,"path":"api/categories/ZOJ/位操作.json"},{"name":"悬线法","slug":"ZOJ/位操作/悬线法","count":1,"path":"api/categories/ZOJ/位操作/悬线法.json"},{"name":"模拟","slug":"ZOJ/位操作/悬线法/模拟","count":1,"path":"api/categories/ZOJ/位操作/悬线法/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/tags/ZOJ.json"}]},{"title":"VJ SWPU-ACM省赛集训赛ONE J Right turn","slug":"vj-swpu-acmne-j-right-turn","date":"2017-04-20T11:04:34.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmne-j-right-turn.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>模拟</strong> <strong>【Tip】</strong> <strong>我的代码感觉上很对…然而莫名其妙总WA.然后把代码改成网上搜的题解的思路,A了…</strong> <strong>我一开始的思路是floyd判圈法,若会碰到同一个路障第二次,则一定无法逃出去.</strong> <strong>这个思路是错的,因为有可能在同一个点转的方向不同,所以如果经过同一个点两次有可能逃出去.</strong> <strong>但每个点最多只能经过三次,第四次时一定是一个圈.所以判断是否经过一个点四次就好了.依然是floyd判圈法.不过要判四次.</strong> <strong>然后成型代码如下.</strong> <strong>【WA Code1】</strong></p>\n<blockquote>\n<p>**`#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long ll;<br>const int INF = 0x3f3f3f3f;</p>\n<p>#define cle(a,val) memset(a,(val),sizeof(a))</p>\n<p>#define SI(N) scanf(“%lld”,&amp;(N))</p>\n<p>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</p>\n<p>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</p>\n<p>#define rep(i,b) for(int i=0;i&lt;(b);i++)</p>\n<p>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</p>\n<p>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)<br>const ll LINF = 0x3f3f3f3f3f3f3f3f;</p>\n<p>#define PU(x) puts(#x);</p>\n<p>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</p>\n<p>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</p>\n<p>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</p>\n<p>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</p>\n<p>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</p>\n<p>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}<br>const double EPS = 1e-9 ;<br>pair&lt;int,int&gt; node;<br>map&lt;pair&lt;int,int&gt;,bool&gt; mp;<br>map&lt;int,vector<int> &gt; EdgeX,EdgeY;<br>int N,X,Y,step;<br>int toward[4]={1,-2,-1,2},t=0;//右下左上</int></p>\n<p>bool floyd(){<br>    X=0,Y=0;<br>    while(1){<br>        if(toward[t]==1){<br>            vector<int>&amp; Just=EdgeY[Y];<br>            int si=Just.size(),flag=0;<br>            rep(i,si){<br>                if(Just[i]&gt;X){<br>                    if(mp[make_pair(Just[i],Y)]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(Just[i],Y)]=true;<br>                    flag=1;<br>                    X=Just[i]-1;<br>                    step++;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==-2){<br>            vector<int>&amp; Just=EdgeX[X];<br>            int si=Just.size(),flag=0;<br>            red(i,si-1,0){<br>                if(Just[i]&lt;Y){<br>                    if(mp[make_pair(X,Just[i])]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(X,Just[i])]=true;<br>                    Y=Just[i]+1;<br>                    step++;<br>                    flag=1;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==-1){<br>            vector<int>&amp; Just=EdgeY[Y];<br>            int si=Just.size(),flag=0;<br>            red(i,si-1,0){<br>                if(Just[i]&lt;X){<br>                    if(mp[make_pair(Just[i],Y)]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(Just[i],Y)]=true;<br>                    flag=1;<br>                    X=Just[i]+1;<br>                    step++;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==2){<br>            vector<int>&amp; Just=EdgeX[X];<br>            int si=Just.size(),flag=0;<br>            rep(i,si){<br>                if(Just[i]&gt;Y){<br>                    if(mp[make_pair(X,Just[i])]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(X,Just[i])]=true;<br>                    Y=Just[i]-1;<br>                    step++;<br>                    flag=1;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }<br>    }<br>}</int></int></int></int></p>\n<p>int main(){<br>    while(~SI(N)){<br>        t=0;<br>        step=0;<br>        mp.clear();<br>        EdgeX.clear();<br>        EdgeY.clear();<br>        rep(i,N){<br>            scanf(“%d%d”,&amp;node.first,&amp;node.second);<br>            mp[node]=false;<br>            EdgeX[node.first].push_back(node.second);<br>            EdgeY[node.second].push_back(node.first);<br>        }<br>        map&lt;int,vector<int> &gt;::iterator it;<br>        for(it=EdgeX.begin();it!=EdgeX.end();it++){<br>            vector<int>&amp; Just=it-&gt;second;<br>            sort(Just.begin(),Just.end());<br>        }<br>        for(it=EdgeY.begin();it!=EdgeY.end();it++){<br>            vector<int>&amp; Just=it-&gt;second;<br>            sort(Just.begin(),Just.end());<br>        }<br>        if(floyd()){<br>            printf(“%d\\n”,step);<br>        }else{<br>            printf(“-1\\n”);<br>        }<br>    }<br>    return 0;<br>}`** </int></int></int></p>\n</blockquote>\n<p><strong>【简单修改后AC代码】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>pair&lt;int,int&gt; node;</strong> <strong>map&lt;pair&lt;int,int&gt;,int&gt; mp;</strong> <strong>map&lt;int,vector<int> &gt; EdgeX,EdgeY;</int></strong> <strong>int N,X,Y,step;</strong> <strong>int toward[4]={1,-2,-1,2},t=0;//右下左上</strong> <strong>bool floyd(){</strong> **    X=0,Y=0;** **    while(1){** **        if(toward[t]==1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;X){** **                    if(mp[make_pair(Just[i],Y)]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(Just[i],Y)]++;** **                    flag=1;** **                    X=Just[i]-1;** **                    step++;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==-2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            red(i,si-1,0){** **                if(Just[i]&lt;Y){** **                    if(mp[make_pair(X,Just[i])]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(X,Just[i])]++;** **                    Y=Just[i]+1;** **                    step++;** **                    flag=1;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==-1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            red(i,si-1,0){** **                if(Just[i]&lt;X){** **                    if(mp[make_pair(Just[i],Y)]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(Just[i],Y)]++;** **                    flag=1;** **                    X=Just[i]+1;** **                    step++;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;Y){** **                    if(mp[make_pair(X,Just[i])]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(X,Just[i])]++;** **                    Y=Just[i]-1;** **                    step++;** **                    flag=1;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }** **    }** <strong>}</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        t=0;** **        step=0;** **        mp.clear();** **        EdgeX.clear();** **        EdgeY.clear();** **        rep(i,N){** **            scanf(“%d%d”,&amp;node.first,&amp;node.second);** **            mp[node]=0;** **            EdgeX[node.first].push_back(node.second);** **            EdgeY[node.second].push_back(node.first);** **        }** **        map&lt;int,vector<int> &gt;::iterator it;** **        for(it=EdgeX.begin();it!=EdgeX.end();it++){** **            vector<int>&amp; Just=it-&gt;second;** **            sort(Just.begin(),Just.end());** **        }** **        for(it=EdgeY.begin();it!=EdgeY.end();it++){** **            vector<int>&amp; Just=it-&gt;second;** **            sort(Just.begin(),Just.end());** **        }** **        if(floyd()){** **            printf(“%d\\n”,step);** **        }else{** **            printf(“-1\\n”);** **        }** **    }** **    return 0;** <strong>}</strong></int></int></int></int></int></int></int></p>\n</blockquote>\n<p><strong>【跟着题解AC Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>pair&lt;int,int&gt; node;</strong> <strong>map&lt;pair&lt;int,int&gt;,bool&gt; mp;</strong> <strong>map&lt;int,vector<int> &gt; EdgeX,EdgeY;</int></strong> <strong>int N,X,Y,step;</strong> <strong>int toward[4]={1,-2,-1,2},t=0;//右下左上</strong> <strong>bool floyd(){</strong> **    X=0,Y=0;** **    while(step&lt;=4<em>N+1){*</em> **        int tmpx=-INF,tmpy=-INF;** **        if(toward[t]==1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size();** **            rep(i,si){** **                if(Just[i]&gt;X){** **                    tmpy=Y;** **                    if(tmpx!=-INF) tmpx=min(tmpx,Just[i]);** **                    else tmpx=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** **    //            if(mp[make_pair(tmpx,Y)]) return false;** **     //           mp[make_pair(tmpx,Y)]=true;** **                X=tmpx-1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==-2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&lt;Y){** **                    tmpx=X;** **                    flag=1;** **                    if(tmpy!=-INF) tmpy=max(tmpy,Just[i]);** **                    else tmpy=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** **  //              if(mp[make_pair(X,tmpy)]) return false;** ** //               mp[make_pair(X,tmpy)]=true;** **                Y=tmpy+1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==-1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&lt;X){** **                    flag=1;** **                    tmpy=Y;** **                    if(tmpx!=-INF) tmpx=max(tmpx,Just[i]);** **                    else tmpx=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** ** //               if(mp[make_pair(tmpx,Y)]) return false;** ** //               mp[make_pair(tmpx,Y)]=true;** **                X=tmpx+1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;Y){** **                    tmpx=X;** **                    flag=1;** **                    if(tmpy!=-INF) tmpy=min(tmpy,Just[i]);** **                    else tmpy=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** ** //              if(mp[make_pair(X,tmpy)]) return false;** **  //              mp[make_pair(X,tmpy)]=true;** **                Y=tmpy-1;** **                step++;** **                t=(t+1)%4;** **            }** **        }** **    }** **    return false;** <strong>}</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        t=0;** **        step=0;** **        mp.clear();** **        EdgeX.clear();** **        EdgeY.clear();** **        rep(i,N){** **            scanf(“%d%d”,&amp;node.first,&amp;node.second);** <strong>//            mp[node]=false;</strong> **            EdgeX[node.first].push_back(node.second);** **            EdgeY[node.second].push_back(node.first);** **        }** **        if(floyd()){** **            printf(“%d\\n”,step);** **        }else{** **            printf(“-1\\n”);** **        }** **    }** **    return 0;** <strong>}</strong></int></int></int></int></p>\n</blockquote>\n","text":"【类型】 模拟 【Tip】 我的代码感觉上很对…然而莫名其妙总WA.然后把代码改成网上搜的题解的思路,A了… 我一开始的思路是floyd判圈法,若会碰到同一个路障第二次,则一定无法逃出去. 这个思路是错的,因为有可能在同一个点转的方向不同,所以如果经过同一个点两次有可能逃出去. ","link":"","raw":null,"photos":[],"categories":[{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/categories/Floyd判圈法.json"},{"name":"VJ","slug":"Floyd判圈法/VJ","count":1,"path":"api/categories/Floyd判圈法/VJ.json"},{"name":"模拟","slug":"Floyd判圈法/VJ/模拟","count":1,"path":"api/categories/Floyd判圈法/VJ/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/tags/Floyd判圈法.json"},{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]},{"title":"VJ SWPU-ACM省赛集训赛ONE E Rectangle","slug":"vj-swpu-acmone-e-rectangle","date":"2017-04-20T06:44:53.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmone-e-rectangle.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>枚举长的长度,则对于长有N-i+1种情况.</strong> <strong>然后得出宽的取值范围为[1,tmp=(K-i)&lt;M?(K-i):M].防溢出.</strong> <strong>画图知在宽的取值范围内情况分别为:M,M-1,M-2…M-tmp+1.共tmp项.</strong> <strong>用等差数列求和公式得出该长下的宽的情况个数.</strong> <strong>乘积累加.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N,M,K;</strong> <strong>ll ans;</strong> <strong>int main(){</strong> **    while(~SIII(N,M,K)){** **        K&gt;&gt;=1;** **        ans=0;** **        for(int i=1;i&lt;=N &amp;&amp; K-i&gt;0;++i){** **            ll tmp=(K-i)&lt;M?(K-i):M;** **            ll sumC=N-i+1;** **            ll sumK=(M+M-tmp+1)<em>tmp/2;*</em> **            ans+=sumC<em>sumK;*</em> **        }** **        printf(“%lld\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 枚举长的长度,则对于长有N-i+1种情况. 然后得出宽的取值范围为[1,tmp=(K-i)&lt;M?(K-i):M].防溢出. 画图知在宽的取值范围内情况分别为:M,M-1,M-2…M-tmp+1.共tmp项. 用等差数列求和公式得出该长下的宽的情况个数. 乘积累加","link":"","raw":null,"photos":[],"categories":[{"name":"VJ","slug":"VJ","count":2,"path":"api/categories/VJ.json"}],"tags":[{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]}]}