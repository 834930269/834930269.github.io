{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"淘宝竞价爬虫","slug":"taobao-bug","date":"2017-09-06T23:40:58.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/taobao-bug.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/09/1-1.png","content":"<p>首先我们先观察搜索为书包的链接: 第一页: <code>https://s.taobao.com/search?q=书包&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.50862.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170906</code> 第二页: <code>https://s.taobao.com/search?q=书包imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.50862.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170906&amp;bcoffset=4&amp;ntoffset=4&amp;p4ppushleft=1%2C48&amp;s=44</code> 我们可以观察到书包的属性是q,而每页有44个商品,所以页数的属性是s. 所以我们推测当链接为: <code>http://s.taobao.com/search?q=书包&amp;s=44</code> 时,时当前搜索目录的第二页. 首先是getHTMLtext:</p>\n<pre><code>def getHTMLtext(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n        return r.text\n    except:\n        print(&quot;&quot;)</code></pre><p>然后我们分析代码,比如第一页第一件商品的价钱如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/1-1.png\" alt=\"第一件\" title=\"第一件\"> 我们在代码页搜索对应的价格89.00,发现对应的标记是’view_price’: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/2-1.png\" alt=\"89.00\" title=\"89.00\"> 然后是对应的标题,这里有一些问题,因为第一个东西的标题和显示的对不上,显示的是放在’title’标记中,而不知道什么的标题放在’raw_title’中: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/3-1.png\" alt> 然后我们开始编写parse方法:</p>\n<pre><code>def parsePage(til,text):\n    try:\n        r1=re.compile(r&apos;&quot;view_price&quot;:&quot;[\\d.]*&quot;&apos;)\n        r2=re.compile(r&apos;&quot;raw_title&quot;:&quot;.*?&quot;&apos;)\n        lip=re.findall(r1,text)\n        lit=re.findall(r2,text)\n        for i in range(len(lip)):\n            price=eval(lip[i].split(&apos;:&apos;)[1])\n            title=eval(lit[i].split(&apos;:&apos;)[1])\n            til.append([price,title])\n    except:\n        print(&apos;&apos;)</code></pre><p>其中eval可以忽略””这玩意？？？ 最终完成品:</p>\n<pre><code>#-*-coding:utf-8-*-\nimport requests\nimport re\n\ndef getHTMLtext(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n        return r.text\n    except:\n        print(&quot;&quot;)\n\n\ndef parsePage(til,text):\n    try:\n        r1=re.compile(r&apos;&quot;view_price&quot;:&quot;[\\d.]*&quot;&apos;)\n        r2=re.compile(r&apos;&quot;raw_title&quot;:&quot;.*?&quot;&apos;)\n        lip=re.findall(r1,text)\n        lit=re.findall(r2,text)\n        for i in range(len(lip)):\n            price=eval(lip[i].split(&apos;:&apos;)[1])\n            title=eval(lit[i].split(&apos;:&apos;)[1])\n            til.append([price,title])\n    except:\n        print(&apos;&apos;)\n\ndef printResult(lis):\n    tplt=&quot;{:4}\\t{:8}\\t{:16}&quot;\n    print(tplt.format(&apos;序号&apos;,&apos;价格&apos;,&apos;商品名称&apos;))\n    for i in range(len(lis)):\n        print(tplt.format(i+1,lis[i][0],lis[i][1]))\n        if lis[i][0]==&apos;89.00&apos;:\n            print(&apos;===============&apos;)\n\ndef main():\n    goods=&apos;书包&apos;\n    deepth=3\n    infolist=[]\n    start_url=&apos;https://s.taobao.com/search?q=书包&apos;\n    for i in range(deepth):\n        try:\n            url=start_url+&apos;&amp;s=&apos;+str(i*44)\n            text=getHTMLtext(url)\n            parsePage(infolist,text)\n        except:\n            continue\n    printResult(infolist)\n\nmain()</code></pre><p>结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/4-1.png\" alt></p>\n","text":"首先我们先观察搜索为书包的链接: 第一页: https://s.taobao.com/search?q=书包&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"},{"name":"爬虫","slug":"Python/未分类/爬虫","count":2,"path":"api/categories/Python/未分类/爬虫.json"}],"tags":[{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"Oracle learning","slug":"record-in-class","date":"2017-09-04T08:22:36.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/record-in-class.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/09/1.png","content":"<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/1.png\" alt=\"S\" title=\"S\"></p>\n<hr>\n<p>create user 用户名 identified by 密码 grant 权限/角色 to 用户 <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/09/2.png\" title=\"Z\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/2.png\" alt=\"Z\" title=\"Z\"></a></p>\n<hr>\n<p>修改密码 <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/3.png\" alt=\"C\" title=\"C\"></p>\n<hr>\n<p>设置角色密码过期 <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/4.png\" alt=\"十多万\" title=\"十多万\"></p>\n<hr>\n<p>加锁,解锁 unlock <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/5.png\" alt=\"SAD\" title=\"SAD\"></p>\n<hr>\n<p>建表 <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/6.png\" alt=\"达到\" title=\"达到\"></p>\n<hr>\n<p>授权查找某用户某表 <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/7.png\" alt=\"sad\" title=\"sad\"></p>\n<hr>\n<p>回收权限 <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/8.png\" alt=\"萨达ad\" title=\"萨达ad\"></p>\n<hr>\n<p>删除用户 <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/9.png\" alt=\"删除用户\" title=\"删除用户\"></p>\n<hr>\n<p>系统设置 set time on/off – 时间显示 set pause on – 每次按回车显示下一个 set pagesize 20 – 一次(页)显示几行 set newpage 5 – 每页与每页之间空几行 set linesize 100 – 一行显示的字数 set numformat format – 格式 set timming on/off – 统计每条sql的运行时间 column sal format $999,999.0 – 改列的格式 column sal off – 关闭以上的更改 column empno heading ‘工作编号’ – 改头的表示方法 ttitle center ‘职工信息表’ – 标题 btitle left ‘2017/9/6’ – 角注 以上加off就可以关闭 describe emp – 描述 spool d:\\output.txt – 保存下输出的内容 spool off – 当spool关闭了以后才会写入上述文件内</p>\n<hr>\n<p>Oracke数据库的创建与管理 数据块是Oracle逻辑存储结构中的最小的逻辑单位. 一个数据块对应一个或者多个物理块,大小由参数DB_BLOCK_SIZE 例:</p>\n<pre><code>system/密码\ncol name format a30\ncol value format a30\nselect name,value from v$parameter where name=&apos;db_block_size&apos;</code></pre><p>数据块: 块头(存放地址信息):数据块标题存放地址,表目录存放表的相关信息(地址),行目录存的是行的地址. 存储区: 自由空间,行数据. 数据区(Extent): 数据区是有连续的数据块结合而成的. 数据区是Oracle存储分配的最小单位. 段: 数据段. 索引段. 临时段. 回滚段. 表空间(TableSpace): 表空间是数据库的最大逻辑划分区域. 一个表空间有一个或多个数据文件组成,一个数据文件只属于一个表空间. 表空间的大小是它所对应的数据文件的大小.</p>\n<pre><code>系统表空间\n辅助表空间(辅助系统表空间)\n撤销表空间\n用户表空间</code></pre><p>日志: 归档模式. 非归档模式. 其他文件: 服务器参数文件. 密码文件. 警告文件. 创建数据库: 1.登录localhost:1158/em system 2.选择服务器 3.存储/数据文件 4.选择表空间(USERS,这里自己选) 修改数据库: 1.登录localhost:1158/em system 2.选择服务器 3.存储/数据文件 4.之后自己找 删除一样. 共享数据库: dispatchers=”(PROTOCOL=TCP) (SERVICE=orclXDB)” 全局数据库名称: db_domain=”” db_name=orcl</p>\n","text":" [Figure] 系统设置 set time on/off – 时间显示 set pause on – 每次按回车显示下一个 set pagesize 20 – 一次(页)显示几行 set newpage 5 – 每页与每页之间空几行 set linesize 100 – 一行","link":"","raw":null,"photos":[],"categories":[{"name":"Oracle","slug":"Oracle","count":2,"path":"api/categories/Oracle.json"},{"name":"未分类","slug":"Oracle/未分类","count":1,"path":"api/categories/Oracle/未分类.json"}],"tags":[{"name":"Oracle","slug":"Oracle","count":2,"path":"api/tags/Oracle.json"}]},{"title":"ASP.Net 记录贴","slug":"asp-net-recode","date":"2017-09-01T10:01:47.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/asp-net-recode.json","excerpt":"","keywords":null,"cover":null,"content":"<p>委派: 委托是方法的抽象，它存储的就是一系列具有相同签名和返回回类型的方法的地址。调用委托的时候，委托包含的所有方法将被执行。 1.委托类型的定义 委托是类型，就好像类是类型一样。与类一样，委托类型必须在被用来创建变量以及类型对象之前声明。</p>\n<pre><code>delegate void MyDel(int x);</code></pre><p>委托类型声明： （1） 以deleagate关键字开头。 （2）返回类型+委托类型名+参数列表。 2.声明委托变量</p>\n<pre><code>MyDel del1,del2;</code></pre><p>3.初始化委托变量</p>\n<pre><code>del1 = new MyDel( myInstObj.MyM1 );\ndel2 = new MyDel( SClass.OtherM2 );</code></pre><p>4.组合委托 委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表是两个操作数的委托调用列表的副本的连接。 委托是恒定的，操作数委托创建后不会被改变。委托组合拷贝的是操作数的副本。</p>\n<pre><code>MyDel del1 = myObj.MyMethod;\nMyDel del2 = SClass.OtherM2;\nMyDel del3 = del1 + del2;   //组合调用列表</code></pre><p>5.委托加减运算 可以使用+=运算符，为委托新增方法。 同样可以使用-=运算符，为委托移除方法。</p>\n<pre><code>MyDel del = myObj.MyMethod;\ndel += SClass.OtherM2; // 增加方法\ndel -= myObj.MyMethod; // 移除方法</code></pre><p>6.委托调用 委托调用跟方法调用类似。委托调用后，调用列表的每个方法将会被执行。 在调用委托前，应判断委托是否为空。调用空委托会抛出异常。</p>\n<pre><code>if(null != del)\n{\n     del();//委托调用\n}</code></pre><p>7.匿名方法 匿名方法是在初始化委托时内联声明的方法。 基本结构：</p>\n<pre><code>deleage( 参数 ) { 语句块 }</code></pre><p>例如：</p>\n<pre><code>delegate int MyDel (int x); //定义一个委托 \n\nMyDel del = delegate( int x){ return x; };</code></pre><p>8.Lambda表达式 Lambda运算符读作”goes to”。</p>\n<pre><code>MyDel del = delegate( int x) { return x; };//匿名方法\nMyDel del2 = (int x) =&gt; {return x;};//Lambda表达式\nMyDel del3 = x =&gt; {return x};//简写的Lambda表达式</code></pre>","text":"委派: 委托是方法的抽象，它存储的就是一系列具有相同签名和返回回类型的方法的地址。调用委托的时候，委托包含的所有方法将被执行。 1.委托类型的定义 委托是类型，就好像类是类型一样。与类一样，委托类型必须在被用来创建变量以及类型对象之前声明。delegate void MyDel(","link":"","raw":null,"photos":[],"categories":[{"name":"ASP.Net","slug":"ASP-Net","count":3,"path":"api/categories/ASP-Net.json"},{"name":"C#","slug":"ASP-Net/C","count":2,"path":"api/categories/ASP-Net/C.json"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"CCF 2016-12/4 & POJ 1738","slug":"ccf-2016-124-poj-1738","date":"2017-08-31T12:45:36.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2016-124-poj-1738.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 石子合并问题 算法: GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn),也可以用动态规划,等等学一下再补充. GarsiaWachs算法(摘自别人的blog):</p>\n<pre><code>具体的算法及证明可以参见《The Art of Computer Programming》第3卷6.2.2节Algorithm G和Lemma W,Lemma X,Lemma Y,Lemma Z。\n只能说一个概要吧：\n设一个序列是A[0..n-1]，每次寻找最小的一个满足A[k-1]&lt;=A[k+1]的k，（方便起见设A[-1]和A[n]等于正无穷大）\n那么我们就把A[k]与A[k-1]合并，之后找最大的一个满足A[j]&gt;A[k]+A[k-1]的j,把合并后的值A[k]+A[k-1]插入A[j]的后面。\n有定理保证，如此操作后问题的答案不会改变。\n举个例子：\n186 64 35 32 103\n因为35&lt;103，所以最小的k是3，我们先把35和32删除，得到他们的和67，并向前寻找一个第一个超过67的数，把67插入到他后面\n186 64（k=3,A[3]与A[2]都被删除了） 103\n186 67（遇到了从右向左第一个比67大的数，我们把67插入到他后面） 64 103\n186 67 64 103 （有定理保证这个序列的答案加上67就等于原序列的答案）\n现在由5个数变为4个数了，继续！\n186 （k=2,67和64被删除了）103\n186 131（就插入在这里） 103\n186 131 103\n现在k=2（别忘了，设A[-1]和A[n]等于正无穷大）\n234 186\n420\n最后的答案呢？就是各次合并的重量之和呗。420+234+131+67=852，哈哈，算对了。\n\n证明嘛，基本思想是通过树的最优性得到一个节点间深度的约束，之后\n证明操作一次之后的解可以和原来的解一一对应，并保证节点移动之后他所在的\n深度不会改变。详见TAOCP。\n\n具体实现这个算法需要一点技巧，精髓在于不停快速寻找最小的k，即维护一个“2-递减序列”\n朴素的实现的时间复杂度是O(n*n)，但可以用一个平衡树来优化（好熟悉的优化方法），使得最终复杂度为O(nlogn)\n\n\n解题思路:（这是我找到的一个关于GarsiaWachs算法的解释）\n\n      1. 这类题目一开始想到是DP, 设dp[i][j]表示第i堆石子到第j堆石子合并最小得分.\n\n         状态方程: dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);\n\n         sum[i]表示第1到第i堆石子总和. 递归记忆化搜索即可.\n\n      2. 不过此题有些不一样, 1&lt;=n&lt;=50000范围特大, dp[50000][50000]开不到这么大数组.\n\n         问题分析:\n\n         (1). 假设我们只对3堆石子a,b,c进行比较, 先合并哪2堆, 使得得分最小.\n\n              score1 = (a+b) + ( (a+b)+c )\n\n              score2 = (b+c) + ( (b+c)+a )\n\n              再次加上score1 &lt;= score2, 化简得: a &lt;= c, 可以得出只要a和c的关系确定,\n\n              合并的顺序也确定.\n\n         (2). GarsiaWachs算法, 就是基于(1)的结论实现.找出序列中满足stone[i-1] &lt;=\n\n              stone[i+1]最小的i, 合并temp = stone[i]+stone[i-1], 接着往前面找是否\n\n              有满足stone[j] &gt; temp, 把temp值插入stone[j]的后面(数组的右边). 循环\n\n              这个过程一直到只剩下一堆石子结束.\n\n        (3). 为什么要将temp插入stone[j]的后面, 可以理解为(1)的情况\n\n             从stone[j+1]到stone[i-2]看成一个整体 stone[mid],现在stone[j],\n\n             stone[mid], temp(stone[i-1]+stone[i-1]), 情况因为temp &lt; stone[j],\n\n             因此不管怎样都是stone[mid]和temp先合并, 所以讲temp值插入stone[j]\n\n             的后面是不影响结果.</code></pre><p>代码实现:</p>\n<pre><code>///186 64 35 32 103\n///GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn)\n/*\n设序列是stone[]，从左往右，找一个满足\nstone[k-1] &lt;= stone[k+1]的k，找到后合\n并stone[k]和stone[k-1]，再从当前位置\n开始向左找最大的j，使其满足\nstone[j] &gt; stone[k]+stone[k-1]，\n插到j的后面就行。一直重复，直到只剩下\n一堆石子就可以了。在这个过程中，可以假设\nstone[-1]和stone[n]是正无穷的。\n*/\n\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=50005;\n\nint stone[maxn];\nint N,ans,T;\n///186 64 35 32 103\nvoid combine(int k){\n    int tmp=stone[k]+stone[k-1];\n    ans+=tmp;\n    for(int i=k;i&lt;T-1;++i)\n        stone[i]=stone[i+1];\n    T--;\n    int j=0;\n    for(j=k-1;j&gt;0&amp;&amp;stone[j-1]&lt;tmp;--j)\n        stone[j]=stone[j-1];\n    stone[j]=tmp;\n    while(j&gt;=2&amp;&amp;stone[j]&gt;=stone[j-2]){\n        int d=T-j;\n        combine(j-1);\n        j=T-d;\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=0;i&lt;N;++i) scanf(&quot;%d&quot;,&amp;stone[i]);\n        T=1;\n        ans=0;\n        for(int i=1;i&lt;N;++i){\n            stone[T++]=stone[i];\n            while(T&gt;=3&amp;&amp;stone[T-3]&lt;=stone[T-1]){\n                combine(T-2);\n            }\n        }\n        while(T&gt;1)combine(T-1);\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}\n///186 64 35 32 103</code></pre>","text":"类型: 石子合并问题 算法: GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn),也可以用动态规划,等等学一下再补充. GarsiaWachs算法(摘自别人的blog):具体的算法及证明可以参见《The Art of Comput","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"GarsiaWachs","slug":"ccf/GarsiaWachs","count":1,"path":"api/categories/ccf/GarsiaWachs.json"},{"name":"POJ","slug":"ccf/GarsiaWachs/POJ","count":1,"path":"api/categories/ccf/GarsiaWachs/POJ.json"}],"tags":[{"name":"GarsiaWachs","slug":"GarsiaWachs","count":1,"path":"api/tags/GarsiaWachs.json"}]},{"title":"Python 爬取中国大学排名","slug":"python-chut","date":"2017-08-30T10:19:46.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/python-chut.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/08/17f778160b1fc4d8d2521e6846de2cbe.png","content":"<p>首先是爬取的目的地址: :zap:<a href=\"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html\" title=\"2016中国最好大学排名\" target=\"_blank\" rel=\"noopener\">=&gt;2016中国最好大学排名</a> 这里我们使用的是Python的request库和BeautifulSoup库,IDE用的是Anaconda的Spyder,Python version=3.6. 首先我们现在html中搜索清华大学(废话= =). 结果如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/17f778160b1fc4d8d2521e6846de2cbe.png\" alt=\"结果\"> 我们发现结果是在节点为’tbody’中,全部代码中也只有这一个地方有’tbody’.所以我们可以通过查找这个标签,然后再向下查找孩子来找到结果,但是我们知道,他的孩子可能会出现字符串类型,所以我们需要用isinstance(x,bs4.element.Tag),Tag–(标签)来过滤掉其它类型. 于是我们写出A程序:</p>\n<pre><code>#CrawUnivRankingA.py\nimport requests\nfrom bs4 import BeautifulSoup\nimport bs4\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef fillUnivList(ulist, html):\n    soup = BeautifulSoup(html, &quot;html.parser&quot;)\n    for tr in soup.find(&apos;tbody&apos;).children:\n        if isinstance(tr, bs4.element.Tag):\n            tds = tr(&apos;td&apos;)\n            ulist.append([tds[0].string, tds[1].string, tds[3].string])\n\ndef printUnivList(ulist, num):\n    print(&quot;{:^10}\\t{:^6}\\t{:^10}&quot;.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;))\n    for i in range(num):\n        u=ulist[i]\n        print(&quot;{:^10}\\t{:^6}\\t{:^10}&quot;.format(u[0],u[1],u[2]))\n\ndef main():\n    uinfo = []\n    url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos;\n    html = getHTMLText(url)\n    fillUnivList(uinfo, html)\n    printUnivList(uinfo, 20) # 20 univs\nmain()</code></pre><p>打印结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/807addc82e8f147efd10ff14afadcc03.png\" alt> 可以看出中间的学校缩进不规范,这是因为中文的问题,他是默认按照英文补充空格的. 改进一下,空格用chr(12288)补充:</p>\n<pre><code>#CrawUnivRankingB.py\nimport requests\nfrom bs4 import BeautifulSoup\nimport bs4\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef fillUnivList(ulist, html):\n    soup = BeautifulSoup(html, &quot;html.parser&quot;)\n    for tr in soup.find(&apos;tbody&apos;).children:\n        if isinstance(tr, bs4.element.Tag):\n            tds = tr(&apos;td&apos;)\n            ulist.append([tds[0].string, tds[1].string, tds[3].string])\n\ndef printUnivList(ulist, num):\n    tplt = &quot;{0:^10}\\t{1:{3}^10}\\t{2:^10}&quot;\n    print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;,chr(12288)))\n    for i in range(num):\n        u=ulist[i]\n        print(tplt.format(u[0],u[1],u[2],chr(12288)))\n\ndef main():\n    uinfo = []\n    url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos;\n    html = getHTMLText(url)\n    fillUnivList(uinfo, html)\n    printUnivList(uinfo, 20) # 20 univs\nmain()</code></pre><p>打印结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/a8ee56c437ee19d41e7e53a863779b97.png\" alt> 结束.</p>\n","text":"首先是爬取的目的地址: :zap:=&gt;2016中国最好大学排名 这里我们使用的是Python的request库和BeautifulSoup库,IDE用的是Anaconda的Spyder,Python version=3.6. 首先我们现在html中搜索清华大学(废话= =)","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"爬虫","slug":"Python/爬虫","count":2,"path":"api/categories/Python/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"Python 爬虫 BeautifulSoup库基本操作","slug":"python-beautifulsoup","date":"2017-08-30T03:53:22.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/python-beautifulsoup.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Code:</p>\n<pre><code>import requests\nr=requests.get(&apos;http://python123.io/ws/demo.html&apos;)\n#print(r.text)\ndemo=r.text\nfrom bs4 import BeautifulSoup#后面的是类\nsoup=BeautifulSoup(demo,&apos;html.parser&apos;)#第一个参宿是信息,解释器html.parse\n#print(soup.prettify())\n1#BeautifulSoup库是解析、遍历、维护、&quot;标签树&quot;的功能库.\n#名称 Name 属性 Attributes\n#四种解释器\n&apos;&apos;&apos;\n1.html.parse\n2.lxml\n3.xml\n4.html5lib\n&apos;&apos;&apos;\n#元素\n&apos;&apos;&apos;\n1.Tag 标签&lt;&gt;\n2.Name 标签的名字&lt;p&gt;=p\n3.Attributes 标签的属性 字典形式组织,格式 &lt;tag&gt;.Attributes\n4.NavigableString 标签内费属性字符串 &lt;p&gt;...(中间这部分)...&lt;/p&gt;格式&lt;tag&gt;.string\n5.Comment 标签内字符串注释部分 一种特殊的Commnet类型\n&apos;&apos;&apos;\nprint(soup.title)\nprint(soup.a.name)\nprint(soup.a.parent.parent.name)#父亲的父亲\nprint(soup.a.attrs)\nprint(soup.a.attrs[&apos;class&apos;],type(soup.a.attrs))\nprint(soup.a.string),print(soup.p.string)\n&apos;&apos;&apos;\n标签树的下行遍历\n.contents 子节点的列表,将&lt;tag&gt;所有儿子节点存入列表\n.children 子节点的迭代类型,与.contents类似,用于循环遍历儿子节点\n.descendants 子孙节点的迭代类型,包含所有子孙节点,用于循环遍历\n&apos;&apos;&apos;\nprint(soup.head)\nprint(soup.head.contents)\nprint(soup.body.contents,&apos;\\n&apos;),print(&apos;len: &apos;,len(soup.body.contents))\n&apos;&apos;&apos;\n上行遍历\n.parent 节点的父亲标签\n.parents 返回节点的先辈标签\n&apos;&apos;&apos;\nfor parent in soup.a.parents:\n    if parent is None:\n        print(parent)\n    else:\n        print(parent.name)\n&apos;&apos;&apos;\n平行遍历\n.next_sibling 返回按照HTML文本顺序的下一个平行节点标签\n.previous_sibling 返回按照HTML文本顺序的上一个平行节点标签\n.next_siblings 迭代类型,返回按照HTML文本顺序的后续所有平行节点标签\n.previous_siblings 迭代类型,返回按照HTML文本顺序的前序所有平行结点标签\n&apos;&apos;&apos;</code></pre>","text":"Code:import requestsr=requests.get(&apos;http://python123.io/ws/demo.html&apos;)#print(r.text)demo=r.textfrom bs4 import BeautifulSoup#后面的是类","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"C# Fluent Interface","slug":"c-fluent-interface","date":"2017-08-29T01:46:17.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/c-fluent-interface.json","excerpt":"","keywords":null,"cover":null,"content":"<p>因为每个Enumerable所包含的LINQ拓展方法,都返回了IEnumerable,这也就代表可以使用串接的方式调用多个LINQ函数,然后实现多条件筛选. 例:</p>\n<pre><code>var query=list.Where(c=&gt; c&lt;10000).Where(c=&gt;c&gt;1000);</code></pre><p>或是提取需要的数据结构:</p>\n<pre><code>var query=list.Where(c=&gt;c&lt;10000).Select(c=&gt;new {id=c});</code></pre>","text":"因为每个Enumerable所包含的LINQ拓展方法,都返回了IEnumerable,这也就代表可以使用串接的方式调用多个LINQ函数,然后实现多条件筛选. 例:var query=list.Where(c=&gt; c&lt;10000).Where(c=&gt;c&gt;10","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"2017 Multi-University Training Contest - Team 9  1008","slug":"2017-multi-university-training-contest-team-9-1008","date":"2017-08-22T11:37:20.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/2017-multi-university-training-contest-team-9-1008.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6168\" title=\"HDU-6168 Numbers\" target=\"_blank\" rel=\"noopener\">HDU-6168 Numbers</a> github Code Link: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008.cpp\" title=\"1008.cpp\" target=\"_blank\" rel=\"noopener\">1008.cpp</a> Test Code: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008test.cpp\" title=\"1008test.cpp\" target=\"_blank\" rel=\"noopener\">1008test.cpp</a> 题解: 用map记录下每个数字出现的次数.然后对b进行排序,首先可以知道,排序后的数组,前两个数一定是a序列的前两个数.然后从这两个数开始拓展,a1+a2必在b中,所以在map中找到a1+a2的数量然后-1,之后把接下来的第一个数Push到a数组中,并且删除一个a1+a3和a2+a3,依次递推.知道a.size()到达sqrt(m/2)或者i&gt;=m为止,结束循环. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=200000;\n\nint c[maxn];\nint m,n;\nmap&lt;int,int&gt; d;\nvector&lt;int&gt; a;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;m)){\n        d.clear();a.clear();\n        n=sqrt(m&lt;&lt;1);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            d[c[i]]++;\n        }\n        sort(c,c+m);\n        a.push_back(c[0]);a.push_back(c[1]);\n        d[c[1]]--;d[c[0]]--;\n        for(int i=1;i&lt;m &amp;&amp; a.size()&lt;n;++i){\n            int si=a.size()-1;\n            for(int j=0;j&lt;si;++j){\n                if(d.find(a[si]+a[j])!=d.end() &amp;&amp; d[a[si]+a[j]]&gt;0){\n                    d[a[si]+a[j]]--;\n         //           printf(&quot;IDone %d\\n&quot;,a[si-1]+a[j]);\n                }\n            }\n            while(d[c[i]]==0){\n                int no=c[i];\n                while(c[i]==no){\n                    ++i;\n                    if(i&gt;=m)break;\n                }\n                if(i&gt;=m)break;\n    //            printf(&quot;Done %d\\n&quot;,c[i]);\n            }\n            if(i&lt;m){\n                a.push_back(c[i]);\n         //       printf(&quot;Push %d\\n&quot;,c[i]);\n                d[c[i]]--;\n            }\n            --i;\n        }\n        printf(&quot;%d\\n&quot;,a.size());\n        printf(&quot;%d&quot;,a[0]);\n        for(int i=1;i&lt;a.size();++i){\n            printf(&quot; %d&quot;,a[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>Test Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint t[5]={3,7,6,9,10};\nvector&lt;int&gt; ans;\nint main(){\n     freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n     freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n     for(int i=0;i&lt;5;++i) ans.push_back(t[i]);\n     for(int i=0;i&lt;5;++i){\n        for(int j=i+1;j&lt;5;++j){\n            ans.push_back(t[i]+t[j]);\n        }\n     }\n     printf(&quot;%d\\n&quot;,ans.size());\n     for(int i=0;i&lt;ans.size();++i) printf(&quot;%d &quot;,ans[i]);\n    return 0;\n}</code></pre>","text":"类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:HDU-6168 Numbers github Code Link: :earth_asia:1008.cpp Test Code: :earth_asia:1008","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]},{"title":"CSU 1803","slug":"csu-1803","date":"2017-08-20T07:41:04.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/csu-1803.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 容斥,唯一分解定理 题目连接: :earth_americas:<a href=\"https://vjudge.net/problem/CSU-1803\" title=\"CSU-1803\" target=\"_blank\" rel=\"noopener\">CSU-1803</a> 题解: 由素分可以得到</p>\n<pre><code>2016=2*2*2*2*2*3*3*7 所以我们可以判断出 a 中有多少2016的因子,然后算出b中与a至少互补的因子个数,利用容斥原理计算出最后的结果.</code></pre><p>github: :moon:<a href=\"https://github.com/834930269/Other_OJ/blob/master/CSU/%E5%AE%B9%E6%96%A5/1803.cpp\" title=\"1803.cpp\" target=\"_blank\" rel=\"noopener\">1803.cpp</a> Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long LL;\nLL arr[10][10][10];\nLL a,b;\nint main(){\n    ///2016=2*2*2*2*2*3*3*7\n\n    while(~scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b)){\n        memset(arr,0,sizeof(arr));\n        for(int i=0;i&lt;6;++i)\n            for(int j=0;j&lt;3;++j)\n                for(int t=0;t&lt;2;++t)\n                    arr[i][j][t]=a/(int)(pow(2,i)*pow(3,j)*pow(7,t));\n        LL ans=0;\n        for(int i=0;i&lt;6;++i)\n            for(int j=0;j&lt;3;++j)\n                for(int t=0;t&lt;2;++t)\n                    ans+=(arr[i][j][t]-arr[i+1][j][t]-arr[i][j+1][t]-arr[i][j][t+1]+arr[i+1][j+1][t]+arr[i+1][j][t+1]+arr[i][j+1][t+1]-arr[i+1][j+1][t+1])*(b/(int)(pow(2,5-i)*pow(3,2-j)*pow(7,1-t)));\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"类型: 容斥,唯一分解定理 题目连接: :earth_americas:CSU-1803 题解: 由素分可以得到2016=2*2*2*2*2*3*3*7 所以我们可以判断出 a 中有多少2016的因子,然后算出b中与a至少互补的因子个数,利用容斥原理计算出最后的结果.github","link":"","raw":null,"photos":[],"categories":[{"name":"CSU","slug":"CSU","count":1,"path":"api/categories/CSU.json"},{"name":"唯一分解定理","slug":"CSU/唯一分解定理","count":1,"path":"api/categories/CSU/唯一分解定理.json"},{"name":"容斥原理","slug":"CSU/唯一分解定理/容斥原理","count":1,"path":"api/categories/CSU/唯一分解定理/容斥原理.json"}],"tags":[{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"},{"name":"CSU","slug":"CSU","count":1,"path":"api/tags/CSU.json"},{"name":"唯一分解定理","slug":"唯一分解定理","count":1,"path":"api/tags/唯一分解定理.json"}]},{"title":"ccf 2017前四题","slug":"ccf-2017-pre-f","date":"2017-08-19T05:25:33.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2017-pre-f.json","excerpt":"","keywords":null,"cover":null,"content":"<p>第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *<em>要登录和会员 *</em> <a href=\"http://118.190.20.162/home.page\" target=\"_blank\" rel=\"noopener\">http://118.190.20.162/home.page</a> github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/tree/master/CCSP/2017-3\" title=\"CCF 2017-3 前四题\" target=\"_blank\" rel=\"noopener\">CCF 2017-3 前四题</a> 第一题:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    int N,K;\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;K)){\n        int ans=0,d,n=0;\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;d);\n            n+=d;\n            if(n&gt;=K){\n                n=0;\n                ans++;\n            }\n        }\n        if(n)ans++;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>第二题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint N,M;\nint I,J;\n\nlist&lt;int&gt; li;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        li.clear();\n        for(int i=1;i&lt;=N;++i){\n            li.push_back(i);\n        }\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%d%d&quot;,&amp;I,&amp;J);\n            if(J==0)continue;\n            list&lt;int&gt;::iterator it,it2;\n            for(it=li.begin();*it!=I;it++){}\n            it2=it;\n            int flag=J&gt;0?1:-1;\n            J=abs(J)+(flag&gt;0?1:0);\n            while(J){\n                J--;\n                flag&gt;0?it++:it--;\n            }\n            li.insert(it,I);\n            li.erase(it2);\n        }\n        list&lt;int&gt;::iterator it;\n        it=li.begin();\n        printf(&quot;%d&quot;,*it);\n        it++;\n        for(;it!=li.end();it++){\n            printf(&quot; %d&quot;,*it);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>第三题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define BUF_SS 101\n\nusing namespace std;\n\nchar buf[101];\nint pre=-1;\n\nint check_hl(int st){\n    char hr[100];\n    string tip;\n    int ind=st+1,cs=0,hs=0;\n    while(buf[ind]!=&apos;]&apos;){\n        if(buf[ind]==&apos;_&apos;){\n            tip+=&quot;&lt;em&gt;&quot;;\n            ind++;\n            while(buf[ind]!=&apos;_&apos;){\n                tip+=buf[ind];\n                ind++;\n            }\n            tip+=&quot;&lt;/em&gt;&quot;;\n            ind++;\n        }else{\n            tip+=buf[ind];\n            ind++;\n        }\n    }\n    ind+=2;\n    while(buf[ind]!=&apos;)&apos;){\n        hr[hs++]=buf[ind];\n        ind++;\n    }\n    hr[hs]=&apos;\\0&apos;;\n    printf(&quot;&lt;a href=\\&quot;%s\\&quot;&gt;&quot;,hr);\n    cout&lt;&lt;tip&lt;&lt;&quot;&lt;/a&gt;&quot;;\n    return ind-st;\n}\n\nint check_em(int st){\n    int ind=st+1;\n    printf(&quot;&lt;em&gt;&quot;);\n    while(buf[ind]!=&apos;_&apos;){\n        if(buf[ind]==&apos;[&apos;){\n            int ed=check_hl(ind);\n            ind+=(ed+1);\n        }else{\n            putchar(buf[ind]);\n            ind++;\n        }\n    }\n    printf(&quot;&lt;/em&gt;&quot;);\n    return ind-st;\n}\n\nvoid check_h(int sz){\n    int n,r=0;\n    char sts[20],ste[20];\n    while(buf[r]==&apos;#&apos;){\n        r++;\n    }\n    int s=r,e=sz-1;\n    sprintf(sts,&quot;&lt;h%d&gt;&quot;,r);\n    sprintf(ste,&quot;&lt;/h%d&gt;&quot;,r);\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;%s&quot;,sts);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;%s\\n&quot;,ste);\n}\n\nvoid check_u(int sz){\n    if(pre!=2)printf(&quot;&lt;ul&gt;\\n&quot;);\n    int s=1,e=sz-1;\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;&lt;li&gt;&quot;);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;&lt;/li&gt;\\n&quot;);\n}\n\nvoid check_p(int sz){\n    if(pre!=3)printf(&quot;&lt;p&gt;&quot;);\n    if(pre==3)putchar(&apos;\\n&apos;);\n    for(int i=0;buf[i]!=&apos;\\n&apos; &amp;&amp; i&lt;sz;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n}\n\nint main(){\n    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n    while(fgets(buf,BUF_SS,stdin)){\n        if(buf[0]==&apos;\\n&apos;){\n            if(pre==3){\n                printf(&quot;&lt;/p&gt;\\n&quot;);\n                pre=0;continue;\n            }else if(pre==2){\n                printf(&quot;&lt;/ul&gt;\\n&quot;);\n                pre=0;continue;\n            }\n            continue;\n        }\n        int sz=strlen(buf);\n        if(buf[0]==&apos;#&apos;) check_h(sz),pre=1;\n        else if(buf[0]==&apos;*&apos;) check_u(sz),pre=2;\n        else check_p(sz),pre=3;\n    }\n    if(pre==3)printf(&quot;&lt;/p&gt;\\n&quot;);\n    if(pre==2)printf(&quot;&lt;/ul&gt;\\n&quot;);\n    return 0;\n}</code></pre><p>写题的时候写了一组测试数据: In[1]:</p>\n<pre><code># Heading\n\n## Sub-heading\n\nParagraphs are separated\nby a blank line.\n\nText attributes _italic_.\n\nBullet list:\n\n*      apples\n* oranges\n* pears\n\nA _[NLJ6link616lins1](http://example.com)_.\n\n[NLJ6_link_616_lins_1](http://example.com)</code></pre><p>out[1]:</p>\n<pre><code>&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;h2&gt;Sub-heading&lt;/h2&gt;\n&lt;p&gt;Paragraphs are separated\nby a blank line.&lt;/p&gt;\n&lt;p&gt;Text attributes &lt;em&gt;italic&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Bullet list:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;apples&lt;/li&gt;\n&lt;li&gt;oranges&lt;/li&gt;\n&lt;li&gt;pears&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A &lt;em&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6link616lins1&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6&lt;em&gt;link&lt;/em&gt;616&lt;em&gt;lins&lt;/em&gt;1&lt;/a&gt;&lt;/p&gt;</code></pre><p>第四题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAX_M=200000+10;\nconst int maxn=200000+10;\nint N,M;\nint A,B,C;\n\nstruct Edge{\n    int from,to,dist;\n};\nstruct HeapNode{\n    int d,from,to;\n    bool operator&lt;(const HeapNode&amp; rhs)const{\n        return d&gt;rhs.d;\n    }\n};\n\nstruct Kruskal{\n    int n,m;///点数和边数\n    vector&lt;Edge&gt; edges;///边表\n    vector&lt;int&gt; G[maxn];///每个节点出发的边编号\n    priority_queue&lt;HeapNode&gt; Q;\n\n    ///并查集\n    int fa[maxn];///父亲\n    int ra[maxn];///高度\n    ///init:初始化(点数)\n    ///find_Root:查找树的根\n    ///unite:合并x和y所属集合\n    ///same:判断x和y是否是同一个集合\n    void init(int n){\n        this-&gt;n=n;\n        for(int i=0;i&lt;n;++i){\n            fa[i]=i;\n            ra[i]=0;\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    int find_Root(int x){\n        if(fa[x]==x){\n            return x;\n        }else{\n            return fa[x]=find_Root(fa[x]);\n        }\n    }\n    void unite(int x,int y){\n        x=find_Root(x);\n        y=find_Root(y);\n        if(x==y) return;\n\n        if(ra[x]&lt;ra[y]){\n            fa[x]=y;\n        }else{\n            fa[y]=x;\n        }\n    }\n    bool same(int x,int y){\n        return find_Root(x)==find_Root(y);\n    }\n\n    void AddEdge(int from,int to,int dist){\n        edges.push_back((Edge){from,to,dist});\n        m=edges.size()-1;\n        G[from].push_back(m-1);\n        Q.push((HeapNode){dist,from,to});\n    }\n\n    int kruskal(){\n        HeapNode h;\n        while(!Q.empty()){\n            if(find_Root(N)==find_Root(1))break;\n            h=Q.top();Q.pop();\n            if(find_Root(h.from)==find_Root(h.to))continue;\n            unite(h.from,h.to);\n        }\n        printf(&quot;%d\\n&quot;,h. d);\n    }\n}K;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        K.init(N);\n        for(int i=0;i&lt;M;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);\n            K.AddEdge(A,B,C);\n        }\n        K.kruskal();\n    }\n    return 0;\n}</code></pre>","text":"第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *要登录和会员 * http://118.190.20.162/home.page git","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"kruskal","slug":"ccf/kruskal","count":1,"path":"api/categories/ccf/kruskal.json"},{"name":"并查集","slug":"ccf/kruskal/并查集","count":1,"path":"api/categories/ccf/kruskal/并查集.json"},{"name":"模拟","slug":"ccf/kruskal/并查集/模拟","count":1,"path":"api/categories/ccf/kruskal/并查集/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"},{"name":"CCF","slug":"CCF","count":1,"path":"api/tags/CCF.json"}]}]}