{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"UVa 1635","slug":"uva-1635","date":"2017-01-10T11:13:32.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1635.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 <a href=\"https://vjudge.net/problem/UVA-1635\" target=\"_blank\" rel=\"noopener\">UVa-1635-Irrelevant Elements</a> 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)<em>(n-k+1)/k. 即 C[i]=C[i-1]</em>(n-i+1)/i. 注意,应该先乘再除,因为C[i-1]/i可能不是整数.但结果一定是整数.而且,因为二项式是递归乘法,所以有时可能会溢出long long,这题就是个例子. 【思路】 因为C(n,i)可能会爆long long,所以先对m做唯一分解，分解成若干素数,并记录每个素数的指数.然后以此计算m的唯一分解式中哥哥素因子在C(n-1,i-1)中的指数即可完成判断.这些指数依然可以用上面那个递推式递推,并且不会涉及高精度. 【参考】 <a href=\"http://blog.csdn.net/u014800748/article/details/43927205\" target=\"_blank\" rel=\"noopener\">Hengjie Yang</a> 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cmath></cmath></p>\n<p>#include<cstring><br>using namespace std;<br>typedef long long LL;<br>LL C[100005];<br>int prime[101][2];<br>int fac_c[100];<br>int N,M;</cstring></p>\n<p>int initM(int m){<br>    int primenum=0;<br>    for(int i=2;i&lt;=sqrt(m);++i){<br>        if(m%i==0){<br>            prime[++primenum][0]=i;<br>            prime[primenum][1]=0;<br>            while(m%i==0){<br>                prime[primenum][1]++;<br>                m/=i;<br>            }<br>        }<br>    }<br>    if(m&gt;1){<br>        prime[++primenum][0]=m;<br>        prime[primenum][1]=1;<br>    }<br>    return primenum;<br>}</p>\n<p>bool check(int m,int k,int primenum){<br>    int a=m-k;<br>    int b=k;<br>    for(int i=1;i&lt;=primenum;++i){<br>        for(;a%prime[i][0]==0;a/=prime[i][0],fac_c[i]++);<br>        for(;b%prime[i][0]==0;b/=prime[i][0],fac_c[i]–);<br>    }<br>    for(int i=1;i&lt;=primenum;++i)<br>        if(prime[i][1]&gt;fac_c[i])<br>        return false;<br>    return true;<br>}</p>\n<p>int main(){<br>    while(cin&gt;&gt;N&gt;&gt;M){<br>        int primenum=initM(M);//唯一分解M,防止爆LL<br>        memset(fac_c,0,sizeof(fac_c));<br>        int cnt=0;//无关数个数<br>        for(int i=1;i&lt;N;++i){<br>            //0~(n-1),这个是组合数C(m,n)的n.  m=n-1 index=i+1<br>            if(check(N,i,primenum))<br>                C[cnt++]=i+1;<br>        }<br>        printf(“%d\\n”,cnt);<br>        for(int i=0;i&lt;cnt;++i)<br>            printf(i==(cnt-1)?”%d\\n”:”%d “,C[i]);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 UVa-1635-Irrelevant Elements 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)(n-k+1)/k. 即 C[i]=C[i-1](n-i+1","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"二项式定理","slug":"UVa/二项式定理","count":1,"path":"api/categories/UVa/二项式定理.json"},{"name":"唯一分解定理","slug":"UVa/二项式定理/唯一分解定理","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理.json"},{"name":"数论","slug":"UVa/二项式定理/唯一分解定理/数论","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论.json"},{"name":"组合数学","slug":"UVa/二项式定理/唯一分解定理/数论/组合数学","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10791","slug":"uva-10791","date":"2017-01-09T05:11:28.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10791.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10791\" target=\"_blank\" rel=\"noopener\">UVa-10791-Minimum Sum LCM</a> 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因子(一定是素数)加到最后的结果中. 其过程等同于素数筛法,先筛2^a1,再筛3^a2 …其筛出的ai不为0的因子的底数一定是素数.因为  *唯一分解定理:一个数可以分解为若干素数的幂相乘的形式. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath><br>using namespace std;<br>typedef long long LL;</cmath></p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    LL N;<br>    int lam=1;<br>    while(cin&gt;&gt;N){<br>        if(N&lt;=0)break;<br>        LL sum=0,cnt=0;<br>        for(int i=2;i&lt;=sqrt(N);++i){<br>            if(N%i==0){<br>                LL mut=1;<br>                cnt++;<br>                while(N%i==0){<br>                    N/=i;<br>                    mut*=i;<br>                }<br>                sum+=mut;<br>            }<br>        }<br>        if(N&gt;1 || cnt==0){<br>            //这里的N是计算以后偶剩下的N,这个N一定是一个素数,直接加即可<br>            sum+=N;<br>            cnt++;<br>        }<br>        if(cnt==1) sum++;<br>       printf(“Case %d: %lld\\n”,lam++,sum);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 UVa-10791-Minimum Sum LCM 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10375","slug":"uva-10375","date":"2017-01-08T14:19:03.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10375.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,素数筛法 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10375\" target=\"_blank\" rel=\"noopener\">UVa-10375-Choose and divide</a> 【唯一分解定理】 任何一个大于1的自然数<em>N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N</em>=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为素数，其中指数ai是正整数。这样的分解称为<em>N</em>的标准分解式. 【思路】 根据题意得: 给定p q r s 求 ①.(p!<em>s!</em>(r-s)!)/(r!<em>q!</em>(p-q)!) 暴力会炸,至于为啥.</p>\n<p>10000! 总位数：35660位,要不要试试？</p>\n<p>1.先筛10000以内的素数. 2.数组e表示当前结果的唯一分解式中各个素数的指数,prime数组第i位的指数是多少.如:e={1，0，2，0，0，0 …}表示pow(2,1)*pow(5,2)=50 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath></cmath></p>\n<p>#define MAXN 10000<br>using namespace std;</p>\n<p>int prime[MAXN];<br>bool is_prime[MAXN];<br>int primesize=0,p,q,r,s;</p>\n<p>int e[MAXN];</p>\n<p>void sieve(){<br>    memset(is_prime,1,sizeof(is_prime));<br>    is_prime[1]=is_prime[0]=false;<br>    for(int i=0;i&lt;MAXN;++i){<br>        if(is_prime[i]){<br>            prime[primesize++]=i;<br>            for(int j=i*2;j&lt;MAXN;j+=i)<br>                is_prime[j]=false;<br>        }<br>    }<br>}</p>\n<p>//乘以或除以n,d=1表示乘,d=-1表示除<br>void add_integer(int n,int d){<br>    for(int i=0;i&lt;primesize;++i){<br>        while(n%prime[i]==0){//必须是while<br>            n/=prime[i];<br>            e[i]+=d;<br>        }<br>        if(n==1)break;//提前终止循环,节约时间<br>    }<br>}</p>\n<p>void add_factorial(int n,int d){<br>    for(int i=1;i&lt;=n;++i)<br>        add_integer(i,d);<br>}</p>\n<p>int main(){<br>    sieve();<br>    while(cin&gt;&gt;p&gt;&gt;q&gt;&gt;r&gt;&gt;s){<br>        memset(e,0,sizeof(e));<br>        //以下一串表示上面的公式①的分子和分母.<br>        add_factorial(p,1);<br>        add_factorial(s,1);<br>        add_factorial(r-s,1);<br>        add_factorial(q,-1);<br>        add_factorial(r,-1);<br>        add_factorial(p-q,-1);<br>        double ans=1;<br>        for(int i=0;i&lt;primesize;++i)<br>            ans*=pow(prime[i],e[i]);<br>        printf(“%.5lf\\n”,ans);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,素数筛法 【题目来源】 UVa-10375-Choose and divide 【唯一分解定理】 任何一个大于1的自然数N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"POJ 3356 AGTC","slug":"poj-3356-agtc","date":"2017-01-07T09:16:52.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-3356-agtc.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 动态规划:编辑距离 【题目来源】 <a href=\"http://poj.org/problem?id=3356\" target=\"_blank\" rel=\"noopener\">POJ-3356-AGTC</a> 【思路来源】 <a href=\"http://www.cnblogs.com/dongsheng/archive/2013/05/27/3102498.html\" target=\"_blank\" rel=\"noopener\">可笑痴狂</a> 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==A[i]，这样做的话， 至少需要 dp[i - 1][j] + 1步操作，即 dp[i][j] = dp[i - 1][j] + 1。 ②、我们可以删除 B[j]，这样的话，B[1…j] 变为A[1…i] 需要 dp[i][j - 1]步， 即 dp[i][j] = dp[i][j - 1] + 1。 ③、我们也可以考虑修改 B[j]，使它变为A[j]，但是如果 B[j]本来就等于 A[i]的话， 那修改其实相当于用了 0步，如果 B[j] != A[i] 的话，那修改相当于用了 1步。 所以 dp[i][j] = dp[i - 1][j - 1] + （A[i] == B[j] ? 0, 1）。 决策： 决策就很简单了，从上面三种状态转移中选择一个最小值就可以了。 处理边界： 处理好边界非常重要，这里需要注意的是对dp[0][0….m],dp[0…..n][0]的初始化， 可以这样看，dp[0][i],就是说A[1…n]是一个空串，而B[1…m]十个长度为i的串， 很显然B串变为A串就是删除i个核苷酸。 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<string></string></p>\n<p>#include<cstring><br>using namespace std;<br>char s1[1005],s2[1005];<br>int dp[1005][1005];<br>int s1l,s2l;</cstring></p>\n<p>int DP(){<br>        for(int i=0;i&lt;s1l;++i){<br>            for(int j=0;j&lt;s2l;++j){<br>                if(s1[i]==s2[j])<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]);<br>                else<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]+1);<br>            }<br>        }<br>    return dp[s1l][s2l];<br>}</p>\n<p>void init(){<br>    memset(dp,0,sizeof(dp));<br>    int tmp=max(s1l,s2l);<br>    for(int i=1;i&lt;=tmp;++i)<br>        dp[i][0]=dp[0][i]=i;<br>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;s1l&gt;&gt;s1){<br>        cin&gt;&gt;s2l&gt;&gt;s2;<br>        init();<br>        cout&lt;&lt;DP()&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 动态规划:编辑距离 【题目来源】 POJ-3356-AGTC 【思路来源】 可笑痴狂 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"编辑距离","slug":"动态规划/编辑距离","count":1,"path":"api/categories/动态规划/编辑距离.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"编辑距离","slug":"编辑距离","count":1,"path":"api/tags/编辑距离.json"}]},{"title":"NEFU 115","slug":"nefu-115","date":"2016-12-26T10:35:46.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/nefu-115.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 斐波那契+lcm+循环节&lt;-找规律 【题目来源】 <a href=\"http://acm.nefu.edu.cn/JudgeOnline/problemShow.php?problem_id=115\" target=\"_blank\" rel=\"noopener\">NEFU-115-斐波那契的整除</a> 【分析】</p>\n<p>输入数据有若干组，每组数据包含一个整数n（1&lt; n &lt;1000000000）。</p>\n<p>从这句中我们得以看出暴力不是一个好方法,考虑循环节,发现当n%4==0时f(n)能被3整除;n%6==0时,f(n)能被4整除;然后由lcm得出f(n)能被12整除,当且仅当n%12==0(lcm(4,6)). 【验证】 打印发现循环节为 3 4 3 12</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>typedef long long LL;<br>int main(){<br>    LL a,b,c;<br>    a=1,b=1;<br>    for(int i=3;i&lt;=50;++i){<br>        c=a+b,a=b,b=c,cout&lt;&lt;i&lt;&lt;”: “&lt;&lt;c&lt;&lt;” “;<br>        if(c%3==0)cout&lt;&lt;” 3”;<br>        if(c%4==0)cout&lt;&lt;” 4”;<br>        cout&lt;&lt;endl;<br>    }<br>    return 0;<br>}</algorithm></p>\n<p>【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int main(){<br>    int n;<br>    while(cin&gt;&gt;n){<br>        if(!(n%12))<br>            cout&lt;&lt;”YES\\n”;<br>        else if(!(n%4))<br>            cout&lt;&lt;”3\\n”;<br>        else if(!(n%6))<br>            cout&lt;&lt;”4\\n”;<br>        else<br>            cout&lt;&lt;”NO\\n”;<br>    }<br>    return 0;<br>}</algorithm></p>\n","text":"【类型】 斐波那契+lcm+循环节&lt;-找规律 【题目来源】 NEFU-115-斐波那契的整除 【分析】输入数据有若干组，每组数据包含一个整数n（1&lt; n &lt;1000000000）。从这句中我们得以看出暴力不是一个好方法,考虑循环节,发现当n%4==0时f(n)能","link":"","raw":null,"photos":[],"categories":[{"name":"NEFU","slug":"NEFU","count":1,"path":"api/categories/NEFU.json"},{"name":"数论","slug":"NEFU/数论","count":1,"path":"api/categories/NEFU/数论.json"},{"name":"算法学习","slug":"NEFU/数论/算法学习","count":1,"path":"api/categories/NEFU/数论/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"nefu","slug":"nefu","count":1,"path":"api/tags/nefu.json"}]},{"title":"HDU 2099","slug":"hdu-2099","date":"2016-12-26T09:54:51.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/hdu-2099.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【暴力水+整除】 因为数据量不大. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int main(){<br>    int a,b;<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>        if(a==0&amp;&amp;b==0)<br>            break;<br>        int flag=0;<br>        for(int i=0;i&lt;=99;++i)<br>        {<br>            if((i+a*100)%b==0)<br>                if(i&lt;10)<br>                    flag==0?flag=1,cout&lt;&lt;”0”&lt;&lt;i:cout&lt;&lt;” 0”&lt;&lt;i;<br>                else<br>                    flag==0?flag=1,cout&lt;&lt;i:cout&lt;&lt;” “&lt;&lt;i;<br>        }<br>        cout&lt;&lt;endl;<br>    }<br>    return 0;<br>}</algorithm></p>\n","text":"【暴力水+整除】 因为数据量不大. 【Code】#include#include<br>using namespace std;<br>int main(){<br>    int a,b;<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>    ","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"算法学习","slug":"HDU/算法学习","count":1,"path":"api/categories/HDU/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"UVa 1025","slug":"uva-1025","date":"2016-12-25T13:49:54.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/uva-1025.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策 2:搭乘往右开的车(如果有)。 决策 3:搭乘往左开的车(如果有)。 【Code】 P268 A Spy in the Metro  </p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;<br>const int inf=0x3f3f3f3f;<br>int N,T,LN,RN,kase=0;<br>bool has_train[205][55][2];<br>int dp[205][55],ti[55];</cstring></p>\n<p>void solve(){</p>\n<pre><code>for(int i=1;i&lt;N;++i) dp\\[T\\]\\[i\\]=inf;\ndp\\[T\\]\\[N\\]=0;\n\nfor(int i=T-1;i&gt;=0;i--)\n    for(int j=1;j&lt;=N;++j){\n        dp\\[i\\]\\[j\\]=dp\\[i+1\\]\\[j\\]+1;//等待一个单位\n        if(j&lt;N&amp;&amp;has_train\\[i\\]\\[j\\]\\[0\\]&amp;&amp;i+ti\\[j\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j\\]\\]\\[j+1\\]);//右\n        if(j&gt;1&amp;&amp;has_train\\[i\\]\\[j\\]\\[1\\]&amp;&amp;i+ti\\[j-1\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j-1\\]\\]\\[j-1\\]);//左\n    }\n\n    cout&lt;&lt;&quot;Case Number &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;;\n    if(dp\\[0\\]\\[1\\]&gt;=inf) cout&lt;&lt;&quot;impossible\\\\n&quot;;\n    else cout&lt;&lt;dp\\[0\\]\\[1\\]&lt;&lt;&quot;\\\\n&quot;;</code></pre><p>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;N&amp;&amp;N){<br>        cin&gt;&gt;T;</p>\n<pre><code>    memset(has\\_train,0,sizeof(has\\_train));\n\n    for(int i=1;i&lt;=N-1;++i)\n        cin&gt;&gt;ti\\[i\\];\n    cin&gt;&gt;LN;//左端点向右开的车\n    for(int i=1;i&lt;=LN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=1;j&lt;=N-1;++j){\n            if(start&lt;=T)has_train\\[start\\]\\[j\\]\\[0\\]=true;//第t秒第j个站点有车\n            start+=ti\\[j\\];\n        }\n    }\n\n    cin&gt;&gt;RN;//右端点向左开的车\n    for(int i=1;i&lt;=RN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=N-1;j&gt;=1;--j){\n               if(start&lt;=T) has_train\\[start\\]\\[j+1\\]\\[1\\]=true;//第t秒第j个站点有车总共N个站台,往回走\n                start+=ti\\[j\\];\n        }\n    }\n    solve();\n\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"},{"name":"算法学习","slug":"UVa/动态规划/算法学习","count":1,"path":"api/categories/UVa/动态规划/算法学习.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"2016/12/25","slug":"20161225","date":"2016-12-25T10:13:56.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/20161225.json","excerpt":"","keywords":null,"cover":null,"content":"<p>人生已经走到这里了,习惯性看着回家的路.向往的生活从“有钱”变成了柴米油盐的欢笑. 离的开的是生活,但是,终归会有一群被这个世界拖累的家人,一边说着,去吧,一边操着两份工作,只为了满足你的虚荣. 不知道今后还能走过多少个春秋冬夏,当然,也不知道他们..我曾想就那样溺于二次元不再出来.我曾想逃避自己的懦弱,为了证明我很强. 谁不是呢,为了那卑微的认同感,为了那虚无缥缈的”存在的意义”. 在一个浮躁的社会,也只有沉溺在某一个东西,还有让更多的人打击你,你才能静下心来.这就是这个世界,浮躁,轻狂,自私,懦弱,染指上这些毒品的后果. 我不想再品尝. 正视与反省,怜悯与同情,不赞同与不反对,同理心与无能为力,自知之明与不妥协放弃,教会我的是书本,思考和我见证过的是我的朋友,阿磊. 习惯性的看着回家的路,却发现,哪怕我在前进,哪怕听着旋律在默默悲愤,仍然在前进,却并没有仔细的观察脚下的路. 无论跑多远,我总是在缘木求鱼,不自觉地在划着曲线前行,无论走多远,目的地只有一个. 家. 妈妈,姥姥姥爷,舅舅舅妈姗姗琨琨,大姨大姨夫姐姐,小姨小姨夫,阿磊,老鳖,李志远,还有初中高中的朋友. 谢谢你们生着我的气却原谅我的脆弱. 圣诞快乐.</p>\n","text":"人生已经走到这里了,习惯性看着回家的路.向往的生活从“有钱”变成了柴米油盐的欢笑. 离的开的是生活,但是,终归会有一群被这个世界拖累的家人,一边说着,去吧,一边操着两份工作,只为了满足你的虚荣. 不知道今后还能走过多少个春秋冬夏,当然,也不知道他们..我曾想就那样溺于二次元不再出","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"51nod DP-矩阵取数问题","slug":"51nod-dp-study","date":"2016-12-24T14:22:05.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/51nod-dp-study.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x – 1, y) , f(x, y – 1) ) + A[x][y] 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<vector><br>using namespace std;<br>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    vector&lt;vector<int> &gt; ve(N+1,vector<int>(N+1,0)),dp(N+1,vector<int>(N+1,0));</int></int></int></vector></p>\n<pre><code>for(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        cin&gt;&gt;ve\\[i\\]\\[j\\];\n\nfor(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        dp\\[i\\]\\[j\\]=max(dp\\[i-1\\]\\[j\\],dp\\[i\\]\\[j-1\\])+ve\\[i\\]\\[j\\];\n\ncout&lt;&lt;dp\\[N\\]\\[N\\]&lt;&lt;endl;\n\nreturn 0;</code></pre><p>}</p>\n","text":"【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"算法学习","slug":"51nod/动态规划/算法学习","count":1,"path":"api/categories/51nod/动态规划/算法学习.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"玲珑杯 R7 D-Pick Up Coin","slug":"linglong-r7-d-pick-up-coin","date":"2016-12-24T13:51:29.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/linglong-r7-d-pick-up-coin.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:</p>\n<p>dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }</p>\n<p>  【Code】(不会,代码搁置,回头看)</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int Q[1010];<br>int dp[1005][1005];<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int n;<br>    cin&gt;&gt;n;<br>    while(n–){<br>        int M;<br>        cin&gt;&gt;M;<br>        for(int i=1;i&lt;=M;++i)<br>            cin&gt;&gt;Q[i];<br>        Q[0]=Q[M+1]=1;<br>        for(int i=0;i&lt;=M+1;++i)<br>            for(int j=0;j&lt;=M+1;++j)<br>                dp[i][j]=0;<br>        for(int len=1;len&lt;=M;++len)<br>                for(int i=1,j=i+len-1;j&lt;=M;++i,++j)<br>                    for(int k=i;k&lt;=j;++k)<br>                        dp[i][j]=max(dp[i][j],dp[i][k-1]+dp[k+1][j]+Q[k]*Q[i-1]*Q[j+1]);</algorithm></p>\n<pre><code>        cout&lt;&lt;dp\\[1\\]\\[M\\]&lt;&lt;endl;\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }  【Code】(不会,代码搁置,回头看)#incl","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]}]}