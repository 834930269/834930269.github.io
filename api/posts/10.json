{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"数据结构补充","slug":"datastruct-add","date":"2018-02-13T13:12:07.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/datastruct-add.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…</p>\n<blockquote>\n<p>注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.</p>\n</blockquote>\n</blockquote>\n<h1 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h1><h2 id=\"要领\"><a href=\"#要领\" class=\"headerlink\" title=\"要领\"></a>要领</h2><blockquote>\n<p>以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.</p>\n<blockquote>\n<p>并查集是不可能分割的,即只能合并,不可分割.</p>\n<blockquote>\n<p>在牛客上听大佬讲课貌似存在可分割并查集,带权并查集.</p>\n</blockquote>\n</blockquote>\n<p>现在拓宽下,并查集常用于判断加入一个点后是否会在原图上形成环. 或者判断有几个连通分量(通常是无向图),然后问你这些节点全部关联起来至少需要添加几条边.</p>\n</blockquote>\n<h2 id=\"实现前奏\"><a href=\"#实现前奏\" class=\"headerlink\" title=\"实现前奏\"></a>实现前奏</h2><blockquote>\n<p>首先是逻辑,并查集实现规则是一个点一个点入图时进行合并,即join,然后在合并时进行find,查找根节点是否相同,不同则将浅的树合并到深的树上,判断深浅通过每次合并时对rank进行操作,然后在一个优化是路径压缩,即如果a节点的最高根节点是c,则直接将a记录为c即可.</p>\n<blockquote>\n<p>以上实现的前提是我们只需要逻辑上正确即可.</p>\n</blockquote>\n</blockquote>\n<h2 id=\"以题为马\"><a href=\"#以题为马\" class=\"headerlink\" title=\"以题为马\"></a>以题为马</h2><blockquote>\n<p>HDU 1232 判断有多少个连通块,然后答案就是ans-1</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nstruct DisjointSet{\n    vector&lt;int&gt; father,rank;\n    int Num;\n    DisjointSet(int n):father(n),rank(n),Num(n){\n        for(int i=1;i&lt;n;++i){\n            father[i]=i;\n        }\n    }\n\n    int find(int v){\n        return father[v]=father[v]==v?v:find(father[v]);\n    }\n\n    void merge(int x,int y){\n        int a=find(x),b=find(y);\n        if(rank[a]&lt;rank[b]){\n            father[a]=b;\n        }else{\n            father[b]=a;\n            if(rank[a]==rank[b]){\n                ++rank[a];\n            }\n        }\n    }\n\n    int getCnum(){\n        int ans=0;\n        for(int i=1;i&lt;Num;++i){\n            if(father[i]==i) ans++;\n        }\n        return ans-1;\n    }\n};\n\nint main(){\n    int m,n;\n\n    while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        DisjointSet ds(n+1);\n        int s,t;\n        scanf(&quot;%d&quot;,&amp;m);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d %d&quot;,&amp;s,&amp;t);\n            ds.merge(s,t);\n        }\n        printf(&quot;%d\\n&quot;,ds.getCnum());\n    }\n    return 0;\n}</code></pre><h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><h1 id=\"线段树区间更新和查询\"><a href=\"#线段树区间更新和查询\" class=\"headerlink\" title=\"线段树区间更新和查询\"></a>线段树区间更新和查询</h1><p>POJ 3468</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q;\nLL lazy[maxn];\nLL sum[maxn];\nLL tree[maxn];\nLL a[maxn];\n\nvoid build(int p,int l,int r){\n    if(l==r){tree[p]=a[l];return;}\n    int mid=(l+r)&gt;&gt;1;\n    build(p&lt;&lt;1,l,mid);\n    build(p&lt;&lt;1|1,mid+1,r);\n    tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];\n}\n\nvoid PushDown(int p,int m){\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nLL find(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return tree[p];\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=find(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=find(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n    for(int i=1;i&lt;=N;++i) scanf(&quot;%lld&quot;,&amp;a[i]);\n    build(1,1,N);\n    char op;\n    int l,r,c;\n    while(Q--){\n        cin&gt;&gt;op;\n        if(op==&apos;Q&apos;){\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            printf(&quot;%lld\\n&quot;,Query(1,1,N,l,r)+find(1,1,N,l,r));\n        }else if(op==&apos;C&apos;){\n            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);\n            update(1,1,N,c,l,r);\n        }\n    }\n    return 0;\n}</code></pre>","text":"2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.并查集要领以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.并查集是不可能分割的,即只能合并,不可分割.在牛客上听大","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"并查集","slug":"HDU/并查集","count":1,"path":"api/categories/HDU/并查集.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"}]},{"title":"POJ 3090","slug":"poj-3090","date":"2018-02-12T11:54:27.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-3090.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/POJ-3090\" title=\"https://vjudge.net/problem/POJ-3090\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-3090</a></p>\n<h1 id=\"Type-欧拉函数\"><a href=\"#Type-欧拉函数\" class=\"headerlink\" title=\"Type: 欧拉函数\"></a>Type: 欧拉函数</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原题转换成该范围内有多少个点的 x与y互质</p>\n<blockquote>\n<p>这个与poj2478这道题求法一样,有一点不同的是,(x,y)存在的同时也会存在(y,x) 并且会同时存在(1,0)(0,1)(1,1)这三个点,所以答案是</p>\n</blockquote>\n<p>Farey[n]*2+3</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000+100;\nint phi[maxn];\nint Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n,kase=1,t;\n    scanf(&quot;%d&quot;,&amp;t);\n    while(t--){\n        scanf(&quot;%d&quot;,&amp;n);\n        printf(&quot;%d %d %d\\n&quot;,kase++,n,Farey[n]*2+3);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-3090Type: 欧拉函数题意第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?题解想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2478","slug":"poj-2478","date":"2018-02-12T09:44:15.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2478.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/POJ-2478\" title=\"https://vjudge.net/problem/POJ-2478\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2478</a></p>\n<h1 id=\"Type-欧拉函数\"><a href=\"#Type-欧拉函数\" class=\"headerlink\" title=\"Type: 欧拉函数\"></a>Type: 欧拉函数</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5} 其中分子与分母互质.</p>\n<blockquote>\n<p>目标是求Fn中的最简分数有多少个</p>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>仔细观察会发现因为所有分数分子分母都是互素的 设n为分母,相同分母n的最简分数的个数就等于与n互质的数的个数. 分母从2开始计数</p>\n<blockquote>\n<p>答案就是2~n的phi(k)的和</p>\n<blockquote>\n<p>注意和斐波那契一样,Farey序列也会超过long long</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000000+100;\nLL phi[maxn];\nLL Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(LL i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(LL j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){\n        printf(&quot;%lld\\n&quot;,Farey[n]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2478Type: 欧拉函数题意F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2407","slug":"poj-2407","date":"2018-02-12T09:09:54.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2407.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/POJ-2407\" title=\"https://vjudge.net/problem/POJ-2407\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2407</a></p>\n<h1 id=\"Type-欧拉函数\"><a href=\"#Type-欧拉函数\" class=\"headerlink\" title=\"Type: 欧拉函数\"></a>Type: 欧拉函数</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>求小于n 且与n互质的数的个数</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>简单欧拉,但因为是十亿的数据量,所以不能预处理</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint phi(int n){\n    int ans=n;\n    for(int i=2;i*i&lt;=n;++i){\n        if(n%i==0){\n            ans=ans-ans/i;\n            while(n%i==0){\n                n/=i;\n            }\n        }\n    }\n    if(n&gt;1){\n        ans=ans-ans/n;\n    }\n    return ans;\n}\n\nint main(){\n    int n;\n    while(cin&gt;&gt;n&amp;&amp;n){\n        cout&lt;&lt;phi(n)&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2407Type: 欧拉函数题意求小于n 且与n互质的数的个数题解简单欧拉,但因为是十亿的数据量,所以不能预处理Code#include&lt;cstdio&gt;#include&lt;algorithm&g","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"UVa 11426","slug":"uva-11426","date":"2018-02-12T08:37:59.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11426.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11426\" title=\"https://vjudge.net/problem/UVA-11426\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11426</a></p>\n<h1 id=\"Type-数论-欧拉函数-递推-思维\"><a href=\"#Type-数论-欧拉函数-递推-思维\" class=\"headerlink\" title=\"Type: 数论,欧拉函数,递推,思维\"></a>Type: 数论,欧拉函数,递推,思维</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n∈[1,4000000]</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>首先我们应该清楚</p>\n<blockquote>\n<p>4000000的数据,用暴力 - 对每个gcd求值相加复杂度是i*j*O(gcd) 你懂就行,这么大的复杂度肯定爆炸.</p>\n</blockquote>\n<p>所以我们第一想法肯定是预处理.</p>\n<blockquote>\n<p>我们设 f(n) 为 (1,n)+(2,n)+(3,n)+…+(n-1,n) 则 S(n)=f(1)+f(2)+…+f(n)</p>\n<blockquote>\n<p>通过这个公式我们就可以递推出所有的 S(n)</p>\n<blockquote>\n<p>S(n)=S(n-1)+f(n)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>然后我们的问题就转化成了求f(n)</p>\n<blockquote>\n<p>首先我们会自然地想到,与n互素的答案是1.即(k,n)的结果都是n的约数</p>\n<blockquote>\n<p>我们可以按照这个约数来进行分类, 用 g(n,i)表示满足gcd(x,n)=i 且 x\\&lt;n 的正整数x的个数 则: f(n)=Sum(i*g(n,i) | i是n的约数,g(n,i)是1~n中gcd(k,n)=i的k的个数)</p>\n<blockquote>\n<p>然后我们注意到: -gcd(x,n)=i -则gcd(x/i,n/i)=1 -即x/i与n/i互质</p>\n</blockquote>\n<p>然后我们就可以将 g(n,i) 看做1~n中与 n/i 互质的数的个数,即</p>\n</blockquote>\n<p>g(n,i) = phi(n/i) 然后我们预处理phi[maxn],预处理完以后处理f(n),这里如果用二重循环依然是接受不了的 所以我们沿用筛法的思想对f[maxn]数组进行预处理,遇到i 是 k 的约数时,直接f[k]+=(i*phi[n/i])</p>\n</blockquote>\n<p>最后预处理S[maxn]即可</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\n我们要求:\nG=Sigma(i=1~N) Sigma(j=i+1~N) GCD(i,j)\nN&lt;=4000000，这样的范围二次循环+GCD肯定是不行的\n所以我们考虑\nf(n)=Sigma(i=1~n-1) gcd(i,n)\n则\nG(n)=Sigma(i=1~n) f(i)\n=G(n-1)+f(n)\n所以我们的问题转换为如何求f(n)\n\n即k都是n的约数\n可以按照约数进行分类,用g(n,i)表示满足 (x,n)=i且x&lt;n的正整数x的个数\n则 f(n)=sum(i\\*g(n,i)|i是n的约数)\n\n再重提: g(n,i)代表满足(x,n)=i,且x&lt;n的正整数x的个数\n\n我们知道,如果 (a,n)=k\n则 (a/k,n/k)=1\n\n所以我们可以理解为g(n,i)代表的是x/i与n/i互质的数的个数\n即满足条件的x/i 有 phi(n/i)个\ng(n,i)=phi(n/i)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=4000000+10;\nLL phi[maxn];\n\nLL f[maxn];\n\nLL g[maxn];\nvoid phi_table(){\n    for(int i=2;i&lt;maxn;++i) phi[i]=0;\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nvoid init(){\n    phi_table();\n    memset(f,0,sizeof(f));\n    for(int i=1;i&lt;maxn;++i){\n        for(int j=i*2;j&lt;maxn;j+=i){\n            f[j]+=(i*phi[j/i]);\n        }\n    }\n    memset(g,0,sizeof(g));\n    for(int i=1;i&lt;maxn;++i) g[i]=g[i-1]+f[i];\n}\n\nint main(){\n    init();\n    int k;\n    while(~scanf(&quot;%d&quot;,&amp;k) &amp;&amp; k){\n        printf(&quot;%lld\\n&quot;,g[k]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11426Type: 数论,欧拉函数,递推,思维题意输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"数论","slug":"UVa/思维/数论","count":1,"path":"api/categories/UVa/思维/数论.json"},{"name":"欧拉函数","slug":"UVa/思维/数论/欧拉函数","count":1,"path":"api/categories/UVa/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"HDU 2035","slug":"hdu-2035","date":"2018-02-11T08:47:36.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2035.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/HDU-2035\" title=\"https://vjudge.net/problem/HDU-2035\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2035</a></p>\n<h1 id=\"Type-同余定理\"><a href=\"#Type-同余定理\" class=\"headerlink\" title=\"Type: 同余定理\"></a>Type: 同余定理</h1><h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>可以将提议理解为 ans%1000</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1000;\nint main(){\n    int A,B;\n    while(cin&gt;&gt;A&gt;&gt;B&amp;&amp;A+B){\n        int ans=1;\n        for(int i=1;i&lt;=B;++i){\n            ans=((ans%mod)*(A%mod))%mod;\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-2035Type: 同余定理题解可以将提议理解为 ans%1000Code#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=1000;","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"牛客练习赛 12 A,B","slug":"nk-12-ab","date":"2018-02-10T08:28:45.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/nk-12-ab.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://www.nowcoder.net/acm/contest/68#question\" title=\"https://www.nowcoder.net/acm/contest/68#question\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/68#question</a></p>\n<h1 id=\"题目都很易懂\"><a href=\"#题目都很易懂\" class=\"headerlink\" title=\"题目都很易懂\"></a>题目都很易懂</h1><h1 id=\"第一题题解\"><a href=\"#第一题题解\" class=\"headerlink\" title=\"第一题题解\"></a>第一题题解</h1><blockquote>\n<p>把弧度值当角度来做即可,如果弧度是负数,把它转换成顺时针下的弧度值即可, 那么如果 a-b\\&lt;0则代表b在a顺时针前面,否则是a在b顺时针之前</p>\n<blockquote>\n<p>然后分情况讨论即可,即钝角和锐角的情况</p>\n</blockquote>\n</blockquote>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    double a,b;\n    int t;\n    cin&gt;&gt;t;\n    while(t--){\n        cin&gt;&gt;a&gt;&gt;b;\n        if(a&lt;0.0) a=M_PI+a;\n        if(b&lt;0.0) b=M_PI+b;\n        double rg=a-b,rt=abs(rg);\n        if(rt&gt;M_PI){\n            if(rg&gt;0.0){\n                printf(&quot;counterclockwise\\n&quot;);\n            }else{\n                printf(&quot;clockwise\\n&quot;);\n            }\n        }else{\n            if(rg&gt;0.0){\n                printf(&quot;clockwise\\n&quot;);\n            }else{\n                printf(&quot;counterclockwise\\n&quot;);\n            }\n        }\n    }\n    return 0;\n}</code></pre><h1 id=\"第二题题解\"><a href=\"#第二题题解\" class=\"headerlink\" title=\"第二题题解\"></a>第二题题解</h1><blockquote>\n<p>我们将vis数组设为两重,一重是有钥匙,一重是无钥匙</p>\n<blockquote>\n<p>vis[has_key?1：0][x][y]</p>\n</blockquote>\n<p>bfs即可</p>\n</blockquote>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef struct Node{\n    int has_key;\n    int cnt,x,y;\n}node;\n\nchar mp[510][510];\nint h,w,sx,sy;\n//об,ио,ср,вС\nint mv[4][2]={ {0,1},{0,-1},{1,0},{-1,0}};\n\nint vis[2][600][600];\n\nvoid bfs(){\n    bool yes=false;\n    queue&lt;node&gt; st;\n    st.push((Node){0,0,sx,sy});\n    vis[0][sx][sy]=1;\n    while(!st.empty()){\n        node nd=st.front();st.pop();\n        if(mp[nd.x][nd.y]==&apos;E&apos;){\n            printf(&quot;%d\\n&quot;,nd.cnt);\n            return;\n        }\n        if(mp[nd.x][nd.y]==&apos;K&apos;){\n            nd.has_key=1;\n        }\n        int nx,ny;\n        for(int i=0;i&lt;4;++i){\n            nx=nd.x+mv[i][0],ny=nd.y+mv[i][1];\n            if(vis[nd.has_key][nx][ny]) continue;\n            if(mp[nx][ny]==&apos;W&apos;) continue;\n            if(mp[nx][ny]==&apos;D&apos; &amp;&amp; !nd.has_key) continue;\n            vis[nd.has_key][nx][ny]=1;\n            st.push((Node){nd.has_key,nd.cnt+1,nx,ny});\n        }\n    }\n    printf(&quot;-1\\n&quot;);\n}\n\nint main(){\n    cin&gt;&gt;h&gt;&gt;w;\n    bool flag=true;\n    memset(vis,0,sizeof(vis));\n    for(int i=0;i&lt;h;++i){\n        scanf(&quot;%s&quot;,mp[i]);\n        for(int j=0;flag &amp;&amp; j&lt;w;++j){\n            if(mp[i][j]==&apos;S&apos;){\n                sx=i,sy=j;\n                flag=false;\n            }\n        }\n    }\n    bfs();\n    return 0;\n}</code></pre>","text":"Linkhttps://www.nowcoder.net/acm/contest/68#question题目都很易懂第一题题解把弧度值当角度来做即可,如果弧度是负数,把它转换成顺时针下的弧度值即可, 那么如果 a-b\\&lt;0则代表b在a顺时针前面,否则是a在b顺时针之前然后分","link":"","raw":null,"photos":[],"categories":[{"name":"bfs","slug":"bfs","count":1,"path":"api/categories/bfs.json"},{"name":"图论","slug":"bfs/图论","count":1,"path":"api/categories/bfs/图论.json"},{"name":"牛客练习赛","slug":"bfs/图论/牛客练习赛","count":1,"path":"api/categories/bfs/图论/牛客练习赛.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"bfs","slug":"bfs","count":1,"path":"api/tags/bfs.json"}]},{"title":"HDU 1021","slug":"hdu-1021","date":"2018-02-09T12:25:13.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1021.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/HDU-1021\" title=\"https://vjudge.net/problem/HDU-1021\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-1021</a></p>\n<h1 id=\"Type-数论-同余定理和余数性质-找规律也可以\"><a href=\"#Type-数论-同余定理和余数性质-找规律也可以\" class=\"headerlink\" title=\"Type: 数论,同余定理和余数性质,找规律也可以\"></a>Type: 数论,同余定理和余数性质,找规律也可以</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11</p>\n<blockquote>\n<p>问:</p>\n<blockquote>\n<p>给你一个数n,如果f(n)整除3,则输出yes,否则no.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>(1) 暴力输出一波会发现如果 n%4==2,则输出yes (2) 正解:</p>\n<blockquote>\n<p>问题可以转换成 f(n)%3 是否等于0 那么我们只需要记录下每个 f(n)%3 的值即可 f(n)≡(f(n-1)+f(n-2))(mod 3) n&gt;=2 f(n)=((f(n-1)%3)+(f(n-2)%3))%3</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><h2 id=\"1-找规律\"><a href=\"#1-找规律\" class=\"headerlink\" title=\"1-找规律\"></a>1-找规律</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(n%4==2){\n            printf(&quot;yes\\n&quot;);\n        }else{\n            printf(&quot;no\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre><h2 id=\"2-正解\"><a href=\"#2-正解\" class=\"headerlink\" title=\"2-正解\"></a>2-正解</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nint m[maxn];\n\nvoid init(){\n    m[0]=7,m[1]=11;\n    for(int i=2;i&lt;=1000000;++i){\n        m[i]=((m[i-1]%3)+(m[i-2]%3))%3;\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        printf(&quot;%s\\n&quot;,(!m[n])?&quot;yes&quot;:&quot;no&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-1021Type: 数论,同余定理和余数性质,找规律也可以题意f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11问:给你一个数n,如果f(n)整除3,则输出yes,否则no.题解(1) 暴力输出","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"POJ 2769","slug":"poj-2769","date":"2018-02-09T09:12:34.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2769.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>可以暴力,不明所以的玄学复杂度 我觉得复杂度大概是 O(100000*log(300))</p>\n</blockquote>\n<pre><code>/*\n我以为这道题有公式...\n谁知道他要靠暴力???\n而且每次枚举前还memset????\n复杂度真的可以么...\n*/\n\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=1000000+100;\n\nbool exist[100010];\nint num[maxn];\nint T;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int N;\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=1;i&lt;=N;++i){\n            scanf(&quot;%d&quot;,&amp;num[i]);\n        }\n        for(int j=1;;++j){\n            bool is=true;\n            memset(exist,false,sizeof(exist));\n            for(int k=1;k&lt;=N;++k){\n                if(exist[num[k]%j]){\n                    is=false;\n                    break;\n                }\n                exist[num[k]%j]=true;\n            }\n            if(is){\n                printf(&quot;%d\\n&quot;,j);\n                break;\n            }\n        }\n    }\n    return 0;\n}</code></pre>","text":"可以暴力,不明所以的玄学复杂度 我觉得复杂度大概是 O(100000*log(300))/*我以为这道题有公式...谁知道他要靠暴力???而且每次枚举前还memset????复杂度真的可以么...*/#include&lt;cstdio&gt;#include&lt;cstrin","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"2018全国多校算法寒假练习赛(三) A","slug":"2018qgs-a","date":"2018-02-08T10:09:44.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/2018qgs-a.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/02/1169018-20180203122824531-2079198459.png","content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://www.nowcoder.net/acm/contest/75/A\" title=\"https://www.nowcoder.net/acm/contest/75/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/75/A</a></p>\n<h1 id=\"Type-数论-Stirling公式\"><a href=\"#Type-数论-Stirling公式\" class=\"headerlink\" title=\"Type: 数论-Stirling公式\"></a>Type: 数论-Stirling公式</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个n,问你n!的八进制位数是多少.</p>\n</blockquote>\n<h1 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h1><blockquote>\n<p>有t(1<del>1000000)组数据 每组数据大小为 0</del>1000000</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>由以上数据范围我们知道不能乱搞(暴力或者打表都会爆)了. 这里提第一个点:</p>\n<blockquote>\n<p>求数M的K进制位数,答案就是</p>\n<blockquote>\n<p>logK(M)+1</p>\n</blockquote>\n</blockquote>\n<p>第二点:</p>\n<blockquote>\n<p>n! 近似公式 - Stirling公式 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/02/1169018-20180203122824531-2079198459.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/02/1169018-20180203122824531-2079198459.png\" alt></a></p>\n</blockquote>\n<p>结合这两点不难得出下列公式:</p>\n<blockquote>\n<p>log8(n!) = M =log8(sqrt(2*pi*n))+log8((n/e)^n) =log8(sqrt(2*pi*n))+log8((n/e)^n) =log8(sqrt(2*pi*n))+n*log8(n/e) =ln(sqrt(2*pi*n))/ln(8)+n*ln(n/e)/ln(8)</p>\n</blockquote>\n<p>常数时间就可以求出来了.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n//M_PI,M_E\nint main(){\n    int t,n;\n    cin&gt;&gt;t;\n    for(int i=0;i&lt;t;++i){\n        scanf(&quot;%d&quot;,&amp;n);\n        if(n==0){\n            printf(&quot;1\\n&quot;);\n            continue;\n        }\n        double ans=log(sqrt(2*M_PI*n))/log(8)+n*log(n/M_E)/log(8);\n        printf(&quot;%d\\n&quot;,(int)ans+1);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://www.nowcoder.net/acm/contest/75/AType: 数论-Stirling公式题意给你一个n,问你n!的八进制位数是多少.数据范围有t(11000000)组数据 每组数据大小为 01000000题解由以上数据范围我们知道不能乱搞(","link":"","raw":null,"photos":[],"categories":[{"name":"Stirling公式","slug":"Stirling公式","count":1,"path":"api/categories/Stirling公式.json"},{"name":"数论","slug":"Stirling公式/数论","count":1,"path":"api/categories/Stirling公式/数论.json"},{"name":"牛客练习赛","slug":"Stirling公式/数论/牛客练习赛","count":1,"path":"api/categories/Stirling公式/数论/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"Stirling公式","slug":"Stirling公式","count":1,"path":"api/tags/Stirling公式.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"}]}]}