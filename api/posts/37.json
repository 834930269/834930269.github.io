{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"UVa 12716","slug":"uva-12716","date":"2016-12-24T13:35:57.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-12716.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【思路】: P318: （1）gcd(a,b)=c； （2）(a^b)=c；通过观察容易发现如果gcd(a,b)=(a^b)=c，那么c=a-b，因此可以事先枚举所有a的因数c，利用b=a-c计算b,然后只需验证是否满足(a^b)==c即可。但本题的数据太大，而且枚举约数不容易，因此可以利用约数c枚举倍数a，这样就会方便很多，打表的效率也足够高；而且，由于a=k_c,b=a-c=(k-1)_c，因此，必有gcd(a,b)=gcd(k_c,(k-1)_c)=c。这样只需比较(a^b)和c即可算出a的所有解数，由于本题要的是前n项的解数，因此最后要累加之间的所有解。 【Code】: (VJ-UVa炸了..还没尝试能否A).</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;</algorithm></p>\n<p>const int maxn = 30000030;<br>int d[maxn];</p>\n<p>void init(){<br>    for(int c=1;c&lt;maxn/2;++c)<br>        for(int a=c+c;a&lt;maxn;a+=c){//a=K*C b=(K-1)*C<br>                int b=a-c;//必有gcd(a,b)=c<br>                if((a^b)==c)d[a]++;<br>        }<br>    for(int i=2;i&lt;maxn;++i)<br>        d[i]+=d[i-1];<br>}</p>\n<p>int main(){<br>    init();<br>    int N,Q=0;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        int M;<br>        cin&gt;&gt;M;<br>        cout&lt;&lt;”Case “&lt;&lt;++Q&lt;&lt;”: “&lt;&lt;d[M]&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"【思路】: P318: （1）gcd(a,b)=c； （2）(a^b)=c；通过观察容易发现如果gcd(a,b)=(a^b)=c，那么c=a-b，因此可以事先枚举所有a的因数c，利用b=a-c计算b,然后只需验证是否满足(a^b)==c即可。但本题的数据太大，而且枚举约数不容易，","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"玲珑杯 R7 C-Duplicate Numbers","slug":"linglong-r7-c-duplicate-numbers","date":"2016-12-24T12:41:59.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/linglong-r7-c-duplicate-numbers.json","excerpt":"","keywords":null,"cover":null,"content":"<p>problem:1073 用map维护.</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<set></set></p>\n<p>#include<map><br>using namespace std;<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int N;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        int M,flag=0;<br>        cin&gt;&gt;M;<br>        map&lt;int,int&gt; ma;<br>        for(int i=0;i&lt;M;++i){<br>            int n;<br>            cin&gt;&gt;n;<br>            ma[n]++;<br>            if(flag==0 &amp;&amp; ma[n]&gt;1) flag=1;<br>        }<br>        if(flag){<br>                map&lt;int,int&gt;::iterator it;<br>                for(it=ma.begin();it-&gt;second&lt;=1;it++){}<br>                    cout&lt;<it->first;<br>                    it++;<br>                for(;it!=ma.end();it++)<br>                    if(it-&gt;second&gt;1)<br>                        cout&lt;&lt;” “&lt;<it->first;<br>                cout&lt;&lt;endl;<br>        }else{<br>            cout&lt;&lt;”none”&lt;&lt;endl;<br>        }<br>    }</it-></it-></map></p>\n<pre><code>return 0;</code></pre><p>}</p>\n","text":"problem:1073 用map维护.#include#include#include#include<br>using namespace std;<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int N","link":"","raw":null,"photos":[],"categories":[{"name":"玲珑杯","slug":"玲珑杯","count":2,"path":"api/categories/玲珑杯.json"}],"tags":[{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"Eratosthenes 筛法","slug":"eratosthenes-p312","date":"2016-12-23T03:30:31.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/eratosthenes-p312.json","excerpt":"","keywords":null,"cover":null,"content":"<p>俗称,埃氏筛法.这里是借用其思路. Problem: 给出正整数N和M,区间[N,M]内的”无平方因子”的数有多少个? 整数P无平方因子,当且仅当不存在k&gt;1,使得p是k^2的倍数,N,M∈[1,1e12],M-N&lt;=1e7. [分析]: 因为数据规模的限制,枚举肯定会超时. [思路]: 对于不超过sqrt(M)的所有素数p,筛掉[N,M]内p^2的倍数. [Code]:</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath></cmath></p>\n<p>#define maxn 10000000+10<br>using namespace std;</p>\n<p>bool squre[maxn];//m-n个是否是无平方因子<br>bool is_prime[maxn];//素数表<br>int prime[maxn];</p>\n<p>int sieve(int n){<br>    int p=0;<br>    for(int i=0;i&lt;=n;i++) is_prime[i]=true;<br>    is_prime[0]=is_prime[1]=false;</p>\n<pre><code>for(int i=2;i&lt;=n;++i){\n    if(is_prime\\[i\\])\n        prime\\[p++\\]=i;\n    for(int j=2*i;j&lt;=n;j+=i)\n        is_prime\\[j\\]=false;\n}\nreturn p;</code></pre><p>}</p>\n<p>int NonSquare(int n,int m){<br>    memset(squre, true, sizeof(squre));<br>    int p=0;<br>    for(int i=0;prime[i]<em>prime[i]&lt;=m;++i){<br>        int d=prime[i]</em>prime[i];<br>        for(int j=1;j<em>d&lt;=m;++j)<br>            if(j</em>d&gt;=n)<br>                squre[j*d-n]=false;<br>    }<br>    for(int i=0;i&lt;=(m-n);++i)<br>        if(squre[i])p++;<br>    return p;<br>}</p>\n<p>int main(){<br>    int m,n,siv;<br>    sieve(1e7);<br>    while(cin&gt;&gt;n&gt;&gt;m){<br>        cout&lt;&lt;”[“&lt;&lt;n&lt;&lt;”,”&lt;&lt;m&lt;&lt;”]内无平方因子数为: “&lt;&lt;NonSquare(n,m)&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n<p>Save Save</p>\n","text":"俗称,埃氏筛法.这里是借用其思路. Problem: 给出正整数N和M,区间[N,M]内的”无平方因子”的数有多少个? 整数P无平方因子,当且仅当不存在k&gt;1,使得p是k^2的倍数,N,M∈[1,1e12],M-N&lt;=1e7. [分析]: 因为数据规模的限制,枚举肯定","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[]},{"title":"hihoCoder 1014","slug":"hihocoder-1014","date":"2016-12-22T13:56:45.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/hihocoder-1014.json","excerpt":"","keywords":null,"cover":null,"content":"<p>蛮有趣的.</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>struct Tree{//以0-26作为Tree的头结点<br>    int num;<br>    Tree* Next[26];<br>    Tree(){<br>        num=0;<br>        int i;<br>        for(i=0;i&lt;26;i++)<br>            Next[i]=NULL;<br>    }<br>}T;</p>\n<p>void In(char <em>str){<br>    Tree</em> H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL)//只有微为空才允许创建<br>            H-&gt;Next[str[i]-‘a’]=new Tree;//想调用构造函数必须new一个Tree<br>        H=H-&gt;Next[str[i]-‘a’];<br>        H-&gt;num++;<br>    }<br>}</p>\n<p>int Se(char *str){<br>    Tree *H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL) return 0;<br>        H=H-&gt;Next[str[i]-‘a’];<br>    }<br>    return H-&gt;num;<br>}</p>\n<p>int main(){<br>    int N;<br>    char str[11]=””;<br>    scanf(“%d”,&amp;N);</p>\n<pre><code>while(N--){\n    scanf(&quot;%s&quot;,str);\n    In(str);\n}\n\nscanf(&quot;%d&quot;,&amp;N);\nwhile(N--){\n    scanf(&quot;%s&quot;,str);\n    printf(&quot;%d\\\\n&quot;,Se(str));\n}\n\nreturn 0;</code></pre><p>}</p>\n<p>Save</p>\n","text":"蛮有趣的.#include#include#include#include#include#include<br>using namespace std;struct Tree{//以0-26作为Tree的头结点<br>    int num;<br>    Tree* Next","link":"","raw":null,"photos":[],"categories":[{"name":"hihoCoder","slug":"hihoCoder","count":1,"path":"api/categories/hihoCoder.json"}],"tags":[{"name":"hiho","slug":"hiho","count":1,"path":"api/tags/hiho.json"}]},{"title":"UVa 1588","slug":"uva-1588","date":"2016-12-22T13:27:56.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/uva-1588.json","excerpt":"","keywords":null,"cover":null,"content":"<p>算法竞赛入门经典 P59 (好恶心的模拟) 参考(思路对,写不出来Orz):<a href=\"http://www.cnblogs.com/luruiyuan/p/5562520.html\" target=\"_blank\" rel=\"noopener\">仰望高端玩家的小清新</a></p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstring></cstring></p>\n<p>#define FOR(i,j,k) for(int i=j,i&lt;k;++i)<br>using namespace std;<br>char a[101],b[101];<br>int n1,n2;</p>\n<p>int solve(char *s1,char *s2,int n){<br>    int sumlen=n1+n2,len=sumlen,minn=min(n1,n2);<br>    for(int i=0;i&lt;n;++i){<br>            int flag=1,fix=min(n-i,minn);<br>            for(int j=0;j&lt;fix;++j)<br>                if(s1[i+j]==’2’ &amp;&amp; s2[j]==’2’){<br>                        flag=0;break;<br>                }<br>            if(flag &amp;&amp; len&gt;sumlen-fix) len=sumlen-fix;<br>        }<br>        return len;<br>}</p>\n<p>int main(){<br>    char a[101],b[101];<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>        n1=strlen(a),n2=strlen(b);<br>        cout&lt;&lt;min(solve(a,b,n1),solve(b,a,n2))&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"算法竞赛入门经典 P59 (好恶心的模拟) 参考(思路对,写不出来Orz):仰望高端玩家的小清新#include#include#include#define FOR(i,j,k) for(int i=j,i&lt;k;++i)<br>using namespace std;<b","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1339","slug":"uva-1339","date":"2016-12-22T12:09:09.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/uva-1339.json","excerpt":"","keywords":null,"cover":null,"content":"<p>算法竞赛入门经典 P75</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio><br>using namespace std;<br>int main(){<br>    char s[101],t[101];<br>    while(cin&gt;&gt;s&gt;&gt;t){<br>        int cnt1[27]={0},cnt2[27]={0},flag=0;<br>        for(int i=0;s[i]!=’\\0’;++i){<br>            if((s[i]==’\\0’&amp;&amp;t[i]!=’\\0’)||(t[i]==’\\0’&amp;&amp;s[i]!=’\\0’)){<br>                cout&lt;&lt;”NO”&lt;&lt;endl;<br>                flag=1; break;<br>            }<br>            cnt1[s[i]-‘A’]++;<br>            cnt2[t[i]-‘A’]++;<br>        }<br>        if(flag)<br>            continue;<br>        sort(cnt1,cnt1+27);<br>        sort(cnt2,cnt2+27);<br>        for(int i=0;i&lt;27;++i)<br>            if(cnt1[i]!=cnt2[i]){<br>                cout&lt;&lt;”NO”&lt;&lt;endl;<br>                flag=1;break;<br>            }<br>        if(flag)<br>            continue;<br>        cout&lt;&lt;”YES”&lt;&lt;endl;<br>    }<br>    return 0;<br>}</cstdio></p>\n","text":"算法竞赛入门经典 P75#include#include#include<br>using namespace std;<br>int main(){<br>    char s[101],t[101];<br>    while(cin&gt;&gt;s&gt;&gt;t){<","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"矩阵类","slug":"matrix","date":"2016-12-20T12:52:03.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/matrix.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【任务】 实现矩阵的基本变换 【接口】 结构体:Matrix 成员变量: int n,m      矩阵大小 int a[][]    矩阵内容 重载运算符    +、-、* 成员函数: void clear() 清空矩阵 【代码】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cstdio><br>using namespace std;<br>const int MAXN=30;<br>const int MAXM=30;</cstdio></p>\n<p>/*<br>* Matrix类, + - *<br>*/</p>\n<p>struct Matrix{<br>    int n,m;//行,列<br>    int a[MAXN][MAXM];<br>    void clear(){<br>        n=m=0;<br>        memset(a,0,sizeof(a));<br>    }<br>    Matrix operator + (const Matrix &amp;b) const{<br>        Matrix tmp;<br>        tmp.n=n; tmp.m=m;<br>        for(int i=0;i&lt;n;++i)<br>            for(int j=0;j&lt;m;++j)<br>                tmp.a[i][j]=a[i][j]+b.a[i][j];<br>        return tmp;<br>    }<br>    Matrix operator - (const Matrix &amp;b) const{<br>        Matrix tmp;<br>        tmp.n=n;  tmp.m=m;<br>        for(int i=0;i&lt;n;++i)<br>            for(int j=0;j&lt;m;++j)<br>                tmp.a[i][j]=a[i][j]-b.a[i][j];<br>        return tmp;<br>    }<br>    Matrix operator * (const Matrix &amp;b) const{<br>        Matrix tmp;<br>        tmp.clear();<br>        tmp.n=n;  tmp.m=b.m;<br>        for(int i=0;i&lt;n;++i)<br>            for(int j=0;j&lt;b.m;++j)<br>                for(int k=0;k&lt;m;++k)<br>                    tmp.a[i][j]+=a[i][k]<em>b.a[k][j];<br>        return tmp;<br>    }<br>};<br>int main(){<br>  Matrix a,b,mut,sum,de;<br>  cout&lt;&lt;”请输入a和b的行和列数:”;<br>  cin&gt;&gt;a.n&gt;&gt;a.m;<br>  b.n=a.n,b.m=a.m;<br>  cout&lt;&lt;”请填充a:”&lt;&lt;endl;<br>  for(int i=0;i&lt;a.n;++i)<br>    for(int j=0;j&lt;a.m;++j)<br>        cin&gt;&gt;a.a[i][j];<br>  cout&lt;&lt;”请填充b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;a.n;++i)<br>    for(int j=0;j&lt;a.m;++j)<br>        cin&gt;&gt;b.a[i][j];<br>  mut=a</em>b;<br>  sum=a+b;<br>  de=a-b;<br>  cout&lt;&lt;”a+b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;sum.n;++i){<br>    for(int j=0;j&lt;sum.m;++j)<br>        cout&lt;&lt;sum.a[i][j]&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>  }<br>  cout&lt;&lt;”a-b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;de.n;++i){<br>    for(int j=0;j&lt;de.m;++j)<br>        cout&lt;&lt;de.a[i][j]&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>  }<br>  cout&lt;&lt;”a*b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;mut.n;++i){<br>    for(int j=0;j&lt;mut.m;++j)<br>        cout&lt;&lt;mut.a[i][j]&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>  }<br>  return 0;<br>}</p>\n<p>Save Save</p>\n","text":"【任务】 实现矩阵的基本变换 【接口】 结构体:Matrix 成员变量: int n,m      矩阵大小 int a[][]    矩阵内容 重载运算符    +、-、* 成员函数: void clear() 清空矩阵 【代码】#include#include#include","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[]},{"title":"杂记.","slug":"post2","date":"2016-12-10T06:29:07.000Z","updated":"2019-07-03T13:51:36.843Z","comments":true,"path":"api/articles/post2.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>2016/12/10.</strong> 喜欢什么,就去追逐,但就因为我是这样的一个纨绔弟子,很多人都说我会偷了西瓜丢了桃.也因此惶惶的度过了那个什么都像母亲索取,却习惯性半途而废的年龄. 开始变得沉稳了,无论是否抗拒与社会同流合污,都会开始选择尊重,尊重别人的选择,用我妈妈习惯的话来说,谁都不容易. 就像我曾在某位ACMer的blog里看到的那首歌: 历历万乡. 也将成为我的精神支柱, 他想要的不多, 只是和别人的不一样.     Save Save Save Save Save Save</p>\n","text":"2016/12/10. 喜欢什么,就去追逐,但就因为我是这样的一个纨绔弟子,很多人都说我会偷了西瓜丢了桃.也因此惶惶的度过了那个什么都像母亲索取,却习惯性半途而废的年龄. 开始变得沉稳了,无论是否抗拒与社会同流合污,都会开始选择尊重,尊重别人的选择,用我妈妈习惯的话来说,谁都不容","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"新博客搭建好了！这里附上老博客的连接","slug":"one","date":"2016-12-09T23:26:53.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/one.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"https://834930269.github.io/\" target=\"_blank\" rel=\"noopener\">https://834930269.github.io/</a> ps:以前的blog是一个github page搭的静态blog，用的框架是octopress. 开始备案域名了… 期待ing.. 谢谢各位老爷大驾光临！   Save Save Save Save Save Save</p>\n","text":"https://834930269.github.io/ ps:以前的blog是一个github page搭的静态blog，用的框架是octopress. 开始备案域名了… 期待ing.. 谢谢各位老爷大驾光临！   Save Save Save Save Save Save","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]}]}