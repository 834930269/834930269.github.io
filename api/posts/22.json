{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"CodeVS 1344","slug":"codevs-1344","date":"2017-08-19T05:04:23.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/codevs-1344.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型:概率演算-模拟退火 题目连接::earth_africa:<a href=\"http://www.codevs.cn/problem/1344/\" title=\"CodeVS-1344\" target=\"_blank\" rel=\"noopener\">CodeVS-1344</a> 模拟退火+题解: :earth_asia:<a href=\"https://zhuanlan.zhihu.com/p/23968011\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/23968011</a> github: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/CodeVS/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/1344.cpp\" title=\"1344.cpp\" target=\"_blank\" rel=\"noopener\">1344.cpp</a> Code:</p>\n<pre><code>#define F(i,n) for(int i=0;i&lt;n;++i)\n#define Fi(i,n) for(int i=1;i&lt;=n;++i)\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=21;\nint n;\ndouble x[maxn],y[maxn];\ndouble dist[maxn][maxn];\nstruct Path{\n    int path[maxn];\n    Path(){\n        F(i,n) path[i]=i;\n    }\n    Path(const Path&amp; p){\n        memcpy(path,p.path,sizeof(path));\n        swap(path[rand()%n],path[rand()%n]);\n    }\n    double dist(){\n        double ans=0;\n        for(int i=1;i&lt;n;++i){\n            ///解决重名的办法\n            ans+= ::dist[path[i-1]][path[i]];\n        }\n        return ans;\n    }\n};\n\nbool accept(double delta,double temper){\n    if(delta&lt;=0) return true;\n    return rand()&lt;=exp((-delta)/temper)*RAND_MAX;\n}\n\ndouble solve(){\n    const double max_temper=10000;\n    const double dec=0.999;\n    double temp=max_temper;\n    Path p;\n    while(temp&gt;0.01){\n        Path p2(p);\n        if(accept(p2.dist()-p.dist(),temp)) p=p2;\n        temp*=dec;\n    }\n    return p.dist();\n}\n\nint main(){\n    srand(19260817U);\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%lf%lf&quot;,x+i,y+i);\n    }\n    for(int i=0;i&lt;n;++i){\n        dist[i][i]=0;\n        for(int j=i+1;j&lt;n;++j){\n            dist[i][j]=dist[j][i]=hypot(x[i]-x[j],y[i]-y[j]);\n        }\n    }\n    double ans=0x3f3f3f3f;\n    int T=155;\n    while(T--){\n        ans=min(ans,solve());\n    }\n    printf(&quot;%.2lf&quot;,ans);\n    return 0;\n}</code></pre>","text":"类型:概率演算-模拟退火 题目连接::earth_africa:CodeVS-1344 模拟退火+题解: :earth_asia:https://zhuanlan.zhihu.com/p/23968011 github: :earth_asia:1344.cpp Code:#de","link":"","raw":null,"photos":[],"categories":[{"name":"CodeVS","slug":"CodeVS","count":1,"path":"api/categories/CodeVS.json"},{"name":"模拟退火","slug":"CodeVS/模拟退火","count":1,"path":"api/categories/CodeVS/模拟退火.json"}],"tags":[{"name":"CodeVS","slug":"CodeVS","count":1,"path":"api/tags/CodeVS.json"},{"name":"模拟退火","slug":"模拟退火","count":1,"path":"api/tags/模拟退火.json"}]},{"title":"最近的多校和codeforce(未补题状态","slug":"current-multi-cf","date":"2017-08-15T14:20:45.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/current-multi-cf.json","excerpt":"","keywords":null,"cover":null,"content":"<p>codeforce: Round428 div2 A: 戳这里-&gt; :earth_americas:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/428DIV2%20A.cpp\" title=\"428DIV2 A.cpp\" target=\"_blank\" rel=\"noopener\">428DIV2 A.cpp</a> Round428 div2 B: 戳这里-&gt; :earth_americas:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/428DIV2B.cpp\" title=\"428DIV2 B.cpp\" target=\"_blank\" rel=\"noopener\">428DIV2 B.cpp</a> 多校: 戳这里-&gt; :earth_americas: <a href=\"https://github.com/834930269/Other_OJ/tree/master/Multi-University%20Training%20Contest\" title=\"水题集合φ(&gt;ω&lt;*) \" target=\"_blank\" rel=\"noopener\">水题集合φ(&gt;ω&lt;*)</a></p>\n","text":"codeforce: Round428 div2 A: 戳这里-&gt; :earth_americas:428DIV2 A.cpp Round428 div2 B: 戳这里-&gt; :earth_americas:428DIV2 B.cpp 多校: 戳这里-&gt; :ear","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"Codeforce","slug":"2017多校/Codeforce","count":1,"path":"api/categories/2017多校/Codeforce.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"推一波喜欢的漫画","slug":"on-yonder-lea","date":"2017-08-12T10:59:26.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/on-yonder-lea.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/08/tumblr_o0ejn6DpQ11v43xego1_1280.jpg","content":"<p>On Yonder Lea ,I’d Shelter Thee. :earth_africa:<a href=\"https://onyonder.tumblr.com/\" title=\"by William Adams\" target=\"_blank\" rel=\"noopener\">by William Adams</a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/08/tumblr_o0ejn6DpQ11v43xego1_1280.jpg\" title=\"feel_sad\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/tumblr_o0ejn6DpQ11v43xego1_1280.jpg\" alt=\"feel_sad\" title=\"feel_sad\"></a></p>\n","text":"On Yonder Lea ,I’d Shelter Thee. :earth_africa:by William Adams  [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"python站 第一次更新","slug":"python-fb","date":"2017-08-11T06:56:11.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-fb.json","excerpt":"","keywords":null,"cover":null,"content":"<p>link: <a href=\"http://be-sunshine.cn:81/blog/0015024342574655180f051270a4a029c3c1a1ecc95fca0000\" title=\"第一次更新 - Mr.赝\" target=\"_blank\" rel=\"noopener\">第一次更新 - Mr.赝</a> 更新内容: <a href=\"http://be-sunshine.cn:81/signin\" title=\"登录界面优化\" target=\"_blank\" rel=\"noopener\">登录界面优化</a></p>\n","text":"link: 第一次更新 - Mr.赝 更新内容: 登录界面优化","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"}],"tags":[]},{"title":"POJ 3468","slug":"poj-3468","date":"2017-08-07T11:10:00.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/poj-3468.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:<a href=\"https://vjudge.net/problem/POJ-3468\" title=\"POJ-3468\" target=\"_blank\" rel=\"noopener\">POJ-3468</a> 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问a<del>b这段数的和，‘C a b c’是把a</del>b这段数都加上c。 题解: 区间问题,首先想到线段树,这里我们建两个线段树.data,datb. data用来维护区间所更新的值. datb则用来维护区间的和. 计算的时候只需要 每部分的区间和 + 每部分更新的值 即为最终答案.(百度说这叫Lazy思想.) github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-3468.cpp\" title=\"POJ-3468.cpp\" target=\"_blank\" rel=\"noopener\">POJ-3468.cpp</a> Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n///区间更新\ntypedef long long ll;\n\nconst int DAT_SIZE=(1&lt;&lt;18)-1;\nconst int MAX_N=100000+10;\nconst int MAX_Q=100000+10;\n\nint N,Q;\nint A[MAX_N];\nchar T[MAX_Q];\nint L[MAX_Q],R[MAX_Q],X[MAX_Q];\n\n///线段树,a维护区间应加值,b维护区间和\nll data[DAT_SIZE],datb[DAT_SIZE];\n\n///对区间[a,b]同时加x\n///k是节点编号,对应的区间是[l,r)\nvoid add(int a,int b,int x,int k,int l,int r){\n    if(a&lt;=l&amp;&amp;r&lt;=b){\n        data[k]+=x;\n    }else if(l&lt;b &amp;&amp; a&lt;r){\n        datb[k]+=(min(b,r)-max(a,l))*x;\n        add(a,b,x,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        add(a,b,x,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n    }\n}\n\n///计算[a,b)的和\nll sum(int a,int b,int k,int l,int r){\n    if(b&lt;=l || a&gt;=r){\n        return 0;\n    }else if(a&lt;=l &amp;&amp; r&lt;=b){\n        return data[k]*(r-l)+datb[k];\n    }else{\n        ll res=(min(b,r)-max(a,l))*data[k];\n        res+=sum(a,b,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        res+=sum(a,b,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n        return res;\n    }\n}\n\n///下标0开头的线段树初始化\n///开区间[a,b)\nvoid solve(){\n    for(int i=0;i&lt;N;++i){\n        add(i,i+1,A[i],0,0,N);\n//        printf(&quot;\\nadd: %d -&gt; %d\\n&quot;,i,A[i]);\n    }\n    for(int i=0;i&lt;Q;++i){\n        if(T[i]==&apos;C&apos;){\n            add(L[i],R[i]+1,X[i],0,0,N);\n        }else{\n            printf(&quot;%lld\\n&quot;,sum(L[i],R[i]+1,0,0,N));\n        }\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;Q)==2){\n        memset(data,0,sizeof(data));\n        memset(datb,0,sizeof(datb));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;A[i]);\n        }\n        ///区间是[0...N)所以要减一\n        for(int i=0;i&lt;Q;++i){\n            scanf(&quot;%*c%c&quot;,&amp;T[i]);\n            if(T[i]==&apos;C&apos;){\n                scanf(&quot;%d%d%d&quot;,&amp;L[i],&amp;R[i],&amp;X[i]);\n                L[i]-=1;R[i]-=1;\n            }else{\n                scanf(&quot;%d%d&quot;,&amp;L[i],&amp;R[i]);\n                L[i]-=1;R[i]-=1;\n            }\n        }\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:POJ-3468 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问ab这段数的和，‘C a b c’是把ab这段数都加上c。 题解: 区间问题,首先想","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2991","slug":"poj-2991","date":"2017-08-05T14:44:10.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/poj-2991.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树 题目连接: :earth_asia:<a href=\"http://poj.org/problem?id=2991\" title=\"Crane\" target=\"_blank\" rel=\"noopener\">POJ-Crane</a> 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子区间的向量+右子区间的向量。 求一个向量（x0,y0）逆时针旋转B度后的向量有一个公式： x1= x0 * cosB - y0 * sinB y1 = x0 * sinB + y0 * cosB 顺时针就把-B代入： x1= x0 * cosB + y0 * sinB y1 = -x0 * sinB + y0 * cosB github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-2991.CPP\" title=\"POJ 2991.cpp\" target=\"_blank\" rel=\"noopener\">POJ 2991.cpp</a> Code:</p>\n<pre><code>#define _USE_MATH_DEFINES///使用math库中的定义\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\nusing namespace std;\n\nconst int ST_SIZE=(1&lt;&lt;15)-1;\nconst int MAX_N=10010;\nconst int MAX_C=10010;\n\nint N,C;\nint L[MAX_N];\nint S[MAX_C],A[MAX_N];\n\ndouble vx[ST_SIZE],vy[ST_SIZE]; ///各节点的向量\ndouble ang[ST_SIZE]; ///各节点的角度\n\ndouble prv[MAX_N];\n\n///初始化线段树\nvoid init(int k,int l,int r){\n    ang[k]=vx[k]=0.0;\n    if(r-l==1){\n        ///叶子结点\n        vy[k]=L[l];\n    }else{\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        init(chl,l,(l+r)&gt;&gt;1);\n        init(chr,(l+r)&gt;&gt;1,r);\n        vy[k]=vy[chl]+vy[chr];\n    }\n}\n\n///把s和s+1的角度变为a\n///v是节点编号,l,r表示当前结点对应的是[l,r]区间\nvoid update(int s,double a,int k,int l,int r){\n    if(s&lt;=l) return;\n    else if(s&lt;r){\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        int m=(l+r)&gt;&gt;1;\n        update(s,a,chl,l,m);\n        update(s,a,chr,m,r);\n        if(s&lt;=m) ang[k]+=a;\n\n        double s=sin(ang[k]),c=cos(ang[k]);\n        vx[k]=vx[chl]+(c*vx[chr]-s*vy[chr]);\n        vy[k]=vy[chl]+(s*vx[chr]+c*vy[chr]);\n    }\n}\n\nvoid solve(){\n    init(0,0,N);\n    for(int i=0;i&lt;C;++i){\n        int s=S[i];\n        double a=A[i]/360.0*2*M_PI;///把角度换算成弧度\n        update(s,a-prv[s],0,0,N);\n        prv[s]=a;\n\n        printf(&quot;%.2f %.2f\\n&quot;,vx[0],vy[0]);\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;C)==2){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;L[i]);\n            prv[i]=M_PI;///180°的弧度值\n        }\n        for(int i=0;i&lt;C;++i)\n            scanf(&quot;%d%d&quot;,&amp;S[i],&amp;A[i]);\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树 题目连接: :earth_asia:POJ-Crane 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"基于python3+mysql+nginx的个人博客","slug":"python3-end-blog-2","date":"2017-08-03T02:11:46.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/python3-end-blog-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg","content":"<p>一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而第三个博客是用nginx,所以使用了不同的端口号,以防冲突): 点击这里=&gt; :octocat:<a href=\"http://be-sunshine.cn:81\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn:81</a> 开源: (github上,暂时还未和python学习篇分开,回头分开再贴,Orz =3 )<del>~</del> 愿我永远有一颗不变的心! <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg\" alt></p>\n","text":"一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"全栈","slug":"Python/全栈","count":1,"path":"api/categories/Python/全栈.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"全栈","slug":"全栈","count":1,"path":"api/tags/全栈.json"}]},{"title":"2017多校训练2 HDU 6047 Maximum Sequence","slug":"2017-hdu-6047-maximum-sequence","date":"2017-07-29T04:51:07.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6047-maximum-sequence.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6047\" title=\"Maximum Sequence\" target=\"_blank\" rel=\"noopener\">Maximum Sequence</a> 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,记录每个i到maxindex(A)的最大值,然后动态更新. github: 1.线段树法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003_Range_Tree.cpp\" title=\"1003_Range_Tree.cpp\" target=\"_blank\" rel=\"noopener\">1003_Range_Tree.cpp</a> 2.暴力动态更新法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003.cpp\" title=\"1003.cpp\" target=\"_blank\" rel=\"noopener\">1003.cpp</a></p>\n<pre><code>///线段树法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst int maxnode=2000050;\n\nint b[maxnode],N;\nint maxv[maxnode];\n\nvoid build(int o,int l,int r){\n    if(l==r){\n        if(l&gt;N) return;///预先分配2*N个结点\n        scanf(&quot;%d&quot;,&amp;maxv[o]);maxv[o]-=l;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(o&lt;&lt;1,l,mid);\n    build(o&lt;&lt;1|1,mid+1,r);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint query(int o,int l,int r,int ll,int rr){\n    if(l&gt;=ll&amp;&amp;r&lt;=rr) return maxv[o];\n    int ma=-1,mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=ll) ma=max(ma,query(o&lt;&lt;1,l,mid,ll,rr));\n    if(rr&gt;mid) ma=max(ma,query(o&lt;&lt;1|1,mid+1,r,ll,rr));\n    return ma;\n}\n\nvoid update(int o,int l,int r,int p,int val){\n    if(l==r){\n        maxv[o]=val;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    if(p&lt;=mid)update(o&lt;&lt;1,l,mid,p,val);\n    else update(o&lt;&lt;1|1,mid+1,r,p,val);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        build(1,1,2*N);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        LL ans=0;\n        for(int i=N+1;i&lt;=2*N;++i){\n            int k=query(1,1,2*N,b[i-N],i-1);\n            update(1,1,2*N,i,k-i);\n            ans=(ans+k)%mod;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n\n///HDU 6047 暴力动态更新法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=500000+50;\nconst int mod=1e9+7;\nint N;\nint a[maxn],b[maxn],maxa[maxn];\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=1;i&lt;=N;++i){\n            int aa;\n            scanf(&quot;%d&quot;,&amp;aa);\n            a[i]=aa-i;\n        }\n        maxa[N]=a[N];\n        for(int i=N-1;i&gt;=1;--i) maxa[i]=max(maxa[i+1],a[i]);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        long long ans=0;\n        ans=(ans+maxa[b[1]])%mod;\n        int t=maxa[b[1]]-N-1;\n        for(int i=2;i&lt;=N;++i){\n            maxa[b[i]]=max(maxa[b[i]],t);\n            ans=(ans+maxa[b[i]])%mod;\n            t=max(t,maxa[b[i]]-N-1);\n        }\n        printf(&quot;%lld\\n&quot;,ans%mod);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: :point_right:Maximum Sequence 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"segmentTree","slug":"2017多校/segmentTree","count":1,"path":"api/categories/2017多校/segmentTree.json"},{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"path":"api/categories/2017多校/segmentTree/思维.json"},{"name":"线段树","slug":"2017多校/segmentTree/思维/线段树","count":1,"path":"api/categories/2017多校/segmentTree/思维/线段树.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"python3学习 数据库","slug":"python3-database","date":"2017-07-29T01:32:25.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-database.json","excerpt":"","keywords":null,"cover":null,"content":"<p>文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Database\" title=\"Database仓库\" target=\"_blank\" rel=\"noopener\">Database仓库</a></p>\n","text":"文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:Database仓库","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"2017多校训练1 HDU 6043 KazaQ's Socks","slug":"2017-hdu-6043-kazaqs-socks","date":"2017-07-27T15:46:42.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6043-kazaqs-socks.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6043\" title=\"KazaQ&#39;s Socks\" target=\"_blank\" rel=\"noopener\">KazaQ’s Socks</a> 题意:穿袜子,洗袜子,求洗了多少次袜子…:sweat_smile: 题解:无 github: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6043\" title=\"KazaQ&#39;s Socks\" target=\"_blank\" rel=\"noopener\">KazaQ’s Socks</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    long long a,b,ans,kase=0;\n    while(~scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b)){\n        if(b&lt;=a){\n            printf(&quot;Case #%lld: %lld\\n&quot;,++kase,b);\n            continue;\n        }else{\n            long long loop=(a-1)&lt;&lt;1,rg=b-a;\n            long long res=rg%loop;\n            if(res==a-1) ans=a-1;\n            else if(res==0) ans=a;\n            else\n                ans=res&gt;a-1?res-a+1:res;\n            printf(&quot;Case #%lld: %lld\\n&quot;,++kase,ans);\n        }\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:KazaQ’s Socks 题意:穿袜子,洗袜子,求洗了多少次袜子…:sweat_smile: 题解:无 github: :point_right:KazaQ’s Socks#include&lt;bits/stdc++.h&gt;using","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"}]}]}