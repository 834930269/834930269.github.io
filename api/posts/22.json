{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"ccf 2017前四题","slug":"ccf-2017-pre-f","date":"2017-08-19T05:25:33.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2017-pre-f.json","excerpt":"","keywords":null,"cover":null,"content":"<p>第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *<em>要登录和会员 *</em> <a href=\"http://118.190.20.162/home.page\" target=\"_blank\" rel=\"noopener\">http://118.190.20.162/home.page</a> github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/tree/master/CCSP/2017-3\" title=\"CCF 2017-3 前四题\" target=\"_blank\" rel=\"noopener\">CCF 2017-3 前四题</a> 第一题:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    int N,K;\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;K)){\n        int ans=0,d,n=0;\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;d);\n            n+=d;\n            if(n&gt;=K){\n                n=0;\n                ans++;\n            }\n        }\n        if(n)ans++;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>第二题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint N,M;\nint I,J;\n\nlist&lt;int&gt; li;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        li.clear();\n        for(int i=1;i&lt;=N;++i){\n            li.push_back(i);\n        }\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%d%d&quot;,&amp;I,&amp;J);\n            if(J==0)continue;\n            list&lt;int&gt;::iterator it,it2;\n            for(it=li.begin();*it!=I;it++){}\n            it2=it;\n            int flag=J&gt;0?1:-1;\n            J=abs(J)+(flag&gt;0?1:0);\n            while(J){\n                J--;\n                flag&gt;0?it++:it--;\n            }\n            li.insert(it,I);\n            li.erase(it2);\n        }\n        list&lt;int&gt;::iterator it;\n        it=li.begin();\n        printf(&quot;%d&quot;,*it);\n        it++;\n        for(;it!=li.end();it++){\n            printf(&quot; %d&quot;,*it);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>第三题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define BUF_SS 101\n\nusing namespace std;\n\nchar buf[101];\nint pre=-1;\n\nint check_hl(int st){\n    char hr[100];\n    string tip;\n    int ind=st+1,cs=0,hs=0;\n    while(buf[ind]!=&apos;]&apos;){\n        if(buf[ind]==&apos;_&apos;){\n            tip+=&quot;&lt;em&gt;&quot;;\n            ind++;\n            while(buf[ind]!=&apos;_&apos;){\n                tip+=buf[ind];\n                ind++;\n            }\n            tip+=&quot;&lt;/em&gt;&quot;;\n            ind++;\n        }else{\n            tip+=buf[ind];\n            ind++;\n        }\n    }\n    ind+=2;\n    while(buf[ind]!=&apos;)&apos;){\n        hr[hs++]=buf[ind];\n        ind++;\n    }\n    hr[hs]=&apos;\\0&apos;;\n    printf(&quot;&lt;a href=\\&quot;%s\\&quot;&gt;&quot;,hr);\n    cout&lt;&lt;tip&lt;&lt;&quot;&lt;/a&gt;&quot;;\n    return ind-st;\n}\n\nint check_em(int st){\n    int ind=st+1;\n    printf(&quot;&lt;em&gt;&quot;);\n    while(buf[ind]!=&apos;_&apos;){\n        if(buf[ind]==&apos;[&apos;){\n            int ed=check_hl(ind);\n            ind+=(ed+1);\n        }else{\n            putchar(buf[ind]);\n            ind++;\n        }\n    }\n    printf(&quot;&lt;/em&gt;&quot;);\n    return ind-st;\n}\n\nvoid check_h(int sz){\n    int n,r=0;\n    char sts[20],ste[20];\n    while(buf[r]==&apos;#&apos;){\n        r++;\n    }\n    int s=r,e=sz-1;\n    sprintf(sts,&quot;&lt;h%d&gt;&quot;,r);\n    sprintf(ste,&quot;&lt;/h%d&gt;&quot;,r);\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;%s&quot;,sts);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;%s\\n&quot;,ste);\n}\n\nvoid check_u(int sz){\n    if(pre!=2)printf(&quot;&lt;ul&gt;\\n&quot;);\n    int s=1,e=sz-1;\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;&lt;li&gt;&quot;);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;&lt;/li&gt;\\n&quot;);\n}\n\nvoid check_p(int sz){\n    if(pre!=3)printf(&quot;&lt;p&gt;&quot;);\n    if(pre==3)putchar(&apos;\\n&apos;);\n    for(int i=0;buf[i]!=&apos;\\n&apos; &amp;&amp; i&lt;sz;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n}\n\nint main(){\n    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n    while(fgets(buf,BUF_SS,stdin)){\n        if(buf[0]==&apos;\\n&apos;){\n            if(pre==3){\n                printf(&quot;&lt;/p&gt;\\n&quot;);\n                pre=0;continue;\n            }else if(pre==2){\n                printf(&quot;&lt;/ul&gt;\\n&quot;);\n                pre=0;continue;\n            }\n            continue;\n        }\n        int sz=strlen(buf);\n        if(buf[0]==&apos;#&apos;) check_h(sz),pre=1;\n        else if(buf[0]==&apos;*&apos;) check_u(sz),pre=2;\n        else check_p(sz),pre=3;\n    }\n    if(pre==3)printf(&quot;&lt;/p&gt;\\n&quot;);\n    if(pre==2)printf(&quot;&lt;/ul&gt;\\n&quot;);\n    return 0;\n}</code></pre><p>写题的时候写了一组测试数据: In[1]:</p>\n<pre><code># Heading\n\n## Sub-heading\n\nParagraphs are separated\nby a blank line.\n\nText attributes _italic_.\n\nBullet list:\n\n*      apples\n* oranges\n* pears\n\nA _[NLJ6link616lins1](http://example.com)_.\n\n[NLJ6_link_616_lins_1](http://example.com)</code></pre><p>out[1]:</p>\n<pre><code>&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;h2&gt;Sub-heading&lt;/h2&gt;\n&lt;p&gt;Paragraphs are separated\nby a blank line.&lt;/p&gt;\n&lt;p&gt;Text attributes &lt;em&gt;italic&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Bullet list:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;apples&lt;/li&gt;\n&lt;li&gt;oranges&lt;/li&gt;\n&lt;li&gt;pears&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A &lt;em&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6link616lins1&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6&lt;em&gt;link&lt;/em&gt;616&lt;em&gt;lins&lt;/em&gt;1&lt;/a&gt;&lt;/p&gt;</code></pre><p>第四题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAX_M=200000+10;\nconst int maxn=200000+10;\nint N,M;\nint A,B,C;\n\nstruct Edge{\n    int from,to,dist;\n};\nstruct HeapNode{\n    int d,from,to;\n    bool operator&lt;(const HeapNode&amp; rhs)const{\n        return d&gt;rhs.d;\n    }\n};\n\nstruct Kruskal{\n    int n,m;///点数和边数\n    vector&lt;Edge&gt; edges;///边表\n    vector&lt;int&gt; G[maxn];///每个节点出发的边编号\n    priority_queue&lt;HeapNode&gt; Q;\n\n    ///并查集\n    int fa[maxn];///父亲\n    int ra[maxn];///高度\n    ///init:初始化(点数)\n    ///find_Root:查找树的根\n    ///unite:合并x和y所属集合\n    ///same:判断x和y是否是同一个集合\n    void init(int n){\n        this-&gt;n=n;\n        for(int i=0;i&lt;n;++i){\n            fa[i]=i;\n            ra[i]=0;\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    int find_Root(int x){\n        if(fa[x]==x){\n            return x;\n        }else{\n            return fa[x]=find_Root(fa[x]);\n        }\n    }\n    void unite(int x,int y){\n        x=find_Root(x);\n        y=find_Root(y);\n        if(x==y) return;\n\n        if(ra[x]&lt;ra[y]){\n            fa[x]=y;\n        }else{\n            fa[y]=x;\n        }\n    }\n    bool same(int x,int y){\n        return find_Root(x)==find_Root(y);\n    }\n\n    void AddEdge(int from,int to,int dist){\n        edges.push_back((Edge){from,to,dist});\n        m=edges.size()-1;\n        G[from].push_back(m-1);\n        Q.push((HeapNode){dist,from,to});\n    }\n\n    int kruskal(){\n        HeapNode h;\n        while(!Q.empty()){\n            if(find_Root(N)==find_Root(1))break;\n            h=Q.top();Q.pop();\n            if(find_Root(h.from)==find_Root(h.to))continue;\n            unite(h.from,h.to);\n        }\n        printf(&quot;%d\\n&quot;,h. d);\n    }\n}K;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        K.init(N);\n        for(int i=0;i&lt;M;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);\n            K.AddEdge(A,B,C);\n        }\n        K.kruskal();\n    }\n    return 0;\n}</code></pre>","text":"第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *要登录和会员 * http://118.190.20.162/home.page git","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"kruskal","slug":"ccf/kruskal","count":1,"path":"api/categories/ccf/kruskal.json"},{"name":"并查集","slug":"ccf/kruskal/并查集","count":1,"path":"api/categories/ccf/kruskal/并查集.json"},{"name":"模拟","slug":"ccf/kruskal/并查集/模拟","count":1,"path":"api/categories/ccf/kruskal/并查集/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"},{"name":"CCF","slug":"CCF","count":1,"path":"api/tags/CCF.json"}]},{"title":"CodeVS 1344","slug":"codevs-1344","date":"2017-08-19T05:04:23.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/codevs-1344.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型:概率演算-模拟退火 题目连接::earth_africa:<a href=\"http://www.codevs.cn/problem/1344/\" title=\"CodeVS-1344\" target=\"_blank\" rel=\"noopener\">CodeVS-1344</a> 模拟退火+题解: :earth_asia:<a href=\"https://zhuanlan.zhihu.com/p/23968011\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/23968011</a> github: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/CodeVS/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/1344.cpp\" title=\"1344.cpp\" target=\"_blank\" rel=\"noopener\">1344.cpp</a> Code:</p>\n<pre><code>#define F(i,n) for(int i=0;i&lt;n;++i)\n#define Fi(i,n) for(int i=1;i&lt;=n;++i)\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=21;\nint n;\ndouble x[maxn],y[maxn];\ndouble dist[maxn][maxn];\nstruct Path{\n    int path[maxn];\n    Path(){\n        F(i,n) path[i]=i;\n    }\n    Path(const Path&amp; p){\n        memcpy(path,p.path,sizeof(path));\n        swap(path[rand()%n],path[rand()%n]);\n    }\n    double dist(){\n        double ans=0;\n        for(int i=1;i&lt;n;++i){\n            ///解决重名的办法\n            ans+= ::dist[path[i-1]][path[i]];\n        }\n        return ans;\n    }\n};\n\nbool accept(double delta,double temper){\n    if(delta&lt;=0) return true;\n    return rand()&lt;=exp((-delta)/temper)*RAND_MAX;\n}\n\ndouble solve(){\n    const double max_temper=10000;\n    const double dec=0.999;\n    double temp=max_temper;\n    Path p;\n    while(temp&gt;0.01){\n        Path p2(p);\n        if(accept(p2.dist()-p.dist(),temp)) p=p2;\n        temp*=dec;\n    }\n    return p.dist();\n}\n\nint main(){\n    srand(19260817U);\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%lf%lf&quot;,x+i,y+i);\n    }\n    for(int i=0;i&lt;n;++i){\n        dist[i][i]=0;\n        for(int j=i+1;j&lt;n;++j){\n            dist[i][j]=dist[j][i]=hypot(x[i]-x[j],y[i]-y[j]);\n        }\n    }\n    double ans=0x3f3f3f3f;\n    int T=155;\n    while(T--){\n        ans=min(ans,solve());\n    }\n    printf(&quot;%.2lf&quot;,ans);\n    return 0;\n}</code></pre>","text":"类型:概率演算-模拟退火 题目连接::earth_africa:CodeVS-1344 模拟退火+题解: :earth_asia:https://zhuanlan.zhihu.com/p/23968011 github: :earth_asia:1344.cpp Code:#de","link":"","raw":null,"photos":[],"categories":[{"name":"CodeVS","slug":"CodeVS","count":1,"path":"api/categories/CodeVS.json"},{"name":"模拟退火","slug":"CodeVS/模拟退火","count":1,"path":"api/categories/CodeVS/模拟退火.json"}],"tags":[{"name":"CodeVS","slug":"CodeVS","count":1,"path":"api/tags/CodeVS.json"},{"name":"模拟退火","slug":"模拟退火","count":1,"path":"api/tags/模拟退火.json"}]},{"title":"最近的多校和codeforce(未补题状态","slug":"current-multi-cf","date":"2017-08-15T14:20:45.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/current-multi-cf.json","excerpt":"","keywords":null,"cover":null,"content":"<p>codeforce: Round428 div2 A: 戳这里-&gt; :earth_americas:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/428DIV2%20A.cpp\" title=\"428DIV2 A.cpp\" target=\"_blank\" rel=\"noopener\">428DIV2 A.cpp</a> Round428 div2 B: 戳这里-&gt; :earth_americas:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/428DIV2B.cpp\" title=\"428DIV2 B.cpp\" target=\"_blank\" rel=\"noopener\">428DIV2 B.cpp</a> 多校: 戳这里-&gt; :earth_americas: <a href=\"https://github.com/834930269/Other_OJ/tree/master/Multi-University%20Training%20Contest\" title=\"水题集合φ(&gt;ω&lt;*) \" target=\"_blank\" rel=\"noopener\">水题集合φ(&gt;ω&lt;*)</a></p>\n","text":"codeforce: Round428 div2 A: 戳这里-&gt; :earth_americas:428DIV2 A.cpp Round428 div2 B: 戳这里-&gt; :earth_americas:428DIV2 B.cpp 多校: 戳这里-&gt; :ear","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"Codeforce","slug":"2017多校/Codeforce","count":1,"path":"api/categories/2017多校/Codeforce.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"推一波喜欢的漫画","slug":"on-yonder-lea","date":"2017-08-12T10:59:26.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/on-yonder-lea.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/08/tumblr_o0ejn6DpQ11v43xego1_1280.jpg","content":"<p>On Yonder Lea ,I’d Shelter Thee. :earth_africa:<a href=\"https://onyonder.tumblr.com/\" title=\"by William Adams\" target=\"_blank\" rel=\"noopener\">by William Adams</a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/08/tumblr_o0ejn6DpQ11v43xego1_1280.jpg\" title=\"feel_sad\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/tumblr_o0ejn6DpQ11v43xego1_1280.jpg\" alt=\"feel_sad\" title=\"feel_sad\"></a></p>\n","text":"On Yonder Lea ,I’d Shelter Thee. :earth_africa:by William Adams  [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"python站 第一次更新","slug":"python-fb","date":"2017-08-11T06:56:11.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-fb.json","excerpt":"","keywords":null,"cover":null,"content":"<p>link: <a href=\"http://be-sunshine.cn:81/blog/0015024342574655180f051270a4a029c3c1a1ecc95fca0000\" title=\"第一次更新 - Mr.赝\" target=\"_blank\" rel=\"noopener\">第一次更新 - Mr.赝</a> 更新内容: <a href=\"http://be-sunshine.cn:81/signin\" title=\"登录界面优化\" target=\"_blank\" rel=\"noopener\">登录界面优化</a></p>\n","text":"link: 第一次更新 - Mr.赝 更新内容: 登录界面优化","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"}],"tags":[]},{"title":"POJ 3468","slug":"poj-3468","date":"2017-08-07T11:10:00.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/poj-3468.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:<a href=\"https://vjudge.net/problem/POJ-3468\" title=\"POJ-3468\" target=\"_blank\" rel=\"noopener\">POJ-3468</a> 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问a<del>b这段数的和，‘C a b c’是把a</del>b这段数都加上c。 题解: 区间问题,首先想到线段树,这里我们建两个线段树.data,datb. data用来维护区间所更新的值. datb则用来维护区间的和. 计算的时候只需要 每部分的区间和 + 每部分更新的值 即为最终答案.(百度说这叫Lazy思想.) github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-3468.cpp\" title=\"POJ-3468.cpp\" target=\"_blank\" rel=\"noopener\">POJ-3468.cpp</a> Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n///区间更新\ntypedef long long ll;\n\nconst int DAT_SIZE=(1&lt;&lt;18)-1;\nconst int MAX_N=100000+10;\nconst int MAX_Q=100000+10;\n\nint N,Q;\nint A[MAX_N];\nchar T[MAX_Q];\nint L[MAX_Q],R[MAX_Q],X[MAX_Q];\n\n///线段树,a维护区间应加值,b维护区间和\nll data[DAT_SIZE],datb[DAT_SIZE];\n\n///对区间[a,b]同时加x\n///k是节点编号,对应的区间是[l,r)\nvoid add(int a,int b,int x,int k,int l,int r){\n    if(a&lt;=l&amp;&amp;r&lt;=b){\n        data[k]+=x;\n    }else if(l&lt;b &amp;&amp; a&lt;r){\n        datb[k]+=(min(b,r)-max(a,l))*x;\n        add(a,b,x,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        add(a,b,x,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n    }\n}\n\n///计算[a,b)的和\nll sum(int a,int b,int k,int l,int r){\n    if(b&lt;=l || a&gt;=r){\n        return 0;\n    }else if(a&lt;=l &amp;&amp; r&lt;=b){\n        return data[k]*(r-l)+datb[k];\n    }else{\n        ll res=(min(b,r)-max(a,l))*data[k];\n        res+=sum(a,b,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        res+=sum(a,b,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n        return res;\n    }\n}\n\n///下标0开头的线段树初始化\n///开区间[a,b)\nvoid solve(){\n    for(int i=0;i&lt;N;++i){\n        add(i,i+1,A[i],0,0,N);\n//        printf(&quot;\\nadd: %d -&gt; %d\\n&quot;,i,A[i]);\n    }\n    for(int i=0;i&lt;Q;++i){\n        if(T[i]==&apos;C&apos;){\n            add(L[i],R[i]+1,X[i],0,0,N);\n        }else{\n            printf(&quot;%lld\\n&quot;,sum(L[i],R[i]+1,0,0,N));\n        }\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;Q)==2){\n        memset(data,0,sizeof(data));\n        memset(datb,0,sizeof(datb));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;A[i]);\n        }\n        ///区间是[0...N)所以要减一\n        for(int i=0;i&lt;Q;++i){\n            scanf(&quot;%*c%c&quot;,&amp;T[i]);\n            if(T[i]==&apos;C&apos;){\n                scanf(&quot;%d%d%d&quot;,&amp;L[i],&amp;R[i],&amp;X[i]);\n                L[i]-=1;R[i]-=1;\n            }else{\n                scanf(&quot;%d%d&quot;,&amp;L[i],&amp;R[i]);\n                L[i]-=1;R[i]-=1;\n            }\n        }\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:POJ-3468 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问ab这段数的和，‘C a b c’是把ab这段数都加上c。 题解: 区间问题,首先想","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2991","slug":"poj-2991","date":"2017-08-05T14:44:10.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/poj-2991.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树 题目连接: :earth_asia:<a href=\"http://poj.org/problem?id=2991\" title=\"Crane\" target=\"_blank\" rel=\"noopener\">POJ-Crane</a> 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子区间的向量+右子区间的向量。 求一个向量（x0,y0）逆时针旋转B度后的向量有一个公式： x1= x0 * cosB - y0 * sinB y1 = x0 * sinB + y0 * cosB 顺时针就把-B代入： x1= x0 * cosB + y0 * sinB y1 = -x0 * sinB + y0 * cosB github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-2991.CPP\" title=\"POJ 2991.cpp\" target=\"_blank\" rel=\"noopener\">POJ 2991.cpp</a> Code:</p>\n<pre><code>#define _USE_MATH_DEFINES///使用math库中的定义\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\nusing namespace std;\n\nconst int ST_SIZE=(1&lt;&lt;15)-1;\nconst int MAX_N=10010;\nconst int MAX_C=10010;\n\nint N,C;\nint L[MAX_N];\nint S[MAX_C],A[MAX_N];\n\ndouble vx[ST_SIZE],vy[ST_SIZE]; ///各节点的向量\ndouble ang[ST_SIZE]; ///各节点的角度\n\ndouble prv[MAX_N];\n\n///初始化线段树\nvoid init(int k,int l,int r){\n    ang[k]=vx[k]=0.0;\n    if(r-l==1){\n        ///叶子结点\n        vy[k]=L[l];\n    }else{\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        init(chl,l,(l+r)&gt;&gt;1);\n        init(chr,(l+r)&gt;&gt;1,r);\n        vy[k]=vy[chl]+vy[chr];\n    }\n}\n\n///把s和s+1的角度变为a\n///v是节点编号,l,r表示当前结点对应的是[l,r]区间\nvoid update(int s,double a,int k,int l,int r){\n    if(s&lt;=l) return;\n    else if(s&lt;r){\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        int m=(l+r)&gt;&gt;1;\n        update(s,a,chl,l,m);\n        update(s,a,chr,m,r);\n        if(s&lt;=m) ang[k]+=a;\n\n        double s=sin(ang[k]),c=cos(ang[k]);\n        vx[k]=vx[chl]+(c*vx[chr]-s*vy[chr]);\n        vy[k]=vy[chl]+(s*vx[chr]+c*vy[chr]);\n    }\n}\n\nvoid solve(){\n    init(0,0,N);\n    for(int i=0;i&lt;C;++i){\n        int s=S[i];\n        double a=A[i]/360.0*2*M_PI;///把角度换算成弧度\n        update(s,a-prv[s],0,0,N);\n        prv[s]=a;\n\n        printf(&quot;%.2f %.2f\\n&quot;,vx[0],vy[0]);\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;C)==2){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;L[i]);\n            prv[i]=M_PI;///180°的弧度值\n        }\n        for(int i=0;i&lt;C;++i)\n            scanf(&quot;%d%d&quot;,&amp;S[i],&amp;A[i]);\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树 题目连接: :earth_asia:POJ-Crane 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"基于python3+mysql+nginx的个人博客","slug":"python3-end-blog-2","date":"2017-08-03T02:11:46.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/python3-end-blog-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg","content":"<p>一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而第三个博客是用nginx,所以使用了不同的端口号,以防冲突): 点击这里=&gt; :octocat:<a href=\"http://be-sunshine.cn:81\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn:81</a> 开源: (github上,暂时还未和python学习篇分开,回头分开再贴,Orz =3 )<del>~</del> 愿我永远有一颗不变的心! <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg\" alt></p>\n","text":"一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"全栈","slug":"Python/全栈","count":1,"path":"api/categories/Python/全栈.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"全栈","slug":"全栈","count":1,"path":"api/tags/全栈.json"}]},{"title":"2017多校训练2 HDU 6047 Maximum Sequence","slug":"2017-hdu-6047-maximum-sequence","date":"2017-07-29T04:51:07.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6047-maximum-sequence.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6047\" title=\"Maximum Sequence\" target=\"_blank\" rel=\"noopener\">Maximum Sequence</a> 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,记录每个i到maxindex(A)的最大值,然后动态更新. github: 1.线段树法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003_Range_Tree.cpp\" title=\"1003_Range_Tree.cpp\" target=\"_blank\" rel=\"noopener\">1003_Range_Tree.cpp</a> 2.暴力动态更新法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003.cpp\" title=\"1003.cpp\" target=\"_blank\" rel=\"noopener\">1003.cpp</a></p>\n<pre><code>///线段树法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst int maxnode=2000050;\n\nint b[maxnode],N;\nint maxv[maxnode];\n\nvoid build(int o,int l,int r){\n    if(l==r){\n        if(l&gt;N) return;///预先分配2*N个结点\n        scanf(&quot;%d&quot;,&amp;maxv[o]);maxv[o]-=l;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(o&lt;&lt;1,l,mid);\n    build(o&lt;&lt;1|1,mid+1,r);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint query(int o,int l,int r,int ll,int rr){\n    if(l&gt;=ll&amp;&amp;r&lt;=rr) return maxv[o];\n    int ma=-1,mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=ll) ma=max(ma,query(o&lt;&lt;1,l,mid,ll,rr));\n    if(rr&gt;mid) ma=max(ma,query(o&lt;&lt;1|1,mid+1,r,ll,rr));\n    return ma;\n}\n\nvoid update(int o,int l,int r,int p,int val){\n    if(l==r){\n        maxv[o]=val;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    if(p&lt;=mid)update(o&lt;&lt;1,l,mid,p,val);\n    else update(o&lt;&lt;1|1,mid+1,r,p,val);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        build(1,1,2*N);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        LL ans=0;\n        for(int i=N+1;i&lt;=2*N;++i){\n            int k=query(1,1,2*N,b[i-N],i-1);\n            update(1,1,2*N,i,k-i);\n            ans=(ans+k)%mod;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n\n///HDU 6047 暴力动态更新法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=500000+50;\nconst int mod=1e9+7;\nint N;\nint a[maxn],b[maxn],maxa[maxn];\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=1;i&lt;=N;++i){\n            int aa;\n            scanf(&quot;%d&quot;,&amp;aa);\n            a[i]=aa-i;\n        }\n        maxa[N]=a[N];\n        for(int i=N-1;i&gt;=1;--i) maxa[i]=max(maxa[i+1],a[i]);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        long long ans=0;\n        ans=(ans+maxa[b[1]])%mod;\n        int t=maxa[b[1]]-N-1;\n        for(int i=2;i&lt;=N;++i){\n            maxa[b[i]]=max(maxa[b[i]],t);\n            ans=(ans+maxa[b[i]])%mod;\n            t=max(t,maxa[b[i]]-N-1);\n        }\n        printf(&quot;%lld\\n&quot;,ans%mod);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: :point_right:Maximum Sequence 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"segmentTree","slug":"2017多校/segmentTree","count":1,"path":"api/categories/2017多校/segmentTree.json"},{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"path":"api/categories/2017多校/segmentTree/思维.json"},{"name":"线段树","slug":"2017多校/segmentTree/思维/线段树","count":1,"path":"api/categories/2017多校/segmentTree/思维/线段树.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"python3学习 数据库","slug":"python3-database","date":"2017-07-29T01:32:25.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-database.json","excerpt":"","keywords":null,"cover":null,"content":"<p>文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Database\" title=\"Database仓库\" target=\"_blank\" rel=\"noopener\">Database仓库</a></p>\n","text":"文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:Database仓库","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}]}