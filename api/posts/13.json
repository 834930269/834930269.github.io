{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"Java I/O","slug":"java-i-o","date":"2018-01-16T05:43:46.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-i-o.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png","content":"<p>[toc]</p>\n<h1><span id=\"io\">I/O</span></h1><h2><span id=\"文件对象\">文件对象</span></h2><h3><span id=\"创建一个文件对象\">创建一个文件对象</span></h3><pre><code>package file;\n\nimport java.io.File;\n\npublic class TestFile {\n    public static void main(String[] args){\n        //绝对路径\n        File f1=new File(&quot;d:/LOLFolder&quot;);\n        System.out.println(&quot;f1的绝对路径: &quot; + f1.getAbsolutePath());\n        //相对路径,相对于工作目录,如果在eclipse中,就是项目目录\n        File f2=new File(&quot;LOL.exe&quot;);\n        System.out.println(&quot;f2的绝对路径: &quot;+f2.getAbsolutePath());\n        //把f1作为父目录创建文件对象\n        File f3=new File(f1,&quot;LOL.exe&quot;);\n        System.out.println(&quot;f3的绝对路径: &quot;+f3.getAbsolutePath());\n    }\n}</code></pre><p>输出:</p>\n<pre><code>f1的绝对路径: d:\\LOLFolder\nf2的绝对路径: D:\\Java\\Learning\\LOL.exe\nf3的绝对路径: d:\\LOLFolder\\LOL.exe</code></pre><h3><span id=\"文件常用方法\">文件常用方法</span></h3><p>exists() -是否存在 isDirectory() -是否是文件夹 isFile() -是否是文件 length() -长度 lastModified() -文件最后修改时间 setlastModified() -修改文件最后修改时间 renameTo(f2 type is File) -把名字改成f2的名字,两个文件必须存在</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.util.Date;\n\npublic class Method {\n    public static void main(String args[]){\n        File f = new File(&quot;d:/LOLFolder/LOL.exe&quot;);\n        System.out.println(&quot;当前文件是：&quot; +f);\n        //文件是否存在\n        System.out.println(&quot;判断是否存在：&quot;+f.exists());\n\n        //是否是文件夹\n        System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());\n\n        //是否是文件（非文件夹）\n        System.out.println(&quot;判断是否是文件：&quot;+f.isFile());\n\n        //文件长度\n        System.out.println(&quot;获取文件的长度：&quot;+f.length());\n\n        //文件最后修改时间\n        long time = f.lastModified();\n        Date d = new Date(time);\n        System.out.println(&quot;获取文件的最后修改时间：&quot;+d);\n        //设置文件修改时间为1970.1.1 08:00:00\n        f.setLastModified(0);\n\n        //文件重命名\n        File f2 =new File(&quot;d:/LOLFolder/DOTA.exe&quot;);\n        f.renameTo(f2);\n        System.out.println(&quot;把LOL.exe改名成了DOTA.exe&quot;);\n\n        System.out.println(&quot;注意： 需要在D:\\\\LOLFolder确实存在一个LOL.exe,\\r\\n才可以看到对应的文件长度、修改时间等信息&quot;);\n    }\n}</code></pre><p>输出:</p>\n<pre><code>当前文件是：d:\\LOLFolder\\LOL.exe\n判断是否存在：false\n判断是否是文件夹：false\n判断是否是文件：false\n获取文件的长度：0\n获取文件的最后修改时间：Thu Jan 01 08:00:00 GMT+08:00 1970\n把LOL.exe改名成了DOTA.exe\n注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\n才可以看到对应的文件长度、修改时间等信息</code></pre><h3><span id=\"文件的常用方法2\">文件的常用方法2</span></h3><p>list() -以字符串数组的形式，返回当前文件夹下的所有文件 File[] fs=f.listFiles() -以文件数组的形式，返回当前文件夹下的所有文件 getParent() -以字符串形式返回所在文件夹 getParentFile() -以文件形式返回获取所在文件夹 mkdir() -创建文件夹,如果父目录不存在,创建失败 mkdirs() -如果父目录不存在,一样创建 createNewFile() -创建新文件,父目录不存在,抛异常 listRoots() -盘符c: d: delete() -删除 deleteOnExit() -JVM结束时删除</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class Method2 {\n    public static void main(String[] args) throws IOException {\n\n        File f = new File(&quot;d:/LOLFolder/skin/garen.ski&quot;);\n\n        // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）\n        f.list();\n\n        // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）\n        File[]fs= f.listFiles();\n\n        // 以字符串形式返回获取所在文件夹\n        f.getParent();\n\n        // 以文件形式返回获取所在文件夹\n        f.getParentFile();\n        // 创建文件夹，如果父文件夹skin不存在，创建就无效\n        f.mkdir();\n\n        // 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹\n        f.mkdirs();\n\n        // 创建一个空文件,如果父文件夹skin不存在，就会抛出异常\n        f.createNewFile();\n        // 所以创建一个空文件之前，通常都会创建父目录\n        f.getParentFile().mkdirs();\n\n        // 列出所有的盘符c: d: e: 等等\n        f.listRoots();\n\n        // 刪除文件\n        f.delete();\n\n        // JVM结束的时候，刪除文件，常用于临时文件的删除\n        f.deleteOnExit();\n\n    }\n}</code></pre><p>流<br>-</p>\n<h3><span id=\"什么是流\">什么是流</span></h3><p><strong>流即一系列数据.</strong> 当不同的介质之间有数据交互的时候，JAVA就使用流来实现。 数据源可以是文件，还可以是数据库，网络甚至是其他的程序 比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流 输入流： InputStream 输出流：OutputStream</p>\n<h3><span id=\"文件输入流\">文件输入流</span></h3><pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class Stream {\n    public static void main(String[] args) {\n        try {\n            File f = new File(&quot;d:/lol.txt&quot;);\n            // 创建基于文件的输入流\n            FileInputStream fis = new FileInputStream(f);\n            // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟中来，也就是读取到内存中\n\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3><span id=\"文件读入与输出\">文件读入与输出</span></h3><pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class bytes {\n    //FileInputStream是InputStream的子类\n    public static void main(String[] args){\n        try{\n            //从文件读入\n            File f=new File(&quot;log.txt&quot;);\n            //创建基于文件的输入流\n            FileInputStream fis=new FileInputStream(f);\n            //创建字节数组,其长度就是文件的长度\n            byte[] all=new byte[(int)f.length()];\n            //以字节流的形式读取文件所有内容\n            fis.read(all);\n            for(byte b:all){\n                System.out.println(b);\n            }\n\n            //每次使用完毕关闭\n            fis.close();\n\n\n            //向文件输出\n            File f1=new File(&quot;log1.txt&quot;);\n            byte data[]={88,89};\n            FileOutputStream fos=new FileOutputStream(f1);\n            fos.write(data);\n            fos.close();\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3><span id=\"关闭文件时需要注意\">关闭文件时需要注意</span></h3><p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端； 如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用 最标准的写法是在 finally 中关闭文件. 1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally. 2. 在finally关闭之前，要先判断该引用是否为空 3. 关闭的时候，需要再一次进行try catch处理 使用try()方式.其使用方法和C#的using(),Python的with一样.</p>\n<h3><span id=\"字符流\">字符流</span></h3><p>这节之前都是字节流 Reader字符输入流 Writer字符输出流 专门用于字符的形式读取和写入数据</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class CharacterStream {\n    public static void main(String[] args){\n        File f=new File(&quot;log.txt&quot;);\n        try(FileReader fr=new FileReader(f)){\n            //以字符流读入到char数组中\n            char[] all=new char[(int)f.length()];\n            fr.read(all);\n            for(char ch : all){\n                System.out.println(ch);\n            }\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n\n        File f1=new File(&quot;log1.txt&quot;);\n        try(FileWriter fr=new FileWriter(f1)){\n            String data=&quot;abcdefghijklmn123456789&quot;;\n            //字符串转字符数组\n            char[] cs=data.toCharArray();\n            fr.write(cs);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3><span id=\"中文编码问题\">中文编码问题</span></h3><p>1.中文编码</p>\n<pre><code>package file;\n\nimport java.io.UnsupportedEncodingException;\n//以字符 中 为例，查看其在不同编码方式下的值是多少\n\npublic class encode {\n    public static void main(String[] args){\n        String str = &quot;中&quot;;\n        showCode(str);\n    }\n\n    private static void showCode(String str){\n        String[] encodes={&quot;BIG5&quot;,&quot;GBK&quot;,&quot;GB2312&quot;,&quot;UTF-8&quot;,&quot;UTF-16&quot;,&quot;UTF32&quot;};\n        for(String encode : encodes){\n            showCode(str,encode);\n        }\n    }\n\n    private static void showCode(String str,String encode){\n        try{\n            //格式化输出用printf\n            System.out.printf(&quot;字符: \\&quot;%s\\&quot; 的在编码方式%s下的十六进制是%n&quot;,str,encode);\n            //str获取encode编码的byte数组 \n            byte[] bs=str.getBytes(encode);\n            for(byte b: bs){\n                //只显示每字节的低两位\n                int i=b&amp;0xff;\n                //toHex =&gt; 16进制\n                System.out.print(Integer.toHexString(i) + &quot;\\t&quot;);\n            }\n            System.out.println();\n            System.out.println();\n        }catch(UnsupportedEncodingException e){\n            System.out.printf(&quot;UnsupportedEncodingException: %s编码方式无法解析字符%s\\n&quot;, encode, str);\n        }\n    }\n}</code></pre><p>2.文件流读取中文</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\n\npublic class fileEncode {\n    public static void main(String[] args) throws UnsupportedEncodingException, FileNotFoundException {\n        File f = new File(&quot;test.txt&quot;);\n        System.out.println(&quot;默认编码方式:&quot;+Charset.defaultCharset());\n        //FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了\n        //而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK\n        try (FileReader fr = new FileReader(f)) {\n            char[] cs = new char[(int) f.length()];\n            fr.read(cs);\n            System.out.printf(&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;,Charset.defaultCharset());\n            System.out.println(new String(cs));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        //FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替\n        //并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式\n        try (InputStreamReader isr = new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))) {\n            char[] cs = new char[(int) f.length()];\n            isr.read(cs);\n            System.out.printf(&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;);\n            System.out.println(new String(cs));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}</code></pre><h3><span id=\"缓存流\">缓存流</span></h3><pre><code>package file;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n//缓存流\npublic class Buffer {\n    public static void main(String[] args) {\n        //缓存流读取\n        {\n            // 准备文件lol.txt其中的内容是\n            // garen kill teemo\n            // teemo revive after 1 minutes\n            // teemo try to garen, but killed again\n            File f = new File(&quot;log.txt&quot;);\n            // 创建文件字符流\n            // 缓存流必须建立在一个存在的流的基础上\n            try (\n                    FileReader fr = new FileReader(f);\n                    //BufferedReader的带参构造函数是一个流\n                    BufferedReader br = new BufferedReader(fr);\n                )\n            {\n                while (true) {\n                    // 一次读一行\n                    String line = br.readLine();\n                    if (null == line)\n                        break;\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        //缓存流写出\n        {\n            File f=new File(&quot;log1.txt&quot;);\n            try(\n                //创建文件字符流\n                FileWriter fw=new FileWriter(f);\n                //缓存流必须建立在一个存在的流的基础上\n                PrintWriter pw=new PrintWriter(fw);\n            ){\n                //直接pw.println\n                pw.println(&quot;garen kill teemo&quot;);\n                //如果想要在不是缓存满了才写入硬盘\n                //就需要使用pw.flush()\n                //pw.flush()\n                //否则会在缓存满了或者结束才写入到硬盘中\n                pw.println(&quot;teemo revive after 1 minutes&quot;);\n                pw.println(&quot;teemo try to garen, but killed again&quot;);\n            }catch(IOException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre><h3><span id=\"对象流\">对象流</span></h3><p>即常见的 Serializable 将对象流化方便传递. 必须实现Serializable接口 Hero类</p>\n<pre><code>package charactor;\n\nimport java.io.Serializable;\n\npublic class Hero implements Serializable {\n    //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号\n    private static final long serialVersionUID = 1L;\n    public String name;\n    public float hp;\n\n}</code></pre><p>应用:</p>\n<pre><code>package stream;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport charactor.Hero;\n\npublic class TestStream {\n\n    public static void main(String[] args) {\n        //创建一个Hero garen\n        //要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口\n        Hero h = new Hero();\n        h.name = &quot;garen&quot;;\n        h.hp = 616;\n\n        //准备一个文件用于保存该对象\n        File f =new File(&quot;d:/garen.lol&quot;);\n\n        try(\n            //创建对象输出流\n            FileOutputStream fos = new FileOutputStream(f);\n            ObjectOutputStream oos =new ObjectOutputStream(fos);\n            //创建对象输入流              \n            FileInputStream fis = new FileInputStream(f);\n            ObjectInputStream ois =new ObjectInputStream(fis);\n        ) {\n            oos.writeObject(h);\n            Hero h2 = (Hero) ois.readObject();\n            System.out.println(h2.name);\n            System.out.println(h2.hp);\n\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}</code></pre><h2><span id=\"常用的控制台输入systeminscanner\">常用的控制台输入System.in(Scanner)</span></h2><pre><code>package stream;\n\nimport java.util.Scanner;\n\npublic class TestStream {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int a = s.nextInt();\n        System.out.println(&quot;第一个整数：&quot;+a);\n        int b = s.nextInt();\n        System.out.println(&quot;第二个整数：&quot;+b);\n    }\n}</code></pre><h2><span id=\"流关系图\">流关系图</span></h2><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png\" alt></a></p>\n","text":"[toc]I/O文件对象创建一个文件对象package file;import java.io.File;public class TestFile {    public static void main(String[] args){        //绝对路径       ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java Throwable","slug":"java-throwable","date":"2018-01-15T02:32:48.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-throwable.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/742.png","content":"<p>Throwable是个接口.用于定义异常和error的类. 异常分为两类: error和exception. exception里又分 运行时异常,可查异常 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/742.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/742.png\" alt></a> throws 和 throw两个关键词,第一个经常出现在函数声明中. 自定义异常:</p>\n<pre><code>class 类名 extends Exception{\n\n    public 类名(){\n\n    }\n    public 类名(String msg){\n        super(msg);\n    }\n}</code></pre>","text":"Throwable是个接口.用于定义异常和error的类. 异常分为两类: error和exception. exception里又分 运行时异常,可查异常  [Figure]  throws 和 throw两个关键词,第一个经常出现在函数声明中. 自定义异常:class 类名 ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"2017 杭电多校训练赛 补题","slug":"2017-hdu-up","date":"2018-01-14T04:25:53.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/2017-hdu-up.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif","content":"<p>[toc]</p>\n<h1><span id=\"第一场\"><strong>第一场</strong></span></h1><h2><span id=\"1003-colorful-tree-hdoj6035\"><strong>1003 Colorful Tree hdoj6035</strong></span></h2><p>题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n<em>(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) *</em> //思路<strong>：Answer = 所有颜色种类 * 所有路径数量 - 每一种颜色有多少路径没有经过 . 一开始假设每条路径都经过了所有颜色，再把每种颜色没经过的路径数减去就行，这个应该很好理解。问题是怎么算没经过的路径数？操作是这样的，如果算颜色1没经过的路径数，我们先把图里所有颜色是1的节点遮起来（假设这个点不存在，图在这个点是断路），图就被分成了很多块，</strong>每块的值= 那一块里的顶点数<em>（那一块里的顶点数-1）/2*</em>。 所有块的值加起来就是不经过颜色1的所有路径数。 到这里是不是还是很好理解，那么问题来了，怎么实现？…题解里说用虚树什么的… 用一个DFS即可，复杂度O（n） 用Size数组储存以每个节点为根节点的子树大小（即子树里节点的个数），Sum数组…很难解释，大概是表示以每种颜色为根节点的子树的大小和，但不是非常准确，如果以颜色2为根节点的子树里还含有颜色为2的节点，那只要算根节点这个颜色为2的子树大小即可，若在以这个颜色为2的点为根节点的子树之外还有颜色为2的点，那还要加上这个点的值…不知道能不能理解…解释不清楚，大概就这个意思… 以下图颜色2为例，代码里最后的for里(即以根<strong>第一个节点</strong>计算中)减去的（n-sum[2]）*（n-sum[2]-1）/2的那部分减去的是下图橙色圈里的那块，dfs里<code>减去pp那部分</code>是下图里蓝色圈的那块。其他具体的按照自己的理解再思考思考。 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" alt></a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 200005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\n//c[]数组是每个节点的颜色\nint c[maxn],head[maxn],len,sum[maxn],size[maxn],vis[maxn];\nLL d;\n//边表\n//邻接表\nstruct node{\n    int v,next;\n}p[maxn&lt;&lt;1];\n\nvoid addedge(int u,int v){\n    //有向边指向点的编号\n    p[len].v=v;\n    //每条边的下一条边是上一次纪录的边的号码\n    p[len].next=head[u];\n    //邻接表的方法\n    //len为当前边的编号\n\n    //只记录当前节点的最后一个边的位置\n    head[u]=len++;\n}\n//对树进行dfs\nvoid dfs(int x,int fa){\n    //非这个点为根的所有该颜色的点\n    LL pre=sum[c[x]];\n    //size数组是当前节点的子节点总数目\n    size[x]=1;\n    int add=0;\n    //通过邻接表对当前节点x进行dfs\n    //等于0则退出\n    for(int i=head[x];~i;i=p[i].next){\n        //如果遇到反向边了,跳过,继续往其他边走\n        if(p[i].v==fa)\n            continue;\n        dfs(p[i].v,x);\n        size[x] += size[p[i].v];\n        //计算当前节点子树所有和当前节点颜色不同的点的个数\n        LL count = size[p[i].v] - sum[c[x]] + pre;\n        pre = sum[c[x]];\n        //当前子树的不同颜色点的个数\n        add += count;\n        //假设其他颜色都是白色,d即等于不同颜色所组成的边的总个数\n        d += count*(count-1)&gt;&gt;1;\n    }\n    //计算以x为根节点子树的所有与x不同颜色的点的个数\n    sum[c[x]] += add + 1;\n}\n\nint main(){\n    int n,tcase=1;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        memset(head,-1,sizeof(head));\n        memset(sum,0,sizeof(sum));\n        memset(vis,0,sizeof(vis));\n        d=len=0;\n        LL number = 0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            //记录颜色,颜色范围是[1,n]\n            if(!vis[c[i]]){\n                vis[c[i]]=1;\n                number++;\n            }\n        }\n        for(int i=1;i&lt;n;++i){\n            int u,v;\n            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);\n            addedge(u,v);\n            addedge(v,u);\n        }\n        dfs(1,0);\n        //ans初始等于(颜色个数)*(所有边的个数)-d(d为每个颜色在每个子树上被减去的不会经过那个颜色的路径的个数)\n        LL ans=(number*(n-1)*n&gt;&gt;1)-d;\n        for(int i=1;i&lt;=n;++i){\n            //不存在的颜色不需要计算,把已存在的颜色计算一下\n            if(vis[i]&amp;&amp;i!=c[1]){\n                //在根节点中与颜色i不同的颜色的个数\n                LL count=n-sum[i];\n                //每个颜色的路径数=(n*(n-1)&gt;&gt;1)-(count*(count-1)&gt;&gt;1)\n                //以根节点为中心减去不同于当前颜色的路径的个数\n                //最终得到的ans即为 每个颜色路径个数 的和\n                ans-=count*(count-1)&gt;&gt;1;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,tcase++,ans);\n    }\n    return 0;\n}</code></pre><h2><span id=\"1006-function-hdoj6038\"><strong>1006 Function hdoj6038</strong></span></h2><p>这道题似懂非懂的写了出来… 大体是寻找循环节. 我写的代码有点乱… 原式为: f[i]=b[f[a[i]]] A:{1,0,2} B{0,1} 可组成f: 000 111 110 001 A:{2,0,1} b{0,2,3,1} 可组成f: 000 231 312 123 以i -&gt; a[i] i -&gt; b[i] 为图的边进行Tarjan. 用Tarjan判断a和b各自有几个环(强连通分量),并且记录下每个环的大小. 然后AC代码如下(以后思路清楚了再重新看看…):</p>\n<pre><code>//HDU 6038\n#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\nconst int maxn=100000+100;\nconst int mod=1e9+7;\ntypedef long long int lli;\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint a[maxn],b[maxn];\n\nstack&lt;int&gt; S;\nmap&lt;int,int&gt; A,B;\n\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\ninline lli qp(lli aa,lli x){\n    if(aa == 0) return 0;\n    lli ans = 1;\n    for(;x;x&gt;&gt;=1){\n        if(x&amp;1) ans = ans*aa % mod;\n        aa = aa*aa % mod;\n    }\n    return ans % mod;\n}\n\nvoid dfs(int u,map&lt;int,int&gt;&amp; T){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v,T);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            //未回溯时计算low数组需要通过pre数组\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        int cnt=0;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            cnt++;\n            if(x==u)break;\n        }\n        T[cnt]++;\n    }\n}\n\nvoid Tarjan(int n,map&lt;int,int&gt;&amp; T){\n    while(!S.empty()){\n        S.pop();\n    }\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i,T);\n    }\n}\n\nint main(){\n    int n,m,kase=0;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;a[i]);\n        }\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;b[i]);\n        }\n        //对aTarjan\n        for(int i=0;i&lt;n;++i){\n            addAdge(i,a[i]);\n        }\n        Tarjan(n,A);\n        for(int i=0;i&lt;n;++i){\n            G[i].clear();\n        }\n        //对bTarjan\n        for(int i=0;i&lt;m;++i){\n            addAdge(i,b[i]);\n        }\n        Tarjan(m,B);\n        for(int i=0;i&lt;m;++i){\n            G[i].clear();\n        }\n\n        long long ans=1;\n        map&lt;int,int&gt;::iterator it1;\n        map&lt;int,int&gt;::iterator it2;\n        for(it1=A.begin();it1!=A.end();it1++){\n            long long tmp=0;\n            for(it2=B.begin();it2!=B.end();it2++){\n                if(it1-&gt;first%it2-&gt;first==0){\n                    tmp=tmp+it2-&gt;second*it2-&gt;first;\n                }\n                //printf(&quot;%d %d : %d %d\\n&quot;,it1-&gt;first,it2-&gt;first,it1-&gt;second,it2-&gt;second);\n            }\n            ans=ans*qp(tmp,it1-&gt;second)%mod;\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n        A.clear();\n        B.clear();\n    }\n    return 0;\n}</code></pre><h2><span id=\"1008-hints-of-sd0061-hdoj6040\"><strong>1008 Hints of sd0061 hdoj6040</strong></span></h2><h1><span id=\"第二场\"><strong>第二场</strong></span></h1><h1><span id=\"第三场\"><strong>第三场</strong></span></h1>","text":"[toc]第一场1003 Colorful Tree hdoj6035题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) * //思路：Answer = 所有颜色种类 * 所有路径数量","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"dfs","slug":"2017多校/dfs","count":1,"path":"api/categories/2017多校/dfs.json"},{"name":"图论","slug":"2017多校/dfs/图论","count":1,"path":"api/categories/2017多校/dfs/图论.json"},{"name":"思维","slug":"2017多校/dfs/图论/思维","count":1,"path":"api/categories/2017多校/dfs/图论/思维.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]},{"title":"Codeforce 915 A、B、C","slug":"codeforce-915-a-b-c","date":"2018-01-14T03:28:45.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/codeforce-915-a-b-c.json","excerpt":"","keywords":null,"cover":null,"content":"<p>A. Garden <strong>【题意】</strong> 选择一个桶可以以最少的小时浇满花园,花园不能重复浇.</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nconst int MAXN=200;\nint n,k;\nint min_bucket_fill;\n\nint main(){\n    while(cin&gt;&gt;n&gt;&gt;k){\n        min_bucket_fill=0x3f3f3f3f;\n        for(int i=0;i&lt;n;++i){\n            int a;\n            cin&gt;&gt;a;\n            if(k%a==0)min_bucket_fill=min(k/a,min_bucket_fill);\n        }\n        printf(&quot;%d\\n&quot;,min_bucket_fill);\n    }\n    return 0;\n}</code></pre><p>B. Browser <strong>【题意】</strong> 给定初始位置,需要使用的页面区间【l,r】,问,从初始位置开始,到关闭所有非区间内标签最少需要多少次点击鼠标.关闭页面也需要点击一次.</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\nusing namespace std;\n\nint n,pos,l,r;\nint main(){\n    while(cin&gt;&gt;n&gt;&gt;pos&gt;&gt;l&gt;&gt;r){\n        if(l==1&amp;&amp;r==n){printf(&quot;0\\n&quot;);continue;}\n        int ans=0;\n        ans=abs(min(abs(pos-l),abs(pos-r))+2+r-l);\n        if(l==1)ans=abs(pos-r)+1;\n        if(r==n)ans=abs(pos-l)+1;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>C. Permute Digits <strong>【题意】</strong> 给定a,b.对a进行任意排列,得到小于等于b且大于等于a的c.问这个c最大是多少. Tip: 注意a,b取值范围是1e18 string数字无法比较大小.</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nlong long str_2_num(string str){\n    long long reg=0;\n    int len=str.size();\n    for(int i=0;i&lt;len;++i){\n        reg*=10;\n        reg+=(str[i]-&apos;0&apos;);\n    }\n    return reg;\n}\n\nint main(){\n    string a,b;\n    string ans;\n    while(cin&gt;&gt;a&gt;&gt;b){\n        int len=a.size();\n        sort(a.begin(),a.end());\n        for(int i=0;i&lt;len;++i){\n            for(int j=i;j&lt;len;++j){\n                string tmp=a;\n                swap(tmp[i],tmp[j]);\n                sort(tmp.begin()+i+1,tmp.end());\n                if(str_2_num(tmp)&lt;=str_2_num(b)&amp;&amp;str_2_num(tmp)&gt;=str_2_num(a))swap(a[i],a[j]);\n            }\n        }\n        cout&lt;&lt;a&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"A. Garden 【题意】 选择一个桶可以以最少的小时浇满花园,花园不能重复浇.#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;usi","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"Codeforce 1B Spreadsheet","slug":"codeforce-1b-spreadsheet","date":"2018-01-13T13:12:09.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/codeforce-1b-spreadsheet.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题意: 26进制的转换,需要注意的是,A &lt;=&gt; 0.所以处理的时候需要注意一下10禁止转26进制的时候是 以(num-1)作为当前数. 另外就是 10转26进制直接从0开始依次*26即可.以及 sscanf() 和 %[A-Z]的用法.</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\n#include&lt;stack&gt;\nusing namespace std;\nconst int MAXN=100;\nint N;\nchar Q[MAXN];\n//10进制转26进制\nvoid solveToAlpha(){\n    stack&lt;char&gt; ans;\n    int a,num;\n    sscanf(Q,&quot;R%dC%d&quot;,&amp;a,&amp;num);\n    int i;\n    for(i=0;num&gt;0;i++){\n        char c=(num-1)%26+&apos;A&apos;;\n        ans.push(c);\n        num=(num-1)/26;\n    }\n    while(!ans.empty()){\n        printf(&quot;%c&quot;,ans.top());\n        ans.pop();\n    }\n    printf(&quot;%d\\n&quot;,a);\n}\n//26进制转10进制\nvoid solveToNum(){\n    int a;\n    char b[MAXN];\n    sscanf(Q,&quot;%[A-Z]%d&quot;,b,&amp;a);\n    long long ans=0;\n    int len=strlen(b);\n    for(int i=0;i&lt;len;++i){\n        ans*=26;\n        ans=ans+b[i]-&apos;A&apos;+1;\n    }\n    printf(&quot;R%dC%lld\\n&quot;,a,ans);\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;N);\n    for(int i=0;i&lt;N;++i){\n        scanf(&quot;%s&quot;,Q);\n        int a,b;\n        //sscanf()\n        if(sscanf(Q,&quot;R%dC%d&quot;,&amp;a,&amp;b)==2){\n            solveToAlpha();\n        }else{\n            solveToNum();\n        }\n    }\n    return 0;\n}</code></pre>","text":"题意: 26进制的转换,需要注意的是,A &lt;=&gt; 0.所以处理的时候需要注意一下10禁止转26进制的时候是 以(num-1)作为当前数. 另外就是 10转26进制直接从0开始依次*26即可.以及 sscanf() 和 %[A-Z]的用法.#include&lt;std","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"Codeforce 1A Theatre Square","slug":"codeforce-1a-theatre-square","date":"2018-01-13T11:38:33.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/codeforce-1a-theatre-square.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题意: 给你一个N*M的矩阵,和a*a的陶瓷,陶瓷不允许被破坏，问最少需要多少陶瓷能铺满矩阵.</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define EPS 1e-9\nusing namespace std;\n\nint n,m,a;\n\nlong long up_bound(double s){\n    long long ans=s;\n    if(s-ans&gt;EPS){\n        ans++;\n    }\n    return ans;\n}\n\nint main(){\n    while(scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;a)!=EOF){\n        long long row = up_bound(1.0*m/a);\n        long long column = up_bound(1.0*n/a);\n        long long ans=row*column;\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"题意: 给你一个N*M的矩阵,和a*a的陶瓷,陶瓷不允许被破坏，问最少需要多少陶瓷能铺满矩阵.#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define EPS 1e-9using ","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"Java 8 默认方法","slug":"java-8-default","date":"2018-01-13T08:27:04.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-8-default.json","excerpt":"","keywords":null,"cover":null,"content":"<p>在之前的学习中,Java 的接口只能声明抽象方法(不写abstract的那种). 但在Java 8 中,接口也可以实现有方法体的方法.被称之为默认方法. 但需要注意,在默认方法中,需要使用 <code>default</code> 关键字. Like this:</p>\n<pre><code>package charactor;\n\npublic interface Mortal {\n    public void die();\n\n    default public void revive() {\n        System.out.println(&quot;本英雄复活了&quot;);\n    }\n}</code></pre>","text":"在之前的学习中,Java 的接口只能声明抽象方法(不写abstract的那种). 但在Java 8 中,接口也可以实现有方法体的方法.被称之为默认方法. 但需要注意,在默认方法中,需要使用 default 关键字. Like this:package charactor;publ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 接口","slug":"java-interface","date":"2018-01-12T13:20:38.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-interface.json","excerpt":"","keywords":null,"cover":null,"content":"<p>接口(interface)的继承需要使用实现(implements)关键词,可以多继承 首先我们新建一个AD类型英雄的接口:</p>\n<pre><code>package charactor;\n\npublic interface AD {\n    //声明一个接口方法\n    //物理伤害\n    public void physicAttack();\n}</code></pre><p>然后我们新建一个AD英雄:</p>\n<pre><code>package charactor;\n\npublic class ADHero extends Hero implements AD{\n    @Override\n    public void physicAttack(){\n        System.out.print(&quot;进行物理攻击&quot;);\n    }\n}</code></pre><p>然后我们新建一个AP类型英雄的接口:</p>\n<pre><code>package charactor;\n\npublic interface AP {\n    public void magicAttack();\n}</code></pre><p>然后我们实现一个AP英雄:</p>\n<pre><code>package charactor;\n\npublic class APHero extends Hero implements AP{\n    @Override\n    public void magicAttack(){\n        System.out.println(&quot;魔法攻击&quot;);\n    }\n}</code></pre><p>然后我们实现一个既可以魔法攻击,又可以物理攻击的英雄:</p>\n<pre><code>package charactor;\n\npublic class ADAPHero extends Hero implements AD,AP{\n    @Override\n    public void physicAttack(){\n        System.out.println(&quot;物理攻击&quot;);\n    }\n    public void magicAttack(){\n        System.out.println(&quot;魔法攻击&quot;);\n    }\n}</code></pre>","text":"接口(interface)的继承需要使用实现(implements)关键词,可以多继承 首先我们新建一个AD类型英雄的接口:package charactor;public interface AD {    //声明一个接口方法    //物理伤害    public void","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 枚举类","slug":"java-enum","date":"2018-01-12T12:53:52.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-enum.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Enum,也是个类 因为是常量,所以一般大写</p>\n<pre><code>public enum Season {\n    SPRING,SUMMER,AUTUMN,WINTER\n}</code></pre><p>测试:</p>\n<pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        Season season = Season.SPRING;\n        switch (season) {\n        case SPRING:\n            System.out.println(&quot;春天&quot;);\n            break;\n        case SUMMER:\n            System.out.println(&quot;夏天&quot;);\n            break;\n        case AUTUMN:\n            System.out.println(&quot;秋天&quot;);\n            break;\n        case WINTER:\n            System.out.println(&quot;冬天&quot;);\n            break;\n        }\n    }\n}</code></pre><p>可以使用foreach:</p>\n<pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        for (Season s : Season.values()) {\n            System.out.println(s);\n        }\n    }\n}</code></pre>","text":"Enum,也是个类 因为是常量,所以一般大写public enum Season {    SPRING,SUMMER,AUTUMN,WINTER}测试:public class HelloWorld {    public static void main(String[] a","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 单例模式","slug":"java-singleton","date":"2018-01-12T12:45:47.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-singleton.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"1饿汉式单例模式\">1.<code>饿汉式</code>单例模式</span></h1><h4><span id=\"giantdragon-应该只有一只通过私有化其构造方法使得外部无法通过new-得到新的实例\">GiantDragon 应该只有一只，通过<code>私有化其构造方法</code>，使得外部无法通过new 得到新的实例。</span></h4><h4><span id=\"giantdragon-提供了一个public-static的getinstance方法外部调用者通过该方法获取12行定义的对象而且每一次都是获取同一个对象-从而达到单例的目的\">GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 从而达到单例的目的。</span></h4><h4><span id=\"这种单例模式又叫做饿汉式单例模式无论如何都会创建一个实例\">这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例</span></h4><pre><code>package charactor;\n\npublic class GiantDragon {\n\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){\n\n    }\n\n    //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个\n\n    private static GiantDragon instance = new GiantDragon();\n\n    //public static 方法，提供给调用者获取12行定义的对象\n    public static GiantDragon getInstance(){\n        return instance;\n    }\n\n}</code></pre><p>测试:</p>\n<pre><code>package charactor;\n\npublic class TestGiantDragon {\n\n    public static void main(String[] args) {\n        //通过new实例化会报错\n//      GiantDragon g = new GiantDragon();\n\n        //只能通过getInstance得到对象\n\n        GiantDragon g1 = GiantDragon.getInstance();\n        GiantDragon g2 = GiantDragon.getInstance();\n        GiantDragon g3 = GiantDragon.getInstance();\n\n        //都是同一个对象\n        System.out.println(g1==g2);\n        System.out.println(g1==g3);\n    }\n}</code></pre><h1><span id=\"2懒汉式单例模式\">2.<code>懒汉式</code>单例模式</span></h1><h4><span id=\"懒汉式单例模式与饿汉式单例模式不同只有在调用getinstance的时候才会创建实例\">懒汉式单例模式与饿汉式单例模式不同，只有在调用getInstance的时候，才会创建实例</span></h4><pre><code>package charactor;\n\npublic class GiantDragon {\n\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){       \n    }\n\n    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null\n    private static GiantDragon instance;\n\n    //public static 方法，返回实例对象\n    public static GiantDragon getInstance(){\n        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象\n        if(null==instance){\n            instance = new GiantDragon();\n        }\n        //返回 instance指向的对象\n        return instance;\n    }\n\n}</code></pre><p>测试:</p>\n<pre><code>package charactor;\n\npublic class TestGiantDragon {\n\n    public static void main(String[] args) {\n        //通过new实例化会报错\n//      GiantDragon g = new GiantDragon();\n\n        //只能通过getInstance得到对象\n\n        GiantDragon g1 = GiantDragon.getInstance();\n        GiantDragon g2 = GiantDragon.getInstance();\n        GiantDragon g3 = GiantDragon.getInstance();\n\n        //都是同一个对象\n        System.out.println(g1==g2);\n        System.out.println(g1==g3);\n    }\n}</code></pre><h3><span id=\"单例模式三要素\">单例模式三要素:</span></h3><p>这个是面试的时候经常会考的点，面试题通常的问法是: 什么是单例模式？ 回答的时候，要答到三元素 1. 构造方法私有化 2. 静态属性指向实例 3. public static的 getInstance方法，返回第二步的静态属性</p>\n","text":"1.饿汉式单例模式GiantDragon 应该只有一只，通过私有化其构造方法，使得外部无法通过new 得到新的实例。GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]}]}