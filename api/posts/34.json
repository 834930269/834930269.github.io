{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"算法学习-图论相关一些基础","slug":"base-graph","date":"2017-03-21T23:58:25.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/base-graph.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png","content":"<p><strong>【先贴上大神的代码截图】</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png\" alt></a>   <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/SFA.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/SFA.png\" alt=\"floyd&amp;spfa\"></a>   <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>struct node{</strong> **    node <em>next;*</em> **    int where;** **    int cost;** <strong>}a[10001],*first[1001];</strong> <strong>bool b[1001];</strong> <strong>inline void dfs(int now){</strong> **    b[now]=true;** **    for(node <em>x=first[now];x;x=x-&gt;next)*</em> **        if(!b[x-&gt;where])** **            dfs(x-&gt;where);** <strong>}</strong> <strong>inline void bfs(int S){</strong> **    int c[1001];** **    c[1]=S;** **    for(int k=1,l=1,l&lt;=k;++l){** **        int m=c[1];** **        for(node <em>x=first[m];x;x=x-&gt;next)*</em> **            if(!b[x-&gt;where])** **                b[x-&gt;where]=true,** **                c[++k]=x-&gt;where;    ** **    }** <strong>}</strong> <strong>//floyd只是一个模板</strong> <strong>inline void floyd(){</strong> **    for(int k=1;k&lt;=n;++k)** **        for(int i=1;i&lt;=n;++i)** **            for(int j=1;j&lt;=n;++j)** **                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);** <strong>}</strong> <strong>//可以处理负边</strong> <strong>inline void spfa(int S,int T){</strong> **    int c[1001],dist[1001];** **    c[1]=S;** **    memset(dist,127,sizeof(dist));** **    dist[S]=0;** **    for(int k=1,l=1;l&lt;=k;++l){** **        int m=c[1];** **        b[m]=false;** **        for(node <em>x=first[m];x;x=x-&gt;next)*</em> **            if(dist[m]+x-&gt;cost&lt;dist[x-&gt;where])** **            {** **                dist[x-&gt;where]=dist[m]+x-&gt;cost;** **                if(!b[x-&gt;where])** **                    b[x-&gt;where]=true,** **                    c[++k]=x-&gt;where;** **            }** **    }**   <strong>}</strong> <strong>int main(){</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【先贴上大神的代码截图】  [Figure]    【Code】#include #include #include using namespace std; struct node{ **    node next;* **    int where;** **    int ","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"Android 学习 碎片的生命周期","slug":"android-fragmenttest","date":"2017-03-21T11:52:08.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/android-fragmenttest.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/20151112223048360.png","content":"<p><strong>【reference】</strong> <strong>《第一行代码-第二版》 GuoLin</strong> <strong>【Prior knowledge/先备知识】</strong> <strong>BaiDu or Google it…= =</strong>   <strong>【碎片的状态和回调】</strong> <strong>1.每个活动在其生命周期内可能会有四种状态.</strong> <strong>-运行状态</strong> <strong>-暂停状态</strong> <strong>-停止状态</strong> <strong>-销毁状态</strong> <strong>类似的,碎片也可能会经历这几种状态,不过会有一些细小的地方的部分区别.</strong> <strong>2.运行状态</strong> <strong>当一个碎片是可见的,并且他所关联的活动正处于运行状态时,该碎片也处于运行状态.</strong> <strong>3.暂停状态</strong> <strong>当一个活动进入暂停状态时(由于另一个未占满屏幕的活动被添加到了栈顶),与他相关联的可见碎片就会进入到暂停状态.</strong> <strong>4.停止状态</strong> <strong>当一个活动进入停止状态时,与他相关联的碎片就会进入到停止状态,或者通过调用FragmentTrasaction的remove(),replace()方法把碎片从活动移除,但如果在事务提交之前调用addToBackStack()方法,这时的碎片也会进入到停止状态。总的来说，进入停止状态的碎片对用户来说是完全不可见的,有可能会被系统回收.</strong> <strong>5.销毁状态</strong> <strong>碎片总是依附于活动而存在的,因此当活动被销毁时,与他相关联的碎片也就会进入到销毁态.</strong> <strong>或者通过调用FragmentTransaction 的remove()、replace()方法将碎片从活动中移除，</strong> <strong>但在事务提交之前并没有调用addToBackStack()方法，这时的碎片也会进入到销毁状态。</strong>   <strong>Fragment提供的附加回调方法:</strong> <strong>①onAttach() 当碎片和活动建立关联的时候调用。</strong> <strong>②onCreateView() 为碎片创建视图（加载布局）时调用。</strong> <strong>③ onActivityCreated() 确保与碎片相关联的活动一定已经创建完毕的时候调用。</strong> <strong>④onDestroyView() 当与碎片关联的视图被移除的时候调用。</strong> <strong>⑤onDetach() 当碎片和活动解除关联的时候调用。</strong>   <strong>【碎片的完整生命周期】</strong>   <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/20151112223048360.png\" alt>   <strong>附上github源码(这一篇的project是FragmentTest):  <a href=\"https://github.com/834930269/Android_study\" target=\"_blank\" rel=\"noopener\">clone这个项目</a></strong></p>\n","text":"【reference】 《第一行代码-第二版》 GuoLin 【Prior knowledge/先备知识】 BaiDu or Google it…= =   【碎片的状态和回调】 1.每个活动在其生命周期内可能会有四种状态. -运行状态 -暂停状态 -停止状态 -销毁状态 类似的","link":"","raw":null,"photos":[],"categories":[{"name":"Android","slug":"Android","count":5,"path":"api/categories/Android.json"}],"tags":[{"name":"Android","slug":"Android","count":5,"path":"api/tags/Android.json"}]},{"title":"最期望来的不会离开","slug":"dontgoaway","date":"2017-03-21T05:17:54.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/dontgoaway.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>最期望永驻的是离不开的我们,最期望是无忧无虑的童年,最期望的是世间没有难过,没有离别,没有疯狂,如果期望无法成为现实,那就保护自己吧,今后一个人的走路,也不会流泪了.</strong> <strong>–原谅我害怕失去的极端.</strong></p>\n","text":"最期望永驻的是离不开的我们,最期望是无忧无虑的童年,最期望的是世间没有难过,没有离别,没有疯狂,如果期望无法成为现实,那就保护自己吧,今后一个人的走路,也不会流泪了. –原谅我害怕失去的极端.","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"开新坑啦~","slug":"new-keng","date":"2017-03-18T11:07:12.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/new-keng.json","excerpt":"","keywords":null,"cover":null,"content":"<p>认认真真记录学习的每个算法咯！  高清马赛克↑↑↑</p>\n","text":"认认真真记录学习的每个算法咯！  高清马赛克↑↑↑","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"算法学习-线段树","slug":"segment-tree","date":"2017-03-18T11:04:39.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/segment-tree.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/QQ%E6%88%AA%E5%9B%BE20170318190105.png","content":"<p>【概念】 线段树是擅长处理区间的,且是一颗完美二叉树(Perfect Binary Tree),树上每一个节点都维护一个区间,根维护的是整个区间,每个节点维护的是父亲的区间二等分后的其中一个子区间。当有n个元素时,对区间的操作可以在O(log n)的时间内完成. 以下我们以实现了Range Minimum Query(RMQ,范围最小值查询)操作的线段树为例,进行说明. 【基于线段树的RMQ的结构】 下面要建立的线段树在给定数列a0,a1,a2,….,an-1的情况下,可以在O(log n)时间内完成如下两种操作.</p>\n<ul>\n<li>给定s和t,求as,as+1,…,at的最小值.                                                                         ΘωΘ~</li>\n<li>给定i和x,把ai的值改成x.</li>\n</ul>\n<p>递归建树,在建树时只需要按从下到上的顺序分别取左右儿子的值中的较小者就可以了.(回溯实现) 【基于线段树的RMQ的查询】 如果要求a0,…,a6的最小值。我们只需要求[a0,a3],[a4,a5],[a6]这三个区间中的最小值即可。 要求某个区间的最小值,向下面这样递归处理就可以了.</p>\n<ul>\n<li>如果所查询的区间和当前节点对应的区间完全没有交集,那么就返回一个不影响答案的值(例如INT_MAX)。</li>\n<li>如果所查询的区间完全包含了当前节点对应的区间,那么就返回当前节点的值.</li>\n<li>以上两种情况都不满足的话,就对两个儿子递归处理,返回两个结果中的较小者.</li>\n</ul>\n<p>【基于线段树的RMQ的值的更新】 在更新a0(a0:5-&gt;2)的值时,需要重新计算a0往上的所有父节点的值.–即,在更新ai的值时,需要对包含i的所有区间对应的节点的值重新计算。在更新时,可以从下面的节点开始向上不断更新,把每个节点的值更新为左右两个儿子的值的较小者就可以了. 【实现】 为了简单起见,在建立线段树时,把数列所有的值都初始化为INT_MAX(limits.h文件中).此外,query的参数中不只传入节点的编号,还传入了节点对应的区间.</p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<climits></climits></strong> <strong>using namespace std;</strong> <strong>const int MAX_N=1&lt;&lt;17;</strong> <strong>//存储线段树的全局数组</strong> <strong>int n,dat[2*MAX_N-1];</strong> <strong>//initialize</strong> <strong>void init(int n_){</strong> <em>*    /*为了简便起见,把元素扩大到2的幂–满二叉树</em>/<em>* **    n=1;** **    while(n&lt;n_) n</em>=2;<em>* **    /*把所有的值都设为INT_MAX</em>/<em>* **    for(int i=0;i&lt;2<em>n-1;++i)dat[i]=INT_MAX;*</em> <strong>}</strong> *<em>/</em>把第k个值(0-indexed)更新为a</em>/<em>* <strong>void updata(int k,int a){</strong> **    /*叶子节点</em>/<em>* **    k+=n-1;** **    dat[k]=a;** **    /*向上更新</em>/<em>* **    while(k&gt;0){** **        k=(k-1)/2;** <strong>dat[k]=min(dat[k*2+1],dat[k*2+2]);</strong> **    }** <strong>}</strong> **/\\</em> 查询<em>* <strong>*求[a,b)的最小值</strong> <strong>*后面的参数是为了计算起来方便而传入的</strong> <strong>*k是节点的编号,l(英文字母),r表示这个节点对应的是[l,r)区间</strong> <strong>*在外部调用时,用query(a,b,0，0，n)</strong> <strong>*这里n为换算成满二叉树后的叶子节点数,如n_=10，n=16</strong> <strong>*/</strong> <strong>int query(int a,int b,int k,int l,int r){</strong> **    /*如果[a,b]和[1,r]不相交,则返回INT_MAX</em>/<em>* **    if(r&lt;=a||b&lt;=l) return INT_MAX;** **    /*如果[a,b]完全包含[1，r],则返回当前节点的值</em>/<em>* **    if(a&lt;=l &amp;&amp; r&lt;=b) return dat[k];** **    else{** **        /*否则返回两个儿子中值的较小者</em>/** **        int v1=query(a,b,k<em>2+1,l,(l+r)/2);*</em> **        int v2=query(a,b,k<em>2+2,(l+r)/2,r);*</em> <strong>return min(v1,v2);</strong> <strong>}</strong> <strong>}</strong> <strong>int main(){</strong> <strong>init(10);//区间为[a0,a9]</strong> **    updata(5,-10);** **    updata(2,-20);** **    updata(0,2);** <strong>cout&lt;&lt;”[0,1) min: “&lt;&lt;query(0,1,0,0,16)&lt;&lt;endl;</strong> **    cout&lt;&lt;”[2,3) min: “&lt;&lt;query(2,3,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[5,6) min: “&lt;&lt;query(5,6,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[0,9) min: “&lt;&lt;query(0,9,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[0,4) min: “&lt;&lt;query(0,4,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[2,7) min: “&lt;&lt;query(2,7,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[3,7) min: “&lt;&lt;query(3,7,0,0,16)&lt;&lt;endl;** **    for(int i=0;i&lt;=32;++i)** <strong>cout&lt;&lt;”deg “&lt;&lt;i&lt;&lt;” = “&lt;&lt;dat[i]&lt;&lt;endl;</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n<p>【Tip】</p>\n<ol>\n<li>query中的n是叶子节点总数,不是区间的上界.</li>\n<li>query查询的是[a,b)半开半闭区间,如,a0=2,想查a0,就必须查[0,1).</li>\n<li>查询和建树/更新都是从下标0开始的.</li>\n</ol>\n<p>【运行结果】 <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/QQ截图20170318190105.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/QQ%E6%88%AA%E5%9B%BE20170318190105.png\" alt></a>   【果断要画图啊】 以上代码建好的树是这样的(渣画质莫介意…): <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/IMG_20170318_185245_1489834380376-1.jpg\" alt></p>\n","text":"【概念】 线段树是擅长处理区间的,且是一颗完美二叉树(Perfect Binary Tree),树上每一个节点都维护一个区间,根维护的是整个区间,每个节点维护的是父亲的区间二等分后的其中一个子区间。当有n个元素时,对区间的操作可以在O(log n)的时间内完成. 以下我们以实现了","link":"","raw":null,"photos":[],"categories":[{"name":"segmentTree","slug":"segmentTree","count":1,"path":"api/categories/segmentTree.json"},{"name":"算法学习","slug":"segmentTree/算法学习","count":1,"path":"api/categories/segmentTree/算法学习.json"}],"tags":[{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"}]},{"title":"Android 学习 抽象类","slug":"android-abstract","date":"2017-03-17T04:31:00.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/android-abstract.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Tip】 抽象类只是一个面向对象的概念,所以可以用在诸如.net,jave EE,PY….. 【在Android中概念】</p>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"**   抽象类**\"></a>**   抽象类**</h1><p>我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。 在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。 同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….） 在使用抽象类时需要注意几点： 1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。 2、抽象方法必须由子类来进行重写。 3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。 4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。 5、子类中的抽象方法不能与父类的抽象方法同名。 6、abstract不能与final并列修饰同一个类。 7、abstract 不能与private、static、final或native并列修饰同一个方法。 【实例】 定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：</p>\n<blockquote>\n<ol>\n<li><p>_public abstract class Animal {  _</p>\n</li>\n<li><p>_    public abstract void cry();  _</p>\n</li>\n<li><p>_}  _</p>\n</li>\n<li><p>_public class Cat extends Animal{  _</p>\n</li>\n<li><p>_    @Override  _</p>\n</li>\n<li><p>_    public void cry() {  _</p>\n</li>\n<li><p>_        System.out.println(“猫叫：喵喵…”);  _</p>\n</li>\n<li><p>_    }  _</p>\n</li>\n<li><p>_}  _</p>\n</li>\n<li><p>_public class Dog extends Animal{  _</p>\n</li>\n<li><p>_    @Override  _</p>\n</li>\n<li><p>_    public void cry() {  _</p>\n</li>\n<li><p>_        System.out.println(“狗叫:汪汪…”);  _</p>\n</li>\n<li><p>_    }  _</p>\n</li>\n<li><p>_}  _</p>\n</li>\n<li><p>_public class Test {  _</p>\n</li>\n<li><p>_    public static void main(String[] args) {  _</p>\n</li>\n<li><p>_        Animal a1 = new Cat();  _</p>\n</li>\n<li><p>_        Animal a2 = new Dog();  _</p>\n</li>\n<li><p>_        a1.cry();  _</p>\n</li>\n<li><p>_        a2.cry();  _</p>\n</li>\n<li><p>_    }  _</p>\n</li>\n<li><p>_}  _</p>\n</li>\n<li><p>_——————————————————————–  _</p>\n</li>\n<li><p>_Output:  _</p>\n</li>\n<li><p>_猫叫：喵喵…  _</p>\n</li>\n<li><p>_狗叫:汪汪…  _</p>\n</li>\n</ol>\n</blockquote>\n","text":"【Tip】 抽象类只是一个面向对象的概念,所以可以用在诸如.net,jave EE,PY….. 【在Android中概念】**   抽象类**我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描","link":"","raw":null,"photos":[],"categories":[{"name":"Android","slug":"Android","count":5,"path":"api/categories/Android.json"}],"tags":[{"name":"Android","slug":"Android","count":5,"path":"api/tags/Android.json"}]},{"title":"OpenJudge \t程序设计与算法（二）第五周作业(2017春季)","slug":"openjudge-two","date":"2017-03-03T05:38:27.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/openjudge-two.json","excerpt":"","keywords":null,"cover":null,"content":"<p>–动态规划 【1:拦截导弹】 【Code】</p>\n<blockquote>\n<p><strong><em>#include&lt;bits/stdc++.h&gt;</em></strong> <strong><em>using namespace std;</em></strong> <strong><em>const int maxn=70;</em></strong> <strong><em>int a[maxn],N;</em></strong> <strong><em>int maxlen[maxn],m=-1;</em></strong> <strong><em>int main(){</em></strong> <strong>_    cin&gt;&gt;N;_</strong> <strong>_    for(int i=1;i&lt;=N;++i){_</strong> <strong>_        cin&gt;&gt;a[i]; maxlen[i]=1;_</strong> <strong>_    }_</strong> <strong>_    for(int i=2;i&lt;=N;++i)_</strong> <strong>_        for(int j=1;j&lt;i;++j)_</strong> <strong>_            if(a[i]&lt;=a[j]){_</strong> <strong>_                maxlen[i]=max(maxlen[i],maxlen[j]+1);_</strong> <strong>_                if(maxlen[i]&gt;m) m=maxlen[i];_</strong> <strong>_            }_</strong> <strong>_    cout&lt;&lt;m&lt;&lt;endl;_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>最长上升序列问题,目前对动规的理解走到了明白1.动规是逆着的递归.2.动规是通过从尾开始动态的更改所有的最忧解,从而找到所需要的最优解.</p>\n","text":"–动态规划 【1:拦截导弹】 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=70; int a[maxn],N; int maxlen[maxn],m=-1; int main(){","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"2017/3/3","slug":"201733","date":"2017-03-03T05:28:23.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/201733.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Please】…【Don’t throw it away】: )</p>\n","text":"【Please】…【Don’t throw it away】: )","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"【第二行代码】Android学习笔记","slug":"android-study","date":"2017-03-01T10:57:37.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/android-study.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【2017/3/1】 1.[Solve] 第二行代码依赖库是v7:24 而Update后的的版本是v7:25 P122 RecyclerView在24.2.1中 但 在 25.0.1中.</p>\n","text":"【2017/3/1】 1.[Solve] 第二行代码依赖库是v7:24 而Update后的的版本是v7:25 P122 RecyclerView在24.2.1中 但 在 25.0.1中.","link":"","raw":null,"photos":[],"categories":[{"name":"Android","slug":"Android","count":5,"path":"api/categories/Android.json"}],"tags":[{"name":"Android","slug":"Android","count":5,"path":"api/tags/Android.json"}]},{"title":"UVa 442","slug":"uva-442","date":"2017-01-24T15:17:02.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-442.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构,栈,STL 【Tip】 这道题和四则运算入栈规则一样,是数字入栈,凡遇到 ‘)’ 则操作前两个字符(这里是矩阵). 矩阵链乘,A(m,n),B(n,d).A(n)==B(n)才成立. 注意.入栈顺序与出栈顺序是相反的,而矩阵链乘不满足乘法交换律.所以(AB)!=(BA)也存在(AB)有值(BA)无值. (这道题没在每条语句执行结束时清空栈,意在.in数据全部有效?)(大雾 【Code】</p>\n<blockquote>\n<p><strong><em>#include<iostream></iostream></em></strong> <strong><em>#include<algorithm></algorithm></em></strong> <strong><em>#include<cstdio></cstdio></em></strong> <strong><em>#include<cstring></cstring></em></strong> <strong><em>#include<stack></stack></em></strong> <strong><em>#include<string></string></em></strong> <strong><em>using namespace std;</em></strong> <strong><em>struct Matrix{</em></strong> <strong>_    int m,n;_</strong> <strong>_    Matrix(int a=0,int b=0):m(a),n(b) {}_</strong> <strong><em>}m[27];</em></strong> <strong><em>stack<matrix> s;</matrix></em></strong> <strong><em>int main(){</em></strong> <strong>_    int n;_</strong> <strong>_    scanf(“%d”,&amp;n);_</strong> <strong>_    for(int i=0;i&lt;n;++i){_</strong> <strong>_        string name;_</strong> <strong>_        cin&gt;&gt;name;_</strong> <strong>_        int k=name[0]-‘A’;_</strong> <strong>_        scanf(“%d%d”,&amp;m[k].m,&amp;m[k].n);_</strong> <strong>_    }_</strong> <strong>_    string expt;_</strong> <strong>_    while(cin&gt;&gt;expt){_</strong> <strong>_        int len=expt.length();_</strong> <strong>_        bool error=false;_</strong> <strong>_        int ans=0;_</strong> <strong>_        for(int i=0;i&lt;len;++i){_</strong> <strong>_            if(isalpha(expt[i])) s.push(m[expt[i]-‘A’]);_</strong> <strong>_            else if(expt[i]==’)’){_</strong> <strong>_                Matrix m2=s.top();s.pop();//这两句注意顺序.比如(AB)肯定是A先入栈,所以第一个出栈的肯定是B_</strong> <strong>_                Matrix m1=s.top();s.pop();_</strong> <strong>_                if(m1.n!=m2.m){_</strong> <strong>_                    error=true;_</strong> <strong>_                    break;_</strong> <strong>_                }else{_</strong> <strong>_                    ans+=m1.n*m1.m*m2.n;_</strong> <strong>_                    s.push(Matrix(m1.m,m2.n));_</strong> <strong>_                }_</strong> <strong>_            }_</strong> <strong>_        }_</strong> <strong>_        if(error) printf(“error\\n”);_</strong> <strong>_        else printf(“%d\\n”,ans);_</strong> <strong>_    }_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>Save</p>\n","text":"【类型】 数据结构,栈,STL 【Tip】 这道题和四则运算入栈规则一样,是数字入栈,凡遇到 ‘)’ 则操作前两个字符(这里是矩阵). 矩阵链乘,A(m,n),B(n,d).A(n)==B(n)才成立. 注意.入栈顺序与出栈顺序是相反的,而矩阵链乘不满足乘法交换律.所以(AB)!","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}