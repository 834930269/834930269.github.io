{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"POJ 1273","slug":"poj-1273","date":"2017-04-17T12:39:14.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-1273.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>最大流Dinic</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<vector></vector></strong> <strong>#include<queue></queue></strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 1e9;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=300;</strong> <strong>int N,M;</strong> <strong>//弧,从from到to的容量为cap,流量为flow的弧当cap=0时,意味此边是反向弧</strong> <strong>//当且仅当flow&lt;cap时,该弧存在于残量网络中</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int from,int to,int cap,int flow):from(from),to(to),cap(cap),flow(flow){}** **    int from,to,cap,flow;** <strong>};</strong> <strong>struct Dinic{</strong> **    int n,m,s,t; //节点数,边数(包括反向弧),源点编号,汇点编号** **    vector<edge> edges;//边表。edges[e]和edges[e^1]互为反向弧。** **    vector<int> G[maxn]; //邻接表,G[i][j]表示节点i的第j条边在e数组中的序号** **    bool vis[maxn]; //BFS使用** **    int d[maxn]; //从起点到i的距离** **    int cur[maxn]; //当前弧的下标** **    //插入弧,原图中的一条弧对应于两个Edge结构体,一个是这条弧本身,另一个是他的反向弧** **    //根据插入顺序不难看出,edges[0]和edges[1]互为反向弧,edges[2]和edges[3]** **    //一般的,edges[e]和edges[e^1]互为反向弧** **    void AddEdge(int from,int to,int cap){** **        edges.push_back((Edge){from,to,cap,0});** **        edges.push_back((Edge){to,from,0,0});** **        m=edges.size();** **        G[from].push_back(m-2);** **        G[to].push_back(m-1);** **    }** **    bool BFS(){** **        cle(vis,0);** **        queue<int> Q;** **        Q.push(s);** **        d[s]=0;** **        vis[s]=1;** **        while(!Q.empty()){** **            int x=Q.front();Q.pop();** **            for(int i=0;i&lt;G[x].size();++i){** **                Edge&amp; e=edges[G[x][i]];** **                if(!vis[e.to] &amp;&amp; e.cap&gt;e.flow){//只考虑残量网络中的狐** **                    vis[e.to]=1;** **                    d[e.to]=d[x]+1;** **                    Q.push(e.to);** **                }** **            }** **        }** **        return vis[t];** **    }** **    int DFS(int x,int a){** **        if(x==t || a==0) return a;** **        int flow=0,f;** **        for(int&amp; i=cur[x];i&lt;G[x].size();++i){//从上次考虑的弧** **            Edge&amp; e=edges[G[x][i]];** **            if(d[x]+1==d[e.to] &amp;&amp; (f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){** **                e.flow+=f;** **                edges[G[x][i]^1].flow-=f;** **                flow+=f;** **                a-=f;** **                if(a==0) break;** **            }** **        }** **        return flow;** **    }** **    int Maxflow(int s,int t){** **        this-&gt;s=s;this-&gt;t=t;** **        int flow=0;** **        while(BFS()){** **            cle(cur,0);** **            flow+=DFS(s,INF);** **        }** **        return flow;** **    }** <strong>};</strong> <strong>int main(){</strong> **    while(~SII(N,M)){** **        Dinic dinic;** **        dinic.n=M;** **        rep(i,N){** **            int a,b,c;** **            SIII(a,b,c);** **            dinic.AddEdge(a,b,c);** **        }** **        printf(“%d\\n”,dinic.Maxflow(1,M));** **    }** **    return 0;** <strong>}</strong></int></int></edge></p>\n</blockquote>\n","text":"【类型】 最大流Dinic 【Code】#include  #include #include #include #include #include #include using namespace std; typedef long long ll; const int INF","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"最大流","slug":"POJ/最大流","count":2,"path":"api/categories/POJ/最大流.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"最大流","slug":"最大流","count":2,"path":"api/tags/最大流.json"}]},{"title":"UVa 437","slug":"uva-437","date":"2017-04-16T14:34:35.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-437.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>DAG上的DP</strong> <strong>下面的代码一是转换成最长单增子序列LIS做的</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=300;</strong> <strong>struct star{</strong> **    int a,b,c;** **    bool operator&lt;(const star &amp;A)const{** **        return a==A.a?b&lt;A.b:a&lt;A.a;** **    }** <strong>};</strong> <strong>star S[maxn];</strong> <strong>int N,kase=1;</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        int x,y,z,k=0;** **        rep(i,N){** **            SIII(x,y,z);** **            S[k].a=x;S[k].b=y;S[k++].c=z;** **            S[k].a=x;S[k].c=y;S[k++].b=z;** **            S[k].b=x;S[k].a=y;S[k++].c=z;** **            S[k].b=x;S[k].c=y;S[k++].a=z;** **            S[k].c=x;S[k].b=y;S[k++].a=z;** **            S[k].c=x;S[k].a=y;S[k++].b=z;** **        }** **        sort(S,S+k);** **        int ans=-INF,dp[maxn];** **        rep(i,k){** **            dp[i]=S[i].c;** **            rep(j,i){** **                if(S[j].a&lt;S[i].a &amp;&amp; S[j].b&lt;S[i].b){** **                    dp[i]=max(dp[i],dp[j]+S[i].c);** **                }** **            }** **            ans=max(ans,dp[i]);** **        }** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>代码二</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=30+5;</strong> <strong>int N,kase=1,blocks[maxn][3],d[maxn][3];</strong> <strong>void get_dimensions(int* v,int b,int dim){</strong> **    int idx=0;** **    rep(i,3) if(i!=dim) v[idx++]=blocks[b][i];** <strong>}</strong> <strong>int dp(int i,int j){</strong> **    int&amp; ans=d[i][j];** **    if(ans&gt;0) return ans;** **    ans=0;** **    int v[2],v2[2];** **    get_dimensions(v,i,j);** **    rep(a,N) rep(b,3){** **        get_dimensions(v2,a,b);** **        if(v2[0]&lt;v[0] &amp;&amp; v2[1]&lt;v[1]) ans=max(ans,dp(a,b));** **    }** **    ans+=blocks[i][j];** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        rep(i,N){** **            rep(j,3) SI(blocks[i][j]);** **            sort(blocks[i],blocks[i]+3);** **        }** **        cle(d,0);** **        int ans=0;** **        rep(i,N) rep(j,3) ans=max(ans,dp(i,j));** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 DAG上的DP 下面的代码一是转换成最长单增子序列LIS做的 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"字符串匹配模板","slug":"zfcpp","date":"2017-04-16T14:03:29.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/zfcpp.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Trie树】</strong> <strong>–数组实现</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int sigma_size=26;</strong> <strong>const int maxnode=1000;</strong> <strong>//字母表为全体小写字母的Trie</strong> <strong>struct Trie{</strong> **    int ch[maxnode][sigma_size];** **    int val[maxnode];** **    int sz;         //节点总数** **    Trie() {sz=1; memset(ch[0],0,sizeof(ch[0])); }//初始时只有一个根节点** **    int idx(char c) {return c-‘a’;} //字符c的编号** **    //插入字符串s,附加信息为v。注意v必须非0,因为0代表”本节点不是单词结点”** **    void In(char <em>s,int v){*</em> **        int u=0,n=strlen(s);** **        for(int i=0;i&lt;n;++i){** **            int c=idx(s[i]);** **            if(!ch[u][c]){  //结点不存在** **                memset(ch[sz],0,sizeof(ch[sz]));** **                val[sz]=0;          //中间结点的附加信息为0** **                ch[u][c]=sz++;      //新建结点** **            }** **            u=ch[u][c];             //往下走** **        }** **        val[u]=v;                   //字符串的最后一个字符的附加信息为v** **    }** **    int Se(char <em>s){*</em> **        int u=0,n=strlen(s);** **        for(int i=0;i&lt;n;++i){** **            int c=idx(s[i]);** **            if(!ch[u][c]) return 0;//单词不存在** **            u=ch[u][c];** **        }** **        return 1;//存在单词** **    }** <strong>};</strong> <strong>int main(){</strong> **    int N;** **    Trie <em>tr=new Trie;*</em> **    char str[11]=””;** **    scanf(“%d”,&amp;N);** **    while(N–){** **        scanf(“%s”,str);** **        tr-&gt;In(str,66);** **    }** **    scanf(“%d”,&amp;N);** **    while(N–){** **        scanf(“%s”,str);** **        printf(“%d\\n”,tr-&gt;Se(str));//1为存在单词,0为不存在** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>–链表实现</strong></p>\n<blockquote>\n<p>**#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>struct Tree{//以0-26作为Tree的头结点<br>    int num;<br>    Tree* Next[26];<br>    Tree(){<br>        num=0;<br>        int i;<br>        for(i=0;i&lt;26;i++)<br>            Next[i]=NULL;<br>    }<br>}T;</p>\n<p>void In(char <em>str){<br>    Tree</em> H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL)//只有微为空才允许创建<br>            H-&gt;Next[str[i]-‘a’]=new Tree;//想调用构造函数必须new一个Tree<br>        H=H-&gt;Next[str[i]-‘a’];<br>        H-&gt;num++;<br>    }<br>}</p>\n<p>int Se(char *str){<br>    Tree *H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL) return 0;<br>        H=H-&gt;Next[str[i]-‘a’];<br>    }<br>    return H-&gt;num;<br>}</p>\n<p>int main(){<br>    int N;<br>    char str[11]=””;<br>    scanf(“%d”,&amp;N);</p>\n<pre><code>while(N--){\n    scanf(&quot;%s&quot;,str);\n    In(str);\n}\n\nscanf(&quot;%d&quot;,&amp;N);\nwhile(N--){\n    scanf(&quot;%s&quot;,str);\n    printf(&quot;%d\\\\n&quot;,Se(str));\n}\n\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n<p><strong>【KMP】</strong> <strong>kmpN() 作用:构造next数组 参数:模式串,模式串长度 kmpC() 作用:返回模式串在主串中出现的次数(可重复) 参数:模式串,模式串长度,主串,主串长度</strong></p>\n<blockquote>\n<p><em>*`int nex[maxn];<br>void kmpN(char</em> x,int len) {<br>  int i=0,j=nex[0]=-1;<br>  while(i&lt;len) {<br>    while(j!=-1&amp;&amp;x[i]!=x[j])j=nex[j];<br>    nex[++i]=++j;<br>  }<br>}</p>\n<p>int kmpC(char x[],int m,char y[],int n) {<br>  int i=0,j=0,ans=0;<br>  while(i&lt;n) {<br>    while(-1!=j&amp;&amp;y[i]!=x[j])j=nex[j];<br>    i++; j++;<br>    if(j&gt;=m) {<br>      ans++;<br>      j=nex[j];<br>    }<br>  }<br>  return ans;<br>}`** </p>\n</blockquote>\n<p><strong>【后缀数组】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=10000+10;</strong> <strong>char s[maxn];</strong> <strong>int sa[maxn],t[maxn],t2[maxn],c[maxn],n;//n是文本串的长度</strong> <strong>//构造字符串s的后缀数组。每个字符值必须为0~m-1</strong> <strong>void build_sa(int m){</strong> <em>*    int i,*x=t,*y=t2;** **    //基数排序** **    for(i=0;i&lt;m;++i) c[i]=0;** **    for(i=0;i&lt;n;++i) c[x[i]=s[i]]++;** **    for(i=1;i&lt;m;++i) c[i]+=c[i-1];** **    for(i=n-1;i&gt;=0;–i) sa[–c[x[i]]]=i;** **    for(int k=1;k&lt;=n;k&lt;&lt;=1){** **        int p=0;** **        //直接用sa数组排序第二关键字** **        for(i=n-k;i&lt;n;++i) y[p++]=i;** **        for(i=0;i&lt;n;++i) if(sa[i]&gt;=k) y[p++] = sa[i]-k;** **        //基数排序第一关键字** **        for(i=0;i&lt;m;++i) c[i]=0;** **        for(i=0;i&lt;n;++i) c[x[y[i]]]++;** **        for(i=0;i&lt;m;++i) c[i]+=c[i-1];** **        for(i=n-1;i&gt;=0;i–) sa[–c[x[y[i]]]]=y[i];** **        //根据sa和y数组计算新的x数组** **        swap(x,y);** **        p=1;x[sa[0]]=0;** **        for(i=1;i&lt;n;++i)** **            x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++;** **        if(p&gt;=n) break; //以后即使继续倍增,sa也不会改变,退出** **        m=p;    //下次基数排序的最大值** **    }** <strong>}</strong> <strong>int m;  //模板长度。简单起见,这里存在全局变量中</strong> **int cmp_suffix(char</em> pattern,int p){//判断模板s是否为后缀p的前缀<em>* **    return strncmp(pattern,s+sa[p],m);** <strong>}</strong> **int find(char</em> P){** **    m=strlen(P);** **    if(cmp_suffix(P,0)&lt;0) return -1;** **    if(cmp_suffix(P,n-1)&gt;0) return -1;** **    int L=0,R=n-1;** **    while(R&gt;=L){            //二分查找** **        int M=L+(R-L)/2;** **        int res=cmp_suffix(P,M);** **        if(!res) return M;** **        if(res&lt;0) R=M-1; else L=M+1;** **    }** **    return -1;              //找不到** <strong>}</strong> <strong>int main(){</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Trie树】 –数组实现#include&lt;bits/stdc++.h&gt; using namespace std; const int sigma_size=26; const int maxnode=1000; //字母表为全体小写字母的Trie struct Tr","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"},{"name":"模板","slug":"未分类/模板","count":3,"path":"api/categories/未分类/模板.json"}],"tags":[]},{"title":"动态规划模板","slug":"dynamic-muban","date":"2017-04-16T04:00:16.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dynamic-muban.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【多重部分和问题】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=100000+10;</strong> <strong>int A[maxn],M[maxn],N,K;</strong> <strong>int dp[maxn];//滚动数组,当前第i个数在第j权下剩余的数量</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;N) &amp;&amp; N){** **        for(int i=0;i&lt;N;++i)** **            scanf(“%d%d”,&amp;A[i],&amp;M[i]);** **        cin&gt;&gt;K;** **        fill(dp,dp+maxn,-1);** **        dp[0]=0;** **        for(int i=0;i&lt;N;++i)** **            for(int j=0;j&lt;=K;++j){** **                if(dp[j]&gt;=0){** **                    dp[j]=M[i];** **                }else if(j&lt;A[i] || dp[j-A[i]]&lt;=0){** **                    dp[j]=-1;** **                }else{** **                    dp[j]=dp[j-A[i]]-1;** **                }** **            }** **        if(dp[K]&gt;=0) printf(“YES\\n”);** **        else puts(“NO”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【不等概率掷硬币】</strong></p>\n<blockquote>\n<p><strong>小Hi有一枚神奇的硬币。已知第i次投掷这枚硬币时，正面向上的概率是Pi。  ** **现在小Hi想知道如果总共投掷N次，其中恰好M次正面向上的概率是多少。</strong> <strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>double dp[1005][1005];</strong> <strong>int main(){</strong> <em>*    int n,m;** **    scanf(“%d%d”,&amp;n,&amp;m);** **    dp[0][0]=1.0;** **    for(int i=0;i&lt;n;++i){** **        double x;** **        scanf(“%lf”,&amp;x);** **        for(int j=0;j&lt;=i;++j){** **            dp[i+1][j]+=dp[i][j]</em>(1.0-x);** **            dp[i+1][j+1]+=dp[i][j]<em>x;*</em> **        }** **    }** **    printf(“%.6lf\\n”,dp[n][m]);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【LIS最长上升子序列】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>int A[30]={1,2,12,4,7,6,32,54,2,8784,23,212,54,59,85,2,6,542,35},N=19;</strong> <strong>int dp[20],maxmum=-INF;</strong> <strong>int main(){</strong> **    rep(i,N){** **        dp[i]=1;** **        rep(j,i){** **            if(A[j]&lt;A[i])** **                dp[i]=max(dp[i],dp[j]+1);** **        }** **        maxmum=max(maxmum,dp[i]);** **    }** **    rep(i,N){** **        printf(“%d “,dp[i]);** **    }** **    printf(“\\n%d\\n”,maxmum);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【排除62和4-数位dp】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【多重部分和问题】#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=100000+10; int A[maxn],M[maxn],N,K; int dp[maxn];//滚动数组,当前第i个数在第j","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"模板","slug":"动态规划/模板","count":1,"path":"api/categories/动态规划/模板.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"POJ 3723","slug":"poj-3723","date":"2017-04-14T02:57:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3723.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>并查集优化kruskal</strong> <strong>【Tip】</strong> <strong>并查集使得可以判断任意两点是否可归溯于同一点,藉此来判断若链接两点是否会形成一个环.</strong> <strong>这道题的输入是两个人以及两个人之间的亲密关系,征募某个人的花费为10000-(已征募人中亲密关系和自己的最大值).</strong> <strong>这里我们在每征募某个人a时,若使用了a,b的关系,就连一条a,b的边。</strong> <strong>如果这个图中存在圈,则一定会出现矛盾(谁是第一个被征募的？).</strong> <strong>所以这个图一定是森林.</strong> <strong>把人看做顶点.关系看做边,则这个问题就可以转化为求解无向图中的最大权森林问题(即亲密度之和最大),最大权森林问题可以通过把所有边权取反来求最小生成树.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>using namespace std;</strong> <strong>const int MAX_N=60000;</strong> <strong>struct edge{</strong> <em>*    int u,v,cost;** <strong>};</strong> <strong>bool comp(const edge&amp; e1,const edge&amp; e2){</strong> **    return e1.cost&lt;e2.cost;** <strong>}</strong> <strong>edge es[MAX_N];</strong> <strong>int V,E;//顶点数和边数</strong> <strong>//并查集</strong> <strong>int par[MAX_N];//父亲</strong> <strong>int rank[MAX_N];//树的高度</strong> <strong>void init_union_find(int n){</strong> **    for(int i=0;i&lt;n;++i){** **        par[i]=i;** **        rank[i]=0;** **    }** <strong>}</strong> <strong>//查询树的根</strong> <strong>int find(int x){</strong> **    if(par[x]==x){** **        return x;** **    }else{** **        return par[x]=find(par[x]);** **    }** <strong>}</strong> <strong>//合并x和y所属集合</strong> <strong>void unite(int x,int y){</strong> **    x=find(x);** **    y=find(y);** **    if(x==y) return;** **    if(rank[x]&lt;rank[y]){** **        par[x]=y;** **    }else{** **        par[y]=x;** **        if(rank[x]==rank[y]) rank[x]++;** **    }** <strong>}</strong> <strong>//判断x和y是否属于同一个集合</strong> <strong>bool same(int x,int y){</strong> **    return find(x)==find(y);** <strong>}</strong> <strong>int kruskal(){</strong> **    sort(es,es+E,comp);** **    int res=0;** **    init_union_find(V);** **    for(int i=0;i&lt;E;++i){** **        edge e=es[i];** **        if(!same(e.u,e.v)){** **            unite(e.u,e.v);** **            res+=e.cost;** **        }** **    }** **    return res;** <strong>}</strong> <strong>int main(){</strong> **    int N;** **    scanf(“%d”,&amp;N);** **    while(N–){** **        int B,G,R;** **        scanf(“%d%d%d”,&amp;G,&amp;B,&amp;R);** **        V=G+B;** **        E=R;** **        for(int i=0;i&lt;R;++i){** **            int a,b,c;** **            scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **            es[i]=(edge){a,G+b,-c};** **        }** **        printf(“%d\\n”,10000</em>(V)+kruskal());** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 并查集优化kruskal 【Tip】 并查集使得可以判断任意两点是否可归溯于同一点,藉此来判断若链接两点是否会形成一个环. 这道题的输入是两个人以及两个人之间的亲密关系,征募某个人的花费为10000-(已征募人中亲密关系和自己的最大值). 这里我们在每征募某个人a时,若","link":"","raw":null,"photos":[],"categories":[{"name":"kruskal","slug":"kruskal","count":1,"path":"api/categories/kruskal.json"},{"name":"POJ","slug":"kruskal/POJ","count":1,"path":"api/categories/kruskal/POJ.json"},{"name":"并查集","slug":"kruskal/POJ/并查集","count":1,"path":"api/categories/kruskal/POJ/并查集.json"}],"tags":[{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"}]},{"title":"POJ 1182","slug":"poj-1182","date":"2017-04-12T10:10:17.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-1182.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>并查集</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>const int MAX_N=150000+10;</strong> <strong>int N,K;</strong> <strong>int T[MAX_N],X[MAX_N],Y[MAX_N];</strong> <strong>//并查集</strong> <strong>int par[MAX_N];//父亲</strong> <strong>int rank[MAX_N];//树的高度</strong> <strong>void init(int n){</strong> **    for(int i=0;i&lt;n;++i){** **        par[i]=i;** **        rank[i]=0;** **    }** <strong>}</strong> <strong>//查询树的根</strong> <strong>int find(int x){</strong> **    if(par[x]==x){** **        return x;** **    }else{** **        return par[x]=find(par[x]);** **    }** <strong>}</strong> <strong>//合并x和y所属集合</strong> <strong>void unite(int x,int y){</strong> **    x=find(x);** **    y=find(y);** **    if(x==y) return;** **    if(rank[x]&lt;rank[y]){** **        par[x]=y;** **    }else{** **        par[y]=x;** **        if(rank[x]==rank[y]) rank[x]++;** **    }** <strong>}</strong> <strong>//判断x和y是否属于同一个集合</strong> <strong>bool same(int x,int y){</strong> **    return find(x)==find(y);** <strong>}</strong> <strong>void solve(){</strong> **    //初始化并查集** **    //元素X,X+N,X+2N分别代表X-A,X-B,X-C** **    init(N<em>3);*</em> **    int ans=0;** **    for(int i=0;i&lt;K;++i){** **        int t=T[i];** **        int x=X[i]-1,y=Y[i]-1;//将x,y转换为从下标为0开始编号的号码** **        if(x&lt;0||x&gt;=N||y&lt;0||y&gt;=N){//不满足条件2** **            ans++;** **            continue;** **        }** **        if(t==1){** **            if(same(x,y+N)||same(x,y+2<em>N)){*</em> **                ans++;** **            }else{** **                unite(x,y);** **                unite(x+N,y+N);** **                unite(x+2*N,y+2*N);** **            }** **        }else{** **            if(same(x,y) || same(x,y+2<em>N)){*</em> **                ans++;** **            }else{** **                unite(x,y+N);** **                unite(x+N,y+2<em>N);*</em> **                unite(x+2<em>N,y);*</em> **            }** **        }** **    }** **    printf(“%d\\n”,ans);** <strong>}</strong> <strong>int main(){</strong> **    scanf(“%d%d”,&amp;N,&amp;K);** **    for(int i=0;i&lt;K;++i){** **        scanf(“%d%d%d”,&amp;T[i],&amp;X[i],&amp;Y[i]);** **    }** **    solve();** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 并查集 【Code】#include #include using namespace std; const int MAX_N=150000+10; int N,K; int T[MAX_N],X[MAX_N],Y[MAX_N]; //并查集 int par[MAX_","link":"","raw":null,"photos":[],"categories":[{"name":"并查集","slug":"并查集","count":1,"path":"api/categories/并查集.json"},{"name":"数据结构","slug":"并查集/数据结构","count":1,"path":"api/categories/并查集/数据结构.json"}],"tags":[{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"}]},{"title":"STL & 函数","slug":"stl","date":"2017-04-12T02:45:11.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/stl.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【fill】</strong> <strong>等同memset.</strong> <strong>fill(起始地址,终止地址,元素);</strong> <strong>【优先队列】</strong> <strong>priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数:</strong> <strong>priority_queue&lt;Type, Container, Functional&gt;</strong> <strong>其中Type 为数据类型， Container 为保存数据的容器，Functional 为元素比较方式。</strong> <strong>Container 必须是用数组实现的容器，比如 vector, deque 但不能用 list.</strong> <strong>STL里面默认用的是 vector. 比较方式默认用 operator&lt; , 所以如果你把后面俩个参数缺省的话，</strong> <strong>优先队列就是大顶堆，队头元素最大。</strong></p>\n<p><strong><code>#include &lt;iostream&gt;</code></strong></p>\n<p><strong><code>#include &lt;queue&gt;</code></strong></p>\n<p><strong><code>using</code> <code>namespace</code> <code>std;</code></strong></p>\n<p><strong><code>int</code> <code>main(){</code></strong></p>\n<p><strong><code>priority_queue&lt;``int``&gt; q;</code></strong></p>\n<p><strong><code>for``(</code> <code>int</code> <code>i= 0; i&lt; 10; ++i ) q.push(</code> <code>rand``() );</code></strong></p>\n<p><strong><code>while``( !q.empty() ){</code></strong></p>\n<p><strong><code>cout &lt;&lt; q.top() &lt;&lt; endl;</code></strong></p>\n<p><strong><code>q.pop();</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong><code>getchar``();</code></strong></p>\n<p><strong><code>return</code> <code>0;</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong>如果要用到小顶堆，则一般要把模板的三个参数都带进去。</strong> <strong>STL里面定义了一个仿函数 greater&lt;&gt;，对于基本类型可以用这个仿函数声明小顶堆</strong></p>\n<p><strong><code>#include &lt;iostream&gt;</code></strong></p>\n<p><strong><code>#include &lt;queue&gt;</code></strong></p>\n<p><strong><code>using</code> <code>namespace</code> <code>std;</code></strong></p>\n<p><strong><code>int</code> <code>main(){</code></strong></p>\n<p><strong><code>priority_queue&lt;``int``, vector&lt;``int``&gt;, greater&lt;``int``&gt; &gt; q;</code></strong></p>\n<p><strong><code>for``(</code> <code>int</code> <code>i= 0; i&lt; 10; ++i ) q.push(</code> <code>rand``() );</code></strong></p>\n<p><strong><code>while``( !q.empty() ){</code></strong></p>\n<p><strong><code>cout &lt;&lt; q.top() &lt;&lt; endl;</code></strong></p>\n<p><strong><code>q.pop();</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong><code>getchar``();</code></strong></p>\n<p><strong><code>return</code> <code>0;</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong>ps:对于结构体Node,如果重载operator &gt; 可直接使用priority_queue&lt;Node,vector<node>,greater<node>&gt;.</node></node></strong></p>\n<p><strong>【set】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<set></set></strong> <strong>using namespace std;</strong> <strong>int main(){</strong> **    //声明** **    set<int> s;<strong>**    //插入元素</strong> **    s.insert(1);** **    s.insert(3);** **    s.insert(5);<strong>**    //查找元素</strong> **    set<int>::iterator ite;<strong>**    ite=s.find(1);</strong> **    if(ite==s.end()) puts(“not found”);** **    else puts(“found”);** **    //删除元素** **    s.erase(3);** **    //其他查找元素的方法** **    if(s.count(3)!=0)puts(“found”);** **    else puts(“not found”);** **    //遍历所有元素** **    for(ite=s.begin();ite!=s.end();++ite){** **        printf(“%d\\n”,<em>ite);*</em> **    }** **    return 0;** <strong>}</strong></int></int></p>\n</blockquote>\n<p><strong>【map】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<map></map></strong> <strong>#inlcude<string></string></strong> <strong>using namespace std;**</strong>int main(){<em>* **    //声明(int为键,const char<em>为值)*</em> **    map&lt;int,const char</em>&gt; m;<strong>**    //插入元素</strong> <em>*    //map里所有元素都是pair,pair是一个结构体** **    //有两个元素,第一个是first,第二个是second** **    m.insert(make_pair(1,”ONE”));** **    m.insert(make_pair(10,”TEN”));** **    m[100]=”HUNDREN”;  //其他的写法<strong>**    //查找元素</strong> **    map&lt;int,const char</em>&gt;::iterator ite;** **    ite=find(1);** **    puts(ite-&gt;second);    //输出ONE,so,这里为什么用second,懂了吧** **    ite=m.find(2);** **    if(ite==m.end()) puts(“not found”);** **    else puts(ite-&gt;second);** **    puts(m[10]);    //返回-&gt;second** **    //删除元素** **    m.erase();** **    //遍历等同于set,不过输出的是pair的first和second.** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【fill】 等同memset. fill(起始地址,终止地址,元素); 【优先队列】 priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数: priority_queue&lt;Type, Container, Functional&gt; 其","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"Android Inflater","slug":"android-inflater","date":"2017-04-09T02:16:24.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/android-inflater.json","excerpt":"","keywords":null,"cover":"http://common.cnblogs.com/images/copycode.gif","content":"<p>在 实际开发中LayoutInflater这个类还是非常有用的，它的作用类似于findViewById()。不同点是LayoutInflater是用 来找res/layout/下的xml布局文件，并且实例化；而findViewById()是找xml布局文件下的具体widget控件(如 Button、TextView等)。 具体作用： 1、对于一个没有被载入或者想要动态载入的界面，都需要使用LayoutInflater.inflate()来载入； 2、对于一个已经载入的界面，就可以使用Activiyt.findViewById()方法来获得其中的界面元素。 LayoutInflater 是一个抽象类，在文档中如下声明：</p>\n<blockquote>\n<p>public abstract class LayoutInflater extends Object</p>\n</blockquote>\n<p><strong>获得 LayoutInflater 实例的三种方式</strong> <strong>1.</strong></p>\n<blockquote>\n<p>LayoutInflater inflater = getLayoutInflater();  //调用Activity的getLayoutInflater()</p>\n</blockquote>\n<p>2.</p>\n<blockquote>\n<p>LayoutInflater localinflater =(LayoutInflater)context.getSystemService (Context.LAYOUT_INFLATER_SERVICE);</p>\n</blockquote>\n<p>3.</p>\n<blockquote>\n<p> LayoutInflater inflater = LayoutInflater.from(context);</p>\n</blockquote>\n<p>其实，这三种方式本质是相同的，从源码中可以看出： <strong>getLayoutInflater()：</strong> Activity 的 getLayoutInflater() 方法是调用 PhoneWindow 的getLayoutInflater()方法，看一下该源代码：  </p>\n<blockquote>\n<p> public PhoneWindow(Context context) {<br>        super(context);<br>        mLayoutInflater = LayoutInflater.from(context);<br>}</p>\n</blockquote>\n<p>  可以看出它其实是调用 LayoutInflater.from(context)。 <strong>LayoutInflater.from(context)：</strong></p>\n<p><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></p>\n<blockquote>\n<p>public static LayoutInflater from(Context context) {<br>    LayoutInflater LayoutInflater =<br>            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<br>    if (LayoutInflater == null) {<br>        throw new AssertionError(“LayoutInflater not found.”);<br>    }<br>    return LayoutInflater;<br>}</p>\n</blockquote>\n<p><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></p>\n<p>可以看出它其实调用 context.getSystemService()。 <strong>结论：所以这三种方式最终本质是都是调用的Context.getSystemService()。</strong> <strong>inflate 方法 通过 sdk 的 api 文档，可以知道该方法有以下几种过载形式，返回值均是 View 对象，如下</strong></p>\n<blockquote>\n<p>public View inflate (int resource, ViewGroup root)<br>public View inflate (XmlPullParser parser, ViewGroup root)<br>public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)<br>public View inflate (int resource, ViewGroup root, boolean attachToRoot)</p>\n</blockquote>\n<p>示意代码：  </p>\n<blockquote>\n<p>LayoutInflater inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);<br>View view = inflater.inflate(R.layout.custom, (ViewGroup)findViewById(R.id.test));<br>//EditText editText = (EditText)findViewById(R.id.content);// error<br>EditText editText = (EditText)view.findViewById(R.id.content);</p>\n</blockquote>\n<p>  <strong>对于上面代码，指定了第二个参数 ViewGroup root，当然你也可以设置为 null 值。</strong> <strong>注意：</strong></p>\n<ul>\n<li>·inflate 方法与 findViewById 方法不同；</li>\n<li>·inflater 是用来找 res/layout 下的 xml 布局文件，并且实例化；</li>\n<li>·findViewById() 是找具体 xml 布局文件中的具体 widget 控件(如:Button、TextView 等)。</li>\n</ul>\n<p>############## <a href=\"http://blog.sina.com.cn/s/blog_48a45b950100u8ax.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_48a45b950100u8ax.html</a></p>\n","text":"在 实际开发中LayoutInflater这个类还是非常有用的，它的作用类似于findViewById()。不同点是LayoutInflater是用 来找res/layout/下的xml布局文件，并且实例化；而findViewById()是找xml布局文件下的具体widget控件","link":"","raw":null,"photos":[],"categories":[{"name":"Android","slug":"Android","count":5,"path":"api/categories/Android.json"}],"tags":[{"name":"Android","slug":"Android","count":5,"path":"api/tags/Android.json"}]},{"title":"UVa 10755","slug":"uva-10755","date":"2017-04-08T08:04:53.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-10755.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>最大子长方体和,降维.</strong> <strong>【题解】</strong> <strong>蓝书P56</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i)</strong> <strong>using namespace std;</strong> <strong>typedef long long LL;</strong> <strong>const int maxn=30;</strong> <strong>const LL INF=1LL&lt;&lt;60;</strong> <strong>LL S[maxn][maxn][maxn];</strong> <strong>void expand(int i,int&amp; b0,int&amp; b1,int&amp; b2){</strong> **    b0=i&1; i&gt;&gt;=1;** **    b1=i&1; i&gt;&gt;=1;** **    b2=i&1;** <strong>}</strong> <strong>int sign(int b0,int b1,int b2){</strong> **    return (b0+b1+b2)%2==1?1:-1;** <strong>}</strong> <strong>LL sum(int x1,int x2,int y1,int y2,int z1,int z2){</strong> **    int dx=x2-x1+1,dy=y2-y1+1,dz=z2-z1+1;** **    LL s=0;** **    for(int i=0;i&lt;8;++i){** **        int b0,b1,b2;** **        expand(i,b0,b1,b2);** **        s-=S[x2-b0*dx][y2-b1*dy][z2-b2*dz]*sign(b0,b1,b2);** **    }** **    return s;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int a,b,c,b0,b1,b2;** **        scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **        memset(S,0,sizeof(S));** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    scanf(“%lld”,&amp;S[x][y][z]);** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    for(int i=1;i&lt;=7;++i){** **                        //001 010 011 100 101 110 111三种位移** **                        expand(i,b0,b1,b2);** **                        //递推求和,sign()-&gt;加 or 减; expand()-&gt;状态** **                        S[x][y][z]+=S[x-b0][y-b1][z-b2]<em>sign(b0,b1,b2);*</em> **                    }** **        LL ans=-INF;** **        for(int x1=1;x1&lt;=a;++x1)** **            for(int x2=x1;x2&lt;=a;++x2)** **                for(int y1=1;y1&lt;=b;++y1)** **                    for(int y2=y1;y2&lt;=b;++y2){** **                        LL M=0;** **                        //对于每次求某个x1,x2,y1,y2区间上的最大子长方体和** **                        //M等价于寻找z区间上(1-z)中最小的子矩阵** **                        for(int z=1;z&lt;=c;++z){** **                            LL s=sum(x1,x2,y1,y2,1,z);** **                            ans=max(ans,s-M);** **                            M=min(M,s);** **                        }** **                    }** **                    printf(“%lld\\n”,ans);** **                    if(T) printf(“\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 最大子长方体和,降维. 【题解】 蓝书P56 【Code】#include #include #include #include #define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i) using namespace std; t","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"LA 3029","slug":"la-3029","date":"2017-04-05T13:07:21.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3029.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>扫描线,悬线法</strong> <strong>【题解】</strong> <strong>蓝书P50</strong> <strong><a href=\"http://blog.csdn.net/qq415200973/article/details/11377199\" target=\"_blank\" rel=\"noopener\">扫描方程的解释</a></strong> <strong>我对代码的理解放在代码里了.</strong> <strong>如果为满：left[i][j]=0,right[i][j]=n,up[i][j]=0,这里是为了下一行的比较做准备。可以模拟试一试。</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>using namespace std;</strong> <strong>const int maxn=1000;</strong> <strong>int mat[maxn][maxn],up[maxn][maxn],left[maxn][maxn],right[maxn][maxn];</strong> <strong>int readchar(){</strong> <em>*    int a=getchar();** **    while(a!=’F’ &amp;&amp; a!=’R’) a=getchar();** **    return a;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int m,n;** **        scanf(“%d%d”,&amp;m,&amp;n);** **        for(int i=0;i&lt;m;++i)** **            for(int j=0;j&lt;n;++j){** **                int ch=getchar();** **                while(ch!=’F’ &amp;&amp; ch!=’R’) ch=getchar();** **                mat[i][j]=ch==’F’?0:1;** **            }** **        int ans=0;** **        for(int i=0;i&lt;m;++i){//从上到下逐行处理** **            int lo=-1,ro=n;** **            for(int j=0;j&lt;n;++j)//从左向右处理** **                if(mat[i][j]==1){left[i][j]=up[i][j]=0;lo=j;}** **                else{** **                    up[i][j]=i==0?1:up[i-1][j]+1;** **                    //lo存的是左边界的下标,而不是到左边将诶有多少空地** **                    //这里,每次遇到障碍(1)时,lo就等于j(重新开始计算左边界)** **                    //然后,left[i][j]存的是当前矩阵的右边界** **                    //这里是lo+1,而不是lo++,所以lo的值在碰到障碍前一直不变** **                    //因为受到上一行的影响,所以需要在上一行和本行中选取一个最大** **                    //下标的左边界.** **                    left[i][j]=i==0?lo+1:max(left[i-1][j],lo+1);** **                }** **            for(int j=n-1;j&gt;=0;–j)//从右往左扫描,维护right并更新答案** **                if(mat[i][j]==1){right[i][j]=n;ro=j;}** **                //为啥等于n捏？？？** **                //为了使其下一行若是空格,作比较的时候,会发现上一行的下标一定是最大的** **                //从而不影响下一行右边界的计算** **                else{** **                    right[i][j]=i==0?ro-1:min(right[i-1][j],ro-1);** **                    ans=max(ans,up[i][j]</em>(right[i][j]-left[i][j]+1));** **                }** **        }** **        printf(“%d\\n”,ans<em>3);*</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 扫描线,悬线法 【题解】 蓝书P50 扫描方程的解释 我对代码的理解放在代码里了. 如果为满：left[i][j]=0,right[i][j]=n,up[i][j]=0,这里是为了下一行的比较做准备。可以模拟试一试。 【Code】#include #include us","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"悬线法","slug":"LA/思维/悬线法","count":1,"path":"api/categories/LA/思维/悬线法.json"}],"tags":[{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"}]}]}