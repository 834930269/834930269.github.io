{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"Unix fork()","slug":"unix-fork","date":"2017-10-05T02:12:20.000Z","updated":"2019-07-03T13:51:36.857Z","comments":true,"path":"api/articles/unix-fork.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171005101046.png","content":"<p>创建一个父进程的子进程,其代码等都是一样的,除了数据和pid不一样. 以下是在Python/Linux下操作示例.(因为服务器上的python总是出现输入不显示,所以直接搞了输出..) <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171005101046.png\" alt=\"Aaron\"></p>\n","text":"创建一个父进程的子进程,其代码等都是一样的,除了数据和pid不一样. 以下是在Python/Linux下操作示例.(因为服务器上的python总是出现输入不显示,所以直接搞了输出..)  [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"Linux","slug":"Linux","count":1,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}]},{"title":"中MPython爬虫成绩","slug":"mid-mpython-bug","date":"2017-10-03T12:56:45.000Z","updated":"2019-07-03T13:51:36.854Z","comments":true,"path":"api/articles/mid-mpython-bug.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171003205226.png","content":"<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171003205226.png\" alt=\"Aaron\"> 90.67分,钦定优秀证书,不过不申请认证了…100太贵了.而且不知道作用大不大..:sob:</p>\n","text":" [Figure]  90.67分,钦定优秀证书,不过不申请认证了…100太贵了.而且不知道作用大不大..:sob:","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"Node.js-Koa-渲染","slug":"node-js-koa-render","date":"2017-10-02T07:30:56.000Z","updated":"2019-07-03T13:51:36.854Z","comments":true,"path":"api/articles/node-js-koa-render.json","excerpt":"","keywords":null,"cover":null,"content":"<p>模块依赖的是:</p>\n<pre><code>&quot;dependencies&quot;: {\n    &quot;nunjucks&quot;: &quot;2.4.2&quot;\n}</code></pre><p>nunjucks. 廖大说很像Jinja2,确实. 首先依然是目录结构,与其他无大差异. 然后是编写app.js中调用渲染的模块:</p>\n<pre><code>const nunjucks = require(&apos;nunjucks&apos;);\n\nfunction createEnv(path,opts){\n    var\n        autoescape=opts.autoescape===undefined?true:opts.autoescape,\n        noCache = opts.noCache || false,\n        watch = opts.watch || false,\n        throwOnUndefined = opts.throwOnUndefined || false,\n        env = new nunjucks.Environment(\n            new nunjucks.FileSystemLoader(&apos;views&apos;,{\n                noCache:noCache,\n                watch:watch,\n            }),{\n                autoescape: autoescape,\n                throwOnUndefined: throwOnUndefined\n            });\n    if(opts.filters){\n        for(var f in opts.filters){\n            env.addFilter(f,opts.filters[f]);\n        }\n    }\n    return env;\n}\n\nvar env=createEnv(&apos;views&apos;,{\n    watch:true,\n    filters:{\n        hex:function(n){\n            return &apos;0x&apos;+n.toString(16);\n        }\n    }\n});</code></pre><p>其中noCache是禁止缓冲,当程序发布时,这个必须是Cache,否则对性能的影响略大. 接下来就对模板html进行渲染了! 首先我们编写一个hello.html:</p>\n<pre><code> &lt;h1&gt;Hello { { name }}&lt;/h1&gt;\n&lt;!-- 循环输出名字 --&gt;\n&lt;body&gt;\n    &lt;h3&gt;Fruits List&lt;/h3&gt;\n    {% for f in fruits %}\n        <p>{ { f }}</p>\n        {% endfor %}\n&lt;/body&gt;</code></pre><p>对其中的 name 和 fruits(List)进行渲染: 代码位于app.js</p>\n<pre><code>var s=env.render(&apos;hello.html&apos;,{name:&apos;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&apos;,fruits:[123,456]});\nconsole.log(s);</code></pre><p>输出结果如下:</p>\n<pre><code>&lt;h1&gt;Hello &lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&lt;/h1&gt;\n&lt;!-- 循环输出名字 --&gt;\n&lt;body&gt;\n    &lt;h3&gt;Fruits List&lt;/h3&gt;\n\n    &lt;p&gt;123&lt;/p&gt;\n\n    &lt;p&gt;456&lt;/p&gt;\n\n&lt;/body&gt;</code></pre><p>可以看到,渲染成功.即简单的拼接字符串. 接下来我们进行网页模板页渲染: 首先我们写一个 base.html:</p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    {% block header %}<h3>Unnamed</h3>{% endblock %}\n        {% block body %}<div>No body</div>{% endblock %}\n    {% block footer %}<div>copyright</div>{% endblock %}\n    \n    \n    \n\n可以看到确实很像jinja2~ 然后我们再写一个继承自base.html的 extend.html:\n\n    {% extends 'base.html' %}\n    \n    {% block header %}<h1>{ { header }}</h1>{% endblock %}\n\n{% block body %}<p>{ { body }}</p>{% endblock %}</code></pre><p>渲染:</p>\n<pre><code>console.log(env.render(&apos;extend.html&apos;,{\n    header: &apos;Hello&apos;,\n    body: &apos;bla bla bla...&apos;\n}));</code></pre><p>结果如下:</p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;p&gt;bla bla bla...&lt;/p&gt;\n    &lt;div&gt;copyright&lt;/div&gt;\n&lt;/body&gt;</code></pre><p>End</p>\n","text":"模块依赖的是:&quot;dependencies&quot;: {    &quot;nunjucks&quot;: &quot;2.4.2&quot;}nunjucks. 廖大说很像Jinja2,确实. 首先依然是目录结构,与其他无大差异. 然后是编写app.js中调用渲染的","link":"","raw":null,"photos":[],"categories":[{"name":"JS","slug":"JS","count":3,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"Egret事件","slug":"egret-event","date":"2017-10-01T06:48:46.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/egret-event.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171001144253.png","content":"<p>先贴跟随书上的问题代码: 项目截图: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171001144253.png\" alt=\"Aaron\"> 代码:</p>\n<pre><code>//Circle.ts\nclass Circle extends egret.Sprite{\n    public constructor(cx:number,cy:number,cr:number){\n        super();\n        this.init(cx,cy,cr);\n    }\n    private shape:egret.Shape;\n    private shapex:number;\n    private shapey:number;\n    private shaper:number;\n    private color:number;\n    public static Event_Click:string=&quot;event_click&quot;;\n    private colorList = [13408665, 16777113, 6710937, 16750848, 16776960, 39372, 13421721, 13382553, 10079232, 16737894, 16776960, 3381708, 13395456, 10066329, 13421619, 16750899, 16777164, 39219, 39372, 13421772, 16737894, 16737792, 16777062, 39270, 13395507, 16764057, 13395456, 13369446, 39321, 16763955];\n    private randmColor():number{\n        return this.colorList[Math.round(Math.random()*this.colorList.length)];\n    }\n    private init(cx:number,cy:number,cr:number){\n        this.color=this.randmColor();\n        this.shape=new egret.Shape();\n        this.shape.graphics.beginFill(this.color);\n        this.shape.graphics.drawCircle(0,0,cr);\n        this.shape.graphics.endFill();\n        //设定矢量圆的位置为父类中心点\n        this.shape.x=-cr;\n        this.shape.y=-cr;\n\n        this.shapex=cx;\n        this.shapey=cy;\n        this.shaper=cr;\n        this.touchEnabled=!0;\n\n        //侦听用户的移动与触摸事件\n        this.addEventListener(egret.TouchEvent.TOUCH_TAP,this.onTouch,this,!1);\n        this.addChild(this.shape);\n        this.x=cx;\n        this.y=cy;\n    }\n    private onTouch(e:egret.TouchEvent):void{\n        var par=this.parent;\n        par.dispatchEventWith(Circle.Event_Click,false,this.color);\n        this.touchEnabled=!1;\n        var tween:egret.Tween=egret.Tween.get(this);\n        tween.to({alpha:0.1},500,egret.Ease.sineOut);\n        tween.call(function(){\n            this.visible=!1;\n            par.removeChild(this);\n            this.removeEventListener(egret.TouchEvent.TOUCH_TAP,this.onTouch,this);\n        },this);\n\n        var circleList:Circle[]=[];\n        var tweenList:egret.Tween[]=[];\n        var redius:number=this.shaper&gt;&gt;1;\n        var tempx:number;\n        var tempy:number;\n        var tempr:number;\n\n        var g:number=0;\n        for(var i:number=0;i&lt;2;++i){\n            for(var t:number=0;t&lt;2;++t){\n                tempx=this.shapex-this.shaper+redius*2*t;\n                tempy=this.shapey-this.shaper+redius*2*i;\n                circleList[g]=new Circle(tempx,tempy,redius);\n                circleList[g].alpha=0.1;\n                circleList[g].scaleX=0.8;\n                circleList[g].scaleY=0.8;\n                par.addChild(circleList[g]);\n                tweenList[g]=egret.Tween.get(circleList[g]);\n                tweenList[g].to({alpha:1,scaleX:1,scaleY:1},1000,egret.Ease.sineIn);\n                g++;\n            }\n        }\n\n    }\n}\n\n\n\n//Main.ts\n    public constructor() {\n        super();\n        this.addEventListener(egret.Event.ADDED_TO_STAGE, this.onAddToStage, this);\n        this.addEventListener(Circle.Event_Click,this.onClickCircle,this);\n    }\n\n    private textCount:egret.TextField;\n    private textTimer:egret.TextField;\n    private textDes:egret.TextField;\n    private timer:egret.Timer;\n    private color:number; \n\n    private onAddToStage(event: egret.Event) {\n        var stageW:number=this.stage.stageWidth;\n        var stageH:number=this.stage.stageHeight;\n\n        var bg=new egret.Shape();\n        bg.graphics.beginFill(0xfccfcc);\n        bg.graphics.drawRect(0,0,stageW,stageH);\n        bg.graphics.endFill();\n\n        this.textCount=new egret.TextField();\n        this.textCount.textColor=0xffffff;\n        this.textCount.y=630;\n        this.textCount.text=&quot;分数 : 0&quot;;\n\n        this.textTimer=new egret.TextField();\n        this.textTimer.textColor=0xffffff;\n        this.textTimer.y=720;\n        this.textTimer.text=&quot;倒计时&quot;;\n\n        this.textDes=new egret.TextField();\n        this.textDes.text=&quot;点击第一个颜色开始&quot;;\n        this.textDes.y=800;\n\n        this.textCount.textAlign=\n            this.textTimer.textAlign=\n                this.textDes.textAlign=\n                    egret.HorizontalAlign.CENTER;\n\n        this.textCount.width=\n            this.textDes.width=\n                this.textTimer.width=stageW;\n\n        this.textCount.textColor=\n            this.textDes.textColor=\n                this.textTimer.textColor=0x000000;\n\n        this.addChild(bg);\n        this.addChild(this.textCount);\n        this.addChild(this.textDes);\n        this.addChild(this.textTimer);\n\n        this.timer=new egret.Timer(1000,30);\n        this.timer.addEventListener(egret.TimerEvent.TIMER,this.onTimer,this);\n        this.timer.addEventListener(egret.TimerEvent.TIMER_COMPLETE,this.onTimerComplete,this);\n\n        var radius:number=60;\n        for(var i:number=0;i&lt;4;++i){\n            for(var t:number=0;t&lt;4;++t){\n                var tempx:number=200+radius*2*t;\n                var tempy:number=190+radius*2*i;\n                var circle:Circle=new Circle(tempx,tempy,radius);\n                this.addChild(circle);\n            }\n        }\n    }\n\n    private count:number=0;\n    private onClickCircle(e:any):void{\n        //e是触发时的事件对象\n        console.log(e,this.color,&quot;   &quot;,e.data);\n        if(this.count==0){\n            this.color=e.data;\n            //console.log(e,&quot;   &quot;,e.data);\n            this.textCount.text=&quot;分数 : &quot;+(++this.count);\n            this.timer.start();\n        }else if(this.color==e.data){\n            this.textCount.text=&quot;分数 : &quot;+(++this.count);\n        }\n    }\n\n    private onTimer(e:egret.TimerEvent):void{\n        this.textTimer.text=&quot;倒计时 : &quot;+(this.timer.repeatCount-this.timer.currentCount);\n    }\n\n    private onTimerComplete(e:egret.TimerEvent):void{\n        this.textDes.text=&quot;这不是极限,刷新再来一次! &quot;;\n        this.removeEventListener(Circle.Event_Click,this.onClickCircle,this);\n    }</code></pre><p>其中我不解的是</p>\n<pre><code>e:any</code></pre><p>和</p>\n<pre><code>e.data</code></pre><p>为什么是color:number类型的.所以准备系统搞一遍Event. **------------ 1.开始… 首先是构造函数中的三个参数，type、bubbles和cancelable。</p>\n<pre><code>type:触发事件的类型.\nbubbles:是指定事件是否参与事件流的冒泡阶段，关于事件流，会在后面的小节中介绍。\ncancelable:表示是否要取消Event对象。</code></pre><p>这里我们用约会的例子来说明一下. 首先定义一个约会的类:</p>\n<pre><code>class DateEvent extends egret.Event\n{\n    public static DATE:string = &quot;约会&quot;;\n    public _year:number = 0;\n    public _month:number = 0;\n    public _date:number = 0;\n    public _where:string = &quot;&quot;;\n    public _todo:string = &quot;&quot;;\n    public constructor(type:string, bubbles:boolean=false, cancelable:boolean=false)\n    {\n        super(type,bubbles,cancelable);\n    }\n}</code></pre><p>其中</p>\n<pre><code>static DATE:string</code></pre><p>代表DATE事件. **------------ 2.侦听器 事件侦听器也就是事件的处理者，负责接收事件携带的信息，并在接收到该事件后执行特定的代码。 Egret中，事件的侦听器必须是一个函数。事件的发送者必须是 egret.EventDispatcher 类或者子类的实例。只有事件发送者才能侦听事件，并且可以 注册侦听器。 注册侦听器:addEventListener(). 侦听器的定义:</p>\n<pre><code>public addEventListener(type:string, listener:Function, thisObject:any, useCapture:boolean = false, priority:number = 0)</code></pre><p>type: 事件类型. listener: 用来处理事件的侦听器,即函数. thisObject: this即可. 注册侦听器: 事件发送者.addEventListener(事件类型, 侦听器, this); 移除侦听器: 事件发送者.removeEventListener(事件类型, 侦听器, this); 最后一个 priority 参数的设置即侦听器的优先级. 而 侦听器 有一个参数是 e:Event.或者 e:any. e.data 即为发送过来的数据. 在项目中 Circle 有这样一个句:</p>\n<pre><code>par.dispatchEventWith(Circle.Event_Click,false,this.color);</code></pre><p>即当事件触发时 打包发送 this.color. 将其改为 0Xffffff 试试: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171001151826.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171001151826.png\" alt></a> 果然如此. 问题解决!****</p>\n","text":"先贴跟随书上的问题代码: 项目截图:  [Figure]  果然如此. 问题解决!****","link":"","raw":null,"photos":[],"categories":[{"name":"Egret","slug":"Egret","count":3,"path":"api/categories/Egret.json"}],"tags":[{"name":"Egret","slug":"Egret","count":3,"path":"api/tags/Egret.json"}]},{"title":"Egret学习笔记","slug":"egret","date":"2017-09-24T08:15:06.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/egret.json","excerpt":"","keywords":null,"cover":"http://cdn.dev.egret.com/egret-docs/Engine2D/displayObjecContainer/depthManagement/566d13d822cef.png","content":"<h3 id=\"【添加与显示对象】\"><a href=\"#【添加与显示对象】\" class=\"headerlink\" title=\"【添加与显示对象】\"></a><strong>【添加与显示对象】</strong></h3><p>1.同一个显示对象只能被添加一次,无论添加多少次只显示最后一个. 2.删除对象是用父对象.removeChild(显示对象),即被删除对象必须有父级对象. 3.判断是否有父级对象存在:</p>\n<pre><code>if( spr.parent ) {\n    spr.parent.removeChild( spr );\n}</code></pre><h3 id=\"【深度管理】\"><a href=\"#【深度管理】\" class=\"headerlink\" title=\"【深度管理】\"></a><strong>【深度管理】</strong></h3><p>1.比较像html中的z-index 2.如果想在一个容器的某个深度添加子节点对象时,要用:</p>\n<pre><code>容器.addChildAt( 显示对象, 深度值 )</code></pre><p>这就很像在队列中插入一个元素: <a href=\"http://cdn.dev.egret.com/egret-docs/Engine2D/displayObjecContainer/depthManagement/566d13d822cef.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://cdn.dev.egret.com/egret-docs/Engine2D/displayObjecContainer/depthManagement/566d13d822cef.png\" alt></a> 3.删除某深度的子对象:</p>\n<pre><code>容器.removeChildAt( 深度值 )</code></pre><p>4.删除掉所有对象:</p>\n<pre><code>容器.removeChildren();</code></pre><p>5.交换不同对象:</p>\n<pre><code>容器.swapChildren( 显示对象, 显示对象 )\n\n容器.swapChildrenAt( 深度值, 深度值 )</code></pre><p>6.重设深度值:</p>\n<pre><code>容器.setChildIndex( 显示对象, 新的深度值 );</code></pre><h3 id=\"【访问容器子对象】\"><a href=\"#【访问容器子对象】\" class=\"headerlink\" title=\"【访问容器子对象】\"></a><strong>【访问容器子对象】</strong></h3><p>1.通过深度获取:</p>\n<pre><code>容器.getChildAt( 深度值 );</code></pre><p>2.设置灰度值:</p>\n<pre><code>对象.alpha = 0.5;</code></pre><p>3.通过name值获取: 设置name的方法:</p>\n<pre><code>对象.name=&quot;&quot;;</code></pre><p>获取方法:</p>\n<pre><code>容器.getChildByName(&quot;&quot;);</code></pre><p>4.方法对比后还是通过深度获取效率更好.</p>\n","text":"【添加与显示对象】1.同一个显示对象只能被添加一次,无论添加多少次只显示最后一个. 2.删除对象是用父对象.removeChild(显示对象),即被删除对象必须有父级对象. 3.判断是否有父级对象存在:if( spr.parent ) {    spr.parent.remove","link":"","raw":null,"photos":[],"categories":[{"name":"Egret","slug":"Egret","count":3,"path":"api/categories/Egret.json"}],"tags":[{"name":"Egret","slug":"Egret","count":3,"path":"api/tags/Egret.json"}]},{"title":"JS事件","slug":"jsonmouseevent","date":"2017-09-13T04:57:42.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/jsonmouseevent.json","excerpt":"","keywords":null,"cover":null,"content":"<p>鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件仅作用在当前焦点的DOM上，通常是和。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当、或的内容改变时触发； submit：当 &lt; form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。</p>\n","text":"鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上","link":"","raw":null,"photos":[],"categories":[{"name":"JS","slug":"JS","count":3,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"C++操作CMD并返回结果","slug":"c-cmd","date":"2017-09-12T10:53:51.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/c-cmd.json","excerpt":"","keywords":null,"cover":null,"content":"<pre><code>#include &lt;iostream&gt;  \nusing namespace std ;  \n// 描述:execmd函数执行命令，并将结果存储到result字符串数组中   \n// 参数:cmd表示要执行的命令  \n// result是执行的结果存储的字符串数组  \n// 函数执行成功返回1，失败返回0    \nint execmd(char* cmd,char* result) {  \n    char buffer[128];                         //定义缓冲区                          \n    FILE* pipe = _popen(cmd, &quot;r&quot;);            //打开管道，并执行命令   \n    if (!pipe)  \n        return 0;                      //返回0表示运行失败   \n\n    while(!feof(pipe)) {  \n        if(fgets(buffer, 128, pipe)){             //将管道输出到result中   \n            strcat(result,buffer);  \n        }  \n    }  \n    _pclose(pipe);                            //关闭管道   \n    return 1;                                 //返回1表示运行成功   \n}  \n\nint main(){  \n    char result[1024*4]=&quot;&quot;;                   //定义存放结果的字符串数组   \n    if(1==execmd(&quot;ipconfig&quot;,result)){  \n        printf(result);  \n    }  \n    system(&quot;pause&quot;);                          //暂停以查看结果   \n}</code></pre>","text":"#include &lt;iostream&gt;  using namespace std ;  // 描述:execmd函数执行命令，并将结果存储到result字符串数组中   // 参数:cmd表示要执行的命令  // result是执行的结果存储的字符串数组  // 函数","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"javascript表单传送文件","slug":"javascrip-form-file","date":"2017-09-10T12:40:21.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/javascrip-form-file.json","excerpt":"","keywords":null,"cover":null,"content":"<p>专门把这次课给搞出来记一下笔记.. 在HTML中,唯一可以上传文件的就是</p>\n<pre><code>&lt;input type=&quot;file&quot;&gt;</code></pre><p>注意，当一个表单包含file时,表单的<em>enctype_必须是_multipart/form-data</em>,<em>method_必须指定为_post</em>,浏览器才能以正确编码并以_multipart/form-data_格式发送表单. Tip: enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。 出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径：</p>\n<pre><code>获取表单上传路径后结果总会是fakepath\n&lt;script&gt;\n$(function () {\n    var\n        fileInput = document.getElementById(&apos;test-file-upload&apos;),\n        filePath = document.getElementById(&apos;test-get-filename&apos;);\n    fileInput.addEventListener(&apos;change&apos;, function () {\n        filePath.innerText = fileInput.value;\n    });\n});\n&lt;/script&gt;\n\n&lt;form method=&quot;post&quot; action=&quot;http://localhost/test&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;p&gt;\n        &lt;input type=&quot;file&quot; id=&quot;test-file-upload&quot; name=&quot;test&quot;&gt;\n    &lt;/p&gt;\n    &lt;p&gt;待上传文件: &lt;span id=&quot;test-get-filename&quot; style=&quot;color:red&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/form&gt;</code></pre><p>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：</p>\n<pre><code>var f = document.getElementById(&apos;test-file-upload&apos;);\nvar filename = f.value; // &apos;C:\\fakepath\\test.png&apos;\nif (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) {\n    alert(&apos;Can only upload image file.&apos;);\n    return false;\n}</code></pre><h2 id=\"File-API\"><a href=\"#File-API\" class=\"headerlink\" title=\"File API\"></a>File API</h2><p>由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。 随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。 HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 下面的例子演示了如何读取用户选取的图片文件，并在一个 &lt; div&gt;中预览图像：</p>\n<pre><code>var\n    fileInput = document.getElementById(&apos;test-image-file&apos;),\n    info = document.getElementById(&apos;test-file-info&apos;),\n    preview = document.getElementById(&apos;test-image-preview&apos;);\n// 监听change事件:\nfileInput.addEventListener(&apos;change&apos;, function () {\n    // 清除背景图片:\n    preview.style.backgroundImage = &apos;&apos;;\n    // 检查文件是否选择:\n    if (!fileInput.value) {\n        info.innerHTML = &apos;没有选择文件&apos;;\n        return;\n    }\n    // 获取File引用:\n    var file = fileInput.files[0];\n    // 获取File信息:\n    info.innerHTML = &apos;文件: &apos; + file.name + &apos;&lt;br&gt;&apos; +\n                     &apos;大小: &apos; + file.size + &apos;&lt;br&gt;&apos; +\n                     &apos;修改: &apos; + file.lastModifiedDate;\n    if (file.type !== &apos;image/jpeg&apos; &amp;&amp; file.type !== &apos;image/png&apos; &amp;&amp; file.type !== &apos;image/gif&apos;) {\n        alert(&apos;不是有效的图片文件!&apos;);\n        return;\n    }\n    // 读取文件:\n    var reader = new FileReader();\n    reader.onload = function(e) {\n        var\n            data = e.target.result; // &apos;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&apos;            \n        preview.style.backgroundImage = &apos;url(&apos; + data + &apos;)&apos;;\n    };\n    // 以DataURL的形式读取文件:\n    reader.readAsDataURL(file);\n});</code></pre><p>上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk…(base64编码)…，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>\n<h2 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h2><p>上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。 你可能会问，单线程模式执行的JavaScript，如何处理多任务？ 在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码： reader.readAsDataURL(file); 就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数： reader.onload = function(e) { // 当文件读取完成后，自动调用此函数: }; 当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>\n","text":"专门把这次课给搞出来记一下笔记.. 在HTML中,唯一可以上传文件的就是&lt;input type=&quot;file&quot;&gt;注意，当一个表单包含file时,表单的enctype_必须是_multipart/form-data,method_必须指定为_post,","link":"","raw":null,"photos":[],"categories":[{"name":"JS","slug":"JS","count":3,"path":"api/categories/JS.json"},{"name":"未分类","slug":"JS/未分类","count":1,"path":"api/categories/JS/未分类.json"}],"tags":[{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"股票数据定向爬虫","slug":"gupiaodingxiangpachong","date":"2017-09-07T12:05:07.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/gupiaodingxiangpachong.json","excerpt":"","keywords":null,"cover":null,"content":"<p>累了…直接撩代码</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport traceback\nimport re\n\ndef getHTMLText(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef getStockList(lst,stockURL):\n    html=getHTMLText(stockURL)\n    soup=BeautifulSoup(html,&apos;html.parser&apos;)\n    a=soup.find_all(&apos;a&apos;)\n    for i in a:\n        try:\n            href=i.attrs[&apos;href&apos;]\n            lst.append(re.findall(r&apos;[s][hz]\\d{6}&apos;,href)[0])\n        except:\n            continue\n\ndef getStockInfo(lst,stockURL,fpath):\n    for stock in lst:\n        url=stockURL+stock+&quot;.html&quot;\n        html=getHTMLText(url)\n        try:\n            if html==&quot;&quot;:\n                continue\n            infoDict={}\n            soup=BeautifulSoup(html,&apos;html.parser&apos;)\n            stockInfo=soup.find(&apos;div&apos;,attrs={&apos;class&apos;:&apos;stock-bets&apos;})\n\n            name=stockInfo.find_all(attrs={&apos;class&apos;:&apos;bets-name&apos;})[0]\n            infoDict.update({&apos;股票名称&apos;:name.text.split()[0]})\n            keyList=stockInfo.find_all(&apos;dt&apos;)\n            valueList=stockInfo.find_all(&apos;dd&apos;)\n            for i in range(len(keyList)):\n                key=keyList[i].text\n                val=valueList[i].text\n                infoDict[key]=val\n\n            with open(fpath,&apos;a&apos;,encoding=&apos;utf-8&apos;) as f:\n                f.write(str(infoDict)+&apos;\\n&apos;)\n        except:\n            traceback.print_exc()\n            continue\n\nif __name__==&apos;__main__&apos;:\n    stock_list_url = &apos;http://quote.eastmoney.com/stocklist.html&apos;\n    stock_info_url = &apos;https://gupiao.baidu.com/stock/&apos;\n    output_file = &apos;E:\\学习相关\\廖雪峰\\python_study\\库\\第三章\\BaiduStockInfo.txt&apos;\n    slist=[]\n    getStockList(slist,stock_list_url)\n    getStockInfo(slist,stock_info_url,output_file)</code></pre><p>结果(超慢的得得得多多多多多多多,还没爬完…不过应该是解析全文默认编码的问题): 2017-09-07 20:08:30 星期四 :earth_asia:<a href=\"https://github.com/834930269/python_study/blob/master/%E5%BA%93/%E7%AC%AC%E4%B8%89%E7%AB%A0/BaiduStockInfo.txt\" title=\"github: 爬取结果.txt\" target=\"_blank\" rel=\"noopener\">github: 爬取结果.txt</a></p>\n","text":"累了…直接撩代码import requestsfrom bs4 import BeautifulSoupimport tracebackimport redef getHTMLText(url):    try:        r=requests.get(url)       ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"},{"name":"爬虫","slug":"Python/未分类/爬虫","count":2,"path":"api/categories/Python/未分类/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"Left Join 和 Left Outer Join","slug":"left-join-and-left-outer-join","date":"2017-09-07T01:18:30.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/left-join-and-left-outer-join.json","excerpt":"","keywords":null,"cover":null,"content":"<p>*<em>通俗的讲：<br>A left join B 的连接的记录数与A表的记录数同<br>A right join B 的连接的记录数与B表的记录数同<br>A left join B 等价B right join A *</em></p>\n","text":"*通俗的讲：<br>A left join B 的连接的记录数与A表的记录数同<br>A right join B 的连接的记录数与B表的记录数同<br>A left join B 等价B right join A *","link":"","raw":null,"photos":[],"categories":[{"name":"SQL","slug":"SQL","count":1,"path":"api/categories/SQL.json"}],"tags":[{"name":"SQL","slug":"SQL","count":2,"path":"api/tags/SQL.json"}]}]}