{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"python3学习 map&reduce+浮点字符串转换浮点数+英文姓名规范+一点点lambda","slug":"python3-map-reduce","date":"2017-07-13T08:03:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-map-reduce.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/map%26reduce/map_reduce.py\" target=\"_blank\" rel=\"noopener\">map_reduce.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[2]:</p>\n<p>#我们先看map。map()函数接收两个参数，一个是函数，</p>\n<p>#一个是Iterable，map将传入的函数依次作用到序列的</p>\n<p>#每个元素，并把结果作为新的Iterator返回。</p>\n<p>#现在,我们用python代码实现1-9映射到x^2<br>def f(x):<br>    return x*x<br>r=map(f,[x for x in range(10)])<br>print(list(r))</p>\n<p>#map()传入的第一个参数是f，即函数对象本身。由于结</p>\n<p>#果r是一个Iterator，Iterator是惰性序列，因此通过</p>\n<p>#list()函数让它把整个序列都计算出来并返回一个list。</p>\n<p># In[3]:</p>\n<p>#将数字转换成字符<br>print(list(map(str,[x for x in range(1,10)])))</p>\n<p># In[4]:</p>\n<p>#reduce<br>‘’’<br>再看reduce的用法。reduce把一个函数作用在一个序列<br>[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce<br>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>\n<p>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>当然,可以直接用sum()<br>‘’’<br>from functools import reduce<br>def add(x,y):<br>    return x+y<br>print(reduce(add,[x for x in range(1,10)]))</p>\n<p># In[5]:</p>\n<p>#如果将[1，3，5，7，9]变成13579<br>def fn(x,y):<br>    return x*10+y<br>print(reduce(fn,[x for x in range(1,10,2)]))</p>\n<p># In[6]:</p>\n<p>‘’’<br>这个例子本身没多大用处，但是，如果考虑到字符串<br>str也是一个序列，对上面的例子稍加改动，配合map()，<br>我们就可以写出把str转换为int的函数：<br>‘’’<br>def char2num(s):<br>    return {‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9}[s]<br>print(reduce(fn, map(char2num, ‘13579’)))</p>\n<p># In[7]:</p>\n<p>#也可以直接返回转换结果<br>def str2int(s):<br>    return reduce(fn, map(char2num, s))<br>print(str2int(‘98661’))</p>\n<p># In[9]:</p>\n<p>#还可以用lambda函数进一步转化，事实证明Python的整数运算是大数= =</p>\n<p>#当然,可以直接用int()<br>def str2int(s):<br>    return reduce(lambda x,y:x*10+y,map(char2num,s))<br>print(str2int(‘46131346431311616131’))</p>\n<p># In[10]:</p>\n<p>#利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，</p>\n<p>#其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：</p>\n<p>#[‘Adam’, ‘Lisa’, ‘Bart’]：<br>def normalize(name):<br>    return name[0].upper()+name[1:].lower()<br># 测试:<br>L1 = [‘adam’, ‘LISA’, ‘barT’]<br>L2 = list(map(normalize, L1))<br>print(L2)</p>\n<p># In[11]:</p>\n<p>#Python提供的sum()函数可以接受一个list并求和，请编写一个prod()</p>\n<p>#函数，可以接受一个list并利用reduce()求积：<br>def prod(L):<br>    return reduce(lambda x,y:x*y,L)<br>print(‘3 * 5 * 7 * 9 =’, prod([3, 5, 7, 9]))</p>\n<p># In[20]:</p>\n<p>#利用map和reduce编写一个str2float函数，把字符串’123.456’转换成浮点数123.456：<br>def str2float(s):<br>    n,l=s.find(‘.’),len(s)<br>    if n!=-1:<br>        return reduce(lambda x,y:x<em>10+y,map(lambda x:int(x),s[:n]))+reduce(lambda x,y:x/10+y,map(lambda x:int(x)/10,s[l-1:n:-1]))<br>    else:<br>        return reduce(lambda x,y:x</em>10+y,map(lambda x:int(x),s))<br>print(‘str2float(\\‘166516516.1133165\\‘) =’, str2float(‘166516516.1133165’))</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: map_reduce.py **# coding: utf-8# In[2]:#我们先看map。map()函数接收两个参数，一个是函数，#一个是Iterable，map将传入的函数依次作用到序列的#每个元素，并把结果作为新的Iterat","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"UVa 10635 + NlogN-LIS","slug":"uva-10635-nlogn-lis","date":"2017-07-12T16:36:41.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10635-nlogn-lis.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Problem Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10635\" target=\"_blank\" rel=\"noopener\">Prince and Princess</a></strong> <strong>【题意】</strong> <strong>有两个长度分别为p+1和q+1的序列,每个序列中的各个元素互不相同,切都是1~n²之间的整数.两个序列的第一个元素都是1,求出A和B的最长公共子序列长度.</strong> <strong>【题解】</strong> <strong>本体是LCS问题,但规模达到了250²=62500,O(pq)的算法显然太慢.所以考虑把A重新按照下标编号,然后输入B的时候判断B中的整数在A中的位置,不存在则为0或者不记录.然后就转换为了求B得最长单增子序列LIS问题.然后用O(nlog(n))的解法解决.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVa%2010635.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10635.cpp</a></strong></p>\n<hr>\n<p>*<em>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=250</em>250+10;<br>const int INF=0x3f3f3f3f;<br>int S[maxn],g[maxn],d[maxn];///LIS所需<br>int num[maxn]; ///num[x]为整数x的编号,num[x]=0表示在A中未出现过<br>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    for(int kase=1;kase&lt;=T;++kase){<br>        int N,p,q,x;<br>        scanf(“%d%d%d”,&amp;N,&amp;p,&amp;q);<br>        fill(num,num+maxn,0);<br>        for(int i=1;i&lt;=p+1;++i){<br>            scanf(“%d”,&amp;x);<br>            num[x]=i;<br>        }<br>        int n=0;<br>        for(int i=0;i&lt;q+1;++i){<br>            scanf(“%d”,&amp;x);<br>            if(num[x]) S[n++]=num[x];<br>        }</p>\n<pre><code>    ///O(nlog(n))求解S\\[0\\]到S\\[n-1\\]的LIS\n    for(int i=1;i&lt;=n;++i){\n        g\\[i\\]=INF;\n    }\n    int ans=0;\n    for(int i=0;i&lt;n;++i){\n        int k=lower_bound(g+1,g+n+1,S\\[i\\])-g;///在g\\[1\\]~g\\[n\\]中查找\n        d\\[i\\]=k;///k是长度\n        g\\[k\\]=S\\[i\\];///g数组记录长度为k的目前最末(最大)元素大小\n        ans=max(ans,d\\[i\\]);\n    }\n    printf(&quot;Case %d: %d\\\\n&quot;,kase,ans);\n}\nreturn 0;</code></pre><p>}**</p>\n","text":"【Problem Link】 Prince and Princess 【题意】 有两个长度分别为p+1和q+1的序列,每个序列中的各个元素互不相同,切都是1~n²之间的整数.两个序列的第一个元素都是1,求出A和B的最长公共子序列长度. 【题解】 本体是LCS问题,但规模达到了25","link":"","raw":null,"photos":[],"categories":[{"name":"LIS","slug":"LIS","count":1,"path":"api/categories/LIS.json"},{"name":"UVa","slug":"LIS/UVa","count":1,"path":"api/categories/LIS/UVa.json"},{"name":"动态规划","slug":"LIS/UVa/动态规划","count":1,"path":"api/categories/LIS/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"LIS","slug":"LIS","count":1,"path":"api/tags/LIS.json"}]},{"title":"MooEC English Course","slug":"mooec-english-course","date":"2017-07-12T11:34:25.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/mooec-english-course.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"http://mooec.com/courses/topic-6-advanced/pages/topic-question\" target=\"_blank\" rel=\"noopener\">MOOEC</a></strong> <strong>【Topic6 Advanced】</strong> <strong>Chatterbox:喋喋不休的人 statement:声明,陈述 expensive:昂贵的</strong></p>\n<p><strong>Chatterbox: Hello, I’m Chatterbox! You heard what some students thought in the video above. Let’s see if you agree or disagreewith some opinions. Answer ‘Agree’ or ‘Disagree’ when you read the statements. Are you ready?</strong></p>\n<p><strong>me: Yes .</strong></p>\n<p><strong>Chatterbox: Here is the first statement: “It is more important to solve problems on Earth than it is to explore outer space.” Doyou Agree or Disagree?</strong></p>\n<p><strong>me: Agree .</strong></p>\n<p><strong>Chatterbox: Many people would agree with you.</strong></p>\n<p><strong>Chatterbox: “Research into outer space could be the solution to Earth’s problems.” Do you Agree or Disagree?</strong></p>\n<p><strong>me: Agree .</strong></p>\n<p><strong>Chatterbox: I see!</strong></p>\n<p><strong>Chatterbox: “Space exploration costs too much.” Do you Agree or Disagree?</strong></p>\n<p><strong>–太空探索花费非常巨大.</strong> <strong>me: Agree .</strong></p>\n<p><strong>Chatterbox: Interesting.</strong></p>\n<p><strong>Chatterbox: “Space exploration usually produces useless results.” Do you Agree or Disagree?</strong></p>\n<p><strong>–太空探索通常会得到无用的结果.</strong> <strong>me: Disagree .</strong></p>\n<p><strong>Chatterbox: You make a fair point.</strong></p>\n<p><strong>Chatterbox: “Knowledge and discovery is never too expensive.” Do you Agree or Disagree?</strong></p>\n<p><strong>me: Disagree .</strong></p>\n<p><strong>Chatterbox:</strong></p>\n<p><strong>Chatterbox: Great job! Now you’ve thought about the opinions surrounding the topic question, you’re ready to go thediscussion board and respond. Click ‘Next’ to continue.</strong></p>\n<p><strong>me: OK .</strong></p>\n","text":"【Link】 MOOEC 【Topic6 Advanced】 Chatterbox:喋喋不休的人 statement:声明,陈述 expensive:昂贵的Chatterbox: Hello, I’m Chatterbox! You heard what some student","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"LibreOJ  516","slug":"libreoj-516","date":"2017-07-12T10:51:48.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/libreoj-516.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Problem Link】</strong> <strong><a href=\"https://loj.ac/problem/516\" target=\"_blank\" rel=\"noopener\">#516. 「LibreOJ β Round #2」DP 一般看规律</a></strong> <strong>【题意】</strong> <strong>输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT.</strong> <strong>【题解】</strong> <strong>每个数字只与他的前驱和后继产生贡献。构建n个set，每次将较小的暴力合并到大的上面，通过lower_bound来找到他的前驱和后继。懒得离散化可以用map来存set。</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LibreOJ/%23516%20DP%E4%B8%80%E8%88%AC%E7%9C%8B%E8%A7%84%E5%BE%8B.cpp\" target=\"_blank\" rel=\"noopener\">#516 DP一般看规律.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int ans,n,m,num,x,y;<br>map&lt;int,set<int> &gt; mp;///数字-&gt;数字下标集映射</int></p>\n<p>void insert_update(int q,int index){<br>    set<int> &amp;r=mp[q];<br>    set<int>::iterator it=r.lower_bound(index);<br>    if(it!=r.end()) ans=min(ans,<em>it-index);///右边相邻第一个<br>    if(it!=r.begin()) it–,ans=min(ans,index-</em>it);///左边相邻第一个<br>    r.insert(index);<br>}</int></int></p>\n<p>int main(){<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)){<br>        ans=2147483647;mp.clear();<br>        for(int i=0;i&lt;n;++i){<br>            scanf(“%d”,&amp;num);<br>            insert_update(num,i);<br>        }<br>        for(int i=0;i&lt;m;++i){<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            if(x==y){printf(“%d\\n”,ans);continue;}<br>            set &amp;r=mp[x],&amp;t=mp[y];<br>            if(r.size()&gt;t.size())swap(r,t);<br>            for(set<int>::iterator si=r.begin();si!=r.end();si++)<br>                insert_update(y,<em>si);<br>            r.clear();<br>            printf(“%d\\n”,ans);<br>        }<br>    }<br>    return 0;<br>}*</em></int></p>\n","text":"【Problem Link】 #516. 「LibreOJ β Round #2」DP 一般看规律 【题意】 输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT. 【题解】 每个数字只与他的前驱和后继产生贡献。构建n个","link":"","raw":null,"photos":[],"categories":[{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/categories/LibreOJ.json"},{"name":"STL","slug":"LibreOJ/STL","count":1,"path":"api/categories/LibreOJ/STL.json"},{"name":"思维","slug":"LibreOJ/STL/思维","count":1,"path":"api/categories/LibreOJ/STL/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"},{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/tags/LibreOJ.json"}]},{"title":"python3学习 生成器+杨辉三角+yield+异常StopIteration","slug":"python3-yield-stopiteration","date":"2017-07-12T08:04:07.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-yield-stopiteration.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/generator/%E7%94%9F%E6%88%90%E5%99%A8.py\" target=\"_blank\" rel=\"noopener\">github: 生成器.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>‘’’<br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，<br>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，<br>那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元<br>素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制<br>，称为生成器：generator。<br>‘’’</p>\n<p>#要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：<br>L=[x<em>x for x in range(10)]<br>print(L)<br>g=(x</em>x for x in range(10))<br>print(g)</p>\n<p>#out[1]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</p>\n<p>#out[2]:  at 0x0000000004C2FB48&gt;</p>\n<p># In[3]:</p>\n<p>‘’’<br>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>\n<p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？</p>\n<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：<br>generator必须紧跟着输入,否则用next()只能输出一次循环</p>\n<p>‘’’<br>g=(x*x for x in range(10))<br>i=0<br>while i&lt;10:<br>    print(next(g))<br>    i+=1</p>\n<p># In[10]:</p>\n<p>#用for<br>g=(x*x for x in range(10))<br>for n in g:<br>    print(n)</p>\n<p># In[6]:</p>\n<p>#斐波那契</p>\n<p>#注意,赋值语句 a,b=b,a+b</p>\n<p>#相当于<br>‘’’<br>t = (b, a + b) # t是一个tuple<br>a = t[0]<br>b = t[1]</p>\n<p>‘’’<br>def fib(max):<br>    n,a,b=0,0,1<br>    while n</p>\n<p>#想要在循环中得到fib2的return值,必须捕获StopIteration错误返回值包括在</p>\n<p>#其中的value中<br>while True:<br>    try:<br>        x=next(f)<br>        print(‘f:’,x)<br>    except StopIteration as ev:<br>        print(‘Generator return value:’,ev.value)<br>        break</p>\n<p># In[17]:</p>\n<p>#yield举例<br>def odd():<br>    print(‘step 1’)<br>    yield 1<br>    print(‘step 2’)<br>    yield(3)<br>    print(‘step 3’)<br>    yield(5)<br>o=odd()<br>print(‘之前没输出’)<br>for n in o:<br>    print(n)</p>\n<p># In[ ]:</p>\n<p>#test<br>‘’’<br>杨辉三角定义如下：</p>\n<pre><code>      1\n    1   1\n  1   2   1\n1   3   3   1</code></pre><p>  1   4   6   4   1<br>1   5   10  10  5   1<br>‘’’<br>def triangles():<br>    L=[1]<br>    while True:<br>        yield L<br>        l=len(L)<br>        R=[1]<br>        for i in range(1,l):<br>            R.append(L[i-1]+L[i])<br>        R.append(1)<br>        L=R[:]<br>‘’’<br>第二种解法,中间为中间列表,和上面一样,只不过直接加起来了,避免了中间变量<br>def triangles():<br>l = [1]<br>while True:<br>    yield l<br>    l = [1] + [l[i]+l[i+1] for i in range(len(l)-1)] + [1]<br>‘’’<br># 期待输出:<br># [1]<br># [1, 1]<br># [1, 2, 1]<br># [1, 3, 3, 1]<br># [1, 4, 6, 4, 1]<br># [1, 5, 10, 10, 5, 1]<br># [1, 6, 15, 20, 15, 6, 1]<br># [1, 7, 21, 35, 35, 21, 7, 1]<br># [1, 8, 28, 56, 70, 56, 28, 8, 1]<br># [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]<br>n = 0<br>for t in triangles():<br>    print(t)<br>    n = n + 1<br>    if n == 10:<br>        break**</p>\n","text":"【Source Code】 github: 生成器.py**# coding: utf-8# In[1]:‘’’<br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，<br>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 列表生成式+isinstance","slug":"python3-listcomprehension","date":"2017-07-12T05:44:56.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python3-listcomprehension.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/List_Comprehensions/%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F.py\" target=\"_blank\" rel=\"noopener\">列表生成式.py</a></strong></p>\n<blockquote>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br>li=list(range(1,11))<br>print(li)</p>\n<p># In[2]:</p>\n<p>#但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：<br>L=[]<br>for x in range(1,11):<br>    L.append(x*x)<br>print(L)</p>\n<p># In[3]:</p>\n<p>#但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：<br>R=[x*x for x in range(1,11)]<br>print(R)</p>\n<p># In[12]:</p>\n<p>#for循环后还可以加上if这样我们就可以筛出仅偶数的平方</p>\n<p>#x&amp;x-1是判断x是否是2的幂，x&amp;1为1为奇<br>R=[x*x for x in range(1,11) if not(x&amp;1)]<br>print(R)</p>\n<p># In[14]:</p>\n<p>#还可以使用两层循环，可以生成全排列：<br>T=[m+n for m in ‘ABC’ for n in ‘XYZ’]<br>print(T)</p>\n<p># In[2]:</p>\n<p>#运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：<br>import os # 导入os模块，模块的概念后面讲到<br>OS=[d for d in os.listdir(‘.’)]# os.listdir可以列出文件目录<br>print(OS)<br># Out [1]: [‘.anaconda’, ‘.android’, ‘.bash_history’, ‘.conda’, ‘.condarc’, ‘.gem’, ‘.gemrc’, ‘.gitconfig’, ‘.idlerc’, ‘.ipynb_checkpoints’, ‘.ipython’, ‘.jupyter’, ‘.oracle_jre_usage’, ‘.packettracer’, ‘.ssh’, ‘.viminfo’, ‘360驱动大师.lnk’, ‘ACDSee5.lnk’, ‘AppData’, ‘Application Data’, ‘Cisco Packet Tracer 6.2sv’, ‘Contacts’, ‘Cookies’, ‘Desktop’, ‘Documents’, ‘Downloads’, ‘fancy_deboss.png’, ‘Favorites’, ‘fontawesome-webfont.svg’, ‘IntelGraphicsProfiles’, ‘Links’, ‘Local Settings’, ‘Music’, ‘My Documents’, ‘NetHood’, ‘NTUSER.DAT’, ‘ntuser.dat.LOG1’, ‘ntuser.dat.LOG2’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TM.blf’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000001.regtrans-ms’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000002.regtrans-ms’, ‘ntuser.ini’, ‘ntuser.pol’, ‘Pictures’, ‘PrintHood’, ‘Recent’, ‘Saved Games’, ‘Searches’, ‘SendTo’, ‘Templates’, ‘Test.ipynb’, ‘Videos’, ‘wc’, ‘WebpageIcons.db’, ‘WIN7激活工具’, ‘XT.DAT.LOG1’, ‘XT.DAT.LOG2’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TM.blf’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000001.regtrans-ms’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000002.regtrans-ms’, ‘「开始」菜单’, ‘列表生成式.ipynb’, ‘宽带连接.lnk’, ‘迭代.ipynb’, ‘迭代.py’]</p>\n<p># In[3]:</p>\n<p>#for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：<br>d={‘x’:’A’,’y’:’B’,’z’:’C’}<br>for k,v in d.items():<br>    print(k,’=’,v)</p>\n<p># In[5]:</p>\n<p>#因此,列表生成式也可以用两个变量生成list:<br>dp=[k+’=’+v for k,v in d.items()]<br>print(dp)</p>\n<p># In[6]:</p>\n<p>#最后把一个list中的字母全变成小写:<br>L=[‘Hello’,’World’,’IBM’,’Apple’]<br>Lp=[s.lower() for s in L]<br>print(Lp)</p>\n<p># In[7]:</p>\n<p>#使用内建的isinstance(key,type)可以判断key是否是type</p>\n<p>#例:<br>L1 = [‘Hello’, ‘World’, 18, ‘Apple’, None]<br>L2=[k.lower() for k in L1 if isinstance(k,str)]<br>print(L2)</p>\n<p># In[ ]:**</p>\n</blockquote>\n","text":"【Source Code】 列表生成式.py **# coding: utf-8# In[1]:#举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br>li=list(range(1,11))<","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 迭代+enumrate","slug":"python3-iterations-enumrate","date":"2017-07-12T01:26:17.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python3-iterations-enumrate.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/iteration/%E8%BF%AD%E4%BB%A3.py\" target=\"_blank\" rel=\"noopener\">迭代.py</a></strong></p>\n<blockquote>\n<p>**# coding: utf-8</p>\n<p># In[2]:</p>\n<p>d={‘a’:1,’b’:2,’c’:3}<br>for key in d:<br>    print(key)</p>\n<p># In[5]:</p>\n<p>for ch in ‘ABC’:<br>    print(ch)</p>\n<p># In[1]:</p>\n<p>#判断是否可迭代<br>from collections import Iterable<br>print(isinstance(‘abc’,Iterable))<br>print(isinstance([1,2,3],Iterable))<br>print(isinstance(123,Iterable))</p>\n<p># In[8]:</p>\n<p>for i,value in enumerate([‘A’,’B’,’C’]):<br>    print(i,value)<br>print(enumerate([‘A’,’B’,’C’]))</p>\n<p>#enumerate是枚举,列举的意思</p>\n<p>#如果对于一个列表,既要遍历索引又要遍历元素时,首先可以这样写<br>list1 = [“这”, “是”, “一个”, “测试”]<br>for i in range (len(list1)):<br>    print(i ,list1[i])<br>print(‘\\n’)</p>\n<p>#但这样很麻烦,所以可以用enumrate这样写<br>for i,value in enumerate(list1):<br>    print(i,value)<br>print(‘\\n’)</p>\n<p>#enumerate还可以接受第二个参数,用于指定初始索引<br>for i,value in enumerate(list1,1):<br>    print(i,value)<br>print(‘\\n’)</p>\n<p># In[9]:</p>\n<p>#在for循环里,同时引用两个变量<br>for x,y in [(1,1),(2,2),(3,3)]:<br>    print(x,y)</p>\n<p># In[ ]:</p>\n<p>#end**</p>\n</blockquote>\n","text":"【Source Code】 迭代.py**# coding: utf-8# In[2]:d={‘a’:1,’b’:2,’c’:3}<br>for key in d:<br>    print(key)# In[5]:for ch in ‘ABC’:<br>    print(ch","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"LA 3882","slug":"la-3882","date":"2017-07-11T07:02:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3882.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3882\" target=\"_blank\" rel=\"noopener\">And Then There Was One</a></strong> <strong>【题解】</strong> <strong>假设问题是从n个人编号分别为0…n-1，取第k个，</strong> <strong>则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2…</strong> <strong>此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号</strong> <strong>把k号设置为0,则</strong> <strong>k 0</strong> <strong>k+1 1</strong> <strong>…</strong> <strong>0 n-k</strong> <strong>1 n-k+1</strong> <strong>假设已经求得了n-1个人情况下的最终胜利者保存在f[n-1]中，则毫无疑问，该胜利者还原到原来的真正编号即为 (f[n-1]+k)%n （因为第二轮重新编号的时候，相当于把每个人的编号都减了k，因此重新+k即可恢复到原来编号）。由此，我们可以想象，当最终只剩下一个人的时候，该人即为胜利者，此时重新编号，因为只有一个人，所以此时f[1]=0</strong> <strong>这样f[2]=(f[1]+k)%2,这样就可以求出最终胜利者在2个人的时候的情况下的编号，由递推公式f[n]=(f[n-1]+k)%n,可递推到最初编号序列中该胜利者的编号。</strong> <strong>因此用这个方法，只需一遍On的扫描，即可求出最终答案</strong> <strong>不过该题要求编号从1开始，只要把f[n]+1即可，同时，该题指定了第一个要删除的人必须为编号为m的人，其实也不难，求出f[n]之后，把原本编号为0的位置移到跟m只相距k的位置即可实现第一次删除的编号为m。所以最终 ans=(f[n]+1+m-k);</strong> <strong>当然因为m-k可能为负数，导致整个ans为负，这样其实最后+n即可解决。</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203882.cpp\" target=\"_blank\" rel=\"noopener\">LA 3882.cpp</a></strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=10000+10;<br>int f[maxn];<br>int main(){<br>    int n,k,m;<br>    while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n){<br>        ///最后一次变换只有一个点,所以最终点设为0<br>        ///每次去掉一个点以后重新编号,所以%i<br>        ///从底向上的方法<br>        f[1]=0;<br>        for(int i=2;i&lt;=n;++i)f[i]=(f[i-1]+k)%i;<br>        ///因为是从0编号,而题目要求从1编号,所以+1<br>        ///因为从0开始,而题目要求从m开始删除第k个<br>        ///所以第一次删除的下标应该是f[n]-k=第一次的起始下标<br>        ///0-k+m+1=真正的起始坐标,因为第一次需要将m设为0,从m开始重新编号<br>        int ans=(m-k+1+f[n])%n;<br>        ///因为m-k+1可能小于0,所以m-k+1+f[n]也可能小于0<br>        if(ans&lt;=0) ans+=n;<br>        printf(“%d\\n”,ans);<br>    }<br>    return 0;<br>}</strong></p>\n</blockquote>\n","text":"【Link】 And Then There Was One 【题解】 假设问题是从n个人编号分别为0…n-1，取第k个， 则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2… 此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号 把k号设置为","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"动态规划","slug":"LA/动态规划","count":1,"path":"api/categories/LA/动态规划.json"},{"name":"思维","slug":"LA/动态规划/思维","count":1,"path":"api/categories/LA/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3902","slug":"la-3902","date":"2017-07-10T13:21:12.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3902.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3902\" target=\"_blank\" rel=\"noopener\">Network</a></strong> <strong>【题解】</strong> <strong>可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表.</strong> <strong>最优选择放置服务器的方法是选择距离主机最远(k)的那个服务器上安装VOD即可.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203902.cpp\" target=\"_blank\" rel=\"noopener\">LA 3902.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;</p>\n<p>const int maxn=1000+10;<br>vector<int> gr[maxn],nodes[maxn];<br>int n,s,k,fa[maxn];<br>bool covered[maxn];</int></p>\n<p>///无根树转有根树,计算fa数组,根据深度把–叶子节点–插入nodes表中<br>///u当前节点下标,f,当前节点父节点下标,d深度.<br>void dfs(int u,int f,int d){<br>    fa[u]=f;<br>    int nc=gr[u].size();<br>    ///距离根节点k距离以内的叶子结点不用记录<br>    if(nc==1 &amp;&amp; d&gt;k) nodes[d].push_back(u);<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f)dfs(v,u,d+1);<br>    }<br>}</p>\n<p>void dfs2(int u,int f,int d){<br>    covered[u]=true;<br>    int nc=gr[u].size();<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f&amp;&amp;d&lt;k)dfs2(v,u,d+1);///只覆盖到新服务器不超过k的结点 ///v!=f =&gt; 如果从f访问到u,那么就不能再从u回访f.深搜嘛.一路莽到底.<br>    }<br>}</p>\n<p>int solve(){<br>    int ans=0;<br>    memset(covered,0,sizeof(covered));<br>    for(int d=n-1;d&gt;k;–d){<br>        for(int i=0;i&lt;nodes[d].size();++i){<br>            int u=nodes[d][i];<br>            if(covered[u])continue;///不考虑已经覆盖的点</p>\n<pre><code>        int v=u;\n        for(int j=0;j&lt;k;++j)v=fa\\[v\\];///找到相邻k级祖先,不可能有-1，因为之前已经把离根k的节点忽略了\n        dfs2(v,-1,0);///在结点v设置服务器,然后通过对该服务器深搜\n                     ///找到所有的叶子结点\n        ans++;\n    }\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d%d”,&amp;n,&amp;s,&amp;k);///节点数,初始VOD服务器的编号和k<br>        for(int i=1;i&lt;=n;++i){gr[i].clear();nodes[i].clear();}<br>        for(int i=0;i&lt;n-1;++i){<br>            int a,b;<br>            scanf(“%d%d”,&amp;a,&amp;b);<br>            gr[a].push_back(b);<br>            gr[b].push_back(a);<br>        }<br>        dfs(s,-1,0);<br>        printf(“%d\\n”,solve());<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【Link】 Network 【题解】 可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"数据结构","slug":"LA/思维/数据结构","count":1,"path":"api/categories/LA/思维/数据结构.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]},{"title":"UVa 10795","slug":"uva-10795","date":"2017-07-09T13:06:29.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10795.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10795\" target=\"_blank\" rel=\"noopener\">A Different Task</a></strong> <strong>汉诺塔问题总结:</strong> <a href=\"http://blog.csdn.net/xueerfei008/article/details/9904681\" target=\"_blank\" rel=\"noopener\"><strong>杭电 汉诺塔问题总结</strong></a> <strong>【题解】</strong> <strong>大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标.</strong> <strong>f(P,i,final):已知各盘子的初始柱子编号数组为P,把盘子1,2,3,4…i全部移到柱子final所需的步数.</strong> <strong>参考局面等于中转态.即中转柱子下标为6-P[i]-finish[i].将前i-1个盘子移动到中转柱上.然后把盘子i移动到final柱子上,最后将i-1个盘子从中转态移动到final.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2010795.cpp\" target=\"_blank\" rel=\"noopener\">UVA 10795.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long LL;</p>\n<p>LL f(int* P,int i,int finaln){<br>    if(i==0) return 0;<br>    ///如果当前最大的这个号的起始盘子等于最终落脚盘子<br>    ///不用移动.所以f(P,i,final)=f(P,i-1,final)<br>    if(P[i]==finaln) return f(P,i-1,finaln);<br>    ///经典汉诺塔的结论,将前i-1个盘子从一个柱子移动到另一个柱子<br>    ///这个步骤需要2^(i-1)-1步.加上移动盘子i到最终盘子<br>    ///的那一步,一共需要2^(i-1)步.<br>    return f(P,i-1,1+2+3-P[i]-finaln)+(1LL&lt;&lt;(i-1));<br>}</p>\n<p>const int maxn=60+10;<br>int n,start[maxn],finish[maxn];</p>\n<p>int main(){<br>    int kase=0;<br>    while(scanf(“%d”,&amp;n)==1&amp;&amp;n){<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;start[i]);<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;finish[i]); ///结论:如果最大的盘子一开始就在最终的柱子上 ///则不用移动. ///找到号码最大的那几个不需要移动的盘子. int k=n; while(k&gt;=1&amp;&amp;start[k]==finish[k])k–;</p>\n<pre><code>    ///结论:由于移动的步数是对称的,即往回移动的步伐\n    ///和步数等于往前移动.\n    LL ans=0;\n    if(k&gt;=1){\n        int other=6-start\\[k\\]-finish\\[k\\];\n        ans=f(start,k-1,other)+f(finish,k-1,other)+1;\n    }\n    printf(&quot;Case %d: %lld\\\\n&quot;,++kase,ans);\n}\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n","text":"【Link】 A Different Task 汉诺塔问题总结: 杭电 汉诺塔问题总结 【题解】 大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标. ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"模拟","slug":"UVa/思维/模拟","count":1,"path":"api/categories/UVa/思维/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}