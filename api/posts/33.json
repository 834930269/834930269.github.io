{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"UVa 11300","slug":"uva-11300","date":"2017-03-31T13:58:43.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-11300.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Spreading 传播,摊开</strong> <strong>wealth 财富,大量</strong> <strong>Communist 共产党者</strong> <strong>regime 政权,政体</strong> <strong>———————注意,名词(可忽略啊？逃</strong> <strong>redistribute 重新分配,再区分</strong> <strong>circular 通知,传单,循环的,圆形的</strong> <strong>properties 性能,道具,内容</strong> <strong>divisible 可分的,可分割的</strong> <strong>a number of 一定数量的,若干,一些</strong> <strong>such that 以至于</strong> <strong>transferred 转移的,转让的</strong> <strong>so that 以便</strong> <strong>counterclockwise 逆时针方向</strong> <strong>【题解】</strong> <strong>蓝书P7</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cstring></cstring></strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=1000010;</strong> <strong>int N;</strong> <strong>long long A[maxn],C[maxn],sum,M;//数据组特别大,要用LL</strong> <strong>int main(){</strong> <strong>while(scanf(“%d”,&amp;N)!=EOF){//输入数据大,scanf比cin快</strong> <strong>sum=0;</strong> **        for(int i=1;i&lt;=N;++i){** **            scanf(“%lld”,&amp;A[i]);** <strong>sum+=A[i];</strong> **        }** <strong>M=sum/N;</strong> **        C[0]=0;** <strong>for(int i=1;i&lt;N;++i)//N不用算,因为到他时他肯定为M,而转手金币在A1和AN-1已经算过了</strong> <strong>C[i]=C[i-1]+A[i]-M;//C1=A1-M;所以直接将C[0]=0</strong> <strong>sort(C,C+N);</strong> **        long long x1=C[N/2],ans=0;//计算x1(中位数)** **        for(int i=0;i&lt;N;++i) ans+=abs(x1-C[i]);** <strong>//把x1代入,计算转手的总金币数,因为是中位数,所以abs</strong> <strong>printf(“%lld\\n”,ans);</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Spreading 传播,摊开 wealth 财富,大量 Communist 共产党者 regime 政权,政体 ———————注意,名词(可忽略啊？逃 redistribute 重新分配,再区分 circular 通知,传单,循环的,圆形的 properties 性能","link":"","raw":null,"photos":[],"categories":[{"name":"Median","slug":"Median","count":1,"path":"api/categories/Median.json"}],"tags":[{"name":"Midian","slug":"Midian","count":1,"path":"api/tags/Midian.json"}]},{"title":"UVa  11464","slug":"uva-11464","date":"2017-03-31T12:59:56.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-11464.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>gird 网格,格子</strong> <strong>so taht 以便</strong> <strong>The parity 奇偶校验</strong> <strong>even 有偶数意</strong> <strong>transformation 转化</strong> <strong>achieve 取得,获得,实现,成功</strong> <strong>requirement 要求</strong> <strong>indicates 表明</strong> <strong>character 性格,品质</strong> <strong>separated 分开,隔开</strong> <strong>instead 代替,反而,相反</strong> <strong>【题解】</strong> <strong>蓝书 P16</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<algorithm></algorithm></strong> <strong>using namespace std;</strong> <strong>const int INF=0x3f3f3f3f;</strong> <strong>const int maxn=20;</strong> <strong>int A[maxn][maxn],B[maxn][maxn],n,T,ca=1;</strong> <strong>int check(int s){</strong> **    memset(B,0,sizeof(B));** <strong>//先初始化第一行</strong> **    for(int i=0;i&lt;n;++i){** **        if(s &amp; (1&lt;&lt;i)) B[0][i]=1;//这句意思是判断每一位上是否是1** <strong>//即(1&lt;&lt;n)只有第n位是1,其他位都是0 为真即为1</strong> <strong>else if(A[0][i]==1) return INF;//1不能变成0</strong> **    }** **    for(int i=1;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            int sum=0;//元素B[i-1][0]的上,左,右元素之和** **            if(i&gt;1)sum+=B[i-2][j];** **            if(j&gt;0)sum+=B[i-1][j-1];** <strong>if(j&lt;n-1)sum+=B[i-1][j+1];</strong> **            B[i][j]=sum%2;//sum是偶数,=0,奇数,=1** **            if(A[i][j]==1 &amp;&amp; B[i][j]==0) return INF;** <strong>//不存在1-&gt;0的操作.</strong> <strong>}</strong> **    }** **    int cnt=0;** **    for(int i=0;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            if(A[i][j]!=B[i][j])** <strong>cnt++;</strong> <strong>}</strong> <strong>}</strong> <strong>return cnt;</strong> <strong>}</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        printf(“Case %d: “,ca++);** **        scanf(“%d”,&amp;n);** **        for(int i=0;i&lt;n;++i)** **            for(int j=0;j&lt;n;++j)** **                scanf(“%d”,&amp;A[i][j]);** <strong>int ans=INF;</strong> **        for(int i=0;i&lt;(1&lt;&lt;n);++i)** <strong>ans=min(ans,check(i));</strong> **        if(ans==INF) ans=-1;** <strong>printf(“%d\\n”,ans);</strong> <strong>}</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 gird 网格,格子 so taht 以便 The parity 奇偶校验 even 有偶数意 transformation 转化 achieve 取得,获得,实现,成功 requirement 要求 indicates 表明 character 性格,品质 separ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"枚举","slug":"UVa/位操作/枚举","count":1,"path":"api/categories/UVa/位操作/枚举.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"}]},{"title":"Math & 基础知识 & 技巧 模板","slug":"muban","date":"2017-03-31T12:06:06.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/muban.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【文件头】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong></p>\n</blockquote>\n<p><strong>【判断奇偶性】</strong> <strong>1. t&amp;1,若结果为1则为奇数，0则为偶数，从而用做滚动数组的第一维下标等作用。 【位操作】 1. 1&lt;&lt;n 表示第n位为1,2^n 2. s &amp; (1&lt;&lt;n) 表示判断s的第n位是否为1 3. 问:一行有N格,每格只能填充0/1,则共有1&lt;&lt;n种填充方法.</strong> <strong>【中位数】 1. |**</strong>X1 – Ci|在数轴上就是x1到Ci的距离，所以问题变成了：给定数轴上的n个点，找 出一个到它们的距离之和尽量小的点。<strong>**这个最优的X1就是这些数的“中位数”。即排序以后位于中间的数。</strong> <strong>【自然常数e】</strong> <strong>e = 2.718281828459  exp(F(X))=e^F(X)  log()是以e为底的对数</strong> <strong>【素数筛法】</strong></p>\n<blockquote>\n<p><strong>int prime[MAX_N];//第i个素数</strong> <strong>bool is_prime[MAX_N+1];//is_prime[i]为true表示i是素数</strong> <strong>//返回n以内的素数的个数</strong> <strong>int sieve(int n){</strong> **    int p=0;** **    for(int i=0;i&lt;=n;i++) is_prime[i]=true;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;=n;i++){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=n;j+=i)*</em> **                is_prime[j]=false;** **        }** **    }** **    return p;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【异或操作】</strong> <strong>原地换值:</strong></p>\n<blockquote>\n<p><strong>stay=stay^to;</strong> <strong>to=to^stay;</strong> <strong>stay=stay^to;</strong></p>\n</blockquote>\n<p><strong>即:</strong></p>\n<blockquote>\n<p><strong>stay==to^stay^to.</strong> <strong>to==stay^to^stay.</strong></p>\n</blockquote>\n<p><strong>^的性质有:</strong></p>\n<blockquote>\n<p><strong>x^y==y^x, (x^y)^z==x^(y^z), x^x==0, x^0==x</strong> <strong>如果A,B不相同,A^B=1否则为1</strong> <strong>x^y^y=x</strong></p>\n</blockquote>\n<p><strong>【java:BigInteger】</strong> <strong>相加:</strong></p>\n<blockquote>\n<p><strong>import java.util.Scanner;</strong> <strong>import java.math.*;</strong> <strong>public class Main{</strong> **    public static void main(String[] rgs){** **        //系统输出的** **        Scanner cin=new Scanner(System.in);** **        BigInteger b=BigInteger.valueOf(0);** **        while(cin.hasNext()){//等同于!=EOF** **            BigInteger c;** **            c=cin.nextBigInteger();** **            b=b.add(c);** **        }** **        System.out.println(b);** **    }** <strong>}</strong></p>\n<p><em>*`import java.util.</em>;<br>import java.math.*;<br>public class Main{<br>    public static void main(String args[]){<br>       Scanner cin = new Scanner(System.in);<br>       BigInteger a, b;</p>\n<pre><code>   //以文件EOF结束\n   while (cin.hasNext()){\n       a = cin.nextBigInteger();\n       b = cin.nextBigInteger();\n\n       System.out.println(a.add(b)); //大整数加法\n       System.out.println(a.subtract(b)); //大整数减法\n       System.out.println(a.multiply(b)); //大整数乘法\n       System.out.println(a.divide(b)); //大整数除法(取整)\n       System.out.println(a.remainder(b)); //大整数取模\n\n       //大整数的比较\n       if( a.compareTo(b) == 0 ) System.out.println(&quot;a == b&quot;); //大整数a==b\n       else if( a.compareTo(b) &gt; 0 ) System.out.println(&quot;a &gt; b&quot;); //大整数a&gt;b\n       else if( a.compareTo(b) &lt; 0 ) System.out.println(&quot;a &lt; b&quot;); //大整数a&lt;b\n\n       //大整数绝对值\n       System.out.println(a.abs()); //大整数a的绝对值\n\n       //大整数的幂\n       int exponent=10;\n       System.out.println(a.pow(exponent)); //大整数a的exponent次幂\n\n       //返回大整数十进制的字符串表示\n       System.out.println(a.toString());\n\n       //返回大整数p进制的字符串表示\n       int p=8;\n       System.out.println(a.toString(p));\n   }\n}</code></pre><p>}`**</p>\n</blockquote>\n<p><strong>【字符串处理】</strong> <strong>正则式处理:</strong> <strong>%[^\\n] 读到回车结束,即读一行.</strong> <strong>【ln】</strong> <strong>ln2=1.693147</strong> <strong>【Floyd判圈法】</strong></p>\n<blockquote>\n<p><strong>void floyd_check(int n,int k){</strong> **        int k1=k,k2=k,ans=k;//ans=k** **        do{** **            k1=next(n,k1);** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **        }while(k1!=k2);** **        printf(“%d\\n”,ans);** <strong>}</strong></p>\n</blockquote>\n<p><strong>【k的个数】</strong></p>\n<blockquote>\n<p><strong>upper_bound(a,a+n,k)-lower_bound(a,a+n,k);</strong></p>\n</blockquote>\n","text":"【文件头】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define cle(a,val) memset(a,(val)","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"},{"name":"模板","slug":"未分类/模板","count":3,"path":"api/categories/未分类/模板.json"}],"tags":[]},{"title":"UVa 213","slug":"uva-213","date":"2017-03-26T08:09:55.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-213.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>schemes 计划,阴谋,方案</strong> ** require 需求,要求,指令** <strong>pattern 模式,图案,样品,模仿</strong> <strong>represents 代表,表现,表示</strong> <strong>The heart of 称心的,乱了粉粹的,中心的,核心的</strong> <strong>adjacent 邻近的,毗邻的</strong> <strong>obtained 获得(obtain)</strong> <strong>Notice 通知,布告,公告</strong> <strong>consist 由什么组成</strong> <strong>mapped 映射</strong> <strong>in order 整齐,秩然有序</strong> <strong>That is 即,就是说,换言之</strong> <strong>suppose 假设</strong> <strong>segment 片段</strong> <strong>binary 二进制的</strong> <strong>representation 表示法</strong> <strong>of …的</strong> <strong>terminated 终止，结束</strong> <strong>entire 全部的,整个的</strong> <strong>signify 表示,意味</strong> <strong>one-at-a-time 一次一个</strong> <strong>extend 扩展</strong> <strong>111 in binary 111的二进制表示</strong> <strong>There be 有</strong> <strong>multiple 倍数的,几倍的</strong> <strong>copies 复制品</strong> <strong>legitimate 合法的,正当的</strong> <strong>appropriate 适当的,恰当的,合适的</strong> <strong>correspond 符合,一致,相应,通信</strong> <strong>separate 单独的</strong> <strong>【题面】</strong> <strong>粉书P83，这个自己看的时候有点迷糊..</strong> <strong>【问题】</strong> <strong>粉书的读入代码(AC)</strong></p>\n<blockquote>\n<p><strong>inline int readText(){</strong> **    fill(code);** <strong>code[1][0]=readchar();//因为</strong> **    for(int plie=2;plie&lt;=7;++plie) {** **        for(int i=0;i&lt;(1&lt;&lt;plie)-1;++i){** <strong>int c=getchar();</strong> <strong>if(c==EOF) return 0;</strong> **            if(c==’\\n’ || c==’\\r’) return 1;** **            code[plie][i]=c;** **        }** **    }    ** <strong>return 1;</strong> <strong>}</strong></p>\n</blockquote>\n<p><strong>我的读入代码(WA)</strong></p>\n<blockquote>\n<p><strong>inline int readText(){</strong> **    int plie=2;** **    int max=3,cnt=0;** **    fill(code);** **    code[1][0]=readchar();//因为** **    for(;;) {** **        int c=getchar();** **        if(c==EOF) return 0;** **        if(c==’\\n’ || c==’\\r’) return 1;** **        code[plie][cnt++]=c;** **        if(cnt==max){** **            max=1&lt;&lt;(plie+1)-1;** **            cnt=0;** **            plie++;** **        }** **    }    ** **    return 1;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【Code】</strong></p>\n<blockquote>\n<p>**`#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#define fill(x) memset(x,0,sizeof(x))<br>using namespace std;<br>int code[8][1&lt;&lt;8];<br>inline char readchar(){<br>    char sta;<br>    while(~scanf(“%c”,&amp;sta) &amp;&amp; sta==’\\n’ || sta==’\\r’){}<br>        //这里的scanf()不要忘了加取反符,否则督导EOF不会存下来.<br>    return sta;<br>}<br>inline int readint(int l){<br>    int v=0;<br>    while(l–) v=v*2+readchar()-‘0’;<br>    return v;<br>}<br>inline int readText(){<br>    fill(code);<br>    code[1][0]=readchar();//因为<br>    for(int plie=2;plie&lt;=7;++plie) {<br>        for(int i=0;i&lt;(1&lt;&lt;plie)-1;++i){<br>            int c=getchar();<br>            if(c==EOF) return 0;<br>            if(c==’\\n’ || c==’\\r’) return 1;<br>            code[plie][i]=c;<br>        }<br>    }<br>    return 1;<br>}</p>\n<p>int main(){<br>    while(readText()){<br>        int digit;<br>        char dig[3],slist;<br>        for(;;){<br>            int len=readint(3);<br>            if(len==0) break;<br>            for(;;){<br>                digit=readint(len);<br>                if(digit==(1&lt;&lt;len)-1)<br>                    break;<br>                putchar(code[len][digit]);<br>            }<br>        }<br>        putchar(‘\\n’);<br>    }<br>    return 0;<br>}`**</p>\n</blockquote>\n","text":"【生词】 schemes 计划,阴谋,方案 ** require 需求,要求,指令** pattern 模式,图案,样品,模仿 represents 代表,表现,表示 The heart of 称心的,乱了粉粹的,中心的,核心的 adjacent 邻近的,毗邻的 obtained","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 489","slug":"uva-489","date":"2017-03-26T02:13:52.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-489.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>series 系列,连续,串联</strong> <strong>Hangman 侩子手</strong> <strong>puzzle 使…疑惑,迷惑,难题,为难</strong> <strong>as well as 也,和,一样,不但…而且</strong> <strong>guesses 猜测</strong> <strong>be the same as 与..一样</strong> <strong>classic 名著,经典著作</strong> <strong>Follows 跟随,遵照</strong> <strong>contestant 竞争者,参赛人</strong> <strong>try-&gt;tries 尝试</strong> <strong>characters 特性,角色.V.描述</strong> <strong>match 比赛,竞赛,对手,匹配</strong> <strong>counted 认为</strong> <strong>as 因为,随着,虽然,依照,当…时,如同,当做</strong> <strong>stroke 划,画一道</strong> <strong>chicken out &lt;美俚&gt;</strong></p>\n<ul>\n<li><strong>因害怕而停止做某事，因胆小而放弃</strong></li>\n<li><strong>临阵退缩</strong></li>\n<li><strong>怯步</strong></li>\n<li><strong>由于胆怯而收兵</strong></li>\n</ul>\n<p><strong>determine 下定决心</strong> <strong>or fails to finish a game 或未能完成比赛</strong> <strong>status 地位,状态</strong> <strong>lower 下游的,下级的,下等的</strong> <strong>section 截面,部分,部门,地区,章节</strong> <strong>indicate 表明,指出,预示,象征</strong> <strong>currently 一般的,当前的</strong> <strong>【题意】</strong> <strong>你在和侩子手玩一个游戏,侩子手有一个单词,你需要猜测单词中有哪些字母,当你猜中一个字母时,正确单词里所有该字母都被标记为correct,(如果你再猜就被认为是错的),当你猜错时侩子手将会划一道,当侩子手划到第7道时,你就挂了,如果在侩子手之前你猜中了全部字母,You win.当然,如果最终你猜测的结果在正确和错误之间,You chickened out.</strong> <strong>【Code】</strong> <strong>好像数组开得太大memset也会耗费不少时间.或者是一开始的cin(关了同步)仍然很慢,第一次TLE了.</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#define fill(A) memset(A,0,sizeof(A))</strong> <strong>using namespace std;</strong> <strong>char contestant[10000],correct[10000];</strong> <strong>int Round,T[30],C[30],flag,fcnt,pcnt,ccnt;</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;Round) &amp;&amp; Round!=-1){** **        fcnt=pcnt=ccnt=0;flag=3;** **        fill(T);fill(C);** **        scanf(“\\n%s\\n%s”,correct,contestant);** **        printf(“Round %d\\n”,Round);** **        for(int i=0;correct[i]!=’\\0’;++i){** **            int t=correct[i]-‘a’;** **            if(C[t]==0)** **                C[t]=1,pcnt++;** **        }** **        for(int i=0;contestant[i]!=’\\0’;++i){** **            int t=contestant[i]-‘a’;** **            if(!T[t] &amp;&amp; C[t])** **                ccnt++,T[t]=1;** **            else** **                fcnt++;** **            if(fcnt==7 &amp;&amp; ccnt&lt;pcnt){** **                puts(“You lose.”),flag=2;** **                break;** **            }** **            if(fcnt&lt;7 &amp;&amp; ccnt&gt;=pcnt){** **                puts(“You win.”),flag=1;** **                break;** **            }    ** **        }** **        if(flag==3)** **            puts(“You chickened out.”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 series 系列,连续,串联 Hangman 侩子手 puzzle 使…疑惑,迷惑,难题,为难 as well as 也,和,一样,不但…而且 guesses 猜测 be the same as 与..一样 classic 名著,经典著作 Follows 跟随,遵照 ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"代码级调试器gdb","slug":"gdb","date":"2017-03-25T11:22:57.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/gdb.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【编译】 假如编译 UVa 1339.cpp这个文件 c++ 编译:g++ -g -o “UVa 1339” “UVa 1339.cpp” 注:必须有-g,才可以用gdb调试. 【调试】 gdb “UVa 1339.exe” 注：如果文件名有字符,空格之类的,断点调试可能出错.上面就是一个教训. 【其他教程】 <a href=\"http://blog.csdn.net/txl199106/article/details/38405581\" target=\"_blank\" rel=\"noopener\">gdb教程</a></p>\n","text":"【编译】 假如编译 UVa 1339.cpp这个文件 c++ 编译:g++ -g -o “UVa 1339” “UVa 1339.cpp” 注:必须有-g,才可以用gdb调试. 【调试】 gdb “UVa 1339.exe” 注：如果文件名有字符,空格之类的,断点调试可能出错.上","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"UVa 1339","slug":"uva-1339-2","date":"2017-03-25T10:42:04.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-1339-2.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词记录】</strong> <strong>empire 帝国</strong> <strong>various 各种各样的,多样的</strong> <strong>departments 部(门)</strong> <strong>provinces 地方,职权</strong> <strong>encrypted 把…编码；把…加密</strong> <strong>prevent eavesdropping. 防止窃听</strong> <strong>ciphers 密码,编码</strong> <strong>substitution 代替/代替物</strong> <strong>permutation 排列/置换</strong> <strong>occurrences 发生,出现,事件</strong> <strong>coincide 一致</strong> <strong>apply 申请,适用</strong> <strong>alphabet 字母表</strong> <strong>separately 分别得,分离的,个别的</strong> <strong>rather 宁可宁愿,相当</strong> <strong>combined 使适合,组合,结合</strong> <strong>those times 大部分条件下？</strong> <strong>Thus 因此</strong> <strong>Archeologists 考古学家</strong> <strong>recently 最近</strong> <strong>engraved 被牢记的,雕刻</strong> <strong>plate 碟,金属板,装甲</strong> <strong>glance 一瞥,扫视</strong> <strong>meaningless 无意义的</strong> <strong>conjecture 推测,猜想</strong> <strong>check 制止,校验,核对</strong> <strong>contains 包含</strong> <strong>several 几个</strong> <strong>consists 由…构成</strong> <strong>punctuation 标点符号</strong> <strong>capital 首都</strong> <strong>do not exceed XXX 不超过</strong> <strong>【题意】</strong> <strong>古老的碑文上雕刻着密文,有两种加密方法,subsitution ciphers和permutation chipers.</strong> <strong>问:判断输入密文str1和破解明文str2是否可以通过以上两种encrypted方式转换.</strong> <strong>subsitution ciphers:一一映射.</strong> <strong>permutation ciphers:位置置换.</strong> <strong>【错解】</strong> <strong>思路:因为后者是由前者重新排序然后重新映射来的,所以第一想法是直接统计Ascii码,然后再判断两者差的绝对值取余字符串长度是否为0.</strong> <strong>错例:AAA,BBB</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>char str1[120],str2[120];</strong> <strong>int len1,len2,sum1,sum2;</strong> <strong>int main(){</strong> **    while(cin&gt;&gt;str1){** **        cin&gt;&gt;str2;** **        len1=strlen(str1),len2=strlen(str2);** **        sum1=sum2=0;** **        if(len1!=len2){** **            puts(“NO”);** **            continue;** **        }** **        for(int i=0;i&lt;len1;++i)** **            sum1+=str1[i];** **        for(int i=0;i&lt;len2;++i)** **            sum2+=str2[i];** **        if(abs(sum1-sum2)%len1==0)** **            puts(“YES”);** **        else** **            puts(“NO”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【正解】</strong> <strong>思路:既然字母可以重排,则每个字母的位置并不重要,重要的是每个字母出现的次数,</strong> <strong>这样可以先统计出两个字符串中各个字母出现的次数.得到两个数组cnt1[26]，cnt2[26]</strong> <strong>然后将数目从大到小排列,如果数组相同,则YES,其他NO.</strong> <strong>一点:没看样例直接搞,按照思路来的,看完题面以后觉得字母映射是全部平移的一一映射,但书上说的是(无规律)一一映射(需要每个字母都要映射,并且映射都不相同,比如不可能:B-&gt;Q,Q-&gt;Q;但可以:B-&gt;Q,Q-&gt;D,C-&gt;C).</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>char str1[120],str2[120];</strong> <strong>int len1,len2,cnt1[30],cnt2[30],sum,flag;</strong> <strong>bool cmp(int a,int b){</strong> **    return a&gt;b;** <strong>}</strong> <strong>int main(){</strong> **    while(cin&gt;&gt;str1){** **        cin&gt;&gt;str2;** **        len1=strlen(str1),len2=strlen(str2);** **        memset(cnt1,0,sizeof(cnt1));** **        memset(cnt2,0,sizeof(cnt2));** **        sum=flag=0;** **        if(len1!=len2){** **            puts(“NO”);** **            continue;** **        }** **        for(int i=0;i&lt;len1;++i){** **            if(cnt1[str1[i]-‘A’]==0)** **                sum++;** **            cnt1[str1[i]-‘A’]++;** **        }** **        for(int i=0;i&lt;len2;++i)** **            cnt2[str2[i]-‘A’]++;** **        sort(cnt1,cnt1+26,cmp);** **        sort(cnt2,cnt2+26,cmp);** **        for(int i=0;i&lt;sum;++i){** **            if(cnt1[i]!=cnt2[i]){** **                flag=1;** **                break;** **            }** **        }** **        puts(flag?”NO”:”YES”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词记录】 empire 帝国 various 各种各样的,多样的 departments 部(门) provinces 地方,职权 encrypted 把…编码；把…加密 prevent eavesdropping. 防止窃听 ciphers 密码,编码 substituti","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"Codeforces 232A Cycles","slug":"codeforces-232a-cycles","date":"2017-03-25T06:43:14.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/codeforces-232a-cycles.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>思路,逻辑题.</strong> <strong>【参考】</strong> <strong>WannaFlyUnion</strong> <strong>【题解】</strong> <strong>每次加入一个点时让他先于点1相连,贡献为0,然后与点2相连,贡献为1,与三相连,贡献为2…依此类推.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>using namespace std;</strong> <strong>const int MAXN=111;</strong> <strong>int mapp[MAXN][MAXN];</strong> <strong>int main(){</strong> **    int n;** **    cin&gt;&gt;n;** **    int l=2;** **    int ant=0;** **    mapp[1][2]=mapp[2][1]=1;** **    for(int i=3;i&lt;=100;++i){** **        l=max(l,i);** **        mapp[i][1]=mapp[1][i]=1;** <strong>//都与点1相连</strong> **        for(int j=2;j&lt;i;++j){** **            mapp[i][j]=mapp[j][i]=1;** <strong>//比如4个点,2和4连贡献了一个,3和4连贡献了两个…</strong> **            ant+=j-1;** **            if(ant==n)** **                break;** **            else if(ant&gt;n){** **                ant-=j-1;** **                mapp[i][j]=mapp[j][i]=0;** **                break;** **            }** **        }** **        if(ant==n)** **            break;** **    }** **    printf(“%d\\n”,l);** **    for (int i = 1 ; i &lt;= l ; i++)  ** **    {  ** **        for (int j = 1 ; j &lt; l ; j++)  ** **            printf (“%d”,mapp[i][j]);  ** **        printf (“%d\\n”,mapp[i][l]);  ** **    }  ** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 思路,逻辑题. 【参考】 WannaFlyUnion 【题解】 每次加入一个点时让他先于点1相连,贡献为0,然后与点2相连,贡献为1,与三相连,贡献为2…依此类推. 【Code】#include  using namespace std; const int MAXN=","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"POJ 3984","slug":"poj-3984","date":"2017-03-24T12:40:32.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-3984.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 bfs 【Tip】 当结构体内部有构造函数时,不能定义二维结构体. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#include<queue></queue></p>\n<p>#include<stack><br>using namespace std;<br>struct node{<br>    int x,y,sx,sy;<br>    //node(int xx,int yy,int ssx,int ssy):x(xx),y(yy),sx(ssx),sy(ssy) {}<br>};<br>node position[10][10];<br>queue q;<br>int vi[6][6]={0};<br>int maze[5][5]={<br>    0, 1, 0, 0, 0,<br>    0, 1, 0, 1, 0,<br>    0, 0, 0, 0, 0,<br>    0, 1, 1, 1, 0,<br>    0, 0, 0, 1, 0,<br>};</stack></p>\n<p>void Bac(int x,int y){<br>    if(x==-1,y==-1){<br>        return;<br>    }<br>    Bac(position[x][y].x,position[x][y].y);<br>    printf(“(%d, %d)\\n”,x,y);<br>}</p>\n<p>node Anode(int x,int y,int sx,int sy){<br>    node A;<br>    A.x=x;<br>    A.y=y;<br>    A.sx=sx;<br>    A.sy=sy;<br>    return A;<br>}</p>\n<p>void bfs(){<br>    position[0][0].x=-1;<br>    position[0][0].y=-1;<br>    position[0][0].sx=0;<br>    position[0][0].sy=0;<br>    q.push(Anode(-1,-1,0,0));<br>    vi[0][0]=1;<br>    while(!q.empty()){<br>        node a=q.front();<br>        if(a.sx==4 &amp;&amp; a.sy==4){<br>            Bac(a.sx,a.sy);<br>            return;<br>        }<br>        q.pop();<br>        if(a.sx+1=0 &amp;&amp; !vi[a.sx][a.sy-1]&amp;&amp; !maze[a.sx][a.sy-1]){<br>            position[a.sx][a.sy-1].sx=a.sx;<br>            position[a.sx][a.sy-1].sy=a.sy-1;<br>            position[a.sx][a.sy-1].x=a.sx;<br>            position[a.sx][a.sy-1].y=a.sy;<br>            q.push(Anode(a.sx,a.sy,a.sx,a.sy-1));<br>            vi[a.sx][a.sy-1]=1;<br>        }<br>        if(a.sx-1&gt;=0 &amp;&amp; !vi[a.sx-1][a.sy]&amp;&amp; !maze[a.sx-1][a.sy]){<br>            position[a.sx-1][a.sy].sx=a.sx-1;<br>            position[a.sx-1][a.sy].sy=a.sy;<br>            position[a.sx-1][a.sy].x=a.sx;<br>            position[a.sx-1][a.sy].y=a.sy;<br>            q.push(Anode(a.sx,a.sy,a.sx-1,a.sy));<br>            vi[a.sx-1][a.sy]=1;<br>        }<br>    }<br>}<br>int main(){<br>    bfs();<br>    return 0;<br>}</p>\n","text":"【类型】 bfs 【Tip】 当结构体内部有构造函数时,不能定义二维结构体. 【Code】#include#include#include#include#include#include#include<br>using namespace std;<br>struct node","link":"","raw":null,"photos":[],"categories":[{"name":"搜索","slug":"搜索","count":2,"path":"api/categories/搜索.json"}],"tags":[{"name":"搜索","slug":"搜索","count":2,"path":"api/tags/搜索.json"}]},{"title":"Android 学习 使用限定符","slug":"android-limited","date":"2017-03-22T07:38:52.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/android-limited.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/%E9%99%90%E5%AE%9A%E7%AC%A6.png","content":"<p><strong>【reference】</strong> <strong>《第一行代码-第二版》 GuoLin</strong>   <strong>【目标】</strong> <strong>在不同分辨率下显示不同的Layout</strong>   <strong>【常见限定符】</strong> <strong><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/限定符.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/%E9%99%90%E5%AE%9A%E7%AC%A6.png\" alt></a></strong> <strong>【最小宽度限定符/Smallest-width Qualifier】</strong> <strong>例如:在res目录下新建layout-sw600dp文件夹=&gt;屏幕宽度大于600dp的设备运行时调用.</strong></p>\n","text":"【reference】 《第一行代码-第二版》 GuoLin   【目标】 在不同分辨率下显示不同的Layout   【常见限定符】  [Figure]  【最小宽度限定符/Smallest-width Qualifier】 例如:在res目录下新建layout-sw600dp文","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]}]}