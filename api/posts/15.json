{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"ASP.NET MVC Filter 登录限制-类Python装饰器","slug":"asp-net-mvc-filter-python","date":"2017-12-10T10:12:21.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/asp-net-mvc-filter-python.json","excerpt":"","keywords":null,"cover":null,"content":"<p>想必学过Flask编写Web服务端的都对 <strong>@login_required</strong> 很熟悉吧,一个语句决定了访问者是否有权限访问当前页面. 那么疑问来了,ASP.NET MVC中是否有类似于Python装饰器一类的语法呢? 答案是有的,如果仅仅是权限以及登录确认的判断的话,ASP.NET MVC 有一个 <strong>AuthorizeAttribute</strong> 类,这个类的结构以及用法可以替代 <strong>@login_required</strong>,接下来编写实现代码. 首先新建一个ASP.NET MVC 项目,新建一个Filter文件夹,该文件夹下存放网站允许访问一类的类. 新建<strong>MyAuthorizeAttribute</strong>类,继承<strong>AuthorizeAttribute</strong> 类,重写AuthorizeCore和HandleUnauthorizedRequest方法. 第一个方法是授权检察,第二个方法是权限判断失败时执行的操作. 接下来实现当时间分钟是偶数时允许登录.</p>\n<pre><code>//MyAuthorizeAttribute.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\n\nnamespace WebApplication3.Filter\n{\n    public class MyAuthorizeAttribute :AuthorizeAttribute\n    {\n        protected override bool AuthorizeCore(HttpContextBase httpContext)\n        {\n            return DateTime.Now.Minute % 2 == 0;  \n        }\n        protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext)\n        {\n            filterContext.HttpContext.Response.Redirect(&quot;/Home/ShowTip&quot;);\n\n            //base.HandleUnauthorizedRequest(filterContext);  \n        }  \n    }\n}\n\n\n//HomeController.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\nusing WebApplication3.Filter;\n\nnamespace WebApplication3.Controllers\n{\n    public class HomeController : Controller\n    {\n        public ActionResult Index()\n        {\n            return View();\n        }\n\n        [MyAuthorizeAttribute]\n        public ActionResult ShowDetails2()\n        {\n            return View();\n        }\n        public ActionResult ShowTip()\n        {\n            return View();\n        }  \n    }\n}</code></pre>","text":"想必学过Flask编写Web服务端的都对 @login_required 很熟悉吧,一个语句决定了访问者是否有权限访问当前页面. 那么疑问来了,ASP.NET MVC中是否有类似于Python装饰器一类的语法呢? 答案是有的,如果仅仅是权限以及登录确认的判断的话,ASP.NET ","link":"","raw":null,"photos":[],"categories":[{"name":"ASP.Net","slug":"ASP-Net","count":3,"path":"api/categories/ASP-Net.json"},{"name":"C#","slug":"ASP-Net/C","count":2,"path":"api/categories/ASP-Net/C.json"},{"name":"MVC","slug":"ASP-Net/C/MVC","count":1,"path":"api/categories/ASP-Net/C/MVC.json"},{"name":"Web","slug":"ASP-Net/C/MVC/Web","count":1,"path":"api/categories/ASP-Net/C/MVC/Web.json"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"},{"name":"MVC","slug":"MVC","count":1,"path":"api/tags/MVC.json"},{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"}]},{"title":"企划录 - 仿知乎+论坛+贴吧+博客 - 假期开始","slug":"qhl","date":"2017-11-29T06:34:37.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/qhl.json","excerpt":"","keywords":null,"cover":null,"content":"<p>打算使用前后端彻底分离的方式. 后端用python,java等编写api. 暂且先定python+flask编写api. 前端使用react+UI(UI框架待定)构建前台. 通过学习react之后进行构建react native app平台. 数据库用mysql(如果学了比这个好点的就用其他的). 喏,置顶企划.先学学react.</p>\n","text":"打算使用前后端彻底分离的方式. 后端用python,java等编写api. 暂且先定python+flask编写api. 前端使用react+UI(UI框架待定)构建前台. 通过学习react之后进行构建react native app平台. 数据库用mysql(如果学了比这个好","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"第八届ACM省赛 Quadrat 找规律","slug":"acm-quadrat","date":"2017-11-27T23:42:08.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/acm-quadrat.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: <a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164</a> B题 题意: 求数位为n位的所有数字(0~9..9(n个9))中,各个数位与其平方%10^n所得数的各个数位之差不超过d的数的个数. 注: 所有的数位之差是循环的,比如9和1差2. 首先打表(不过我认为这道题是数位dp,但我不会):</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\n\nconst int num[5]={1,10,100,1000,10000};\nint a[15][15];\nvoid init(){\n    memset(a, 0, sizeof(a));\n    for(int i = 0; i &lt;= 9; ++i){\n        for(int j = 0; j &lt;= 9; ++j){\n            a[i][j] = abs(i-j);\n            if(a[i][j] &gt; 5) a[i][j] = 10 - a[i][j];\n        }\n    }\n}\n\nbool judge(int i,int digit,int d){\n    int res=i*i;\n    for(int j=1;j&lt;=digit;++j){\n        int b=i%10;\n        int c=res%10;\n        i/=10;res/=10;\n        if(a[b][c]&gt;d) return false;\n    }\n    return true;\n}\n\nint check(int nb,int d){\n    int cnt=0;\n    for(int i=0;i&lt;num[nb];++i){\n        if(judge(i,nb,d))\n            cnt++;\n    }\n    return cnt;\n}\n\nint main(){\n    init();\n    for(int i=1;i&lt;=4;++i){\n        printf(&quot;%d:&quot;,i);\n        for(int j=0;j&lt;4;++j){\n            printf(&quot; %d&quot;,check(i,j));\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>发现dp[i][j]=dp[i-1][j]<em>(2</em>j+1) Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nlong long dp[19][4];\n\nvoid init(){\n    dp[1][0]=4;dp[1][1]=4;\n    dp[1][2]=8;dp[1][3]=8;\n    for(int i=2;i&lt;=18;++i){\n        for(int j=0;j&lt;4;++j){\n            dp[i][j]=dp[i-1][j]*(2*j+1);\n        }\n    }\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int n,d;\n        scanf(&quot;%d %d&quot;,&amp;n,&amp;d);\n        printf(&quot;%lld\\n&quot;,dp[n][d]);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164 B题 题意: 求数位为n位的所有数字(0~9..9(n个9))中,各个数位与其平方%10^n所得数的各个数位","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"思维","slug":"Sdut/思维","count":1,"path":"api/categories/Sdut/思维.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/思维/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/思维/第八届ACM山东省赛.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"ASP.NET API2 设计 RESTful API 服务端解决跨域","slug":"asp-net-api2-ky-restful-api","date":"2017-11-26T10:16:55.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/asp-net-api2-ky-restful-api.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原理: 只需要在消息头中添加一句: Access-Control-Allow-Origin * 即可. 解决方案是直接在nuget中安装 Microsoft Asp.Net Web Api 2.2 Cross-Origin 然后在App-Start/WebApiConfig.cs下：</p>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web.Http;\nusing System.Web.Http.Cors;\n\nnamespace WAPI\n{\n    public static class WebApiConfig\n    {\n        public static void Register(HttpConfiguration config)\n        {\n            //跨域配置\n            config.EnableCors(new EnableCorsAttribute(&quot;*&quot;, &quot;*&quot;, &quot;*&quot;));\n            // Web API configuration and services\n\n            // Web API routes\n            config.MapHttpAttributeRoutes();\n\n            config.Routes.MapHttpRoute(\n                name: &quot;DefaultApi&quot;,\n                routeTemplate: &quot;api/{controller}/{id}&quot;,\n                defaults: new { id = RouteParameter.Optional }\n            );\n        }\n    }\n}</code></pre><p>即可.</p>\n","text":"原理: 只需要在消息头中添加一句: Access-Control-Allow-Origin * 即可. 解决方案是直接在nuget中安装 Microsoft Asp.Net Web Api 2.2 Cross-Origin 然后在App-Start/WebApiConfig.cs","link":"","raw":null,"photos":[],"categories":[{"name":"ajax","slug":"ajax","count":4,"path":"api/categories/ajax.json"},{"name":"ASP.Net","slug":"ajax/ASP-Net","count":3,"path":"api/categories/ajax/ASP-Net.json"},{"name":"C#","slug":"ajax/ASP-Net/C","count":1,"path":"api/categories/ajax/ASP-Net/C.json"},{"name":"RestFul_API","slug":"ajax/ASP-Net/C/RestFul-API","count":1,"path":"api/categories/ajax/ASP-Net/C/RestFul-API.json"}],"tags":[{"name":"ajax","slug":"ajax","count":4,"path":"api/tags/ajax.json"},{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"},{"name":"RestFul_API","slug":"RestFul-API","count":2,"path":"api/tags/RestFul-API.json"}]},{"title":"ASP.NET API2 设计 RESTful API","slug":"asp-net-api2-restful-api","date":"2017-11-26T04:12:55.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/asp-net-api2-restful-api.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171126121235.jpg","content":"<p>Copyright @ <a href=\"https://docs.microsoft.com/en-us/aspnet/web-api/overview/getting-started-with-aspnet-web-api/tutorial-your-first-web-api\" title=\"DocsASP.NETASP.NET Web API\" target=\"_blank\" rel=\"noopener\">DocsASP.NETASP.NET Web API</a> 微软的官方文档</p>\n<blockquote>\n<p>首先是新建ASP.NET api项目 然后是设计Model</p>\n<blockquote>\n<p>Product.cs</p>\n</blockquote>\n</blockquote>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace WAPI.Models\n{\n    public class Product\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public string Category { get; set; }\n        public decimal Price { get; set; }\n    }\n}</code></pre><blockquote>\n<p>编写Controller(路由)</p>\n<blockquote>\n<p>ProductsController.cs</p>\n</blockquote>\n</blockquote>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Web.Http;\n\nusing WAPI.Models;\n\nnamespace WAPI.Controllers\n{\n    public class ProductsController : ApiController\n    {\n        // XXM =&gt; decimal类型小数\n        Product[] products = new Product[]{\n            new Product{ Id=1,Name=&quot;Tomato Soup&quot;,Category=&quot;Groceries&quot;,Price=1},\n            new Product{ Id=2,Name=&quot;Yo-yo&quot;,Category=&quot;Toys&quot;,Price=3.75M},\n            new Product{ Id=3,Name=&quot;Hammer&quot;,Category=&quot;Hardware&quot;,Price=16.99M}\n        };\n\n        public IEnumerable&lt;Product&gt; GetAllProducts()\n        {\n            return products;\n        }\n\n        public IHttpActionResult GetProduct(int id)\n        {\n            //容器.FirstOrDefault(Boolean) 返回满足条件的第一个元素,如未找到,返回默认值\n            var product = products.FirstOrDefault((p) =&gt; p.Id == id);\n            if (product == null)\n            {\n                //ApiController.NotFound()\n                //即404界面\n                return NotFound();\n            }\n            //正常返回\n            return Ok(product);\n        }\n    }\n}</code></pre><blockquote>\n<p>最后通过编写前端界面,并使用JQuery来实现ajax传输,显示</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;\n    &lt;title&gt;Product App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;h2&gt;All Products&lt;/h2&gt;\n        &lt;ul id=&quot;products&quot;/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;h2&gt;Search by ID&lt;/h2&gt;\n        &lt;input type=&quot;text&quot; id=&quot;prodId&quot; size=&quot;5&quot;/&gt;\n        &lt;input type=&quot;button&quot; value=&quot;Search&quot; onclick=&quot;find();&quot;/&gt;\n        &lt;p id=&quot;product&quot;/&gt;\n    &lt;/div&gt;\n\n    &lt;script src=&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.0.3.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        var uri = &apos;api/products&apos;;\n\n        $(document).ready(function () {\n            //Send an AJAX request\n            $.getJSON(uri)\n                .done(function (data) {\n                    //On success,&apos;data&apos; contains a list of products.\n                    $.each(data, function (key, item) {\n                        //Add a list item for the product。\n                        $(&apos;&lt;li&gt;&apos;, { text: formatItem(item) }).appendTo($(&apos;#products&apos;));\n                    });\n                });\n        });\n\n\n        function formatItem(item) {\n            return item.Name + &apos;: $&apos; + item.Price;\n        }\n\n        function find() {\n            var id = $(&apos;#prodId&apos;).val();\n            $.getJSON(uri + &apos;/&apos; + id)\n                .done(function (data) {\n                    $(&apos;#product&apos;).text(formatItem(data));\n                })\n                .fail(function (jqXHR, textStatus, err) {\n                    $(&apos;#product&apos;).text(&apos;Error: &apos; + err);\n                });\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><blockquote>\n<p>结果如下所示</p>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ截图20171126121235.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171126121235.jpg\" alt></a></p>\n","text":"Copyright @ DocsASP.NETASP.NET Web API 微软的官方文档首先是新建ASP.NET api项目 然后是设计ModelProduct.csusing System;using System.Collections.Generic;using Sys","link":"","raw":null,"photos":[],"categories":[{"name":"ajax","slug":"ajax","count":4,"path":"api/categories/ajax.json"},{"name":"ASP.Net","slug":"ajax/ASP-Net","count":3,"path":"api/categories/ajax/ASP-Net.json"},{"name":"JS","slug":"ajax/ASP-Net/JS","count":1,"path":"api/categories/ajax/ASP-Net/JS.json"},{"name":"RestFul_API","slug":"ajax/ASP-Net/JS/RestFul-API","count":1,"path":"api/categories/ajax/ASP-Net/JS/RestFul-API.json"}],"tags":[{"name":"ajax","slug":"ajax","count":4,"path":"api/tags/ajax.json"},{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"RestFul_API","slug":"RestFul-API","count":2,"path":"api/tags/RestFul-API.json"},{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"HDU 2588 GCD","slug":"hdu-2588-gcd","date":"2017-11-25T11:45:09.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/hdu-2588-gcd.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 数论-欧拉函数-折半枚举 原题连接: <a href=\"https://vjudge.net/problem/HDU-2588\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2588</a></p>\n<blockquote>\n<p>题意</p>\n<blockquote>\n<p>输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.</p>\n</blockquote>\n<p>题解</p>\n<blockquote>\n<p>首先无法枚举X求GCD(X,N) 我们考虑 (X,N) = (q*d,b*d) 其中d是X,N的最大公约数. 可以知道 b&gt;=q 且 b与q互质①. 所以就转换成了对每个这样的d求 euler(b)(见①) 且 d&gt;=M 的个数. 也就转换成了枚举d求euler(b)之和.但是这仍是O(TNlgN)复杂度的. 所以我们采用折半枚举的做法,因为要枚举的是d,而d*b在sqrt(N)之后就变成了b*d了.所以我们可以只需要枚举sqrt(N)个数,将b,d都看做b即可.</p>\n</blockquote>\n</blockquote>\n<p>Code:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    for(int i=0;i&lt;T;++i){\n        int ans=0;\n        int N,M;\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;M);\n        for(int i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                if(i&gt;=M)\n                    ans+=euler(N/i);\n                if((N/i)!=i &amp;&amp; (N/i)&gt;=M)\n                ///如果==i且&gt;=M的话证明i&gt;=M,而不需要计算两次,所以排除掉\n                    ans+=euler(i);\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"类型: 数论-欧拉函数-折半枚举 原题连接: https://vjudge.net/problem/HDU-2588题意输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.题解首先无法枚举X求GCD(X,N) 我们考","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"数论","slug":"HDU/数论","count":1,"path":"api/categories/HDU/数论.json"},{"name":"欧拉函数","slug":"HDU/数论/欧拉函数","count":1,"path":"api/categories/HDU/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"AOJ NTL_1_D Euler's Phi Function & 欧拉函数相关","slug":"aoj-ntl-1-d-eulers-phi-function","date":"2017-11-25T07:35:20.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-ntl-1-d-eulers-phi-function.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg","content":"<p>欧拉函数: 提供1到N中与N互质的数的个数.</p>\n<h2><span id=\"定义和简单性质\">定义和简单性质</span></h2><p>欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. <strong>对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).</strong></p>\n<h3><span id=\"性质\">性质</span></h3><blockquote>\n<p>1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(q-1)</p>\n<blockquote>\n<p>欧拉函数是积性函数,但不是完全积性函数.</p>\n</blockquote>\n</blockquote>\n<p>证明： 函数的积性即： 若m,n互质,则φ(mn)=φ(m)φ(n).由“m,n互质”可知m,n无公因数,所以: φ(m)φ(n)=m(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)·n(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 其中p1,p2,p3…pn为m的质因数,p1’,p2’,p3’…pn’为n的质因数,而m,n无公因数,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 互不相同,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 均为mn的质因数且为mn质因数的全集,所以: φ(mn)=mn(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 所以: φ(mn)=φ(m)φ(n). 即φ(mn)=φ(n)*φ(m)只在(n,m)=1时成立(n与m互质).</p>\n<blockquote>\n<p>2.对于一个正整数N的素数幂分解N=P1^q1_P2^q2_…*Pn^qn.</p>\n</blockquote>\n<pre><code>则 φ(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn).</code></pre><blockquote>\n<p>3.除了N=2,φ(N)都是偶数. 4.设N为正整数,∑φ(d)=N (d|N)(d是N的质因数).</p>\n</blockquote>\n<p>根据性质二,我们可以在O(sqrt(n))的时间内暴力求出一个数的欧拉函数值. 如果我们要求1000000以内所有数的欧拉函数,怎么办. 上面的方法复杂度将高达O(N*sqrt(N)). 暴力方法:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int a[10]={2,10,100,1000,5,7,9,11,12,13};\n    for(int i=0;i&lt;10;++i)\n        cout&lt;&lt;euler(a[i])&lt;&lt;endl;\n    return 0;\n}</code></pre><p>结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" alt></a> 我们可以将这个方法和筛法求素数的想法结合,试用筛法求出1~n内各个数字的euler(n). φ(n)=n_（1-1/p1)(1-1/p2)….(1-1/pk) 其中p1、p2…pk为n的所有素因子(这个素因子是由整数素分得来的)。 比如：φ(12)=12_(1-1/2)(1-1/3)=4。 比如求10以内所有数的φ值：</p>\n<blockquote>\n<p>1.设一数组phi[11]，赋初值phi[1]=1,phi[2]=2…phi[10]=10 2.然后从2开始循环</p>\n<blockquote>\n<p>把2的倍数的φ值<em>(1-1/2)，则phi[2]=2_1/2=1,phi[4]=4_1/2=2,phi[6]=6_1/2=3….； 再是3，3的倍数的φ值</em>(1-1/3)，则phi[3]=3_2/3=2,phi[6]=3*2/3=2，phi[9]=…..； 再5，再7…因为对每个素数都进行如此操作，因此任何一个n都得到了φ(n)=n*（1-1/p1)(1-1/p2)….(1-1/pk)的运算</p>\n</blockquote>\n</blockquote>\n<p>代码如下:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h2><span id=\"aoj-ntl_1_d-eulers-phi-function\">AOJ NTL_1_D Euler’s Phi Function</span></h2><p>这道题数值范围是1e10,没超过int.而且只需要求一个数的euler. O(lgn)暴力即可.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;euler(n)&lt;&lt;endl;\n\n    return 0;\n}</code></pre>","text":"欧拉函数: 提供1到N中与N互质的数的个数.定义和简单性质欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. 对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).性质1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"},{"name":"欧拉函数","slug":"AOJ/数论/欧拉函数","count":1,"path":"api/categories/AOJ/数论/欧拉函数.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"数论 -  幂乘以及取模相关推导","slug":"number-theory-pow-and-mod","date":"2017-11-25T06:21:18.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/number-theory-pow-and-mod.json","excerpt":"","keywords":null,"cover":null,"content":"<p>幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.</p>\n<blockquote>\n<p>mod相关</p>\n<blockquote>\n<p>:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由如下</p>\n</blockquote>\n</blockquote>\n<pre><code>设a除以M的余数和商分别为ar,aq.\nb除以M的余数和商分别为br,bq.\na*b =(aq*M+ar)*(bq*M+br)\n    =aq*bq*M^2+ar*bq*M+aq*br*M+ar*br\n    =(aq*bq*M^+ar*bq+aq*br)*M+ar*br\n\n故 (a*b)%M = ar*br\n             = a%M*b%M</code></pre><blockquote>\n<blockquote>\n<p>:arrow_forward:除法相对复杂,具体可以通过费小马定理求解.</p>\n</blockquote>\n</blockquote>\n<p>幂乘模板题: <code>NTL_1_B:Power</code></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst ull md=1000000007;\n\nll mod_pow(ull x,ull n,ull mod){\n    ull res=1;\n    while(n&gt;0){\n        if(n&amp;1) res=res*x%mod;\n        x=x*x%mod;\n        n&gt;&gt;=1;\n    }\n    return res;\n}\n\nint main(){\n    ull m,n;\n    scanf(&quot;%llu %llu&quot;,&amp;m,&amp;n);\n    printf(&quot;%lld\\n&quot;,mod_pow(m,n,md));\n    return 0;\n}</code></pre>","text":"幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.mod相关:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"}]},{"title":"博客开放注册了哦","slug":"dasdasd","date":"2017-11-25T03:18:04.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/dasdasd.json","excerpt":"","keywords":null,"cover":null,"content":"<p>可以直接在注册的时候填写密码了!</p>\n","text":"可以直接在注册的时候填写密码了!","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"c++ & c 实现 TCP/UDP通讯","slug":"c-c-tcp-udp-tx","date":"2017-11-24T00:37:46.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/c-c-tcp-udp-tx.json","excerpt":"","keywords":null,"cover":null,"content":"<p>向前链接 Python TCP/UDP 编程: <a href=\"http://be-sunshine.cn/index.php/2017/07/26/python3-udptcp-ip/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2017/07/26/python3-udptcp-ip/</a></p>\n<blockquote>\n<p>三个任务:</p>\n<blockquote>\n<p>实现tcp通信 实现udp通信 使用tcp实现客户加入通知全部客户,使用轮询方法</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"基础知识\">基础知识</span></h2><p>套接字<code>socket(int af,int type,int protocol)</code>函数共三个参数.第一个参数af用来指定地址族,在Windows下可以使用的参数值有多个,但<code>真正</code>可以使用的只有两个,分别是 AF_INET 和 PF_INET。 这两个宏在winsock2.h下是相同的. 为了保证兼容性,尽量使用PF_INET比较好. 第二个参数type是指定新套接字描述符的类型.这里可以用的值通常有3个.分别是SOCK_STREAM,SOCK_DGRAM和SOCK_RAW,分别表示流套接字,数据包套接字和原始协议接口. 第三个参数是协议. 如果第二个参数使用<code>SOCK_STREAM</code>,name第三个参数应该使用<code>IPPROTO_TCP</code>.<code>SOCK_DGRAM</code>:<code>IPPROTO_UDP</code>. 即若第二个参数是这两个,第三个参数可以是0.如果是<code>RAW</code>,则第三个参数必须指定. 调用成功会返回一个新的套接字描述符.如果失败,则返回 INVALID_SOCKET.如果调用失败,想要知道原因,需要调用WSAGetLastError()得到错误码.</p>\n<h2><span id=\"面向连接协议的函数\">面向连接协议的函数</span></h2><p>这里来介绍一些基本的函数:bind(),listen(),accept(),connect(),send()和recv(). socket()只是新建了一个socket描述符,但内部信息尚未完善,,比如在网络通信时本地的端口和IP等. 这些信息需要使用bind()方法来完成. bind()函数定义如下:</p>\n<blockquote>\n<blockquote>\n<p>int bind(SOCKET s,const struct sockaddr FAR *name,int namelen)</p>\n</blockquote>\n</blockquote>\n<p>第一个参数是套接字描述符,也就是我们需要用到的socket 第二个参数是一个sockaddr结构体,提供套接字一个地址和端口信息. 第三个参数是namelen是sockaddr的大小. 其中第二个参数结构体定义如下:</p>\n<p>struct sockaddr{<br>    u_short sa_family;/*address family*/<br>    char sa_data[14];/*up to 14 bytes of direct address.*/<br>};</p>\n<p>但是需要使用转换将sockaddr之前的协议结构体 <code>sockaddr_in</code>转换成sockaddr.</p>\n<p>struct sockaddr_in {<br>    short sin_family;<br>    u_short sin_port;<br>    struct in_addr sin_addr;<br>    char sin_zero[8];<br>}</p>\n<p>struct in_addr{<br>    union{<br>        struct{u_char s_b1,s_b2,s_b3,s_b4;}  S_un_b;<br>        struct{u_short s_w1,s_w2;}  S_un_w;<br>        u_long  S_addr;<br>    }S_un;<br>};</p>\n<p>其中点分十进制ip转换成无符号长整型的函数是 <code>unsigned long inet_addr(const char FAR *cp);</code> 逆函数:转换成点分十进制 <code>char FAR * inet_ntoa(struct in_addr in);</code> sin_port需要的转换函数: <code>htons()和htonl() 逆向:ntohs()和ntohl()</code> 监听端口的函数定义如下:</p>\n<p>int listen(SOCKET s,int backlog);</p>\n<p>第一个参数是描述符,第二个参数是允许进入连接请求队列的个数.backlog的最大值由系统指定. 在winsock2.h中,其最大值由SOMAXCONN表示,该值的定义如下:</p>\n<p>#define SOMAXCONN 0x7fffffff</p>\n<p>接受连接请求的函数定义如下:</p>\n<p>SOCKET accept(SOCKET s,struct sockaddr FAR *addr,int FAR *addrlen);<br>//FAR:近指针</p>\n<h2><span id=\"任务一tcp\">任务一:TCP</span></h2><blockquote>\n<p>服务端</p>\n<blockquote>\n<p>WSAStartup()-&gt;socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;send()/recv()-&gt;closesocket()-&gt;WSACleanup()</p>\n</blockquote>\n<p>客户端</p>\n<blockquote>\n<p>WSAStartuo()-&gt;socket()-&gt;connect()-&gt;send()/recv()-&gt;closesocket()-&gt;WSACleanup()</p>\n</blockquote>\n</blockquote>\n<p>Code: 服务端:</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;winsock2.h&gt;\n#pragma comment (lib,&quot;ws2_32&quot;)\n\nint main(){\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2),&amp;wsaData);\n\n    //创建套接字\n    SOCKET sLisent = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);\n\n    //对sockaddr_in结构体填充地址,端口等信息\n    struct sockaddr_in ServerAddr;\n    ServerAddr.sin_family=AF_INET;\n    ServerAddr.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;);\n    ServerAddr.sin_port=htons(1234);\n\n    //绑定套接字与地址信息\n    bind(sLisent,(SOCKADDR *)&amp;ServerAddr,sizeof(ServerAddr));\n\n    //监听端口\n    listen(sLisent,SOMAXCONN);\n\n    //获取请求连接\n    struct sockaddr_in ClientAddr;\n    int nSize=sizeof(ClientAddr);\n\n    SOCKET sClient=accept(sLisent,(SOCKADDR *)&amp;ClientAddr,&amp;nSize);\n    //输出客户端使用的IP地址和端口号\n    printf(&quot;Client IP=%s:%d\\r\\n&quot;,inet_ntoa(ClientAddr.sin_addr),ntohs(ClientAddr.sin_port));\n\n    //发送消息\n    char szMsg[MAXBYTE]={0};\n    lstrcpy(szMsg,&quot;hello Client!\\r\\n&quot;);\n    send(sClient,szMsg,strlen(szMsg)+sizeof(char),0);\n\n    //接收消息\n    recv(sClient,szMsg,MAXBYTE,0);\n    printf(&quot;Client Msg : %s \\r\\n&quot;,szMsg);\n\n    WSACleanup();\n\n    getchar();\n\n    return 0;\n}</code></pre><p>客户端:</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;winsock2.h&gt;\n#pragma comment (lib,&quot;ws2_32&quot;)\n\nint main(){\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2),&amp;wsaData);\n\n    //创建套接字\n    SOCKET sServer = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);\n\n    //对sockaddr_in结构体填充地址,端口等信息\n    struct sockaddr_in ServerAddr;\n    ServerAddr.sin_family=AF_INET;\n    ServerAddr.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;);\n    ServerAddr.sin_port=htons(1234);\n\n    //连接服务器\n    connect(sServer,(SOCKADDR *)&amp;ServerAddr,sizeof(ServerAddr));\n\n    char szMsg[MAXBYTE]={0};\n\n    //接收消息\n    recv(sServer,szMsg,MAXBYTE,0);\n    printf(&quot;Server Msg: %s \\r\\n&quot;,szMsg);\n\n    //发送消息\n    lstrcpy(szMsg,&quot;hello Server!\\r\\n&quot;);\n    send(sServer,szMsg,strlen(szMsg)+sizeof(char),0);\n\n    WSACleanup();\n\n    getchar();\n\n    return 0;\n}</code></pre><h2><span id=\"任务二udp\">任务二:UDP</span></h2><blockquote>\n<p>服务端</p>\n<blockquote>\n<p>socket()-&gt;bind()-&gt;sendto()/recvfrom()-&gt;closesocket()</p>\n</blockquote>\n<p>客户端</p>\n<blockquote>\n<p>socket()-&gt;sendto()/recvfrom()-&gt;closesocket()</p>\n</blockquote>\n</blockquote>\n<p>code: 服务端:</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;winsock2.h&gt;\n#pragma comment (lib,&quot;ws2_32&quot;)\n\nint main(){\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2),&amp;wsaData);\n\n    //创建套接字\n    SOCKET sServer = socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);\n\n    //对socketaddr_in填充\n    struct sockaddr_in ServerAddr;\n    ServerAddr.sin_family=AF_INET;\n    ServerAddr.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;);\n    ServerAddr.sin_port=htons(1234);\n\n    //绑定套接字与地址信息\n    bind(sServer,(SOCKADDR *)&amp;ServerAddr,sizeof(ServerAddr));\n\n    //接收消息\n    char szMsg[MAXBYTE]={0};\n    struct sockaddr_in ClientAddr;\n    int nSize=sizeof(ClientAddr);\n    recvfrom(sServer,szMsg,MAXBYTE,0,(SOCKADDR*)&amp;ClientAddr,&amp;nSize);\n    printf(&quot;Client Msg: %s \\r\\n&quot;,szMsg);\n    printf(&quot;Client IP=%s: %d\\r\\n&quot;,inet_ntoa(ClientAddr.sin_addr),ntohs(ClientAddr.sin_port));\n\n    //发送消息\n    lstrcpy(szMsg,&quot;hello Client!\\r\\n&quot;);\n    nSize=sizeof(ClientAddr);\n    sendto(sServer,szMsg,strlen(szMsg)+sizeof(char),0,(SOCKADDR*)&amp;ClientAddr,nSize);\n\n    WSACleanup();\n    getchar();\n\n\n    return 0;\n}</code></pre><p>客户端:</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;winsock2.h&gt;\n#pragma comment (lib,&quot;ws2_32&quot;)\n\nint main(){\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2),&amp;wsaData);\n\n    //创建套接字\n    SOCKET sClient = socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);\n\n    //对socketaddr_in填充\n    struct sockaddr_in ServerAddr;\n    ServerAddr.sin_family=AF_INET;\n    ServerAddr.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;);\n    ServerAddr.sin_port=htons(1234);\n\n    //发送消息\n    char szMsg[MAXBYTE]={0};\n    lstrcpy(szMsg,&quot;Hello Server!\\r\\n&quot;);\n    int nSize=sizeof(ServerAddr);\n    sendto(sClient,szMsg,strlen(szMsg)+sizeof(char),0,(SOCKADDR *)&amp;ServerAddr,nSize);\n\n    //接收消息\n    nSize=sizeof(ServerAddr);\n    recvfrom(sClient,szMsg,MAXBYTE,0,(SOCKADDR *)&amp;ServerAddr,&amp;nSize);\n    printf(&quot;Server Msg : %s\\r\\n&quot;,szMsg);\n\n    WSACleanup();\n\n    getchar();\n    return 0;\n}</code></pre><h2><span id=\"任务三轮询式多客户端连接\">任务三:轮询式多客户端连接</span></h2><p>code: 服务端:</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;winsock2.h&gt;\n#include &lt;windows.h&gt;\n#include&lt;vector&gt;\n#pragma comment (lib,&quot;ws2_32&quot;)\nusing namespace std;\n\nint main(){\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2),&amp;wsaData);\n\n    //创建套接字\n    SOCKET sLisent = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);\n\n    //对sockaddr_in结构体填充地址,端口等信息\n    struct sockaddr_in ServerAddr;\n    ServerAddr.sin_family=AF_INET;\n    ServerAddr.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;);\n    ServerAddr.sin_port=htons(1234);\n\n    //绑定套接字与地址信息\n    bind(sLisent,(SOCKADDR *)&amp;ServerAddr,sizeof(ServerAddr));\n\n    vector&lt;SOCKET&gt; cStack;\n\n    while(1){\n        //监听端口\n        listen(sLisent,SOMAXCONN);\n\n        //获取请求连接\n        struct sockaddr_in ClientAddr;\n        int nSize=sizeof(ClientAddr);\n\n        SOCKET sClient=accept(sLisent,(SOCKADDR *)&amp;ClientAddr,&amp;nSize);\n        cStack.push_back(sClient);\n        //输出客户端使用的IP地址和端口号\n        printf(&quot;Client IP=%s:%d\\r\\n&quot;,inet_ntoa(ClientAddr.sin_addr),ntohs(ClientAddr.sin_port));\n\n        //向全部客户端发送消息\n        for(int i=0;i&lt;cStack.size();++i){\n            char szMsg[MAXBYTE]={0};\n            lstrcpy(szMsg,&quot;hello Client!\\r\\n&quot;);\n            send(cStack[i],szMsg,strlen(szMsg)+sizeof(char),0);\n\n            //接收消息\n            recv(cStack[i],szMsg,MAXBYTE,0);\n            printf(&quot;Client Msg : %s \\r\\n&quot;,szMsg);\n        }\n    }\n    WSACleanup();\n\n    getchar();\n\n    return 0;\n}</code></pre><p>客户端:</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;winsock2.h&gt;\n#include&lt;windows.h&gt;\n#pragma comment (lib,&quot;ws2_32&quot;)\n\nint main(){\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2),&amp;wsaData);\n\n    //创建套接字\n    SOCKET sServer = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);\n\n    //对sockaddr_in结构体填充地址,端口等信息\n    struct sockaddr_in ServerAddr;\n    ServerAddr.sin_family=AF_INET;\n    ServerAddr.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;);\n    ServerAddr.sin_port=htons(1234);\n    while(1){\n        //连接服务器\n        connect(sServer,(SOCKADDR *)&amp;ServerAddr,sizeof(ServerAddr));\n\n        char szMsg[MAXBYTE]={0};\n\n        //接收消息\n        printf(&quot;接收消息\\n&quot;);\n        recv(sServer,szMsg,MAXBYTE,0);\n        printf(&quot;Server Msg: %s \\r\\n&quot;,szMsg);\n\n        //发送消息\n        lstrcpy(szMsg,&quot;hello Server!\\r\\n&quot;);\n        send(sServer,szMsg,strlen(szMsg)+sizeof(char),0);\n\n    }\n    WSACleanup();\n\n    getchar();\n\n    return 0;\n}</code></pre><p>以上代码编译连接以后直接运行<code>.exe</code>即可,注意,需要在IDE中添加依赖库<code>libws2_32.a</code></p>\n","text":"向前链接 Python TCP/UDP 编程: http://be-sunshine.cn/index.php/2017/07/26/python3-udptcp-ip/三个任务:实现tcp通信 实现udp通信 使用tcp实现客户加入通知全部客户,使用轮询方法基础知识套接字soc","link":"","raw":null,"photos":[],"categories":[{"name":"tcp","slug":"tcp","count":2,"path":"api/categories/tcp.json"},{"name":"网络编程","slug":"tcp/网络编程","count":2,"path":"api/categories/tcp/网络编程.json"},{"name":"轮询通信","slug":"tcp/网络编程/轮询通信","count":1,"path":"api/categories/tcp/网络编程/轮询通信.json"}],"tags":[{"name":"网络编程","slug":"网络编程","count":4,"path":"api/tags/网络编程.json"},{"name":"tcp","slug":"tcp","count":3,"path":"api/tags/tcp.json"},{"name":"轮询通信","slug":"轮询通信","count":1,"path":"api/tags/轮询通信.json"}]}]}