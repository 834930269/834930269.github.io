{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"2322","slug":"2322","date":"2019-01-10T06:21:34.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/2322.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>终于狠下心花了181买了Gamemaker studio2!!!(little (⊙︿⊙) little (<em>^▽^</em>))</p>\n</blockquote>\n<p>:yum: :yum: :yum:</p>\n","text":"终于狠下心花了181买了Gamemaker studio2!!!(little (⊙︿⊙) little (^▽^)):yum: :yum: :yum:","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"tl2","slug":"tl2","date":"2019-01-10T06:13:33.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/tl2.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"主题迁移时的问题汇总\"><a href=\"#主题迁移时的问题汇总\" class=\"headerlink\" title=\"主题迁移时的问题汇总\"></a>主题迁移时的问题汇总</h2><blockquote>\n<p>1.鼠标,仅需要在style.css中加入以下代码即可,其中鼠标文件地址自己设置</p>\n<blockquote>\n<p>Tip：鼠标必须是cur格式</p>\n</blockquote>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn:9011/static/file/cur.css\" target=\"_blank\" rel=\"noopener\">cur.css</a></p>\n<blockquote>\n<p>2.雪花，直接将下面文件拆分,启动的那部分放到footer.php中,逻辑部分放在header.php中(均是主题).</p>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn:9011/static/file/Snow.js\" title=\"Snow.js\" target=\"_blank\" rel=\"noopener\">Snow.js</a></p>\n","text":"主题迁移时的问题汇总1.鼠标,仅需要在style.css中加入以下代码即可,其中鼠标文件地址自己设置Tip：鼠标必须是cur格式cur.css2.雪花，直接将下面文件拆分,启动的那部分放到footer.php中,逻辑部分放在header.php中(均是主题).Snow.js","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"主题彻底换了一遍","slug":"ls","date":"2019-01-10T04:31:16.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/ls.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>主题彻底换了一遍,有些问题可以解决,但解决后太丑,所以决定先弃置. 比如摘要,如果要解决,可能需要每个都重新搞一下摘要.所以只有第一页解决了,其他的…Emmmm每个都是显示全部文章.</p>\n</blockquote>\n","text":"主题彻底换了一遍,有些问题可以解决,但解决后太丑,所以决定先弃置. 比如摘要,如果要解决,可能需要每个都重新搞一下摘要.所以只有第一页解决了,其他的…Emmmm每个都是显示全部文章.","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":8,"path":"api/tags/随笔.json"}]},{"title":"JeffE 算法课翻译目录","slug":"jeffe-traslation","date":"2019-01-08T13:04:42.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/jeffe-traslation.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"3-动态规划\"><a href=\"#3-动态规划\" class=\"headerlink\" title=\"3- 动态规划\"></a>3- 动态规划</h1><h2 id=\"3-1-起源\"><a href=\"#3-1-起源\" class=\"headerlink\" title=\"3-1 起源\"></a>3-1 起源</h2><p><a href=\"http://be-sunshine.cn/index.php/2019/04/08/jeffe-3-1-dporigin/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/04/08/jeffe-3-1-dporigin/</a></p>\n","text":"3- 动态规划3-1 起源http://be-sunshine.cn/index.php/2019/04/08/jeffe-3-1-dporigin/","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"排序可视化","slug":"sort-vis","date":"2019-01-08T08:57:47.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/sort-vis.json","excerpt":"","keywords":null,"cover":null,"content":"<p>源码: <a href=\"https://github.com/834930269/sort_visualization\" title=\"排序的可视化\" target=\"_blank\" rel=\"noopener\">排序的可视化</a></p>\n<blockquote>\n<p>暂时有： 插入排序,归并排序,快速排序,快速排序(严蔚敏版),选择排序,希尔排序</p>\n</blockquote>\n<blockquote>\n<p>运行方式,IDLE打开,然后打开某算法下的AlgoVisualizer,在main函数上run即可(有些算法设置了需要点击才会开始运行)</p>\n</blockquote>\n<p>一下目录为待补充(回头写)</p>\n<h1 id=\"可视化框架\"><a href=\"#可视化框架\" class=\"headerlink\" title=\"可视化框架\"></a>可视化框架</h1><h2 id=\"Java-swing的MVC架构\"><a href=\"#Java-swing的MVC架构\" class=\"headerlink\" title=\"Java swing的MVC架构\"></a>Java swing的MVC架构</h2><h3 id=\"M-模型\"><a href=\"#M-模型\" class=\"headerlink\" title=\"M-模型\"></a>M-模型</h3><h3 id=\"V-视图\"><a href=\"#V-视图\" class=\"headerlink\" title=\"V-视图\"></a>V-视图</h3><h3 id=\"C-控制层\"><a href=\"#C-控制层\" class=\"headerlink\" title=\"C-控制层\"></a>C-控制层</h3><h3 id=\"具体架构可扩展至其他语言\"><a href=\"#具体架构可扩展至其他语言\" class=\"headerlink\" title=\"具体架构可扩展至其他语言\"></a>具体架构可扩展至其他语言</h3><h2 id=\"基于MVC架构下的排序可视化基础框架\"><a href=\"#基于MVC架构下的排序可视化基础框架\" class=\"headerlink\" title=\"基于MVC架构下的排序可视化基础框架\"></a>基于MVC架构下的排序可视化基础框架</h2>","text":"源码: 排序的可视化暂时有： 插入排序,归并排序,快速排序,快速排序(严蔚敏版),选择排序,希尔排序运行方式,IDLE打开,然后打开某算法下的AlgoVisualizer,在main函数上run即可(有些算法设置了需要点击才会开始运行)一下目录为待补充(回头写)可视化框架Java","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"聊天室内核从0开始 – 3 Seq2Seq","slug":"seq2seq","date":"2019-01-06T14:32:09.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/seq2seq.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Seq2Seq\"><a href=\"#Seq2Seq\" class=\"headerlink\" title=\"Seq2Seq\"></a>Seq2Seq</h1><p>关于Seq2Seq模型,看如下博客即可,针对的视频讲解可以去BliBli搜相关视频,基本一致. <a href=\"https://blog.csdn.net/wangyangzhizhou/article/details/77883152\" title=\"深度学习的seq2seq模型\" target=\"_blank\" rel=\"noopener\">深度学习的seq2seq模型</a></p>\n<blockquote>\n<p>注意要看下注意力机制</p>\n</blockquote>\n<h1 id=\"tensorflow-基础\"><a href=\"#tensorflow-基础\" class=\"headerlink\" title=\"tensorflow 基础\"></a>tensorflow 基础</h1><h1 id=\"项目完整代码-有空写其他的\"><a href=\"#项目完整代码-有空写其他的\" class=\"headerlink\" title=\"项目完整代码(有空写其他的)\"></a>项目完整代码(有空写其他的)</h1><blockquote>\n<p>这个项目中仅有一个训练一轮的模型(所以仅供看看).如果有需要还是要训练多点,但是前提当然是你有一个好的机器或者服务器,如果有信用卡也可以选择取Github Cloud 或者AWS上选择免费的服务器来帮你训练(时间会很长)</p>\n</blockquote>\n<p><a href=\"https://pan.baidu.com/s/1D18ZwROdqyilBuy6EU4xLA\" title=\"chatbot2\" target=\"_blank\" rel=\"noopener\">chatbot2</a></p>\n","text":"Seq2Seq关于Seq2Seq模型,看如下博客即可,针对的视频讲解可以去BliBli搜相关视频,基本一致. 深度学习的seq2seq模型注意要看下注意力机制tensorflow 基础项目完整代码(有空写其他的)这个项目中仅有一个训练一轮的模型(所以仅供看看).如果有需要还是要训","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"机器学习","slug":"Python/机器学习","count":2,"path":"api/categories/Python/机器学习.json"},{"name":"聊天机器人内核","slug":"Python/机器学习/聊天机器人内核","count":1,"path":"api/categories/Python/机器学习/聊天机器人内核.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"},{"name":"聊天机器人内核","slug":"聊天机器人内核","count":3,"path":"api/tags/聊天机器人内核.json"}]},{"title":"聊天室内核从0开始 – 2 处理语料库","slug":"type-3","date":"2019-01-04T12:48:01.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/type-3.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>最后更新于2019/1/4</p>\n</blockquote>\n<h1 id=\"处理语料库\"><a href=\"#处理语料库\" class=\"headerlink\" title=\"处理语料库\"></a>处理语料库</h1><h2 id=\"简单处理提问与应答\"><a href=\"#简单处理提问与应答\" class=\"headerlink\" title=\"简单处理提问与应答\"></a>简单处理提问与应答</h2><blockquote>\n<p>这里我们本来可以用jieba或者其他的一些库来帮忙分词,但是因为网上存在已经分好词的语料库,所以可以省略这一步. 至于语料库,可以在github上直接搜索语料库即可以搜到. 一般语料库如下:</p>\n</blockquote>\n<pre><code>E\nM 呵/呵\nM 是/王/若/猫/的/。\nE\nM 不/是\nM 那/是/什/么/？\nE\nM 怎/么/了\nM 我/很/难/过/，/安/慰/我/~\nE\nM 开/心/点/哈/,/一/切/都/会/好/起/来\nM 嗯/ /会/的</code></pre><p>其中E代表是下一组应答的开始,M代表的是一句话. 可以认为是一问一答.</p>\n<h2 id=\"将一个句子编码化\"><a href=\"#将一个句子编码化\" class=\"headerlink\" title=\"将一个句子编码化\"></a>将一个句子编码化</h2><blockquote>\n<p>因为我们如果企图对一个句子进行判断和操作时,我们需要将这串句子编码化成为一组数字更为方便,且占内存更少. 当然,我们用这组句子编码成数字以后也可以重新根据数字编码回字符.</p>\n</blockquote>\n<p>举个栗子: map[3]=’a’,map[2]=’b’ 则 32 = ab,且 ba = 23</p>\n<blockquote>\n<p>Python的一个语法糖:</p>\n<blockquote>\n<p>[2]*2=[2,2]</p>\n</blockquote>\n<p>2019/1/9 日更新-完善注释</p>\n</blockquote>\n<pre><code>import numpy as np\n\n# 句子编码化\nclass WordSequence(object):\n    #标注TAG\n    PAD_TAG=&apos;&lt;pad&gt;&apos;\n    UNK_TAG=&apos;&lt;unk&gt;&apos; # 未识别\n    START_TAG=&apos;&lt;s&gt;&apos;\n    END_TAG=&apos;&lt;/s&gt;&apos;\n\n    PAD=0\n    UNK=1\n    START=2\n    END=3\n\n    # 初始化标签\n    def __init__(self):\n        self.dict = {\n            WordSequence.PAD_TAG: WordSequence.PAD,\n            WordSequence.UNK_TAG: WordSequence.UNK,\n            WordSequence.START_TAG: WordSequence.START,\n            WordSequence.END_TAG: WordSequence.END\n        }\n        # 是否训练过了\n        self.fited=False\n\n    # 将word的词性转换为下标\n    def to_index(self,word):\n        assert self.fited,&apos;WordSequence尚未进行fit操作&apos;\n        # 如果有,返回下标\n        if word in self.dict:\n            return self.dict[word]\n        # 没有,返回UNKnow\n        return WordSequence.UNK\n\n    def to_word(self,index):\n        assert self.fited,&apos;WordSequence尚未进行fit操作&apos;\n        # 遍历dict,找到就返回value\n        for k,v in self.dict.items():\n            if v==index:\n                return k\n        # 否则返回不知道\n        return WordSequence.UNK_TAG\n\n    def size(self):\n        assert self.fited, &apos;WordSequence尚未进行fit操作&apos;\n        return len(self.dict) + 1\n\n    def __len__(self):\n        return self.size()\n\n    # 对数据进行处理\n    def fit(self,sentences,min_count=5,max_count=None,max_features=None):\n        assert not self.fited, &apos;WordSequence只能进行一次fit&apos;\n\n        count={}\n        # 遍历所有句子\n        for sentence in sentences:\n            arr=list(sentence)\n            # 统计词频\n            for a in arr:\n                if a not in count:\n                    count[a]=0\n                count[a]+=1\n        # 只统计词频大于最小值的\n        if min_count is not None:\n            count={k:v for k,v in count.items() if v&gt;=min_count}\n        # 仅统计词频小于最大值的\n        if max_count is not None:\n            count={k:v for k,v in count.items() if v&lt;=max_count}\n\n        # 如果有特征值数的限制,比如[1,2,3]max_features=2,则\n        # 需要用的是[1,2]\n        if isinstance(max_features,int):\n            # list(dict)=[(key,value),...]\n            count = sorted(list(count.items()),key=lambda x:x[1])\n            if max_features is not None and len(count) &gt; max_features:\n                count = count[-int(max_features):]# 从尾部向前\n            # 这个以及下面那个类似于前向星式存图法里的\n            # 下标递增式存法,即加入一个元素,该元素下标\n            # 变成当前已存在的元素个数\n            # 就是把count中的key作为dict的key\n            # 在dict中的下标作为dict的value\n            for w,_ in count:\n                self.dict[w]=len(self.dict)\n        else:\n            for w in sorted(count.keys()):\n                self.dict[w]=len(self.dict)\n\n        # 处理完成\n        self.fited=True\n\n    # 序列成数列\n    def transform(self, sentence, max_len=None):\n        assert self.fited, &apos;WordSequence尚未进行fit操作&apos;\n        # PAD -&gt; 填充标签,先填充本来的句子长度所有元素为PAD\n        # 如: [&apos;&lt;PAD&gt;&apos;,&apos;&lt;PAD&gt;&apos;...]\n        if max_len is not None:\n            r = [self.PAD] * max_len\n        else:\n            r = [self.PAD] * len(sentence)\n\n        for index, a in enumerate(sentence):\n            if max_len is not None and index &gt;= len(r):\n                break\n            r[index] = self.to_index(a)\n\n        return np.array(r)\n\n    # 序列转回字母\n    def inverse_transform(self, indices, ignore_pad=False, ignore_unk=False, ignore_start=False, ignore_end=False):\n        ret = []\n        for i in indices:\n            word = self.to_word(i)\n            if word == WordSequence.PAD_TAG and ignore_pad:\n                continue\n            if word == WordSequence.UNK_TAG and ignore_unk:\n                continue\n            if word == WordSequence.START_TAG and ignore_start:\n                continue\n            if word == WordSequence.END_TAG and ignore_end:\n                continue\n\n            ret.append(word)\n\n        return ret\n\n\ndef test():\n    ws = WordSequence()\n    ws.fit([[&apos;你&apos;, &apos;好&apos;, &apos;啊&apos;], [&apos;你&apos;, &apos;好&apos;, &apos;哦&apos;], ])\n\n    indice = ws.transform([&apos;我&apos;, &apos;们&apos;, &apos;好&apos;])\n    print(indice)\n\n    back = ws.inverse_transform(indice)\n    print(back)\n\n\nif __name__ == &apos;__main__&apos;:\n    test()</code></pre><blockquote>\n<p>可以发现其实都是一些简单的映射.将每个字符都映射到一个整数上面去.</p>\n<blockquote>\n<p>这样做以后再将其打包成pkl会大大减少占用硬盘: 83MB-&gt;750kb 了解一下</p>\n</blockquote>\n</blockquote>\n<h2 id=\"对于语料中句子的规范化\"><a href=\"#对于语料中句子的规范化\" class=\"headerlink\" title=\"对于语料中句子的规范化\"></a>对于语料中句子的规范化</h2><blockquote>\n<p>这里我们提供三个函数(可自行编码):</p>\n</blockquote>\n<pre><code># 这个函数的作用是在有多个回答的条件下将回答合并起来\ndef make_split(line):\n    if re.match(r&apos;.*([，···?!\\.,!？])$&apos;, &apos;&apos;.join(line)):\n        return []\n\n    return [&apos;, &apos;]\n\n# 是否是一个有意义的句子(这里我们不做规则)\ndef good_line(line):\n    #if len(re.findall(r&apos;[a-zA-Z0-9]&apos;, &apos;&apos;.join(line))) &gt; 2:\n        #return False\n    return True\n\n# 规范化语料,即对于已提取出的预料中的句子进行处理\ndef regular(sen):\n    #sen = re.sub(r&apos;\\.{3,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;···{2,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;[,]{1,100}&apos;, &apos;，&apos;, sen)\n    #sen = re.sub(r&apos;[\\.]{1,100}&apos;, &apos;。&apos;, sen)\n    #sen = re.sub(r&apos;[\\?]{1,100}&apos;, &apos;？&apos;, sen)\n    #sen = re.sub(r&apos;[!]{1,100}&apos;, &apos;！&apos;, sen)\n\n    return sen</code></pre><blockquote>\n<p>可以发现我基本都注释掉了,因为小黄鸡的语料库就是标准的一问一答,不是自然地语料库(微信随便提取的那类),所以不需要过多的处理.</p>\n</blockquote>\n<h2 id=\"打包成pkl文件\"><a href=\"#打包成pkl文件\" class=\"headerlink\" title=\"打包成pkl文件\"></a>打包成pkl文件</h2><blockquote>\n<p>首先说一下pkl文件:</p>\n<blockquote>\n<p>pkl文件是Python运行时产生的数据序列化后存储下来的文件格式,类似于其他语言的序列化.方便以后的继续使用和读取.</p>\n</blockquote>\n</blockquote>\n<p>具体的处理语料库和打包(一问一答Tuple)代码如下:</p>\n<pre><code># -*- coding:utf-8 -*-\n\nimport re\nimport pickle\nimport sys\nfrom tqdm import tqdm\n\n\ndef make_split(line):\n    if re.match(r&apos;.*([，···?!\\.,!？])$&apos;, &apos;&apos;.join(line)):\n        return []\n\n    return [&apos;, &apos;]\n\n# 是否是一个有意义的句子(这里我们不做规则)\ndef good_line(line):\n    #if len(re.findall(r&apos;[a-zA-Z0-9]&apos;, &apos;&apos;.join(line))) &gt; 2:\n        #return False\n    return True\n\n# 规范化语料\ndef regular(sen):\n    #sen = re.sub(r&apos;\\.{3,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;···{2,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;[,]{1,100}&apos;, &apos;，&apos;, sen)\n    #sen = re.sub(r&apos;[\\.]{1,100}&apos;, &apos;。&apos;, sen)\n    #sen = re.sub(r&apos;[\\?]{1,100}&apos;, &apos;？&apos;, sen)\n    #sen = re.sub(r&apos;[!]{1,100}&apos;, &apos;！&apos;, sen)\n\n    return sen\n\n# 这样设置的意思是无限制\ndef main(limit=99999, x_limit=1, y_limit=1):\n    from word_sequence import WordSequence\n    print(&apos;extract lines&apos;)\n    fp=open(&quot;xiaohuangji.conv&quot;,&apos;r&apos;,errors=&apos;ignore&apos;,encoding=&apos;utf-8&apos;)\n\n    groups=[]\n    group=[]\n\n    # 提取出所有问答组\n    for line in tqdm(fp):\n        if line.startswith(&apos;M &apos;):\n            line=line.replace(&apos;\\n&apos;,&apos;&apos;)\n            if &apos;/&apos; in line:\n                line = line[2:].split(&apos;/&apos;)\n            else:\n                line=list(line[2:])\n            line=line[:-1]\n\n            group.append(list(regular(&apos;&apos;.join(line))))\n        else:\n            if group:\n                groups.append(group)\n                group = []\n    if group:\n        groups.append(group)\n        group = []\n\n    print(&apos;extract group&apos;)\n\n    x_data = []\n    y_data = []\n    # 将问与答分开\n    for group in tqdm(groups):\n        for i,line in  enumerate(group):\n            last_line=None\n            # last_line是上一句\n            if i&gt;0:\n                last_line = group[i-1]\n                if not good_line(last_line):\n                    last_line = None\n            if i&lt;len(group)-1:\n                next_line=group[i+1]\n                if not good_line(next_line):\n                    next_line=None\n            # 如果有下一句\n            if not last_line:\n                x_data.append(line)\n                y_data.append(next_line)\n\n        #print(len(x_data), len(y_data))\n\n    print(len(x_data), len(y_data))\n    # 构建问答,测试前20个\n    for ask,answer in zip(x_data[:20],y_data[:20]):\n        print(&apos;&apos;.join(ask))\n        print(&apos;&apos;.join(answer))\n        print(&apos;-&apos; * 20)\n\n    # 生成pkl文件\n    data=list(zip(x_data,y_data))\n\n    data=[\n        (x,y) for x,y in data if limit&gt;len(x) &gt;=x_limit and limit &gt; len(y) &gt;= y_limit\n    ]\n\n    # 打包成pkl\n    x_data, y_data = zip(*data)\n    ws_input = WordSequence()\n    ws_input.fit(x_data + y_data)\n    print(&apos;dump&apos;)\n    pickle.dump(\n        (x_data, y_data), open(&apos;chatbot.pkl&apos;, &apos;wb&apos;))\n    pickle.dump(ws_input, open(&apos;ws.pkl&apos;, &apos;wb&apos;))\n    print(&apos;done&apos;)\n\nif __name__ == &apos;__main__&apos;:\n    main()</code></pre><h1 id=\"聊天室内核从0开始-–-3-Seq2Seq\"><a href=\"#聊天室内核从0开始-–-3-Seq2Seq\" class=\"headerlink\" title=\"聊天室内核从0开始 – 3 Seq2Seq\"></a>聊天室内核从0开始 – 3 Seq2Seq</h1><p><a href=\"http://be-sunshine.cn/index.php/2019/01/06/seq2seq/\" title=\"聊天室内核从0开始 – 3 Seq2Seq\" target=\"_blank\" rel=\"noopener\">聊天室内核从0开始 – 3 Seq2Seq</a></p>\n","text":"最后更新于2019/1/4处理语料库简单处理提问与应答这里我们本来可以用jieba或者其他的一些库来帮忙分词,但是因为网上存在已经分好词的语料库,所以可以省略这一步. 至于语料库,可以在github上直接搜索语料库即可以搜到. 一般语料库如下:EM 呵/呵M 是/王/若/猫/的/","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"聊天机器人内核","slug":"Python/聊天机器人内核","count":1,"path":"api/categories/Python/聊天机器人内核.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"聊天机器人内核","slug":"聊天机器人内核","count":3,"path":"api/tags/聊天机器人内核.json"}]},{"title":"聊天室内核从0开始 - 1 前置知识与NLP","slug":"type-2","date":"2019-01-01T13:02:42.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/type-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2019/01/1234352-13d969531284a9f9.png","content":"<blockquote>\n<p>最后更新于2019/1/6</p>\n</blockquote>\n<h1 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h1><h2 id=\"TensorFlow\"><a href=\"#TensorFlow\" class=\"headerlink\" title=\"TensorFlow\"></a>TensorFlow</h2><blockquote>\n<ol>\n<li>张量(Tensor)</li>\n<li>图(Flow-&gt;Graph)</li>\n<li>会话(Session)</li>\n</ol>\n</blockquote>\n<h3 id=\"张量-Tensor\"><a href=\"#张量-Tensor\" class=\"headerlink\" title=\"张量(Tensor)\"></a>张量(Tensor)</h3><blockquote>\n<p>类似于矩阵,一维的张量叫做向量</p>\n</blockquote>\n<h3 id=\"计算图-Graph\"><a href=\"#计算图-Graph\" class=\"headerlink\" title=\"计算图(Graph)\"></a>计算图(Graph)</h3><blockquote>\n<p>TensorFlow的计算图的组成和数据结构中的图不同.</p>\n<blockquote>\n<ol>\n<li>图的节点: op-&gt;即操作.</li>\n<li>图的边: 即数据流,此处的数据流就是上述张量.</li>\n</ol>\n</blockquote>\n</blockquote>\n<h3 id=\"会话-Session\"><a href=\"#会话-Session\" class=\"headerlink\" title=\"会话(Session)\"></a>会话(Session)</h3><blockquote>\n<p>在TensorFlow中,要想启动一个图的前提是要先创建一个会话,Ts所有对图的操作,都必须在会话中进行.</p>\n</blockquote>\n<h3 id=\"模型训练一般流程\"><a href=\"#模型训练一般流程\" class=\"headerlink\" title=\"模型训练一般流程\"></a>模型训练一般流程</h3><p>document.write(“graph TD\\nA(开始) –&gt; B(定义数据集)\\nB –&gt; C(定义模型)\\nC –&gt;D(编写并训练模型)\\nD –&gt;E(模型测试)\\n”);</p>\n<h2 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h2><h3 id=\"模拟机替代AVG\"><a href=\"#模拟机替代AVG\" class=\"headerlink\" title=\"模拟机替代AVG\"></a>模拟机替代AVG</h3><p>为了解决Android Studio使用AVG虚拟机时会导致内存占用过大的问题. 这里我们选用网易旗下的MuMu模拟器.</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>document.write(“graph TD\\nA(开启MuMu模拟器) –&gt; B(进入到MuMu根目录的上层目录)\\nB –&gt; C(找到vmonitorbin)\\nC –&gt;D(在cmd中进入到上述地址-先进入盘符)\\nD –&gt;E(输入adb_server.exe connect port-如7555)\\n”);</p>\n<p>注意:这个必须在Android Studio开启时连接才可以,如果出现Empty host name,多连接几次就可以了. 使用这个方法就可以有效减少内存的占用问题.</p>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><h3 id=\"神经网络相关学习视频\"><a href=\"#神经网络相关学习视频\" class=\"headerlink\" title=\"神经网络相关学习视频\"></a>神经网络相关学习视频</h3><p><a href=\"https://www.icourse163.org/learn/DA-1002183004?tid=1002301011#/learn/content\" target=\"_blank\" rel=\"noopener\">https://www.icourse163.org/learn/DA-1002183004?tid=1002301011#/learn/content</a> 因为其中涉及内容过多,且基础,故我在此仅讲解几个比较生疏难懂的概念,而不做展开,其基础推荐在学号高数和概率论以及线性代数这三门课程以后再进行展开(也可以不需要,但理解上会有些困难).</p>\n<h3 id=\"梯度下降\"><a href=\"#梯度下降\" class=\"headerlink\" title=\"梯度下降\"></a>梯度下降</h3><blockquote>\n<p>在了解梯度下降前你需要知道</p>\n<blockquote>\n<ol>\n<li>计算图的节点是简单的操作</li>\n<li>高数求导中的链式求导法</li>\n<li>既然它们的节点时简单的运算,那么就可以很方便地使用链式求导法则对其进行求导 &gt; 比如 Y=Z+b,Z=b+2 dY/db=dZ/db+d(b)/db</li>\n</ol>\n</blockquote>\n<p>则如下图所示 <img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/1234352-13d969531284a9f9.png\" alt> 计算图是正向传播的,而计算图中的反向计算梯度是反向计算的,即函数的上升方向. 故反向传播以后计算出来的梯度只需要取负即是梯度下降的方向了.</p>\n</blockquote>\n<p>以上基础知识熟悉以后可以看这篇文章: <a href=\"https://www.jianshu.com/p/c7e642877b0e\" title=\"深入浅出,梯度下降法及其实现\" target=\"_blank\" rel=\"noopener\">深入浅出,梯度下降法及其实现</a></p>\n<h3 id=\"向量化\"><a href=\"#向量化\" class=\"headerlink\" title=\"向量化\"></a>向量化</h3><blockquote>\n<p>这个不难理解,即计算图中数据流都是向量,大大缩短计算时间.</p>\n</blockquote>\n<h3 id=\"Python广播机制\"><a href=\"#Python广播机制\" class=\"headerlink\" title=\"Python广播机制\"></a>Python广播机制</h3><blockquote>\n<p>举几个例子吧,具体在实践中总结,或查阅相关DOC.</p>\n</blockquote>\n<pre><code>A = numpy.array([1,2,3])\nresult = A + 100\nprint(result)\n\n输出: [101 102 103]</code></pre><h3 id=\"激活函数\"><a href=\"#激活函数\" class=\"headerlink\" title=\"激活函数\"></a>激活函数</h3><blockquote>\n<p>计算图的每层节点将上一层的输出作为本层的输入,如果没有激活函数,那么最终的结果等效于F(x)=x即线性函数. 而激活函数则是在层与层间添加上一个激活函数,使之并不完全作为线性函数来传递数据(即进入什么数据,出来就一定是唯一结果) 即由激活函数判断是否输出</p>\n</blockquote>\n<h3 id=\"神经元模型-参考书籍-西瓜书\"><a href=\"#神经元模型-参考书籍-西瓜书\" class=\"headerlink\" title=\"神经元模型(参考书籍-西瓜书)\"></a>神经元模型(参考书籍-西瓜书)</h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/20180507224752660.png\" alt></p>\n<blockquote>\n<p>在生物神经网络中,，每个神经元与其他神经元相连,当它”兴奋”时,就会向相连的神经元发送化学物质,从而改变这些神经元内的电位,如果某神经元的电位超过一个”阈值”,那么他就会被激活,即”兴奋”起来,向其他神经元发送化学物质. 现在最常用的组成神经网络的节点神经元模型是M-P神经元模型.在这个模型中,神经元接收到来自其它n个神经元传递过来的输入信号,这些输入信号通过带权重的连接进行传递,神经元接收到的总输入值将与神经元的阈值进行比较,然后通过”激活函数”处理以产生神经元的输出.</p>\n</blockquote>\n<h3 id=\"神经网络分类\"><a href=\"#神经网络分类\" class=\"headerlink\" title=\"神经网络分类\"></a>神经网络分类</h3><blockquote>\n<p>大部分在上述的视频中都有系统介绍,这里我只做总结</p>\n</blockquote>\n<h4 id=\"感知机与深层神经网络\"><a href=\"#感知机与深层神经网络\" class=\"headerlink\" title=\"感知机与深层神经网络\"></a>感知机与深层神经网络</h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/p.png\" alt></p>\n<blockquote>\n<p>即 输入层 -&gt; 隐藏层 -&gt; 输出层</p>\n</blockquote>\n<h4 id=\"BP神经网络\"><a href=\"#BP神经网络\" class=\"headerlink\" title=\"BP神经网络\"></a>BP神经网络</h4><blockquote>\n<p>BP网络即前向传播+反向传播来更新偏置. 特点:</p>\n<blockquote>\n<p>1-可以通过逐层信息传递到最后的输出. 2-沿着一条直线计算,直到最后一层,求出计算结果. 3-包含输入层、输出层和隐藏层,其目的是实现从输入到输出的映射. 4-一般包含多层,并且层与层之间是全连接的,不存在同层和跨层连接.</p>\n</blockquote>\n</blockquote>\n<h4 id=\"循环神经网络RNN和LSTM\"><a href=\"#循环神经网络RNN和LSTM\" class=\"headerlink\" title=\"循环神经网络RNN和LSTM\"></a>循环神经网络RNN和LSTM</h4><blockquote>\n<p>这类计算图是针对于成序列的数据的.</p>\n<blockquote>\n<p>类似于造句,造音乐等.如果一个序列过长,则会导致可能在计算后面序列的时候将前面序列的影响变低.从而导致序列无法有效处理”长期依赖”的问题.</p>\n</blockquote>\n</blockquote>\n<h5 id=\"RNN\"><a href=\"#RNN\" class=\"headerlink\" title=\"RNN\"></a>RNN</h5><h6 id=\"前向传播\"><a href=\"#前向传播\" class=\"headerlink\" title=\"前向传播\"></a>前向传播</h6><blockquote>\n<p>普通的CNN模型即上述的神经网络模型,而NLP遵守的规则一般为对于一个句子的分析,每个单词的分析,如果采取上述的线性模型可能会导致语言没有一点逻辑,即 “我/爱/你” - 则针对我输出A,针对爱输出B,针对你输出C 得到结果ABC. 而RNN最大的特点在于其可记忆性.什么叫可记忆性呢?即上一个单词的结果要传递给下一层,使下一个单词运算出的结果可以结合上一个单词以及当前的单词一起得出最后的结果.</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/1042406-20170306142253375-175971779.png\" alt></p>\n<blockquote>\n<p>如上图,右侧是拆分后的RNN,x(i)代表的是第i个单词,而计算后的h(i)会传递给h(i+1),y(i)是由上一层计算出来的词向量. 数学公式表达为:</p>\n<blockquote>\n<p>h(i)=g(w*h(i-1)+w*x(i)+bh) g(激活函数)一般选为tanh/Relu y(i)=g(w*h(i)+by) g一般选择sigmod/softmax</p>\n</blockquote>\n<p>优化: 因为词向量的行是相同的,所以将列拼在一起即可.</p>\n<blockquote>\n<p>h(i)=g(w*[h(i-1),x(i)]+bh)</p>\n</blockquote>\n</blockquote>\n<h6 id=\"反向传播\"><a href=\"#反向传播\" class=\"headerlink\" title=\"反向传播\"></a>反向传播</h6><blockquote>\n<p>反向传播作用依然是：减少误差,计算lost函数. 用倒数来计算某一个节点队最终结果的影响程度.训练完后,取平均值(大概,这点我没太仔细看).</p>\n</blockquote>\n<p>一个比较通俗易懂的链接: <a href=\"https://blog.csdn.net/shaomingliang499/article/details/50587300\" title=\" 一步一步教你反向传播\" target=\"_blank\" rel=\"noopener\">一步一步教你反向传播</a></p>\n<h6 id=\"RNN的几种类型\"><a href=\"#RNN的几种类型\" class=\"headerlink\" title=\"RNN的几种类型\"></a>RNN的几种类型</h6><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/20180719232051968.jpg\" alt></p>\n<h5 id=\"LSTM\"><a href=\"#LSTM\" class=\"headerlink\" title=\"LSTM\"></a>LSTM</h5><blockquote>\n<p>再清楚了RNN以后,LSTM其实就是基于RNN的一个变种.</p>\n<blockquote>\n<p>因为RNN实际应用中无法解决长效记忆的问题,所以催生出了LSTM这一模型.放一个简单的视频可以看下.</p>\n</blockquote>\n<p><a href=\"https://www.bilibili.com/video/av15998549?from=search&seid=17651800282007333668\" title=\"什么是 LSTM RNN 循环神经网络 ?\" target=\"_blank\" rel=\"noopener\">什么是 LSTM RNN 循环神经网络 ?</a></p>\n</blockquote>\n<h2 id=\"NLP\"><a href=\"#NLP\" class=\"headerlink\" title=\"NLP\"></a>NLP</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>自然语言处理,探索如何处理及运用自然语言,即让电脑懂人类的语言. 包含文本分析、信息检索、词性标注、问答系统等.</p>\n</blockquote>\n<ol>\n<li><p>词法分析</p>\n<blockquote>\n<p>分词技术、词性标注(名词n,形容词a,副词d,人称代词rr,动词v…)、命名实体识别、词义消歧</p>\n</blockquote>\n</li>\n<li><p>句法分析</p>\n</li>\n<li><p>语义分析</p>\n</li>\n</ol>\n<h3 id=\"分词技术\"><a href=\"#分词技术\" class=\"headerlink\" title=\"分词技术\"></a>分词技术</h3><blockquote>\n<p>中科院分词系统(nlpir): <a href=\"http://ictclas.nlpir.org/nlpir/\" title=\"语义分词系统\" target=\"_blank\" rel=\"noopener\">中科院语义分词系统</a></p>\n</blockquote>\n<h3 id=\"命名实体识别\"><a href=\"#命名实体识别\" class=\"headerlink\" title=\"命名实体识别\"></a>命名实体识别</h3><blockquote>\n<p>即分词方法. 命名实体识别（Named Entity Recognition，简称NER），又称作“专名识别”，是指识别文本中具有特定意义的实体，主要包括人名、地名、机构名、专有名词等。 一般分为两种方法</p>\n<blockquote>\n<p>基于规则和词典的方法.</p>\n</blockquote>\n</blockquote>\n<p>document.write(“graph TD\\n\\nC(基于统计的方法)\\nC –&gt;D[隐马尔可夫模型]\\nC –&gt;E[较大熵]\\nC –&gt;F[支持向量机]\\nC –&gt;G[条件随机场]\\n”);</p>\n<h3 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h3><p>即概率论中的贝叶斯概型.</p>\n<blockquote>\n<p>在为序列定型中的用法:</p>\n<blockquote>\n<p>如: 分次以后判断每个单词是垃圾邮件的可能性大小,再用朴素贝叶斯计算出该邮件是垃圾邮件的概率.</p>\n</blockquote>\n</blockquote>\n<h3 id=\"马尔科夫过程\"><a href=\"#马尔科夫过程\" class=\"headerlink\" title=\"马尔科夫过程\"></a>马尔科夫过程</h3><blockquote>\n<p>其实我也没搞懂意义在哪~ (1)独立随机过程为马尔可夫过程。 (2)独立增量过程为马尔可夫过程：没{X(t)，t∈[0，+∞)}为一独立增量过程，且有P(X(0)=x0)=1，x0为常数，则X(t)为马尔可夫过程。 (3)泊松过程为马尔可夫过程。 (4)维纳过程为马尔可夫过程。 (5)质点随机游动过程为马尔可夫过程。 即下一时刻的状态只依赖于上一时刻,而与上一时刻以前无关.</p>\n</blockquote>\n<h3 id=\"语料的处理方法\"><a href=\"#语料的处理方法\" class=\"headerlink\" title=\"语料的处理方法\"></a>语料的处理方法</h3><ol>\n<li>数据清洗(去掉无意义的标签,url,符号等)</li>\n<li>分词、大小写转换、添加句首句尾、词性标注.</li>\n<li>统计词频、抽取文本特征、特征选择、计算特征权重、归一化</li>\n<li>划分训练集、测试集（先分几份,然后7-3划分）</li>\n</ol>\n<h1 id=\"聊天室内核从0开始-–-2-处理语料库\"><a href=\"#聊天室内核从0开始-–-2-处理语料库\" class=\"headerlink\" title=\"聊天室内核从0开始 – 2 处理语料库\"></a>聊天室内核从0开始 – 2 处理语料库</h1><p><a href=\"http://be-sunshine.cn/index.php/2019/01/04/type-3/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/04/type-3/</a></p>\n","text":"最后更新于2019/1/6前置知识TensorFlow张量(Tensor)图(Flow-&gt;Graph)会话(Session)张量(Tensor)类似于矩阵,一维的张量叫做向量计算图(Graph)TensorFlow的计算图的组成和数据结构中的图不同.图的节点: op-&gt","link":"","raw":null,"photos":[],"categories":[{"name":"Android","slug":"Android","count":5,"path":"api/categories/Android.json"},{"name":"NLP","slug":"Android/NLP","count":1,"path":"api/categories/Android/NLP.json"},{"name":"TensorFlow","slug":"Android/NLP/TensorFlow","count":1,"path":"api/categories/Android/NLP/TensorFlow.json"},{"name":"机器学习","slug":"Android/NLP/TensorFlow/机器学习","count":1,"path":"api/categories/Android/NLP/TensorFlow/机器学习.json"},{"name":"聊天机器人内核","slug":"Android/NLP/TensorFlow/机器学习/聊天机器人内核","count":1,"path":"api/categories/Android/NLP/TensorFlow/机器学习/聊天机器人内核.json"}],"tags":[{"name":"Android","slug":"Android","count":5,"path":"api/tags/Android.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"},{"name":"聊天机器人内核","slug":"聊天机器人内核","count":3,"path":"api/tags/聊天机器人内核.json"},{"name":"NLP","slug":"NLP","count":1,"path":"api/tags/NLP.json"},{"name":"TensorFlow","slug":"TensorFlow","count":1,"path":"api/tags/TensorFlow.json"}]},{"title":"聊天室架构从0开始 - 1 TCP&UDP问题","slug":"type-1","date":"2019-01-01T01:00:24.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/type-1.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/12/ServerSocket%E4%B8%8ESocket.png","content":"<blockquote>\n<p>最后更新于2019/1/1</p>\n</blockquote>\n<h1 id=\"课设过程中的记录\"><a href=\"#课设过程中的记录\" class=\"headerlink\" title=\"课设过程中的记录\"></a>课设过程中的记录</h1><h2 id=\"序言-tcp与udp的族谱\"><a href=\"#序言-tcp与udp的族谱\" class=\"headerlink\" title=\"序言 - tcp与udp的族谱\"></a>序言 - tcp与udp的族谱</h2><h3 id=\"借助工具-流式读取\"><a href=\"#借助工具-流式读取\" class=\"headerlink\" title=\"借助工具 - 流式读取\"></a>借助工具 - 流式读取</h3><p><a href=\"http://be-sunshine.cn/index.php/2018/06/21/javaweb-two/\" title=\"java流式读取\" target=\"_blank\" rel=\"noopener\">戳-&gt;java流式读取</a></p>\n<h3 id=\"简单tcp问题\"><a href=\"#简单tcp问题\" class=\"headerlink\" title=\"简单tcp问题\"></a>简单tcp问题</h3><p>因为要求服务端是无限接收客户端的请求,所以服务端必须用线程来新建和处理请求.</p>\n<h4 id=\"服务端代码\"><a href=\"#服务端代码\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h4><pre><code>import javax.print.DocFlavor;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.SQLTransactionRollbackException;\n\npublic class Server {\n    public static void main(String[] args)throws IOException {\n        //如果不指定端口号和ip地址,默认是本地\n        ServerSocket server=new ServerSocket(2019);\n        System.out.println(&quot;服务器准备就绪~&quot;);\n        System.out.println(&quot;服务器信息: &quot;+server.getInetAddress()+&quot; P:&quot;+server.getLocalPort() );\n\n        //等待客户端连接\n        while(true) {\n            //得到客户端\n            Socket client = server.accept();\n            //客户端构建异步线程\n            ClientHandler clientHandler = new ClientHandler(client);\n            //启动线程\n            clientHandler.start();\n        }\n    }\n\n    //处理多个请求时要用异步\n    private static class ClientHandler extends Thread{\n        private Socket socket;\n        private boolean flag=true;\n\n        ClientHandler(Socket socket){\n            this.socket=socket;\n        }\n\n        //运行时运行run\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;新客户端连接: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n            try{\n                //得到打印流,用于数据输出：服务器回送数据使用\n                PrintStream socketOutput=new PrintStream(socket.getOutputStream());\n                //得到输入流,用于接收数据\n                BufferedReader socketInput=new BufferedReader(new InputStreamReader(\n                        socket.getInputStream()));\n\n                do{\n                    String str=socketInput.readLine();\n                    //equalsIgnoreCase忽略大小写\n                    if(&quot;bye&quot;.equalsIgnoreCase(str)){\n                        flag=false;\n                        //回送\n                        socketOutput.println(&quot;bye&quot;);\n                    }else{\n                        System.out.println(str);\n                        socketOutput.println(&quot;回送： &quot;+ str.length());\n                    }\n                }while(flag);\n\n                socketInput.close();\n                socketOutput.close();\n            }catch(Exception e){\n                System.out.println(&quot;连接异常断开&quot;);\n            }finally {\n                //连接关闭(每个线程)\n                try{\n                    socket.close();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(&quot;客户端已退出: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n        }\n    }\n}</code></pre><h4 id=\"客户端代码\"><a href=\"#客户端代码\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h4><pre><code>import java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class Client {\n    public static void main(String[] args)throws IOException {\n        Socket socket=new Socket();\n        ///超时时间\n        socket.setSoTimeout(3000);\n        //连接本地,端口2000,超时时间3000ms\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),2019),3000);\n        System.out.println(&quot;已发起服务器连接,并进入后续流程~&quot;);\n        System.out.println(&quot;客户端信息: &quot;+socket.getLocalAddress()+&quot; P:&quot;+socket.getLocalPort());\n        System.out.println(&quot;服务器信息: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort() );\n\n        try{\n            //发送接收数据\n            todo(socket);\n        }catch(Exception e){\n            System.out.println(&quot;异常关闭&quot;);\n        }\n        //释放资源\n        socket.close();\n        System.out.println(&quot;客户端已关闭&quot;);\n    }\n\n    private static void todo(Socket client) throws IOException{\n        //构建键盘输入流\n        InputStream in=System.in;\n        BufferedReader  input=new BufferedReader(new InputStreamReader(in));\n\n        //得到Socket输出流,并转换为打印流\n        OutputStream output=client.getOutputStream();\n        PrintStream socketPrintStream=new PrintStream(output);\n\n        //得到Socket输入流,并转换为BufferedReader\n        InputStream inputStream=client.getInputStream();\n        BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n        boolean flag=true;\n        do{\n            //键盘读一行\n            String str=input.readLine();\n            //发送到服务器\n            socketPrintStream.println(str);\n\n            //从服务器读取一行\n            String echo=socketBufferedReader.readLine();\n            if(&quot;bye&quot;.equalsIgnoreCase(echo)){\n                flag=false;\n            }else{\n                System.out.println(echo);\n            }\n        }while(flag);\n\n        //关闭全部流,资源释放\n        socketBufferedReader.close();\n        socketPrintStream.close();\n        input.close();\n    }\n}</code></pre><h3 id=\"常见协议端口号\"><a href=\"#常见协议端口号\" class=\"headerlink\" title=\"常见协议端口号\"></a>常见协议端口号</h3><p>协议</p>\n<p>端口</p>\n<p>TCP or UDP</p>\n<p>FTP</p>\n<p>20,21</p>\n<p>TCP</p>\n<p>SSH</p>\n<p>22</p>\n<p>TCP</p>\n<p>Telnet</p>\n<p>23</p>\n<p>TCP</p>\n<p>SMTP</p>\n<p>25</p>\n<p>TCP</p>\n<p>DNS</p>\n<p>53</p>\n<p>UDP</p>\n<p>TFTP</p>\n<p>69</p>\n<p>UDP</p>\n<p>HTTP</p>\n<p>80</p>\n<p>TCP</p>\n<p>POP3</p>\n<p>110</p>\n<p>TCP</p>\n<p>IMAP4</p>\n<p>143</p>\n<p>TCP</p>\n<p>HTTPS</p>\n<p>443</p>\n<p>TCP</p>\n<p>其中49152~65535号端口属于动态端口,没有端口可以被正式注册.</p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>UDP是不可靠连接的协议,它的结构简单,不保留数据备份,无校验,速度快,容易丢包,可广播. 自身协议占用64位. 0-15(2个字节,短整型):发送源ip 16-31：接收源ip 32-47:长度 48-64:校验字段和header 其余均为data域: 最大的数据长度为65507 Bite,超过的要自行分包.</p>\n<h4 id=\"UDP能做什么\"><a href=\"#UDP能做什么\" class=\"headerlink\" title=\"UDP能做什么?\"></a>UDP能做什么?</h4><ol>\n<li>解析ip时的DNS就是依赖于UDP,以及TFTP,SNMP</li>\n<li>视频,音频,普通数据(无关紧要的数据),但若下载时用的是tcp</li>\n</ol>\n<h4 id=\"UDP-核心API\"><a href=\"#UDP-核心API\" class=\"headerlink\" title=\"UDP 核心API\"></a>UDP 核心API</h4><ol>\n<li>UDP并未合并到Socket核心包中.</li>\n</ol>\n<p>API</p>\n<p>作用</p>\n<p>DatagramSocket()</p>\n<p>创建简单实例,不指定端口和ip</p>\n<p>DatagramSocket(int port)</p>\n<p>创建监听某端口实例</p>\n<p>DatagramSocket(int port，InetAddress localAddr)</p>\n<p>创建固定端口指定ip的实例</p>\n<p>receive(DatagramPacket d)</p>\n<p>继续DatagramPacket后-接收</p>\n<p>sent(DatagramPacket d)</p>\n<p>继续DatagramPacket后-发送</p>\n<p>setSoTimeout(int timeout)</p>\n<p>设置传输/监听时超时时间,毫秒</p>\n<p>close()</p>\n<p>关闭,释放资源</p>\n<p>DatagramPacket(byte[] buf,int offset,int length,InetAddress address,int port)</p>\n<p>用于处理报文,拆包,封包,是发送/接收实体 - byte数组，可用区间(offset,length),接收者(发送时有效)地址(address,port)</p>\n<p>DatagramPacket(byte[] buf,int length,SocketAddress address)</p>\n<p>用Socket封装</p>\n<p>setData(byte[] buf,int offset,int length)</p>\n<p>DatagramPacket.setData构造一,指定偏移</p>\n<p>setData(byte[] buf)</p>\n<p>DatagramPacket无偏移</p>\n<p>setLength(int length)</p>\n<p>DatagramPacket单独指定长度</p>\n<p>getData(),getOffset(),getLength()</p>\n<p>DatagramPacket获取信息</p>\n<p>setAddress(InetAddress address),setPort(int iport)</p>\n<p>DatagramPacket指定发送时接收端ip</p>\n<p>setSocketAddress(SocketAddress address)</p>\n<p>DatagramPacket指定封装ip端口后的SocketAddress</p>\n<p>get…()</p>\n<p>DatagramPacket获取这些信息</p>\n<h4 id=\"单播-广播和多播\"><a href=\"#单播-广播和多播\" class=\"headerlink\" title=\"单播,广播和多播\"></a>单播,广播和多播</h4><ol>\n<li>单播: 将信息传给单点，两者间</li>\n<li>多播(组播): 给一组设备发送</li>\n<li>广播: 给所有设备(同一网段)发送</li>\n</ol>\n<h4 id=\"UDP点对点\"><a href=\"#UDP点对点\" class=\"headerlink\" title=\"UDP点对点\"></a>UDP点对点</h4><h5 id=\"服务提供方代码\"><a href=\"#服务提供方代码\" class=\"headerlink\" title=\"服务提供方代码\"></a>服务提供方代码</h5><pre><code>import javax.xml.crypto.Data;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\n/*\n UDP 服务提供方\n */\npublic class UDPProvider {\n    public static void main(String[] args)throws IOException {\n        System.out.println(&quot;Provider Started.&quot;);\n\n        //作为接受者,制定一个端口用于数据接收\n        DatagramSocket ds=new DatagramSocket(20000);\n\n        //构建接收实体\n        final byte[] buf=new byte[512];\n        DatagramPacket receivePack=new DatagramPacket(buf,buf.length);\n\n        //接收\n        ds.receive(receivePack);\n\n        //打印接收到的信息与发送者的信息\n        //发送端ip地址\n        String ip=receivePack.getAddress().getHostAddress();\n        int port=receivePack.getPort();\n        int dataLen=receivePack.getLength();\n        String data=new String(receivePack.getData(),0,dataLen);\n        System.out.println(&quot;UDPProvider receive from ip:&quot;+ip+&quot;\\tport:&quot;+port+&quot;\\tdata:&quot;+data);\n\n        //构建一份回送数据\n        String responseData=&quot;Receive data with len：&quot;+dataLen;\n        byte[] responseDataBytes=responseData.getBytes();\n        //直接根据发送者构建一份回送信息\n        DatagramPacket responsePacket= new DatagramPacket(responseDataBytes,responseDataBytes.length,receivePack.getAddress(),receivePack.getPort());\n        ds.send(responsePacket);\n\n        //完成\n        System.out.println(&quot;UDPProvider Finished.&quot;);\n        ds.close();\n    }\n}</code></pre><h5 id=\"服务请求方代码\"><a href=\"#服务请求方代码\" class=\"headerlink\" title=\"服务请求方代码\"></a>服务请求方代码</h5><pre><code>import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\n/*\n    UDP搜索者,用于搜索服务支持方\n */\npublic class UDPSearcher {\n    public static void main(String[] args)throws IOException {\n        System.out.println(&quot;UDPSearcher Started.&quot;);\n\n        //作为搜索方,系统直接分配端口\n        DatagramSocket ds=new DatagramSocket();\n\n        //构建一份请求数据\n        String requestData=&quot;HelloWorld&quot;;\n        byte[] requestDataBytes=requestData.getBytes();\n        //直接根据构建一份请求信息\n        DatagramPacket requestPacket= new DatagramPacket(requestDataBytes,requestDataBytes.length);\n        requestPacket.setAddress(InetAddress.getLocalHost());\n        requestPacket.setPort(20000);\n\n        ds.send(requestPacket);\n\n        //构建接收实体\n        final byte[] buf=new byte[512];\n        DatagramPacket receivePack=new DatagramPacket(buf,buf.length);\n\n        //接收\n        ds.receive(receivePack);\n\n        //打印接收到的信息与发送者的信息\n        //发送端ip地址\n        String ip=receivePack.getAddress().getHostAddress();\n        int port=receivePack.getPort();\n        int dataLen=receivePack.getLength();\n        String data=new String(receivePack.getData(),0,dataLen);\n        System.out.println(&quot;UDPSearcher receive from ip:&quot;+ip+&quot;\\tport:&quot;+port+&quot;\\tdata:&quot;+data);\n\n\n        //完成\n        System.out.println(&quot;UDPSearcher Finished.&quot;);\n        ds.close();\n    }\n}</code></pre><h4 id=\"UDP广播\"><a href=\"#UDP广播\" class=\"headerlink\" title=\"UDP广播\"></a>UDP广播</h4><h5 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h5><ol>\n<li>线程中的CountDownLatch异步通知外部.</li>\n<li>线程关闭</li>\n<li>局域网广播地址255.255.255.255</li>\n<li>唯一标识库 UUID</li>\n<li>字符串处理API （startsWith(String),substring(length)）</li>\n<li>DatagramSocket和DatagramPacket</li>\n</ol>\n<h5 id=\"简单架构\"><a href=\"#简单架构\" class=\"headerlink\" title=\"简单架构\"></a>简单架构</h5><ol>\n<li>无论客户端还是服务端,在发送前首先要保证自己的监听时开启的,否则可能因为指令优化导致先发送而却无法接收.</li>\n<li>搜索端用内部类建立Device来保存设备数据.</li>\n<li>搜索端用CountDownLatch来通知监听器该请求已成功.</li>\n<li>搜索端和客户端共用一个MessageCreator类来解析互传的消息.</li>\n<li>DatapramSocket是监听端口,DatapramPacket是封装/拆封报文.</li>\n</ol>\n<h5 id=\"解析信息代码\"><a href=\"#解析信息代码\" class=\"headerlink\" title=\"解析信息代码\"></a>解析信息代码</h5><pre><code>import org.omg.CORBA.INTERNAL;\n\npublic class MessageCreator{\n    private static final String SN_HEADER = &quot;收到暗号,我是(SN): &quot;;\n    private static final String PORT_HEADER=&quot;这是暗号,请回电端口(Port)&quot;;\n\n    public static String buildWithPort(int port){\n        return PORT_HEADER+port;\n    }\n\n    public static int parsePort(String data){\n        if(data.startsWith(PORT_HEADER)){\n            return Integer.parseInt(data.substring(PORT_HEADER.length()));\n        }\n        return -1;\n    }\n\n    public static String buildWithSN(String SN){\n        return SN_HEADER+SN;\n    }\n\n    public static String parseSN(String data){\n        if(data.startsWith(SN_HEADER)){\n            return data.substring(PORT_HEADER.length());\n        }\n        return null;\n    }\n}</code></pre><h5 id=\"服务提供端代码\"><a href=\"#服务提供端代码\" class=\"headerlink\" title=\"服务提供端代码\"></a>服务提供端代码</h5><pre><code>import javax.xml.crypto.Data;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.util.UUID;\n\n/*\n UDP 服务提供方\n */\npublic class UDPProvider {\n    public static void main(String[] args)throws IOException {\n        //生成一份唯一标识\n        String sn= UUID.randomUUID().toString();\n        //开启监听\n        Provider provider=new Provider(sn);\n        provider.start();\n\n        //本地读取任意键盘信息后可以退出\n        System.in.read();\n        provider.exit();\n    }\n\n    private static class Provider extends Thread{\n        private final String sn;\n        private boolean done=false;\n        private DatagramSocket ds=null;\n        public Provider(String sn){\n            super();\n            this.sn=sn;\n        }\n\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;Provider Started.&quot;);\n            try {\n                //作为接受者,制定一个端口用于监听数据接收\n                ds = new DatagramSocket(20000);\n\n                while (!done) {\n                    //构建接收实体\n                    final byte[] buf = new byte[512];\n                    DatagramPacket receivePack = new DatagramPacket(buf, buf.length);\n\n                    //接收\n                    ds.receive(receivePack);\n\n                    //打印接收到的信息与发送者的信息\n                    //发送端ip地址\n                    String ip = receivePack.getAddress().getHostAddress();\n                    int port = receivePack.getPort();\n                    int dataLen = receivePack.getLength();\n                    String data = new String(receivePack.getData(), 0, dataLen);\n                    System.out.println(&quot;UDPProvider receive from ip:&quot; + ip + &quot;\\tport:&quot; + port + &quot;\\tdata:&quot; + data);\n\n                    //解析回送端口号\n                    int responsePort = MessageCreator.parsePort(data);\n                    if(responsePort !=-1) {\n                        //构建一份回送数据\n                        String responseData = MessageCreator.buildWithSN(sn);\n                        byte[] responseDataBytes = responseData.getBytes();\n                        //直接根据发送者构建一份回送信息,发送到指定Port上去,并附上口令sn\n                        DatagramPacket responsePacket =\n                                new DatagramPacket(responseDataBytes,\n                                responseDataBytes.length,\n                                receivePack.getAddress(),\n                                responsePort);\n                        ds.send(responsePacket);\n                    }\n\n                }\n            }catch (Exception ignore){\n            }finally {\n                //done退出后阻塞异常到这里再判断一次是否需要退出\n                close();\n            }\n            //完成\n            System.out.println(&quot;UDPProvider Finished.&quot;);\n        }\n\n        private void close(){\n            if(ds!=null){\n                ds.close();\n                ds=null;\n            }\n        }\n\n        ///提供随时停止的方法\n        void exit(){\n            done=true;\n            close();\n        }\n    }\n}</code></pre><h5 id=\"客户搜索端代码\"><a href=\"#客户搜索端代码\" class=\"headerlink\" title=\"客户搜索端代码\"></a>客户搜索端代码</h5><pre><code>import java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n/*\n    UDP搜索者,用于搜索服务支持方\n */\npublic class UDPSearcher {\n    //监听端口\n    private static final int LISTEN_PORT=30000;\n\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        System.out.println(&quot;UDPSearcher Started.&quot;);\n\n        Listener listener=listen();\n        sendBroadcast();\n\n        //本地读取任意键盘信息后可以退出\n        System.in.read();\n        List&lt;Device&gt; devices=listener.getDevicesAndClose();\n        for (Device device: devices) {\n            System.out.println(&quot;Device:&quot; + device.toString());\n        }\n\n        System.out.println(&quot;完成&quot;);\n    }\n\n    //用于监听请求服务端后的回发\n    private static  Listener listen() throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(1);\n        Listener listener=new Listener(LISTEN_PORT,countDownLatch);\n        listener.start();\n\n        //执行countdownlatch.countdown()后await释放\n        countDownLatch.await();\n        return listener;\n    }\n\n    //广播\n    private static void sendBroadcast() throws IOException {\n        System.out.println(&quot;UDPSearcher sendBroadcast Started.&quot;);\n\n        //作为搜索方,系统直接分配端口\n        DatagramSocket ds=new DatagramSocket();\n\n        //构建一份请求数据\n        String requestData=MessageCreator.buildWithPort(LISTEN_PORT);\n        byte[] requestDataBytes=requestData.getBytes();\n        //直接根据构建一份请求信息\n        DatagramPacket requestPacket= new DatagramPacket(requestDataBytes,\n                requestDataBytes.length);\n        requestPacket.setAddress(InetAddress.getByName(&quot;255.255.255.255&quot;));\n        requestPacket.setPort(20000);\n\n        ds.send(requestPacket);\n        ds.close();\n        System.out.println(&quot;发送已完成.&quot;);\n    }\n\n    public static class Device{\n        ///必须要\n        final int port;\n        final String ip;\n        final String sn;\n        public Device(int port, String ip, String sn) {\n            this.port = port;\n            this.ip = ip;\n            this.sn = sn;\n        }\n\n        @Override\n        public String toString() {\n            return &quot;Device{&quot; +\n                    &quot;port=&quot; + port +\n                    &quot;, ip=&apos;&quot; + ip + &apos;\\&apos;&apos; +\n                    &quot;, sn=&apos;&quot; + sn + &apos;\\&apos;&apos; +\n                    &apos;}&apos;;\n        }\n    }\n\n    private static class Listener extends Thread{\n        private final int listenPort;\n        //用CountDownLatch通知外部已启动\n        private final CountDownLatch countDownLatch;\n        private final List&lt;Device&gt; devices=new ArrayList&lt;&gt;();\n        private boolean done=false;\n        private DatagramSocket ds=null;\n\n        public Listener(int listenPort,CountDownLatch countDownLatch){\n            super();\n            this.listenPort=listenPort;\n            this.countDownLatch=countDownLatch;\n        }\n        @Override\n        public void run(){\n            super.run();\n\n            //通知已启动\n            countDownLatch.countDown();\n            try{\n                //监听端口\n                ds=new DatagramSocket(listenPort);\n                while(!done) {\n                    //构建接收实体\n                    final byte[] buf = new byte[512];\n                    DatagramPacket receivePack = new DatagramPacket(buf, buf.length);\n\n                    //接收\n                    ds.receive(receivePack);\n\n                    //打印接收到的信息与发送者的信息\n                    //发送端ip地址\n                    String ip = receivePack.getAddress().getHostAddress();\n                    int port = receivePack.getPort();\n                    int dataLen = receivePack.getLength();\n                    String data = new String(receivePack.getData(), 0, dataLen);\n                    System.out.println(&quot;UDPSearcher receive from ip:&quot; + ip + &quot;\\tport:&quot; + port + &quot;\\tdata:&quot; + data);\n\n                    String sn=MessageCreator.parseSN(data);\n                    if(sn!=null){\n                        Device device=new Device(port,ip,sn);\n                        devices.add(device);\n                    }\n                }\n            }catch(Exception ignore){\n\n            }finally {\n                close();\n            }\n            System.out.println(&quot;UDPSearcher listener finished&quot;);\n        }\n\n        private void close(){\n            if(ds!=null){\n                ds.close();\n                ds=null;\n            }\n        }\n\n        List&lt;Device&gt; getDevicesAndClose(){\n            done=true;\n            close();\n            return devices;\n        }\n    }\n\n}</code></pre><h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>tcp是传输控制协议,是一种面向连接,可靠的,基于字节流的传输曾通信协议. 区别于UDP: udp基于数字报,不可靠. 相同: 完成第四层所指定的职责.</p>\n<h4 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h4><ol>\n<li>三次握手、四次挥手</li>\n<li>具有校验机制、可靠、数据传输稳定</li>\n<li>建立连接后,传递字节流数据</li>\n</ol>\n<h4 id=\"TCP能做什么\"><a href=\"#TCP能做什么\" class=\"headerlink\" title=\"TCP能做什么?\"></a>TCP能做什么?</h4><ol>\n<li>聊天消息传输、推送</li>\n<li>单人语音、视频聊天(信息要求完全准确用tcp)</li>\n<li>几乎udp可以做的tcp都可以做,只不过需要考虑复杂性和心跟那个问题</li>\n<li>限制: 无法进行广播,多播</li>\n</ol>\n<h4 id=\"TCP核心API\"><a href=\"#TCP核心API\" class=\"headerlink\" title=\"TCP核心API\"></a>TCP核心API</h4><p>API</p>\n<p>功能</p>\n<p>socket()</p>\n<p>创建一个socket</p>\n<p>bind()</p>\n<p>绑定一个Socket到一个本地地址和端口上</p>\n<p>connect()</p>\n<p>连接到远程套接字</p>\n<p>accept()</p>\n<p>接受一个新的连接,调用该方法时,服务端会进入阻塞状态,直到有一个套接字到达</p>\n<p>write()</p>\n<p>把数据写入到Socket输出流</p>\n<p>read()</p>\n<p>从Socket输入流中读取数据</p>\n<h4 id=\"创建流程\"><a href=\"#创建流程\" class=\"headerlink\" title=\"创建流程\"></a>创建流程</h4><h5 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h5><ol>\n<li>创建 Socket</li>\n<li>bind本地套接字(占用一个端口)</li>\n<li>connect远程套接字(成功)</li>\n<li>客户端与远程套接字通信</li>\n</ol>\n<h5 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h5><ol>\n<li>创建 SeverSocket</li>\n<li>bind本地套接字(占用一个端口)</li>\n<li>connect客户端套接字(成功)</li>\n<li>客户端与远程套接字通信</li>\n</ol>\n<h4 id=\"Socket也可以创建进程与进程间通信\"><a href=\"#Socket也可以创建进程与进程间通信\" class=\"headerlink\" title=\"Socket也可以创建进程与进程间通信\"></a>Socket也可以创建进程与进程间通信</h4><h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h4><ol>\n<li>客户端发起的(SYN 连接请求)</li>\n<li>服务端回送ACK</li>\n<li>匹配成功,客户端在发送给服务端一个ACK</li>\n</ol>\n<h4 id=\"四次挥手-断开\"><a href=\"#四次挥手-断开\" class=\"headerlink\" title=\"四次挥手(断开)\"></a>四次挥手(断开)</h4><p>FIN是申请结束字段. 1. 客户端发送: FIN=1,seq=u 2. 服务端发送: ACK=1,seq=v,ack=u+1 这之后因为可能会有一些信息还未发送完毕,所以需要发送完再进行断开确认.</p>\n<ol start=\"3\">\n<li>服务端发送: FIN=1,ACK=1,seq=w,ack=u+1</li>\n<li>客户端发送: ACK=1,seq=u+1,ack=w+1</li>\n</ol>\n<h4 id=\"前置知识-1\"><a href=\"#前置知识-1\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h4><h5 id=\"客户端-1\"><a href=\"#客户端-1\" class=\"headerlink\" title=\"客户端\"></a>客户端</h5><h6 id=\"Nagle算法\"><a href=\"#Nagle算法\" class=\"headerlink\" title=\"Nagle算法\"></a>Nagle算法</h6><p>当我们在发送报文时,如果报文是成块的发送,那么对报文的利用率将会很高,但如果是一小段一小段的发送的话,对于当前tcp的链接将会是很低效的,因为每次都需要额外处理的开销. 而Nagle算法就是为了解决小包的问题.</p>\n<blockquote>\n<p>其核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送</p>\n</blockquote>\n<h6 id=\"心跳包\"><a href=\"#心跳包\" class=\"headerlink\" title=\"心跳包\"></a>心跳包</h6><blockquote>\n<p>人活着的证明之一是心跳依然在跳动,心跳包就是用于判断在长时间无活动的前提下连接是否已断开.</p>\n<blockquote>\n<p>socket.setKeepAlive(true)</p>\n</blockquote>\n</blockquote>\n<h6 id=\"连接关闭缓冲\"><a href=\"#连接关闭缓冲\" class=\"headerlink\" title=\"连接关闭缓冲\"></a>连接关闭缓冲</h6><blockquote>\n<p>在两端连接执行关闭操作前必须要保证两端数据已经传输完成. 如果没有传输完成就关闭大概率会导致数据异常,而socket库对于关闭有三种方式.（内置于socket.setSoLinger()函数中）</p>\n<blockquote>\n<ol>\n<li>socket.setSoLinger(false,0) 关闭时立即返回,底层系统接管出输出流,将缓冲区内数据发送完全.</li>\n<li>true,0:关闭时立即返回,抛弃缓冲区数据,直接发送RST结束命令到对方</li>\n<li>true,200: 关闭后等待200ms,然后按第二种方式处理.</li>\n</ol>\n</blockquote>\n</blockquote>\n<h6 id=\"紧急数据内敛\"><a href=\"#紧急数据内敛\" class=\"headerlink\" title=\"紧急数据内敛\"></a>紧急数据内敛</h6><blockquote>\n<p>将某一块数据的优先级提至最高,一般不需要</p>\n<blockquote>\n<p>socket.setOOBInline(true) (默认false)</p>\n</blockquote>\n</blockquote>\n<h6 id=\"设置缓冲区大小\"><a href=\"#设置缓冲区大小\" class=\"headerlink\" title=\"设置缓冲区大小\"></a>设置缓冲区大小</h6><blockquote>\n<p>1024是1kb,1024*1024是1mb</p>\n<blockquote>\n<p>加快速度可以用 data &lt;&lt; 10 代表1kb</p>\n<blockquote>\n<p>socket.setReceiveBufferSize(64 * 1024 * 1024); 接受缓冲区 socket.setSendBufferSize(64 * 1024 * 1024); 发送缓冲区</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h6 id=\"设置性能参数\"><a href=\"#设置性能参数\" class=\"headerlink\" title=\"设置性能参数\"></a>设置性能参数</h6><blockquote>\n<p>短链接，延迟，带宽的相对重要性</p>\n<blockquote>\n<p>socket.setPerformancePreferences(1, 1, 0); 其中这三个参数代表的是权重占比,无实际意义.</p>\n</blockquote>\n</blockquote>\n<h6 id=\"几种不同的套接字参数\"><a href=\"#几种不同的套接字参数\" class=\"headerlink\" title=\"几种不同的套接字参数\"></a>几种不同的套接字参数</h6><pre><code>// 无代理模式，等效于空构造函数\nSocket socket = new Socket(Proxy.NO_PROXY);\n\n// 新建一份具有HTTP代理的套接字，传输数据将通过www.baidu.com:8080端口转发\nProxy proxy = new Proxy(Proxy.Type.HTTP,\n        new InetSocketAddress(Inet4Address.getByName(&quot;www.baidu.com&quot;), 8800));\nsocket = new Socket(proxy);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上\nsocket = new Socket(&quot;localhost&quot;, PORT);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上\nsocket = new Socket(Inet4Address.getLocalHost(), PORT);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上，并且绑定到本地20001端口上\nsocket = new Socket(&quot;localhost&quot;, PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\nsocket = new Socket(Inet4Address.getLocalHost(), PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n\nSocket socket = new Socket();\n// 绑定到本地20001端口\nsocket.bind(new InetSocketAddress(Inet4Address.getLocalHost(), LOCAL_PORT));</code></pre><h6 id=\"连接数据的流式操作\"><a href=\"#连接数据的流式操作\" class=\"headerlink\" title=\"连接数据的流式操作\"></a>连接数据的流式操作</h6><blockquote>\n<p>我仅用一串代码表示,但经过事实证明,各类型数据在ByteBuffer这个NIO库下只能传输一个数据,多了的话就会出现数据紊乱.除非用字符串传送.</p>\n</blockquote>\n<pre><code>//得到Socket输出流,并转换为打印流\n   OutputStream outputStream=client.getOutputStream();\n\n   //得到Socket输入流,并用ByteBuffer包裹起来\n   InputStream inputStream=client.getInputStream();\n   byte[] buffer=new byte[256];\n   ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n   // byte\n   byteBuffer.put((byte) 126);\n\n   // char\n   char c = &apos;a&apos;;\n   byteBuffer.putChar(c);\n\n   // int\n   int i = 2323123;\n   byteBuffer.putInt(i);\n\n   // bool\n   boolean b = true;\n   byteBuffer.put(b ? (byte) 1 : (byte) 0);\n\n   // Long\n   long l = 298789739;\n   byteBuffer.putLong(l);\n\n\n   // float\n   float f = 12.345f;\n   byteBuffer.putFloat(f);\n\n\n   // double\n   double d = 13.31241248782973;\n   byteBuffer.putDouble(d);\n\n   // String\n   String str = &quot;Hello你好！&quot;;\n   byteBuffer.put(str.getBytes());\n\n   //发送到服务器\n   outputStream.write(buffer,0,byteBuffer.position()+1);\n\n   //接受服务器返回\n   int read=inputStream.read(buffer);\n   System.out.println(&quot;收到数量: &quot;+read);\n\n   //资源释放\n   outputStream.close();\n   inputStream.close();</code></pre><h5 id=\"服务端-1\"><a href=\"#服务端-1\" class=\"headerlink\" title=\"服务端\"></a>服务端</h5><h6 id=\"ServerSocket\"><a href=\"#ServerSocket\" class=\"headerlink\" title=\"ServerSocket\"></a>ServerSocket</h6><blockquote>\n<p>对于服务端的Socket,为何要用ServerSocket?因为不一定只有一个客户端啊,课本部分会有一大堆Socket传过来啊,所以ServerSocket其实是用来处理多个Socket用的，最后仍然要回归到处理Socket</p>\n</blockquote>\n<h6 id=\"ServerSocket-与-Socket的关系\"><a href=\"#ServerSocket-与-Socket的关系\" class=\"headerlink\" title=\"ServerSocket 与 Socket的关系\"></a>ServerSocket 与 Socket的关系</h6><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/12/ServerSocket%E4%B8%8ESocket.png\" alt></p>\n<h6 id=\"ServerSocket配置\"><a href=\"#ServerSocket配置\" class=\"headerlink\" title=\"ServerSocket配置\"></a>ServerSocket配置</h6><pre><code>ServerSocket serverSocket=new ServerSocket();\n// 绑定到本地端口20000上，并且设置当前可允许等待链接的队列为50个\n//serverSocket = new ServerSocket(PORT);\n\n// 等效于上面的方案，队列设置为50个\n//serverSocket = new ServerSocket(PORT, 50);\n\n// 与上面等同\n// serverSocket = new ServerSocket(PORT, 50, Inet4Address.getLocalHost());\n// 是否复用未完全关闭的地址端口\nserverSocket.setReuseAddress(true);\n\n// 等效Socket#setReceiveBufferSize\nserverSocket.setReceiveBufferSize(64 * 1024 * 1024);\n\n// 设置serverSocket#accept超时时间\n// serverSocket.setSoTimeout(2000);\n\n// 设置性能参数：短链接，延迟，带宽的相对重要性\nserverSocket.setPerformancePreferences(1, 1, 1);</code></pre><h4 id=\"服务端代码-1\"><a href=\"#服务端代码-1\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h4><pre><code>import org.omg.CORBA.PRIVATE_MEMBER;\n\nimport javax.print.DocFlavor;\nimport java.io.*;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.sql.SQLTransactionRollbackException;\n\npublic class Server {\n    private static final int PORT=20000;\n    public static void main(String[] args)throws IOException {\n        //如果不指定端口号和ip地址,默认是本地\n        ServerSocket server=createServerSocket();\n\n        initServerSocket(server);\n\n        server.bind(new InetSocketAddress(Inet4Address.getLocalHost(),PORT),50);\n\n        System.out.println(&quot;服务器准备就绪~&quot;);\n        System.out.println(&quot;服务器信息: &quot;+server.getInetAddress()+&quot; P:&quot;+server.getLocalPort() );\n\n        //等待客户端连接\n        while(true) {\n            //得到客户端\n            Socket client = server.accept();\n            //客户端构建异步线程\n            ClientHandler clientHandler = new ClientHandler(client);\n            //启动线程\n            clientHandler.start();\n        }\n    }\n\n    private static ServerSocket createServerSocket() throws IOException {\n        ServerSocket serverSocket=new ServerSocket();\n        // 绑定到本地端口20000上，并且设置当前可允许等待链接的队列为50个\n        //serverSocket = new ServerSocket(PORT);\n\n        // 等效于上面的方案，队列设置为50个\n        //serverSocket = new ServerSocket(PORT, 50);\n\n        // 与上面等同\n        // serverSocket = new ServerSocket(PORT, 50, Inet4Address.getLocalHost());\n        return serverSocket;\n    }\n\n    private static void initServerSocket(ServerSocket serverSocket)throws IOException{\n        //是否复用未完全关闭的地址端\n        serverSocket.setReuseAddress(true);\n\n        // 等效Socket#setReceiveBufferSize\n        serverSocket.setReceiveBufferSize(64 * 1024 * 1024);\n\n        // 设置serverSocket#accept超时时间\n        // serverSocket.setSoTimeout(2000);\n\n        // 设置性能参数：短链接，延迟，带宽的相对重要性\n        serverSocket.setPerformancePreferences(1, 1, 1);\n    }\n\n    //处理多个请求时要用异步\n    private static class ClientHandler extends Thread{\n        private Socket socket;\n        private boolean flag=true;\n\n        ClientHandler(Socket socket){\n            this.socket=socket;\n        }\n\n        //运行时运行run\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;新客户端连接: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n            try{\n                //得到套接字流\n                OutputStream outputStream=socket.getOutputStream();\n                InputStream inputStream=socket.getInputStream();\n                byte[] buffer=new byte[256];\n                int readCount=inputStream.read(buffer);\n                ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n                // byte\n                byte be = byteBuffer.get();\n\n                // char\n                char c = byteBuffer.getChar();\n\n                // int\n                int i = byteBuffer.getInt();\n\n                // bool\n                boolean b = byteBuffer.get() == 1;\n\n                // Long\n                long l = byteBuffer.getLong();\n\n                // float\n                float f = byteBuffer.getFloat();\n\n                // double\n                double d = byteBuffer.getDouble();\n\n                // String\n                int pos = byteBuffer.position();\n\n                String str = new String(buffer, pos, readCount - pos - 1);\n\n                System.out.println(&quot;收到数量：&quot; + readCount + &quot; 数据：&quot;\n                        + be + &quot;\\n&quot;\n                        + c + &quot;\\n&quot;\n                        + i + &quot;\\n&quot;\n                        + b + &quot;\\n&quot;\n                        + l + &quot;\\n&quot;\n                        + f + &quot;\\n&quot;\n                        + d + &quot;\\n&quot;\n                        + str + &quot;\\n&quot;);\n                System.out.println(buffer.toString());\n\n                outputStream.write(buffer, 0, readCount);\n                outputStream.close();\n                inputStream.close();\n            }catch(Exception e){\n                System.out.println(&quot;连接异常断开&quot;);\n            }finally {\n                //连接关闭(每个线程)\n                try{\n                    socket.close();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(&quot;客户端已退出: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n        }\n    }\n}</code></pre><h4 id=\"客户端代码-1\"><a href=\"#客户端代码-1\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h4><pre><code>import java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\n\npublic class Client {\n\n    private static final int PORT=20000;\n    private static final int LOCAL_PORT=20001;\n\n    public static void main(String[] args)throws IOException {\n        Socket socket=createSocket();\n\n        initSocket(socket);\n\n        //连接本地,端口20000,超时时间3000ms\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),PORT),3000);\n        System.out.println(&quot;已发起服务器连接,并进入后续流程~&quot;);\n        System.out.println(&quot;客户端信息: &quot;+socket.getLocalAddress()+&quot; P:&quot;+socket.getLocalPort());\n        System.out.println(&quot;服务器信息: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort() );\n\n        try{\n            //发送接收数据\n            todo(socket);\n        }catch(Exception e){\n            System.out.println(&quot;异常关闭&quot;);\n        }\n        //释放资源\n        socket.close();\n        System.out.println(&quot;客户端已关闭&quot;);\n    }\n\n    private static Socket createSocket() throws IOException{\n        /*\n        // 无代理模式，等效于空构造函数\n        Socket socket = new Socket(Proxy.NO_PROXY);\n\n        // 新建一份具有HTTP代理的套接字，传输数据将通过www.baidu.com:8080端口转发\n        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n                new InetSocketAddress(Inet4Address.getByName(&quot;www.baidu.com&quot;), 8800));\n        socket = new Socket(proxy);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上\n        socket = new Socket(&quot;localhost&quot;, PORT);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上\n        socket = new Socket(Inet4Address.getLocalHost(), PORT);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上，并且绑定到本地20001端口上\n        socket = new Socket(&quot;localhost&quot;, PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n        socket = new Socket(Inet4Address.getLocalHost(), PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n        */\n        Socket socket=new Socket();\n        //绑定到本地20001端口\n        socket.bind(new InetSocketAddress(Inet4Address.getLocalHost(),LOCAL_PORT));\n        return socket;\n    }\n\n    private static void initSocket(Socket socket)  throws SocketException{\n        //设置读取超时时间为2秒\n        socket.setSoTimeout(2000);\n        //是否复用未完全关闭的Socket地址,对于指定build操作后的套接字有效\n        socket.setReuseAddress(true);\n        //是否需要开启Nagle算法\n        socket.setKeepAlive(true);\n        //是否需要在长时间无数据时确认是否依然连接(类似于心跳包),时间大约为2h\n        socket.setKeepAlive(true);\n\n        // 对于close关闭操作行为进行怎样的处理；默认为false，0\n        // false、0：默认情况，关闭时立即返回，底层系统接管输出流，将缓冲区内的数据发送完成\n        // true、0：关闭时立即返回，缓冲区数据抛弃，直接发送RST结束命令到对方，并无需经过2MSL等待\n        // true、200：关闭时最长阻塞200毫秒，随后按第二情况处理\n        socket.setSoLinger(true,20);\n        // 是否让紧急数据内敛，默认false；紧急数据通过 socket.sendUrgentData(1);发送\n        socket.setOOBInline(true);\n\n        // 设置接收发送缓冲器大小\n        socket.setReceiveBufferSize(64 * 1024 * 1024);\n        socket.setSendBufferSize(64 * 1024 * 1024);\n\n        // 设置性能参数：短链接，延迟，带宽的相对重要性\n        socket.setPerformancePreferences(1, 1, 0);\n\n    }\n\n    private static void todo(Socket client) throws IOException{\n        //得到Socket输出流,并转换为打印流\n        OutputStream outputStream=client.getOutputStream();\n\n        //得到Socket输入流,并用ByteBuffer包裹起来\n        InputStream inputStream=client.getInputStream();\n        byte[] buffer=new byte[256];\n        ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n        // byte\n        byteBuffer.put((byte) 126);\n\n        // char\n        char c = &apos;a&apos;;\n        byteBuffer.putChar(c);\n\n        // int\n        int J = 12138;\n        byteBuffer.putInt(J);\n\n        // bool\n        boolean b = true;\n        byteBuffer.put(b ? (byte) 1 : (byte) 0);\n\n        // Long\n        long l = 298789739;\n        byteBuffer.putLong(l);\n\n\n        // float\n        float f = 12.345f;\n        byteBuffer.putFloat(f);\n\n\n        // double\n        double d = 13.31241248782973;\n        byteBuffer.putDouble(d);\n\n        // String\n        String str = &quot;Hello你好！&quot;;\n        byteBuffer.put(str.getBytes());\n\n        //发送到服务器\n        outputStream.write(buffer,0,byteBuffer.position()+1);\n\n        //接受服务器返回\n        int read=inputStream.read(buffer);\n        System.out.println(&quot;收到数量: &quot;+read);\n\n        //资源释放\n        outputStream.close();\n        inputStream.close();\n    }\n}</code></pre><h1 id=\"聊天室架构从0开始-–-2-TCP-UDP-实现搜索IP与端口\"><a href=\"#聊天室架构从0开始-–-2-TCP-UDP-实现搜索IP与端口\" class=\"headerlink\" title=\"聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口\"></a>聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口</h1><p><a href=\"be-sunshine.cn/index.php/2019/01/14/ty2/\" title=\"聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口\">聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口</a></p>\n","text":"最后更新于2019/1/1课设过程中的记录序言 - tcp与udp的族谱借助工具 - 流式读取戳-&gt;java流式读取简单tcp问题因为要求服务端是无限接收客户端的请求,所以服务端必须用线程来新建和处理请求.服务端代码import javax.print.DocFlavor;","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"tcp","slug":"Java/tcp","count":1,"path":"api/categories/Java/tcp.json"},{"name":"网络编程","slug":"Java/tcp/网络编程","count":1,"path":"api/categories/Java/tcp/网络编程.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"},{"name":"网络编程","slug":"网络编程","count":4,"path":"api/tags/网络编程.json"},{"name":"tcp","slug":"tcp","count":3,"path":"api/tags/tcp.json"}]},{"title":"23种设计模式","slug":"23-sort-dp","date":"2018-07-09T08:54:25.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/23-sort-dp.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/07/8c8553195537694e12194e5ed24b72fd.png","content":"<h1 id=\"开题\"><a href=\"#开题\" class=\"headerlink\" title=\"开题\"></a>开题</h1><h2 id=\"设计模式作用\"><a href=\"#设计模式作用\" class=\"headerlink\" title=\"设计模式作用?\"></a>设计模式作用?</h2><p>需求敲定了,模块划完了,你们要开工了,但是问题出来了,如果不是一个人开发,那代码如何统一起来?不扯犊子的话你总不能一个人一种代码习惯,然后找人把他们整合起来?这复杂度有点高吧… 那就解耦吧,高内聚低耦合嘛,为什么低耦合,就是为了整合规则,让每个人的代码都不能违反规则.然后在规则上将每个人的代码分开.这就叫解耦,其实解耦这个概念在很多地方都用到了,架构上也有.可得见解耦是多么的重要. 设计模式就起了这个作用.只给小组程序猿提供接口.</p>\n<h2 id=\"优点-目的？\"><a href=\"#优点-目的？\" class=\"headerlink\" title=\"优点/目的？\"></a>优点/目的？</h2><ul>\n<li>面向接口编程</li>\n<li>降低耦合度</li>\n<li>增加灵活度</li>\n</ul>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类?\"></a>分类?</h2><ul>\n<li>创建模式(解决如何在创建的过程中创建对象/对象结构)</li>\n<li>结构模式(专注于结构化的划分和设计)</li>\n<li>行为模式(专注于行为设计,如何更灵活,更大程度上可扩展,或降低耦合度)</li>\n</ul>\n<h3 id=\"创建模式\"><a href=\"#创建模式\" class=\"headerlink\" title=\"创建模式\"></a>创建模式</h3><ul>\n<li>简单工厂模式(静态工厂方法模式)</li>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n<li>单例模式</li>\n<li>建造模式</li>\n<li>原始模型模式</li>\n</ul>\n<h3 id=\"结构模式\"><a href=\"#结构模式\" class=\"headerlink\" title=\"结构模式\"></a>结构模式</h3><h3 id=\"行为模式\"><a href=\"#行为模式\" class=\"headerlink\" title=\"行为模式\"></a>行为模式</h3><h2 id=\"学习的时候要注意什么\"><a href=\"#学习的时候要注意什么\" class=\"headerlink\" title=\"学习的时候要注意什么?\"></a>学习的时候要注意什么?</h2><ul>\n<li>每个模式的类图</li>\n<li>模式的结构</li>\n<li>每个模式的角色</li>\n<li>模式的实例</li>\n<li>优缺点</li>\n<li>每个模式的应用场景</li>\n</ul>\n<h1 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h1><h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/8c8553195537694e12194e5ed24b72fd.png\" alt></p>\n<h2 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/4e335b0476fe377bf2de07c32b93f643.png\" alt></p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>两种方式创建工厂类,一个是利用Java反射机制,一个是根据规定创建. <a href=\"https://github.com/834930269/Design-pattern/tree/master/DP/src/simplefactory\" target=\"_blank\" rel=\"noopener\">https://github.com/834930269/Design-pattern/tree/master/DP/src/simplefactory</a></p>\n","text":"开题设计模式作用?需求敲定了,模块划完了,你们要开工了,但是问题出来了,如果不是一个人开发,那代码如何统一起来?不扯犊子的话你总不能一个人一种代码习惯,然后找人把他们整合起来?这复杂度有点高吧… 那就解耦吧,高内聚低耦合嘛,为什么低耦合,就是为了整合规则,让每个人的代码都不能违反","link":"","raw":null,"photos":[],"categories":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}]}]}