{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"Python Flask 10.0.1上传文件","slug":"python-flask-upfile","date":"2017-10-17T13:55:17.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-upfile.json","excerpt":"","keywords":null,"cover":null,"content":"<p><code>1.</code> <code>os模块</code>:</p>\n<pre><code>#获取指定文件目录\nos.path.abspath(os.path.join(os.getcwd(),&quot;static/Gravatar&quot;))</code></pre><p><code>2.``Flask_wtf.file包</code>:里面放着各种处理文件上传的处理表单类. <code>3.</code>获取当前文件的<code>url</code>:</p>\n<pre><code>if filename is None:\n    fn=&apos;default.jpg&apos;\nelse:\n    fn=filename\nfn = os.path.abspath(os.path.join(app.config[&apos;UPLOADED_PHOTOS_DEST&apos;],fn))</code></pre><p><code>代码</code>:</p>\n<pre><code>#app.py\n# -*- coding: utf-8 -*-\nfrom flask import Flask, render_template\nfrom flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\nfrom flask_wtf import FlaskForm\nfrom flask_wtf.file import FileField, FileRequired, FileAllowed\nfrom wtforms import SubmitField\nimport os\n\napp = Flask(__name__)\napp.config[&apos;SECRET_KEY&apos;] = &apos;I have a dream&apos;\napp.config[&apos;UPLOADED_PHOTOS_DEST&apos;] = os.path.abspath(os.path.join(os.getcwd(),&quot;static/Gravatar&quot;))\n\nphotos = UploadSet(&apos;photos&apos;,IMAGES)\nconfigure_uploads(app,photos)\npatch_request_class(app)\n\n#创建Form\nclass UploadForm(FlaskForm):\n    photo = FileField(validators=[FileAllowed(photos,u&apos;只能上传图片哦!&apos;),\n                                  FileRequired(u&apos;文件为选择!&apos;)])\n    submit = SubmitField(u&apos;上传&apos;)\n\n@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef upload_file():\n    form = UploadForm()\n    if form.validate_on_submit():\n        filename = photos.save(form.photo.data)\n        file_url = photos.url(filename)\n    else:\n        file_url = None\n        filename = None\n    if filename is None:\n        fn=&apos;default.jpg&apos;\n    else:\n        fn=filename\n    fn = os.path.abspath(os.path.join(app.config[&apos;UPLOADED_PHOTOS_DEST&apos;],fn))\n    return render_template(&apos;index.html&apos;,form=form,file_url=file_url,filename=fn)\n\nif __name__ == &apos;__main__&apos;:\n    app.run()</code></pre><p><code>前台-app/templates</code>:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;title&gt;Upload File&lt;/title&gt;\n&lt;h1&gt;图片上传&lt;/h1&gt;\n&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;\n     { { form.hidden_tag() }}\n     { { form.photo }}\n     {% for error in form.photo.errors %}\n             <span style=\"color: red;\">{ { error }}</span>\n         {% endfor %}\n     { { form.submit }}\n&lt;/form&gt;\n{ { filename }}\n{% if file_url %}\n    <br><img src=\"{ { file_url }}\">\n    {% endif %}</code></pre>","text":"1. os模块:#获取指定文件目录os.path.abspath(os.path.join(os.getcwd(),&quot;static/Gravatar&quot;))2.``Flask_wtf.file包:里面放着各种处理文件上传的处理表单类. 3.获取当前文件的url:","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 7 博客架构一: 登录注册模块","slug":"python-flask-7-blog-login-regist","date":"2017-10-14T14:53:28.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-7-blog-login-regist.json","excerpt":"","keywords":null,"cover":"http://img.blog.csdn.net/20160924183725708","content":"<p><code>1.</code>flask_login模块中,views层判断是否登录用<code>current_user.is_authenticated</code>,但是,<code>flask-login2.x</code>是current_user.is_authenticated<code>()</code>,<code>flask-login3.x</code>是current_user.is_authenticated 即:</p>\n<pre><code>&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;\n    {% if current_user.is_authenticated %}\n            <li><a href=\"{ { url_for('auth.logout') }}\">Sign Out</a></li>\n        {% else %}\n            <li><a href=\"{ { url_for('auth.login') }}\">Sign In</a></li>\n        {% endif %}\n&lt;/ul&gt;</code></pre><p><code>2.</code>在 <code>SQLAlchemy</code> 中， add() 操作之后数据成为<code>pending</code> 状态，此时数据<code>不会立即</code>写入到数据库中。 当你执行 <code>query()</code> 的时候，它会先把之前状态为 pending 的数据<code>写入到数据库</code>，并且<code>更新当前 session</code> 中存储的数据，然后再执行 <code>query()</code> <code>3.</code>如果出现<code>Can&#39;t locate revision identified by &#39;XXX&#39;</code>,要删除一下数据库中的<code>alembic_version</code>表,保证版本不会互相影响以完成更新.</p>\n<h1><span id=\"项目地址github\">项目地址(Github):</span></h1><p><a href=\"https://github.com/834930269/Flask_Study/tree/master/flask-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%842-%E6%B3%A8%E5%86%8C%E5%92%8C%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81\" title=\"flask-大型网站架构2-注册和邮箱验证\" target=\"_blank\" rel=\"noopener\"><code>Click Here: flask-大型网站架构2-注册和邮箱验证</code></a> <code>4.</code>看到了一个之前没太注意的地方: <a href=\"http://img.blog.csdn.net/20160924183725708\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.blog.csdn.net/20160924183725708\" alt></a> 这里是Flask-Login需要的自己实现的四个函数.可以用一个<code>UserMixin</code>解决.但需要自己实现一个<code>回调函数</code>。 <a href=\"http://img.blog.csdn.net/20160924183906725\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.blog.csdn.net/20160924183906725\" alt></a> <a href=\"http://img.blog.csdn.net/20160924183919554\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.blog.csdn.net/20160924183919554\" alt></a> 这就是代码里</p>\n<pre><code>@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))</code></pre><p>这段代码的意义. ..有点累..躺尸一会,先不更新了..<code>_(:3」∠)_我的床需要我</code></p>\n","text":"1.flask_login模块中,views层判断是否登录用current_user.is_authenticated,但是,flask-login2.x是current_user.is_authenticated(),flask-login3.x是current_user.is","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 7.1 @property","slug":"python-flask-7-1-property","date":"2017-10-14T12:54:20.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-7-1-property.json","excerpt":"","keywords":null,"cover":null,"content":"<p>见之前的文章===&gt; <a href=\"http://be-sunshine.cn/index.php/2017/07/16/python3-property/\" title=\"python3学习 @property\" target=\"_blank\" rel=\"noopener\"><code>Click Here: python3学习 @property</code></a></p>\n","text":"见之前的文章===&gt; Click Here: python3学习 @property","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python  Flask(六) 大型网站架构","slug":"python-flasksix-large-application-structure","date":"2017-10-13T05:35:46.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flasksix-large-application-structure.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B711.png","content":"<h1><span id=\"large-application-structure\">Large Application Structure</span></h1><hr>\n<p>有了之前的基础后我们再来看第六章就轻松多了. 首先贴上<code>稍加修改</code>的后项目地址: <a href=\"https://github.com/834930269/Flask_Study/tree/master/flask-%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%84\" title=\"&lt;code&gt;Click Here: flask-转换结构&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>Click Here: flask-转换结构</code></a> 我们可以看到项目目录下有两个<code>Config</code>文件,其中<code>副本</code>是同书上一样的使用<code>SQLite</code>作为数据库文件来使用的,而且email的<code>smtp</code>服务器地址为<code>smtp.gmail.com</code>(文件中不是这个地址,需要改一下). 而修改后的<code>config.py</code>使用<code>mysql</code>作为基数据库,<code>smtp.qq.com</code>作为email的发送地址的. 这里说我在<code>config.py</code>的项目中设的各个环境变量即相应的意义.</p>\n<pre><code>1.MAIL_SENDER: 发送email的用户(abc@qq.com)=&gt;\n               在qq邮箱中这一项必须和发送者的邮箱一样\n2.MAIL_USERNAME: 发送者的用户名\n3.MAIL_PASSWORD: 发送者的密码=&gt;这里因为QQ邮箱使用的\n                 是授权码作为密码,所以需要申请一下授权码\n                 正常的密码是无法登录的\n4.FLASKY_ADMIN: 同是发送者的用户名,但是如果不填写的话,\n                则默认不发送邮件,所以可以不用设置.\n                不设置这项的话上面三项均可以忽略.\n5.DATABASE_USERNAME: 你在mysql中创建data_dev数据库时\n                     指定授权可操作该数据库的用户名\n6.DATABASE_PASSWORD: 同5的密码</code></pre><p>因为在<code>mysql</code>的数据库<code>命名规范</code>中,<code>data-dev</code>是不被允许的. 所以我将它改为了<code>data_dev</code>. 在运行项目前,需要先创建<code>data_dev</code>数据库,并创建一个可以操作该数据库的用户,假设我们创建的用户是: <code>USER: ABC</code> <code>USER_PASSWORD: ABC</code> 我们在数据库和用户创建好了以后将<code>相应的环境变量</code>放进环境中: <code>set DATABASE_USERNAME=ABC</code> <code>set DATABASE_PASSWORD=ABC</code> 这里我们不对上面4项进行设置,这样就默认不发送邮件. 然后我们需要建立<code>迁移数据库</code>,以便完成对数据库表项的<code>初始化</code>. <code>python manage.py db init</code> <code>python manage.py db migrate -m &#39;commit&#39;</code> <code>python manage.py db upgrade</code> 然后我们就可以运行项目了! <code>manage.py runserver</code> 结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B711.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B711.png\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B712.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B712.png\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B713.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B713.png\" alt></a></p>\n","text":"Large Application Structure有了之前的基础后我们再来看第六章就轻松多了. 首先贴上稍加修改的后项目地址: Click Here: flask-转换结构 我们可以看到项目目录下有两个Config文件,其中副本是同书上一样的使用SQLite作为数据库文件来使","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 6.0.2 相对路径","slug":"python-flask-6-0-2-path","date":"2017-10-13T04:17:13.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-6-0-2-path.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg","content":"<p>在Python引入包时,我们会发现有这样的一种引用方法: <code>from . import XX</code>,以及<code>from .. import xx</code>. 这就是相对路径引用. 其中有几点需要注意. <code>1.</code>在编译时,存在这种相对引用的<code>.py</code>是无法被<code>单独编译</code>的,只有在编译最高级的<code>.py</code>时,才不会报<code>编译级别错误</code>. <code>2.</code>存在<code>跨文件夹引用</code>时,需要在相应文件夹内创建一个<code>__init__.py</code>才可以引用成功,(<code>就算该文件是空的也没关系</code>)因为加了这个文件,编译器才会把该文件夹看做一个<code>package</code>,即可以用<code>from 文件夹名 import 类/文件</code>等方式进行引用. <code>3.</code>在主程序运行后,调用每个包时会先调用该包的<code>__init__.py</code>文件,然后再调用对应<code>import</code>的内容. 这里我结合上一节的<code>Factory method</code>编写了一个简单的测试程序:</p>\n<pre><code>具体目录结构如下:\n--工厂函数/\n    --tests/\n        --abc/\n            --__init__.py\n            --qb.py\n        --__init__.py\n        --test2.py\n    --test.py(主程)</code></pre><p>项目地址: <a href=\"https://github.com/834930269/python_study/tree/master/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0\" title=\"&lt;code&gt;Click Here: 工厂函数&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>Click Here: 工厂函数</code></a> 运行<code>test.py</code>,<code>Result:</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg\" alt></a> <code>test.py</code>:</p>\n<pre><code>from tests.abc.qb import crete_factory_method\n\nfactory_test = crete_factory_method(&apos;这是第一个单元测试&apos;)\n\nfactory_test2 = crete_factory_method(&apos;这是第二个单元测试&apos;)\n\nfactory_test.print_str()\n\nfactory_test2.print_str()</code></pre><p><code>tests/__init__.py</code>:</p>\n<pre><code>print(&quot;I&apos;m Tom&apos;s __init__!&quot;)</code></pre><p><code>tests/test2.py</code>:</p>\n<pre><code>class mq(object):\n    def __init__(self,string_c):\n        self.config_str=string_c\n    def print_str(self):\n        print(self.config_str)</code></pre><p><code>tests/abc/__init__.py</code>:</p>\n<pre><code>print(&apos;由此可知,如果直接编译qb.py会报错,因为等级?错误,但是直接编译最顶层的test.py就不会报错了.&apos;)</code></pre><p><code>tests/abc/qb.py</code>:</p>\n<pre><code>from ..test2 import mq\n\ndef crete_factory_method(config_str):\n    tp=mq(config_str)\n    return tp</code></pre>","text":"在Python引入包时,我们会发现有这样的一种引用方法: from . import XX,以及from .. import xx. 这就是相对路径引用. 其中有几点需要注意. 1.在编译时,存在这种相对引用的.py是无法被单独编译的,只有在编译最高级的.py时,才不会报编译级别","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 6.0.1 工厂函数","slug":"python-flask-6-0-1-factory-method","date":"2017-10-12T13:53:30.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-6-0-1-factory-method.json","excerpt":"","keywords":null,"cover":null,"content":"<p>开始大型网站架构的时候,有很多概念晦涩难懂,其中就有这个工厂函数. 以下是来自别人的博客: <a href=\"http://blog.csdn.net/qbw2010/article/details/45314541http://blog.csdn.net/qbw2010/article/details/45314541\" title=\"...Clicke Here...\" target=\"_blank\" rel=\"noopener\"><code>...Clicke Here...</code></a></p>\n<pre><code>def maker(N):  \n    def action(X):  \n        return X ** N  \n    return action  </code></pre><p>这个函数就是一个典型的<code>工厂函数</code>. 其中会牵扯到一个概念,<code>延迟执行</code>. 我们可以看到,这个函数是有<code>参数</code>的. 实例化对象:</p>\n<pre><code>f = maker(2)  </code></pre><p>然后我们在对象实例化后传入参数:</p>\n<pre><code>f(3)</code></pre><p>结果会输出9. 每次maker()的时候都会生成一个新的实例化对象. 而用实例化对象传入参数返回的就是返回的<code>调用函数返回的值</code>.</p>\n<pre><code> 1、Python中的def语句是一个可执行语句——函数并不存在，直到Python运行了def后才存在。当Python运行到def语句时，将创建一个函数对象，并将其赋值给某一变量名，这个变量名就是函数名。\n\n2、当函数被调用时，其调用者停止运行直到这个函数完成了工作，之后函数将控制权返回调用者。函数通过return语句将计算得到的值传递给调用者，返回值成为函数调用的结果，即return将一个函数结果发送给调用者。\n\n3、参数通过赋值传递给了函数。改变参数名并不会改变调用者中的变量名，但是改变传递的可变参数可以改变调用者共享的那个对象，即函数是通过赋值（对象引用）传递的。\n\n 4、函数maker里面嵌套了一个函数action，首先传给maker函数一个参数N，这个参数传给了action函数，action函数获得具体的参数形成具体的函数，此时，action(X)函数已经具体化了，也就是def action(X):return X**2，然后将action(X)返回给顶层，并赋值给f，即f是action(X)，然后再传递参数到f中，也就是传给了action(X)。</code></pre><p>在书中的:</p>\n<pre><code>def create_app(config_name):\n    app=Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)   \n\n    bootstrap.init_app(app)\n    mail.init_app(app)\n    moment.init_app(app)\n    db.init_app(app)\n    from .main import main as main_blueprint\n    app.register_blueprint(main_blueprint)\n\n    return app</code></pre><p>即为工厂函数,接受的参数是Config_name. 其返回的是实例化后的app对象,即可以对每种单元测试进行覆盖,而并非是对每种测试都重新运行一遍. 想对哪种单元测试进行测试时,只需调用其(工厂函数)返回的app实例化对象即可. 以下是我自己写的<code>工厂函数单元测试</code>样例:</p>\n<pre><code>class mq(object):\n    def __init__(self,string_c):\n        self.config_str=string_c\n    def print_str(self):\n        print(self.config_str)\n\ndef crete_factory_method(config_str):\n    tp=mq(config_str)\n    return tp\n\nfactory_test = crete_factory_method(&apos;这是第一个单元测试&apos;)\n\nfactory_test2 = crete_factory_method(&apos;这是第二个单元测试&apos;)\n\nfactory_test.print_str()\n#Out[]:这是第一个单元测试\n\nfactory_test2.print_str()\n#Out[]:这是第二个单元测试</code></pre><p>这样就明白了吧:)</p>\n","text":"开始大型网站架构的时候,有很多概念晦涩难懂,其中就有这个工厂函数. 以下是来自别人的博客: ...Clicke Here...def maker(N):      def action(X):          return X ** N      return action  ","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask5.1 Context(上下文=>跟随变量)","slug":"python-flask5-1-context","date":"2017-10-11T07:29:31.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask5-1-context.json","excerpt":"","keywords":null,"cover":null,"content":"<p>这是一个概念性的东西. 这里贴几个地址(有些我没看懂): <code>1.</code>轮子哥:</p>\n<pre><code>vczh\n    vczh: 《C++Primer 5th》强势审校\n\n每一段程序都有很多外部变量。只有像Add这种简单的函数才是\n没有外部变量的。一旦你的一段程序有了外部变量，这段程序就\n不完整，不能独立运行。你为了使他们运行，就要给所有的外部\n变量一个一个写一些值进去。这些值的集合就叫上下文。\n\n譬如说在C++的lambda表达是里面，[写在这里的就是上下文](int a, int b){ ... }。</code></pre><p>似懂非懂. <code>2.</code>: 最近在学Python + Flask，搜到了这个问题，也来回答一下吧。既然题主也在学Flask，就用Flask来举例：Flask从客户端收到请求的时候，视图函数如果要处理请求的话，可能就要访问一些对象。那么这些对象可以通过参数的形式传递进来，或者是在函数中访问外部变量。所以这个外部变量要有特定的值才会有意义，也即所谓的上下文。譬如Flask中的request变量，这是一个请求上下文，也就是当请求被推送之后，request才会有意义，接下来才可以使用request，否则就会报错，因为缺少上下文。引用一段《Flask Web开发》中的代码：</p>\n<pre><code>from flask import request\n\n@app.route(&apos;/&apos;)\ndef index():\n    user_agent = request.headers.get(&apos;User-Agent&apos;)\n    return &apos;&lt;p&gt;Your browser is %s&lt;/p&gt;&apos; % user_agent  </code></pre><p>就像前面说的，函数index()访问了request这个外部变量，但request必须在请求推送之后才可以使用，这就是一个请求上下文全局变量。 <strong>作者：Blackbelly 链接：<a href=\"https://www.zhihu.com/question/26387327/answer/128743651\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/26387327/answer/128743651</a> 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong> <code>3.</code>转自简书: <a href=\"http://www.jianshu.com/p/7a7efbb7205f\" title=\"Click Here: Flask的Context(上下文)学习笔记\" target=\"_blank\" rel=\"noopener\">Click Here: Flask的Context(上下文)学习笔记</a></p>\n","text":"这是一个概念性的东西. 这里贴几个地址(有些我没看懂): 1.轮子哥:vczh    vczh: 《C++Primer 5th》强势审校每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask(五) Email","slug":"python-flask-email","date":"2017-10-10T11:07:25.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-email.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B77.png","content":"<p>moudule:Flask_mail 配置参数: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B77.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B77.png\" alt></a> 中文: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B78.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B78.png\" alt></a> 如果不进行配置,Flask_Mail会自动连接localhost上的端口25 啊……调了一大堆错,总算搞定了QQ的邮件发送…… :sob: :sob: :sob: :sob: :sob: :sob: :sob: :sob: <code>1.</code>向QQ发送邮件是通过<code>SMTP协议</code>发送的,所以我们需要在QQ邮箱的设置中<code>开启SMTP协议</code>: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010185347.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010185347.png\" alt></a> <code>2.</code>因为QQ采用的是<code>授权码</code>发送邮件的方式,所以发送邮件时的<code>密码是授权码</code>,需要<code>申请一下</code>(这个授权码会被改变,但我不知道是怎样的条件会改变).如上图的<code>生成授权码</code>. <code>3.</code>千万不要把TTL写成TLE!!!!!! <code>4.</code>set MAIL_USERNAME/PASSWORD=<code>***</code> 这个操作是在cmd界面下直接输入即可,意为将<code>key-value:环境变量-值</code>放在系统内.python取出是依赖<code>os模块</code>的<code>os.environ.get(&#39;key&#39;)</code>取出value的. <code>5.</code>对于QQ邮箱而言,新生成的<code>msg对象</code>的<code>sender</code>需要和你发送到的目标用户一样,否则会出现<code>501</code>错误:发送者与接收者不是同一人. <code>6.</code>发送的<code>shell</code>大概代码为: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190344.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190344.png\" alt></a> <code>7.</code>AC <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190501.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190501.png\" alt></a> Code:</p>\n<pre><code>#--*--coding:utf-8--*--\nfrom datetime import datetime\nfrom flask import Flask, render_template,session,redirect,url_for,flash\nfrom flask_script import Manager\nfrom flask_bootstrap import Bootstrap   \nfrom flask_moment import Moment\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField,SubmitField\nfrom wtforms.validators import Required\nfrom flask_sqlalchemy import SQLAlchemy\nimport os\nfrom flask_mail import Mail\n\nclass NameForm(FlaskForm):\n    name=StringField(&apos;What is your name?&apos;,validators=[Required()])\n    submit=SubmitField(&apos;Submit&apos;)\n\napp = Flask(__name__)\n\n#Flask-WTF : secret_key\n#app.config dict used to save config message.\napp.config[&apos;MAIL_SERVER&apos;]=&apos;smtp.qq.com&apos;\napp.config[&apos;MAIL_PORT&apos;]=587\n#app.config[&apos;MAIL_USE_TLE&apos;]=True\napp.config[&apos;MAIL_USE_TLS&apos;] = True\napp.config[&apos;MAIL_USERNAME&apos;]=os.environ.get(&apos;MAIL_USERNAME&apos;)\napp.config[&apos;MAIL_PASSWORD&apos;]=os.environ.get(&apos;MAIL_PASSWORD&apos;)\napp.config[&apos;SECRET_KEY&apos;]=&apos;hard to guess string&apos;\napp.config[&apos;SQLALCHEMY_DATABASE_URI&apos;]=\\\n    &apos;mysql://root:zwt~19970210@localhost/data&apos;\napp.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = True\napp.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = False\ndb=SQLAlchemy(app)\n\nmanager = Manager(app)\nbootstrap = Bootstrap(app)\nmoment = Moment(app)\nmail=Mail(app)\n\nclass Role(db.Model):\n    __tablename__ = &apos;roles&apos;\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), unique=True)\n    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;, lazy=&apos;dynamic&apos;)\n\n    def __repr__(self):\n        return &apos;&lt;Role %r&gt;&apos; % self.name\n\n\nclass User(db.Model):\n    __tablename__ = &apos;users&apos;\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, index=True)\n    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;))\n\n    def __repr__(self):\n        return &apos;&lt;User %r&gt;&apos; % self.username\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template(&apos;404.html&apos;), 404\n\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    return render_template(&apos;500.html&apos;), 500\n\n\n@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef index():\n    form=NameForm()\n    if form.validate_on_submit():\n        user=User.query.filter_by(username=form.name.data).first()\n        if user is None:\n            user =User(username=form.name.data)\n            db.session.add(user)\n            session[&apos;known&apos;]=False\n        else:\n            session[&apos;known&apos;]=True\n        session[&apos;name&apos;]=form.name.data\n        form.name.data=&apos;&apos;\n        return redirect(url_for(&apos;index&apos;))\n    return render_template(&apos;index.html&apos;,\n                           current_time=datetime.utcnow(),form=form,name=session.get(&apos;name&apos;),known=session.get(&apos;known&apos;,False))\n\n\n@app.route(&apos;/user/&lt;name&gt;&apos;)\ndef user(name):\n    return render_template(&apos;user.html&apos;, name=name)\n\n\nif __name__ == &apos;__main__&apos;:\n    db.create_all()\n    manager.run()</code></pre><p>接下来我要试试Gmail.. 9.成功,而且好像知道了怎么用自己的一个账号发送给另一个账号的奇技淫巧…recipients参数是目标邮箱.结果如下: Gmail: 1. 给自己发的结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193039.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193039.png\" alt></a> 2.给QQ邮箱发的结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193200.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193200.png\" alt></a> QQ: 接收到Gmail发送的结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193350.png\" alt=\"Aaron\"><code>10.</code>将发送邮件功能集成到页面. 功能=&gt;每次添加新用户发送到邮箱信息:<code>&#39;User { { username }} has joined.&#39;</code> 主要<code>发送</code>代码如下:</p>\n<pre><code>def send_email(to,subject,template,**k):\n    msg=Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;]+subject,\n        sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;],recipients=[to])\n    msg.body=render_template(template+&apos;.txt&apos;,**k)\n    msg.html=render_template(template+&apos;.html&apos;,**k)\n    mail.send(msg)</code></pre><p><code>调用</code>代码:</p>\n<pre><code>@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef index():\n    form=NameForm()\n    if form.validate_on_submit():\n        user=User.query.filter_by(username=form.name.data).first()\n        if user is None:\n            user =User(username=form.name.data)\n            db.session.add(user)\n            session[&apos;known&apos;]=False\n            if app.config[&apos;FLASKY_ADMIN&apos;]:\n                send_email(app.config[&apos;FLASKY_ADMIN&apos;],&apos;New User&apos;,&apos;mail/new_user&apos;,user=user)\n        else:\n            session[&apos;known&apos;]=True\n        session[&apos;name&apos;]=form.name.data\n        form.name.data=&apos;&apos;\n        return redirect(url_for(&apos;index&apos;))\n    return render_template(&apos;index.html&apos;,\n                           current_time=datetime.utcnow(),form=form,name=session.get(&apos;name&apos;),known=session.get(&apos;known&apos;,False))</code></pre><p><code>11.</code>最终结果如下: 添加新用户<code>Aaron Swartz</code>: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/ASDADASDAWDA1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/ASDADASDAWDA1.png\" alt></a> <code>12.</code>用异步的方法发送邮件:这样会产生一种无延迟感,用户体验更好. 代码如下:</p>\n<pre><code>from threading import Thread\n\ndef send_async_email(app,msg):\n    with app.app_context():\n        mail.send(msg)\n\ndef send_email(to,subject,template,**k):\n    msg=Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;]+subject,\n        sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;],recipients=[to])\n    msg.body=render_template(template+&apos;.txt&apos;,**k)\n    msg.html=render_template(template+&apos;.html&apos;,**k)\n    thr=Thread(target=send_async_email,args=[app,msg])\n    thr.start()\n    return thr</code></pre><h1><span id=\"done\"><strong>Done!</strong></span></h1>","text":"moudule:Flask_mail 配置参数:  [Figure]  12.用异步的方法发送邮件:这样会产生一种无延迟感,用户体验更好. 代码如下:from threading import Threaddef send_async_email(app,msg):    wit","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"},{"name":"未分类","slug":"Flask/Python/未分类","count":2,"path":"api/categories/Flask/Python/未分类.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"password","slug":"password","date":"2017-10-10T10:51:35.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/password.json","excerpt":"","keywords":null,"cover":null,"content":"<p>834930269@Zwt19970210</p>\n","text":"834930269@Zwt19970210","link":"","raw":null,"photos":[],"categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]},{"title":"Python Flask(四) Integration with the Python Shell","slug":"python-flask-integration-with-the-python-shell","date":"2017-10-10T02:14:17.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-integration-with-the-python-shell.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010101231.jpg","content":"<p>集成Python Shell,为了不每次启动都手动创建示例(比如from/import之类),所以调用这个. 但这个并不是给网站用的,是给开发者用的. 一开始我没太理解为什么要用这个包,后来看到了一个回答,很详细的:</p>\n<hr>\n<h3><span id=\"click-here-flask-script-内的shell-类-使用\"> ***</span></h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010101231.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010101231.jpg\" alt></a></p>\n","text":"集成Python Shell,为了不每次启动都手动创建示例(比如from/import之类),所以调用这个. 但这个并不是给网站用的,是给开发者用的. 一开始我没太理解为什么要用这个包,后来看到了一个回答,很详细的: *** [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}]}