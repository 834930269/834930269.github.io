{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"python3学习 多进程+进程池+进程间通信+子进程","slug":"python3-multiprocess","date":"2017-07-19T06:29:28.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-multiprocess.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:</strong></p>\n<ol>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/multiprocessing_test.py\" target=\"_blank\" rel=\"noopener\">multiprocessing_test.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E5%AD%90%E8%BF%9B%E7%A8%8B.py\" target=\"_blank\" rel=\"noopener\">子进程.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E8%BF%9B%E7%A8%8B%E6%B1%A0.py\" target=\"_blank\" rel=\"noopener\">进程池.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.py\" target=\"_blank\" rel=\"noopener\">进程间通信.py</a></strong></li>\n</ol>\n<p><strong>不贴代码了..略多.点上面得超链接进github↑↑</strong></p>\n","text":"【Source Code】 github:multiprocessing_test.py子进程.py进程池.py进程间通信.py不贴代码了..略多.点上面得超链接进github↑↑","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"UVa 10859","slug":"uva-10859","date":"2017-07-18T07:52:02.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/uva-10859.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10859\" target=\"_blank\" rel=\"noopener\">Placing Lampposts</a></strong> <strong>【题意】</strong> <strong>给你一个ｎ个点ｍ条边的无向无环图，在尽量少的节点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。</strong> <strong>在灯的总数最小的前提下，被两盏灯同时被照亮的边数应该尽量大。</strong> <strong>【题解】</strong> <strong>树形dp,Lrj P70。</strong> <strong>这题教会了我一个很有用的技巧：有两个所求的值要优化，比如让a尽量小，ｂ也尽量小</strong> <strong>那么可以转化为让 M*a+b尽量小，其中Ｍ应该是一个比“a的最大值和b的最小值之差”还要大的数</strong> <strong>最终的答案为ans/M, ans%M</strong> <strong>回到这题，要求放的灯总数最小，被两盏灯同时照亮的边数尽量大。</strong> <strong>因为每条边要么被一盏灯照亮，要么被两盏灯照亮，所以可以转换为：</strong> <strong>求：放的灯总数量最少，被一盏灯照亮的边数尽量少。</strong> <strong>就可以变成球 M*a+b 的最小值，ａ为放置的灯数量，ｂ为被一盏灯照的边数</strong> <strong>f[u][1]表示u点放灯时的整个子树最小值</strong> <strong>f[u][0]表示u点不放灯时的整个子树最小值</strong> <strong>如果u放，那么u个子结点可以选择放，也可以不放，选择其中较小的值。如果选的是不照，就要增加一条只有一个灯照的边</strong> <strong>如果u不放，那么其子结点就必须选择要放，而且每条边都只有一个灯照</strong> <strong>【Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVA%2010859.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10859.cpp</a></strong></p>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int T,n,m,vis[2000][2],d[2000][2];<br>vector Graph[1010];</p>\n<p>int dp(int i,int j,int f){<br>    if(vis[i][j]) return d[i][j];<br>    vis[i][j]=1;<br>    int&amp; ans=d[i][j];</p>\n<pre><code>ans=2000;\nfor(int k=0;k&lt;Graph\\[i\\].size();++k)** \n    if(Graph\\[i\\]\\[k\\]!=f) \n       ans+=dp(Graph\\[i\\]\\[k\\],1,i); \nif(!j &amp;&amp; f&gt;=0)  ans++;\n\nif(j || f&lt;0){\n    int sum=0;\n    for(int k=0;k&lt;Graph\\[i\\].size();++k) \n       if(Graph\\[i\\]\\[k\\]!=f) \n          sum+=dp(Graph\\[i\\]\\[k\\],0,i); \n    if(f&gt;=0) sum++;\n    ans=min(ans,sum);\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d”,&amp;n,&amp;m);<br>        for(int i=0;i&lt;n;++i) Graph[i].clear();<br>        for(int i=0;i&lt;m;++i){<br>            int x,y;<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            Graph[x].push_back(y);<br>            Graph[y].push_back(x);<br>        }<br>        memset(vis,0,sizeof(vis));<br>        int ans=0;<br>        for(int i=0;i&lt;n;++i){<br>            if(!vis[i][0])///新的一棵树<br>                ans+=dp(i,0,-1);<br>        }<br>        printf(“%d %d %d\\n”,ans/2000,m-ans%2000,ans%2000);<br>    }<br>    return 0;<br>}</p>\n","text":"【Topic Link】 Placing Lampposts 【题意】 给你一个ｎ个点ｍ条边的无向无环图，在尽量少的节点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。 在灯的总数最小的前提下，被两盏灯同时被照亮的边数应该尽量大。 【题解】 树形dp,Lrj P7","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"树形dp","slug":"UVa/树形dp","count":1,"path":"api/categories/UVa/树形dp.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"树形dp","slug":"树形dp","count":1,"path":"api/tags/树形dp.json"}]},{"title":"Educational Codeforces Round 25 B","slug":"educational-codeforces-round-25-b","date":"2017-07-16T18:37:23.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/educational-codeforces-round-25-b.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【题目】</p>\n<h2><span id=\"b-five-in-a-row\">B. Five-In-a-Row</span></h2><h5><span id=\"time-limit-per-test1-second-memory-limit-per-test256megabytes\">time limit: per test1 second memory limit: per test256megabytes</span></h5><h5><span id=\"input-standard-input-output-standard-output\">input: standard input output: standard output</span></h5><p>Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts. In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately. Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.</p>\n<p><strong>Input</strong></p>\n<p>You are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell. It is guaranteed that in the current arrangement nobody has still won.</p>\n<p><strong>Output</strong></p>\n<p>Print ‘YES’ if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print ‘NO’.</p>\n<p><strong>Examples</strong></p>\n<p><strong>Input</strong></p>\n<p>XX.XX…..<br>…..OOOO.<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….</p>\n<p><strong>Output</strong></p>\n<p>YES</p>\n<p><strong>Input</strong></p>\n<p>XXOXX…..<br>OO.O……<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….</p>\n<p><strong>Output</strong></p>\n<p>NO Link: <a href=\"http://codeforces.com/contest/825/problem/B\" target=\"_blank\" rel=\"noopener\">http://codeforces.com/contest/825/problem/B</a> 【题意】 X是否能在一步以内连成五子.可以则赢. 【题解】 数据量不大,枚举八个方向即可,注意,每次只能往一个方向走,不能拐弯.而且必须枚举八方向,不能只枚举向下的几个方向. 如果找到第一个五子,则往后就不需要计算了. 【Sourcr Code】 github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/Educational%20Codeforces%20Round%2025%20%20B.cpp\" target=\"_blank\" rel=\"noopener\">Educational Codeforces Round 25 B.cpp</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>char mp[11][11];<br>bool re;<br>int d[8][3]={ {0,1},{1,0},{1,1},{1,-1},{-1,1},{-1,-1},{0,-1},{-1,0}};</p>\n<p>bool check(int x,int i,int y,int j){<br>    if(x+i&gt;=0&amp;&amp;x+i&lt;10&amp;&amp;y+j&gt;=0&amp;&amp;y+j&lt;=10)<br>        return true;<br>    else return false;<br>}</p>\n<p>void dfs(int x,int y,int win,int ct,int dir){<br> //   if(dir==3)<br> //       printf(“(%d,%d):%d %d\\n”,x,y,win,dir);<br>    if(win==5 || re){re=true;return;}<br>    int i=d[dir][0],j=d[dir][1];<br>    if(check(x,i,y,j)){<br>        if(mp[x+i][y+j]==’X’) dfs(x+i,y+j,win+1,ct,dir);<br>        if(mp[x+i][y+j]==’.’ &amp;&amp; ct==0) dfs(x+i,y+j,win+1,1,dir);<br>    }<br>}</p>\n<p>int main(){<br>    re=false;<br>    for(int i=0;i&lt;10;++i)<br>        gets(mp[i]);<br>    for(int i=0;i&lt;10;++i){<br>        if(re)break;<br>        for(int j=0;j&lt;10;++j){<br>            if(mp[i][j]==’X’){<br>                for(int k=0;k&lt;8;++k){<br>                    dfs(i,j,1,0,k);<br>                    if(re)break;<br>                }<br>                if(re)break;<br>            }<br>        }<br>    }<br>    if(re)printf(“YES\\n”);<br>    else printf(“NO\\n”);<br>    return 0;<br>}</p>\n<p>/**<br>….X…..<br>…X.OOOO.<br>..X…….<br>.X……..<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>**/</p>\n","text":"【题目】B. Five-In-a-Rowtime limit: per test1 second memory limit: per test256megabytesinput: standard input output: standard outputAlice and Bo","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"},{"name":"dfs","slug":"Codeforce/dfs","count":1,"path":"api/categories/Codeforce/dfs.json"},{"name":"图论","slug":"Codeforce/dfs/图论","count":1,"path":"api/categories/Codeforce/dfs/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]},{"title":"Educational Codeforces Round 25 A","slug":"educational-codeforces-round-25-a-cpp","date":"2017-07-16T18:26:21.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/educational-codeforces-round-25-a-cpp.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题目以及连接】</strong></p>\n<h2><span id=\"a-binary-protocol\">A. Binary Protocol</span></h2><h5><span id=\"time-limit-per-test1-second\">time limit per test:1 second</span></h5><h5><span id=\"memory-limit-per-test256-megabytes\">memory limit per test:256 megabytes</span></h5><h5><span id=\"input-standard-input\">input: standard input</span></h5><h5><span id=\"output-standard-output\">output: standard output</span></h5><p>Polycarp has just invented a new binary protocol for data transmission. He is encoding positive integer decimal number to binary string using following algorithm:</p>\n<ul>\n<li>Each digit is represented with number of ‘1’ characters equal to the value of that digit (for 0 it is zero ones).</li>\n<li>Digits are written one by one in order corresponding to number and separated by single ‘0’ character.</li>\n</ul>\n<p>Though Polycarp learnt how to encode the numbers, he has no idea how to decode them back. Help him calculate the decoded number.</p>\n<p><strong>Input</strong></p>\n<p>The first line contains one integer number <em>n</em> (1 ≤ <em>n</em> ≤ 89) — length of the string <em>s</em>. The second line contains string <em>s</em> — sequence of ‘0’ and ‘1’ characters, number in its encoded format. It is guaranteed that the number corresponding to the string is positive and doesn’t exceed 109. The string always starts with ‘1’.</p>\n<p><strong>Output</strong></p>\n<p>Print the decoded number.</p>\n<p><strong>Examples</strong></p>\n<p><strong>Input</strong></p>\n<p>3<br>111</p>\n<p><strong>Output</strong></p>\n<p>3</p>\n<p><strong>Input</strong></p>\n<p>9<br>110011101</p>\n<p><strong>Output</strong></p>\n<p>2031 Link: <a href=\"http://codeforces.com/contest/825/problem/A\" target=\"_blank\" rel=\"noopener\">Codeforce Educational Codeforces Round 25 A</a> <strong>【题意】</strong> 给出一串二进制字符串,翻译成原来的数字.规则为数字间以单独的0为分隔符.多余的0当做一个0输出,最后有几个0输出几个0. (后面那个意思蒙出来的,英语渣,有点没搞懂最后一个条件是为什么). <strong>【题解】</strong> 逐位记录即可. <strong>【Source Code】</strong> github:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/Educational%20Codeforces%20Round%2025%20%20A.cpp\" target=\"_blank\" rel=\"noopener\">Educational Codeforces Round 25 A.cpp –忽然发现–原来链接中有空格使用%20处理的.但是空格多了,复制的时候不会复制上%20..要手敲</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int n;<br>    while(~scanf(“%d”,&amp;n)){<br>        char digit,pre=’0’;<br>        int cnt=0;<br>        for(int i=0;i&lt;n;++i){<br>            cin&gt;&gt;digit;<br>            if(digit==’1’) cnt++;<br>            if(digit==’0’) {printf(“%d”,cnt);cnt=0;}<br>        }<br>        if(digit==’1’) printf(“%d”,cnt);<br>        if(digit==’0’) printf(“0”);<br>        printf(“\\n”);<br>    }<br>    return 0;<br>}</p>\n","text":"【题目以及连接】A. Binary Protocoltime limit per test:1 secondmemory limit per test:256 megabytesinput: standard inputoutput: standard outputPolycar","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"},{"name":"未分类","slug":"Codeforce/未分类","count":1,"path":"api/categories/Codeforce/未分类.json"},{"name":"枚举","slug":"Codeforce/未分类/枚举","count":1,"path":"api/categories/Codeforce/未分类/枚举.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"},{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"}]},{"title":"python3学习 enumerate","slug":"python3-enumerate","date":"2017-07-16T09:01:37.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-enumerate.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/enumerate.py\" target=\"_blank\" rel=\"noopener\">enumerate.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[15]:</p>\n<p>from enum import Enum<br>Month=Enum(‘Months’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘Jun’, ‘Jul’, ‘Aug’, ‘Sep’, ‘Oct’, ‘Nov’, ‘Dec’))<br>for name,member in Month.__members__.items():<br>    print(name,’=&gt;’,member,’,’,member.value)</p>\n<p># In[17]:</p>\n<p>#如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：<br>from enum import unique<br>@unique<br>class WeekDay(Enum):<br>    Sun = 0 # Sun的value被设定为0<br>    Mon = 1<br>    Tue = 2<br>    Wed = 3<br>    Thu = 4<br>    Fri = 5<br>    Sat = 6</p>\n<p>#@unique装饰器可以帮助我们检查保证没有重复值。<br>day1=WeekDay.Mon<br>print(day1)<br>print(WeekDay[‘Tue’])<br>print(WeekDay.Tue.value)<br>print(day1 == WeekDay.Mon)<br>print(day1 == WeekDay.Tue)<br>print(WeekDay(1))</p>\n<p>for name,member in WeekDay.__members__.items():<br>    print(name,’=&gt;’,member,member.value)</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: enumerate.py **# coding: utf-8# In[15]:from enum import Enum<br>Month=Enum(‘Months’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 定制类","slug":"python3-str-getatr","date":"2017-07-16T08:33:50.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-str-getatr.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:<a href=\"https://github.com/834930269/python_study/blob/master/oop/%E5%AE%9A%E5%88%B6%E7%B1%BB.py\" target=\"_blank\" rel=\"noopener\">定制类.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[3]:</p>\n<p>#__str__<br>class student(object):<br>    def __init__(self,name):<br>        self.name=name<br>    def __str__(self):<br>        return ‘Student object (name: %s)’ % self.name<br>    __repr__=__str__<br>s=student(‘Michael’)</p>\n<p>#__str__是控制打印时输出类型,__repr__是控制台直接s输出的类型</p>\n<p>#如果不重写,那会输出&lt;__main__.Student object at 地址&gt;<br>s<br>print(s)</p>\n<p># In[10]:</p>\n<p>#__iter__<br>‘’’<br>如果一个类想被用于for … in循环，类似list或tuple那样，就必<br>须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python<br>的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个<br>值，直到遇到StopIteration错误时退出循环。</p>\n<p>斐波那契:<br>‘’’<br>class Fib(object):<br>    def __init__(self):<br>        self.a, self.b = 0, 1 # 初始化两个计数器a，b</p>\n<pre><code>def \\_\\_iter\\_\\_(self):\n    return self # 实例本身就是迭代对象，故返回自己\n\ndef \\_\\_next\\_\\_(self):\n    self.a, self.b = self.b, self.a + self.b # 计算下一个值\n    if self.a &gt; 100000: # 退出循环的条件\n        raise StopIteration()\n    return self.a # 返回下一个值\ndef \\_\\_getitem\\_\\_(self, n):\n    if isinstance(n, int): # n是索引\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n    if isinstance(n, slice): # n是切片\n        start = n.start\n        stop = n.stop\n        if start is None:\n            start = 0\n        a, b = 1, 1\n        L = \\[\\]\n        for x in range(stop):\n            if x &gt;= start:\n                L.append(a)\n            a, b = b, a + b\n        return L</code></pre><p>for i in Fib():<br>    print(i)</p>\n<p># In[14]:</p>\n<p>#__getitem__</p>\n<p>#Fib实例虽然能作用于for循环，看起来和list有点像，</p>\n<p>#但是，把它当成list来使用还是不行</p>\n<p>#要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：<br>f=Fib()<br>print(f[0],f[1],f[2],f[100])<br>‘’’<br>但是list有个神奇的切片方法：</p>\n<blockquote>\n<blockquote>\n<p>&gt; list(range(100))[5:10]<br>[5, 6, 7, 8, 9]</p>\n</blockquote>\n</blockquote>\n<p>对于Fib却报错。原因是__getitem__()传入的参数<br>可能是一个int，也可能是一个 切片对象slice ，所以要做判断：</p>\n<p>class Fib(object):<br>    def __getitem__(self, n):<br>        if isinstance(n, int): # n是索引<br>        if isinstance(n, slice): # n是切片<br>‘’’<br>print(f[:20])#但是没有判断倒序切片以及没有对step参数作处理：</p>\n<p>‘’’<br>此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以<br>作key的object，例如str。</p>\n<p>与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋<br>值。最后，还有一个__delitem__()方法，用于删除某个元素。</p>\n<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的<br>list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”<br>，不需要强制继承某个接口。<br>‘’’</p>\n<p># In[18]:</p>\n<p>#__getattr__</p>\n<p>#正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：<br>class Student(object):<br>    def __init__(self):<br>        self.name = ‘Michael’<br>    def __getattr__(self, attr):<br>        if attr==’score’:<br>            return 99<br>        if attr==’age’:<br>            return lambda: 25<br>        raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)</p>\n<p>#调用name属性，没问题，但是，调用不存在的score属性，就有问题了<br>‘’’</p>\n<blockquote>\n<blockquote>\n<p>&gt; s = Student()<br>&gt; print(s.name)<br>Michael<br>&gt; print(s.score)<br>Traceback (most recent call last):<br>  …<br>AttributeError: ‘Student’ object has no attribute ‘score’<br>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>\n</blockquote>\n</blockquote>\n<p>要避免这个错误，除了可以加上一个score属性外，Python还有另<br>一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：<br>class Student(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self):\n    self.name = &apos;Michael&apos;\n\ndef \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;score&apos;:\n        return 99</code></pre><p>返回函数也是完全可以的：<br>class Student(object):</p>\n<pre><code>def \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;age&apos;:\n        return lambda: 25</code></pre><p>只是调用方式要变为：</p>\n<blockquote>\n<blockquote>\n<p>&gt; s.age()<br>25<br>注意，只有在没有找到属性的情况下，才调用__getattr__，<br>已有的属性，比如name，不会在__getattr__中查找。</p>\n</blockquote>\n</blockquote>\n<p>此外，注意到任意调用如s.abc都会返回None，这是因为我们<br>定义的__getattr__默认返回就是None。要让class只响应特定<br>的几个属性，我们就要按照约定，抛出AttributeError的错误：<br>raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)<br>‘’’<br>s=Student()<br>print(s.name,s.score,s.age())</p>\n<p># In[19]:</p>\n<p>‘’’<br>举个例子：</p>\n<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>\n<pre><code>http://api.server/user/friends\nhttp://api.server/user/timeline/list</code></pre><p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>\n<p>利用完全动态的__getattr__，我们可以写出一个链式调用：<br>‘’’<br>class Chain(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self, path=&apos;&apos;):\n    self._path = path\n\ndef \\_\\_getattr\\_\\_(self, path):\n    return Chain(&apos;%s/%s&apos; % (self._path, path))\n\ndef \\_\\_str\\_\\_(self):\n    return self._path\n\n\\_\\_repr\\_\\_ = \\_\\_str\\_\\_</code></pre><p>#try<br>print(Chain().status.user.timeline.list)</p>\n<p>#out[]: /status/user/timeline/list</p>\n<p>#这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，</p>\n<p>#而且，不随API的增加而改变！</p>\n<p>#还有些REST API会把参数放到URL中，比如GitHub的API：</p>\n<p>#GET /users/:user/repos</p>\n<p>#调用时，需要把:user替换为实际用户名。</p>\n<p># In[21]:</p>\n<p>#__call__<br>class Student(object):<br>    def __init__(self, name):<br>        self.name = name</p>\n<pre><code>def \\_\\_call\\_\\_(self):\n    print(&apos;My name is %s.&apos; % self.name)</code></pre><p>s = Student(‘Michael’)<br>s()</p>\n<p># In[29]:</p>\n<p>print(callable(max),callable(map),callable(str),callable(‘123’))</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github:定制类.py **# coding: utf-8# In[3]:#__str__<br>class student(object):<br>    def __init__(self,name):<br>        self.name","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 oop-多重继承+MixIn","slug":"python3-oop-mixin","date":"2017-07-16T05:56:37.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-oop-mixin.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/Multi%20inheritance.py\" target=\"_blank\" rel=\"noopener\">Multi inheritance.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：<br>class Animal(object):<br>    pass</p>\n<p># 大类:<br>class Mammal(Animal):<br>    pass</p>\n<p>class Bird(Animal):<br>    pass</p>\n<p># 各种动物:<br>class Dog(Mammal):<br>    pass</p>\n<p>class Bat(Mammal):<br>    pass</p>\n<p>class Parrot(Bird):<br>    pass</p>\n<p>class Ostrich(Bird):<br>    pass</p>\n<p>#现在，我们要给动物再加上Runnable和Flyable的功能，</p>\n<p>#只需要先定义好Runnable和Flyable的类：<br>class Runnable(object):<br>    def run(self):<br>        print(‘Running…’)</p>\n<p>class Flyable(object):<br>    def fly(self):<br>        print(‘Flying…’)</p>\n<p>#对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：<br>class Dog(Mammal, Runnable):<br>    pass</p>\n<p>#对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：<br>class Bat(Mammal, Flyable):<br>    pass</p>\n<p>#通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>\n<p># In[4]:</p>\n<p>‘’’<br>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<br>Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多<br>重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继<br>承Runnable。这种设计通常称之为MixIn。</p>\n<p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn<br>和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和<br>植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>\n<p>class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):<br>    pass<br>‘’’</p>\n<p>‘’’<br>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>\n<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>\n<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>\n<p>class MyTCPServer(TCPServer, ForkingMixIn):<br>    pass</p>\n<p>编写一个多线程模式的UDP服务，定义如下：</p>\n<p>class MyUDPServer(UDPServer, ThreadingMixIn):<br>    pass</p>\n<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>\n<p>class MyTCPServer(TCPServer, CoroutineMixIn):<br>    pass</p>\n<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>\n<p>‘’’</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: Multi inheritance.py **# coding: utf-8# In[1]:#采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：<br>class Animal(object):<br>    pass# 大类:<","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 @property","slug":"python3-property","date":"2017-07-16T05:36:11.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-property.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/property.py\" target=\"_blank\" rel=\"noopener\">property.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[2]:</p>\n<p>‘’’<br>还记得装饰器（decorator）可以给函数动态加上功能吗？<br>对于类的方法，装饰器一样起作用。Python内置的@property<br>装饰器就是负责把一个方法变成属性调用的：<br>‘’’<br>class Student(object):<br>    @property<br>    def score(self):<br>        return self._score<br>    @score.setter<br>    def score(self,value):<br>        if not isinstance(value,int):<br>            raise ValueError(‘score must be an integer!’)<br>        if value &lt; 0 or value &gt; 100:<br>            raise ValueError(‘score must between 0 ~ 100!’)<br>        self._score = value<br>‘’’<br>@property的实现比较复杂，我们先考察如何使用。把一个getter方<br>法变成属性，只需要加上@property就可以了，此时，@property本身<br>又创建了另一个装饰器@score.setter，负责把一个setter方法变成属<br>性赋值，于是，我们就拥有一个可控的属性操作：</p>\n<p>相当于 Get Set<br>‘’’<br>a=Student()<br>a.score = 60 # OK，实际转化为a.set_score(60)<br>print(a.score)# OK，实际转化为s.get_score()</p>\n<p># In[3]:</p>\n<p>#a.score=9999  ValueError(‘score must between 0 ~ 100!’)</p>\n<p>#还可以定义只读属性，只定义getter方法，不定义setter方法</p>\n<p>#就是一个只读属性：<br>class Student(object):</p>\n<pre><code>@property\ndef birth(self):\n    return self._birth\n\n@birth.setter\ndef birth(self, value):\n    self._birth = value\n\n@property\ndef age(self):\n    return 2015 - self._birth</code></pre><p>#上面的birth是可读写属性，而age就是一个只读属性，因为age</p>\n<p>#可以根据birth和当前时间计算出来。</p>\n<p>‘’’<br>练习</p>\n<p>请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：<br>‘’’<br>class Screen(object):<br>    @property<br>    def width(self):<br>        return self._width<br>    @width.setter<br>    def width(self,value):<br>        self._width=value<br>    @property<br>    def height(self):<br>        return self._height<br>    @height.setter<br>    def height(self,value):<br>        self._height=value<br>    @property<br>    def resolution(self):<br>        return self.width*self.height<br># test:<br>s = Screen()<br>s.width = 1024<br>s.height = 768<br>print(s.resolution)<br>assert s.resolution == 786432, ‘1024 * 768 = %d ?’ % s.resolution</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: property.py**# coding: utf-8# In[2]:‘’’<br>还记得装饰器（decorator）可以给函数动态加上功能吗？<br>对于类的方法，装饰器一样起作用。Python内置的@property<br>装饰器","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 __slots__","slug":"python3-slots","date":"2017-07-16T04:40:11.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-slots.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/slots.py\" target=\"_blank\" rel=\"noopener\">slots.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[6]:</p>\n<p>class Student(object):<br>    pass<br>s=Student()<br>s.name=’Michael’<br>print(s.name)</p>\n<p>#还可以尝试给实例绑定一个方法：<br>def set_age(self,age):<br>    self.age=age<br>from types import MethodType<br>s.set_age=MethodType(set_age,s)#绑定方法<br>s.set_age(25)<br>print(s.age)</p>\n<p>#但是，给一个实例绑定的方法，对另一个实例是不起作用的：<br>s2=Student()</p>\n<p>#s2.set_age(25)</p>\n<p># In[8]:</p>\n<p>#为了给所有实例都绑定方法，可以给class绑定方法：<br>def set_score(self,score):<br>    self.score=score<br>Student.set_score=set_score</p>\n<p>#给class绑定方法后，所有实例均可调用：<br>s.set_score(20)<br>s2.set_score(30)<br>print(s.score,s2.score)</p>\n<p># In[9]:</p>\n<p>#使用__slots__</p>\n<p>#但是，如果我们想要限制实例的属性怎么办？比如，</p>\n<p>#只允许对Student实例添加name和age属性。</p>\n<p>#为了达到限制的目的，Python允许在定义class的时候，</p>\n<p>#定义一个特殊的__slots__变量，来限制该class实例能添加的属性：<br>class student(object):<br>    __slots__ = (‘name’, ‘age’) # 用tuple定义允许绑定的属性名称<br>s=student()<br>s.name=’Michael’<br>s.age=8</p>\n<p>#s.score=20#AttributeError</p>\n<p># In[10]:</p>\n<p>#使用__slots__要注意，__slots__定义的属性仅</p>\n<p>#对当前类实例起作用，对继承的子类是不起作用的：<br>class GraduateStudent(student):<br>    pass<br>g = GraduateStudent()<br>g.score=9999#没抛异常</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: slots.py **# coding: utf-8# In[6]:class Student(object):<br>    pass<br>s=Student()<br>s.name=’Michael’<br>print(s.nam","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 多态和继承","slug":"python3-inheritance-and-polymorphisn","date":"2017-07-15T16:44:40.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/python3-inheritance-and-polymorphisn.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Inheritance_and_polymorphisn.py\" target=\"_blank\" rel=\"noopener\">Inheritance_and_polymorphisn.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[5]:</p>\n<p>‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称为子类（Subclass），而被继<br>承的class称为基类、父类或超类（Base class、Super class）。<br>‘’’</p>\n<p>#比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：<br>class Animal(object):<br>    def run(self):<br>        print(‘Animal is running…’)</p>\n<p>#当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：<br>class Dog(Animal):<br>    pass<br>class Cat(Animal):<br>    pass<br>‘’’<br>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是<br>它的子类。Cat和Dog类似。</p>\n<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由<br>于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什<br>么事也没干，就自动拥有了run()方法：<br>‘’’<br>dog=Dog()<br>dog.run()<br>cat=Cat()<br>cat.run()</p>\n<p>#当子类和父类都存在相同的run()方法时，我们说，</p>\n<p>#子类的run()覆盖了父类的run()，在代码运行的时候，</p>\n<p>#总是会调用子类的run()。这样，我们就获得了继承的</p>\n<p>#另一个好处：多态。<br>class Puppy(Animal):<br>    def run(self):<br>        print(‘Puppy is running…’)<br>class Shark(Animal):<br>    def run(self):<br>        print(‘Shark is running…’)<br>puppy=Puppy()<br>puppy.run()</p>\n<p># In[7]:</p>\n<p>#判断一个变量是否是某个类型可以用isinstance()判断：</p>\n<p>#可以发现,puppy可以使Animal也可以是Puppy.<br>print(isinstance(puppy,Animal))<br>print(isinstance(puppy,Puppy))<br>b=Animal()<br>print(isinstance(b,Puppy))</p>\n<p>#所以，在继承关系中，如果一个实例的数据类型是某个子类</p>\n<p>#，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p>\n<p># In[12]:</p>\n<p>#要理解多态的好处，我们还需要再编写一个函数，这个函数接受</p>\n<p>#一个Animal类型的变量：<br>def run_twice(animal):<br>    animal.run()<br>    animal.run()<br>run_twice(Dog())<br>run_twice(Puppy())<br>run_twice(Shark())</p>\n<p># In[ ]:</p>\n<p>‘’’<br>多态的好处在于:</p>\n<p>新增一个Animal的子类，不必对  –run_twice()–<br>做任何修改，实际上，任何依赖Animal作为参数的函<br>数或者方法都可以不加修改地正常运行，原因就在于<br>多态。</p>\n<p>著名的“开闭”原则：</p>\n<p>对扩展开放：允许新增Animal子类；</p>\n<p>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则<br>传入的对象必须是Animal类型或者它的子类，否则，将无法调用<br>run()方法。</p>\n<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。<br>我们只需要保证传入的对象有一个run()方法就可以了：</p>\n<p>class Timer(object):<br>    def run(self):<br>        print(‘Start…’)</p>\n<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一<br>个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看<br>做是鸭子。<br>‘’’**</p>\n","text":"【Source Code】 github: Inheritance_and_polymorphisn.py **# coding: utf-8# In[5]:‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}]}