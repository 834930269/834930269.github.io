{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"2017多校训练1 HDU 6043 KazaQ's Socks","slug":"2017-hdu-6043-kazaqs-socks","date":"2017-07-27T15:46:42.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6043-kazaqs-socks.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6043\" title=\"KazaQ&#39;s Socks\" target=\"_blank\" rel=\"noopener\">KazaQ’s Socks</a> 题意:穿袜子,洗袜子,求洗了多少次袜子…:sweat_smile: 题解:无 github: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6043\" title=\"KazaQ&#39;s Socks\" target=\"_blank\" rel=\"noopener\">KazaQ’s Socks</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    long long a,b,ans,kase=0;\n    while(~scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b)){\n        if(b&lt;=a){\n            printf(&quot;Case #%lld: %lld\\n&quot;,++kase,b);\n            continue;\n        }else{\n            long long loop=(a-1)&lt;&lt;1,rg=b-a;\n            long long res=rg%loop;\n            if(res==a-1) ans=a-1;\n            else if(res==0) ans=a;\n            else\n                ans=res&gt;a-1?res-a+1:res;\n            printf(&quot;Case #%lld: %lld\\n&quot;,++kase,ans);\n        }\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:KazaQ’s Socks 题意:穿袜子,洗袜子,求洗了多少次袜子…:sweat_smile: 题解:无 github: :point_right:KazaQ’s Socks#include&lt;bits/stdc++.h&gt;using","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"}]},{"title":"2017多校训练1 HDU 6034 Balala Power!","slug":"2017-hdu-6034-balala-power","date":"2017-07-27T15:41:01.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6034-balala-power.json","excerpt":"","keywords":null,"cover":"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg","content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6034\" title=\"Balala Power!\" target=\"_blank\" rel=\"noopener\">Balala Power!</a> <a href=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" title=\"Balala\" target=\"_blank\" rel=\"noopener\"><img src=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" alt=\"Balala\" title=\"Balala\"></a> 题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可以有前导0,规则是为0的字符不能位于len&gt;1的字符串的开头. 题解: 统计每个字符的总结果,排序,最大的字符赋值25,然后依次往下赋值.然后判断前导0,找到第一个可以为0的存在的字符,将它赋值为0,之后其他的左移一位.(出现前导0的情况表示26个字符都已经出现了). github: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/1/1002.cpp\" title=\"1002.cpp\" target=\"_blank\" rel=\"noopener\">1002.cpp</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1e5+5;\nconst int mod=1e9+7;\nstruct star{\n    int reg[100005];\n    bool vi;\n    int c;\n    bool operator &lt; (const star &amp;A)const{\n        for(int i=maxn-1;i&gt;=0;--i){\n            if(reg[i]&gt;A.reg[i]) return 1;\n            else if(reg[i]&lt;A.reg[i]) return 0;\n            else continue;\n        }\n    }\n}ch[30];\nchar str[100005];\nint Hash[30];///字符-权值映射\nlong long ans,fac[100005];\ninline void init(){\n    for(int i=0;i&lt;27;++i){\n        memset(ch[i].reg,0,sizeof(ch[i].reg));\n        ch[i].vi=true;\n        ch[i].c=0;\n    }\n    ans=0;\n}\nint main(){\n    int n,len,p,kase=0;\n    fac[0]=1;///预先处理26^i;\n    for(int i=1;i&lt;maxn;++i)\n        fac[i]=fac[i-1]*26%mod;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        init();\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            len=strlen(str);\n            for(int j=0;j&lt;len;++j){\n                p=str[j]-&apos;a&apos;;\n                ch[p].reg[len-j-1]++;\n            }\n            if(len&gt;1)\n                ch[str[0]-&apos;a&apos;].vi=false;\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                if(ch[i].reg[j]&gt;=26){\n                    ch[i].reg[j+1]+=ch[i].reg[j]/26;\n                    ch[i].reg[j]%=26;\n                }\n            }\n            ch[i].c=i;\n        }\n        sort(ch,ch+26);\n        for(int i=0;i&lt;26;++i)\n            Hash[ch[i].c]=26-i-1;\n        for(int i=25;i&gt;=0;--i){///从最小的开始判断是否可以为0\n            if(ch[i].vi){\n                for(int j=25;j&gt;i;--j)\n                    Hash[ch[j].c]=Hash[ch[j-1].c];\n                Hash[ch[i].c]=0;\n                break;\n            }\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                ans=(ans+fac[j]*ch[i].reg[j]*Hash[ch[i].c]%mod)%mod;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:Balala Power!  [Figure]  题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]},{"title":"2017多校训练1 HDU 6033 Add More Zero","slug":"2017-hdu-6033-add-more-zero","date":"2017-07-27T13:56:28.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6033-add-more-zero.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6033\" title=\"HDU: Problem-6033\" target=\"_blank\" rel=\"noopener\">HDU: Problem-6033</a> 题意/解: 求m*log10(2) github: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/1/A.cpp\" title=\"A.cpp\" target=\"_blank\" rel=\"noopener\">A.cpp</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int kase=0;\n    double t=log(2)/log(10),n;\n    while(~scanf(&quot;%lf&quot;,&amp;n)){\n        int a=n*t;\n        printf(&quot;Case #%d: %d\\n&quot;,++kase,a);\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:HDU: Problem-6033 题意/解: 求m*log10(2) github: :point_right:A.cpp#include&lt;bits/stdc++.h&gt;using namespace std;int main()","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"未分类","slug":"2017多校/未分类","count":1,"path":"api/categories/2017多校/未分类.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"}]},{"title":"python3学习 UDP+TCP-IP编程","slug":"python3-udptcp-ip","date":"2017-07-26T14:19:14.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-udptcp-ip.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: —-TCP: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/TCP-IP/echo-server.py\" title=\"服务端: echo-server.py\" target=\"_blank\" rel=\"noopener\">服务端: echo-server.py</a> 2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/TCP-IP/echo-client.py\" title=\"客户端: echo-client.py\" target=\"_blank\" rel=\"noopener\">客户端: echo-client.py</a> —-UDP: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/UDP/echo-server.py\" title=\"服务端: echo-server.py\" target=\"_blank\" rel=\"noopener\">服务端: echo-server.py</a> 2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/UDP/echo-client.py\" title=\"客户端: echo-client.py\" target=\"_blank\" rel=\"noopener\">客户端: echo-client.py</a> 【TCP】 服务端:</p>\n<pre><code>import socket,threading,time\n\n#协议IPV4 后者是基于流的TCP\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n\n#绑定,监听端口\ns.bind((&apos;127.0.0.1&apos;,9999))\n\n#最大连接数为5\ns.listen(5)\nprint(&apos;Watting for connection...&apos;)\n\ndef tcplink(sock,addr):\n    print(&apos;Accpet new connection from %s:%s...&apos; % addr)\n    sock.send(b&apos;Welcome!&apos;)\n    while True:\n        data=sock.recv(1024)\n        time.sleep(1)\n        if not data or data.decode(&apos;utf-8&apos;)==&apos;exit&apos;:\n            break\n        sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;))\n    sock.close()\n    print(&apos;Connection from %s:%s closed.&apos; % addr)\n\nwhile True:\n    #接受一个连接\n    sock,addr=s.accept()\n    #创建新线程来处理TCP连接\n    t=threading.Thread(target=tcplink,args=(sock,addr))\n    t.start()</code></pre><p>客户端:</p>\n<pre><code>import socket\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n#建立连接\ns.connect((&apos;127.0.0.1&apos;,9999))\n#接受欢迎消息\nprint(s.recv(1024).decode(&apos;utf-8&apos;))\nfor data in [b&apos;Michael&apos;,b&apos;Tracy&apos;,b&apos;Sarah&apos;]:\n    #发送数据:\n    s.send(data)\n    print(s.recv(1024).decode(&apos;utf-8&apos;))\ns.send(b&apos;exit&apos;)\ns.close</code></pre><p>【UDP】 服务端:</p>\n<pre><code>import socket,threading,time\n\n#IPV4,UDP\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n#绑定端口\ns.bind((&apos;127.0.0.1&apos;,9999))\nprint(&apos;Bind UDP on 9999...&apos;)\n\ndef udplink(data,addr):\n    s.sendto(b&apos;Hello, %s!&apos; % data,addr)\n\nwhile True:\n    #接收数据\n    #recvfrom()方法返回数据和客户端的地址与端口\n    data,addr=s.recvfrom(1024)\n    t=threading.Thread(target=udplink,args=(data,addr))\n    time.sleep(1)\n    t.start()</code></pre><p>客户端:</p>\n<pre><code>import socket\n\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n\nfor data in [b&apos;Michael&apos;,b&apos;Tracy&apos;,b&apos;Sarah&apos;]:\n    #发送数据\n    s.sendto(data,(&apos;127.0.0.1&apos;,9999))\n    #接收数据\n    print(s.recv(1024).decode(&apos;utf-8&apos;))\ns.close()</code></pre>","text":"【Source Code】 github: —-TCP: 1.:point_right:服务端: echo-server.py 2.:point_right:客户端: echo-client.py —-UDP: 1.:point_right:服务端: echo-server.py","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 GUI","slug":"python3-gui","date":"2017-07-24T15:35:45.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-gui.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 Tkinter library is this demo’s library. github: :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/GUI/GUI-tk.py\" title=\"GUI-tk.py\" target=\"_blank\" rel=\"noopener\">GUI-tk.py</a></p>\n<pre><code>from tkinter import *\nimport tkinter.messagebox as messagebox\n\nclass Application(Frame):\n    def __init__(self,master=None):\n        Frame.__init__(self,master)\n        self.pack()\n        self.createWidgets()\n\n    def createWidgets(self):\n        self.nameInput=Entry(self)\n        self.nameInput.pack()\n        self.alertButton=Button(self,text=&apos;Hello&apos;,command=self.hello)\n        self.alertButton.pack()\n        self.helloLabel=Label(self,text=&apos;Hello,world!&apos;)\n        self.helloLabel.pack()\n        self.quitButton=Button(self,text=&apos;Quit&apos;,command=self.quit)\n        self.quitButton.pack()\n    def hello(self):\n        name=self.nameInput.get() or &apos;world&apos;\n        messagebox.showinfo(&apos;Message&apos;,&apos;Hello, %s&apos; % name)\napp=Application()\n#设置窗口标题\napp.master.title(&apos;Hello World&apos;)\n#启动消息循环\napp.mainloop()</code></pre>","text":"【Source Code】 Tkinter library is this demo’s library. github: :point_right:GUI-tk.pyfrom tkinter import *import tkinter.messagebox as messag","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 PIL图像处理库","slug":"python3-pillow","date":"2017-07-24T10:42:57.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-pillow.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi.py\" title=\"pi.py\" target=\"_blank\" rel=\"noopener\">pi.py</a></p>\n<pre><code>from PIL import Image\n\n#打开一个jpg文件,是当前路径\nim=Image.open(&apos;test.jpg&apos;)\n#获得图像尺寸\nw,h=im.size\nprint(&apos;Original Image size: %sx%s&apos; % (w,h))\n#缩放到50%\nim.thumbnail((w//2,h//2))\nprint(&apos;Resize image to: %sx%s&apos; %(w//2,h//2))\n#把缩放后的图像用jpeg保存\nim.save(&apos;thumbnail.jpg&apos;,&apos;jpeg&apos;)</code></pre><p>2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi2.py\" title=\"pi2.py\" target=\"_blank\" rel=\"noopener\">pi2.py</a></p>\n<pre><code>from PIL import Image,ImageFilter\n#打开一个文件,当前路径\nim=Image.open(&apos;test.jpg&apos;)\n#应用模糊滤镜\nim2=im.filter(ImageFilter.BLUR)\nim2.save(&apos;blur.jpg&apos;,&apos;jpeg&apos;)</code></pre><p>3.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi3.py\" title=\"pi3.py\" target=\"_blank\" rel=\"noopener\">pi3.py</a></p>\n<pre><code>from PIL import Image,ImageDraw,ImageFont,ImageFilter\n\nimport random\n\n#随机字母\ndef rndChar():\n    return chr(random.randint(65,90))\n#随机颜色1;\ndef rndColor():\n    return (random.randint(64,255),random.randint(64,255),random.randint(64,255))\n#随机颜色2\ndef rndColor2():\n    return (random.randint(32,255),random.randint(32,255),random.randint(32,255))\n\n#240*60\nwidth=240\nheight=60\nimage=Image.new(&apos;RGB&apos;,(width,height),(255,255,255))\n#穿件Font对象\nfont=ImageFont.truetype(&apos;Arial.ttf&apos;,36)\n#创建Draw对象\ndraw=ImageDraw.Draw(image)\n#填充每个像素\nfor x in range(width):\n    for y in range(height):\n        draw.point((x,y),fill=rndColor())\n#输出文字\nfor t in range(4):\n    draw.text((60*t+10,10),rndChar(),font=font,fill=rndColor2())\n#模糊:\nimage=image.filter(ImageFilter.BLUR)\nimage.save(&apos;code.jpg&apos;,&apos;jpeg&apos;)</code></pre>","text":"【Source Code】 github: 1.:point_right:pi.pyfrom PIL import Image#打开一个jpg文件,是当前路径im=Image.open(&apos;test.jpg&apos;)#获得图像尺寸w,h=im.sizeprint(&a","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 常用模块","slug":"python3-useful-moudle","date":"2017-07-21T16:06:17.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-useful-moudle.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: 1. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/Base64.py\" title=\"Base64.py\" target=\"_blank\" rel=\"noopener\">Base64</a> 2. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/MD5%E5%8A%A0%E5%AF%86%E5%AF%86%E7%A0%81.py\" title=\"MD5加密密码.py\" target=\"_blank\" rel=\"noopener\">MD5加密密码.py</a> 3. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/SAX%E8%A7%A3%E6%9E%90XML.py\" title=\"SAX解析XML.py\" target=\"_blank\" rel=\"noopener\">SAX解析XML.py</a> 4. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/With%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86.py\" title=\"with语法实现模块管理.py\" target=\"_blank\" rel=\"noopener\">with语法实现模块管理.py</a> 5. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/datetime_M.py\" title=\"datetime.py\" target=\"_blank\" rel=\"noopener\">datetime.py</a></p>\n","text":"【Source Code】 github: 1. :point_right:Base64 2. :point_right:MD5加密密码.py 3. :point_right:SAX解析XML.py 4. :point_right:with语法实现模块管理.py 5. :poin","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 正则表达式","slug":"python3-regular-expression","date":"2017-07-20T12:42:52.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-regular-expression.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】</p>\n<ul>\n<li><p>:point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Regular%20Expression\" title=\"Regular Expression模块\" target=\"_blank\" rel=\"noopener\">Regular Expression模块</a></p>\n<p>s=’ABC\\-001’#对应正则表达式字符串为’ABC-001’<br>#因为python本身需要转义,但用 r 前缀的话,就可以忽略转义字符了<br>s=r’ABC-001’<br>import re<br>print(‘成功的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010-12345’))<br>print(‘失败的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010 12345’))</p>\n<p>test=’用户输入的字符串’<br>if re.match(r’正则表达式’,test):</p>\n<pre><code>print(&apos;ok&apos;)</code></pre><p>else:</p>\n<pre><code>print(&apos;failed&apos;)</code></pre><p>#切分字符串<br>#用正则表达式切分字符串比用固定的字符更灵活,<br>print(‘a b   c’.split(‘ ‘))<br>#[‘a’, ‘b’, ‘’, ‘’, ‘c’],无法识别连续的空格<br>#用正则表达式试试<br>print(re.split(r’\\s+’,’a b   c’))<br>#[‘a’, ‘b’, ‘c’]<br>print(re.split(r’[\\s,;]+’, ‘a,b;; c  d’))<br>#[‘a’, ‘b’, ‘c’, ‘d’]</p>\n<p>#分组<br>m=re.match(r’^(\\d{3})-(\\d{3,8})$’,’010-12345’)<br>print(m)<br>print(‘m.group(0): ‘,m.group(0),’\\nm.group(1): ‘,m.group(1),’\\nm.group(2): ‘,m.group(2))</p>\n<p>‘’’<br>^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从<br>匹配的字符串中提取出区号和本地号码</p>\n<p>如果正则表达式中定义了组，就可以在Match对象上用<br>group()方法提取出子串来。<br>‘’’<br>#提取时间<br>t=’19:05:30’<br>m=re.match(r’^(0[0-9]|1[0-9]|2[0-3]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$’,t)<br>print(m.groups())</p>\n<p>#这样可以直接匹配出合法时间,但有些时候,正则也无法完全验证,这时候就要配合程序了</p>\n<p>#贪婪匹配<br>#正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符<br>print(re.match(r’^(\\d+)(0<em>)$’, ‘102300’).groups())<br>#Out[]:(‘102300’, ‘’)<br>#由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0</em>只能匹配空字符串了。</p>\n<p>#必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，<br>#加个?就可以让\\d+采用非贪婪匹配：</p>\n<p>#尽可能少 匹配<br>print(re.match(r’^(\\d+?)(0*)$’, ‘102300’).groups())<br>#out[]:(‘1023’, ‘00’)</p>\n<p>#编译<br>‘’’<br>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>\n<pre><code>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；\n\n用编译后的正则表达式去匹配字符串。</code></pre><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预<br>编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br>‘’’<br>re_telephone = re.compile(r’^(\\d{3})-(\\d{3,8})$’)<br>print(re_telephone.match(‘010-12345’).groups())<br>print(re_telephone.match(‘010-8086’).groups())</p>\n</li>\n</ul>\n<pre><code>#邮箱匹配1\nimport re\nEmail=input(&apos;please enter the Email:&apos;)\nre_mode=re.compile(r&apos;&lt;([a-zA-Z]* [a-zA-Z]*)&gt; [\\w.]*@\\w+.[a-z]*&apos;)\nwe=re_mode.match(Email)\nif we:\n    print(we.groups())\nelse:\n    print(&apos;failed!&apos;)\n\n#邮箱匹配2\nimport re\n&apos;&apos;&apos;\n&gt;&gt;&gt; 834930269@qq.com\nok!\n&apos;&apos;&apos;\ntest=input(&apos;please enter:&apos;)\nre_mode=re.compile(r&apos;[0-9a-zA-Z._]*@\\w+.com&apos;)\nif re_mode.match(test):\n    print(&apos;ok!&apos;)\nelse:\n    print(&apos;failed!&apos;)</code></pre>","text":"【Source Code】:point_right:Regular Expression模块s=’ABC\\-001’#对应正则表达式字符串为’ABC-001’<br>#因为python本身需要转义,但用 r 前缀的话,就可以忽略转义字符了<br>s=r’ABC-001’<br>i","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"UVa 11235","slug":"uva-11235","date":"2017-07-20T06:41:58.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/uva-11235.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Topic Link】 :point_right:<a href=\"https://vjudge.net/problem/UVA-11235\" target=\"_blank\" rel=\"noopener\">Frequent values</a> 【类别】 RMQ,游程编码 【题意】 给出一个非降序的整数数组，你的任务是对于一系列询问，回答区间内出现最多的值的次数. 【题解】 题目给的数组是非降序的.所有相等的元素都会聚集到一起。这样就可以把整个数组进行游程编码(Run Length Encoding,RLE).比如 (-1,1,1,2,2,2,4)就可以编码成(-1,1),(1,2),(2,3),(4,1),其中(a,b)表示有b个连续的a。用value[i]和count[i]分别表示第i段的数值和出现次数,num[p]、left[p]、right[p]、分别表示位置p所在段的编号和左右端点的位置.每次查询(L,R)的结果为以下三个部分的最大值:</p>\n<ol>\n<li>从L到L所在段的结束处的元素个数(right[L]-L+1)</li>\n<li>从R所在段开始到R的元素个数(R-left[R]+1)</li>\n<li>中间第num[L]+1段到第num[R]-1段的count的最大值,这一步是典型的RMQ问题,主要的时间也就花费在这里.</li>\n<li>特殊:如果L和R在同一个段中,则答案是R-L+1</li>\n</ol>\n<p>【代码】 github:</p>\n<ol>\n<li><p>:point_right:<a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch3/UVa%2011235.cpp\" target=\"_blank\" rel=\"noopener\">UVa 11235.cpp</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>#define INF 0x3f3f3f3f<br>using namespace std;<br>const int maxn=100010;<br>vector<int> cnt;<br>int num[maxn],le[maxn],ri[maxn];<br>int dp[maxn][20];<br>int N,Q;</int></p>\n<p>void RMQ_init(){</p>\n<pre><code>int n=cnt.size();\nfor(int i=0;i&lt;n;++i) dp[i][0]=-cnt[i];\n///2*(2^(j-1))=2^j\n///dp(i,j)表示从i开始,长度为2^j的一段元素中的最小值.\nfor(int j=1;(1&lt;&lt;j)&lt;=n;++j)\n    for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i)\n        dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);</code></pre><p>}</p>\n<p>int RMQ(int L,int R){</p>\n<pre><code>if(L&gt;R) return 0;\nint k=0;\n///如果2^(k+1)&lt;=R-L+1,那么k还可以加一\nwhile((1&lt;&lt;(k+1)&lt;=R-L+1))k++;\nreturn min(dp[L][k],dp[R-(1&lt;&lt;k)+1][k]);</code></pre><p>}</p>\n<p>int main(){</p>\n<pre><code>while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n    scanf(&quot;%d&quot;,&amp;Q);\n    cnt.clear();\n    int pre=INF,ct=0;\n    for(int i=0;i&lt;N;++i){\n        int numpy;\n        scanf(&quot;%d&quot;,&amp;numpy);\n        if(numpy!=pre){\n            pre=numpy;\n            ct++;\n            num[i]=ct-1;\n            le[i]=i;\n            if(i&gt;=1)\n                for(int j=le[i-1];j&lt;i;++j)\n                    ri[j]=i-1;\n            cnt.push_back(1);\n        }else{\n            num[i]=num[i-1];\n            le[i]=le[i-1];\n            cnt[ct-1]++;\n        }\n        if(i==N-1)\n            for(int j=le[i];j&lt;=i;++j)\n                ri[j]=i;\n    }</code></pre><p>/**</p>\n<pre><code>for(int i=0;i&lt;cnt.size();i++)\n    cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;cnt[i]&lt;&lt;&quot; &quot;;\ncout&lt;&lt;endl;\nfor(int i=0;i&lt;N;i++)\n    printf(&quot;%d(left,right,num):%d %d %d\\n&quot;,i,le[i],ri[i],num[i]);</code></pre><p>**/</p>\n<pre><code>    RMQ_init();\n    for(int i=0;i&lt;Q;++i){\n        int a,b;\n        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n        if(num[--a]==num[--b])\n            printf(&quot;%d\\n&quot;,b-a+1);\n        else\n            printf(&quot;%d\\n&quot;,max(max((ri[a]-a+1),-RMQ(num[a]+1,num[b]-1)),(b-le[b]+1)));\n    }\n}\nreturn 0;</code></pre><p>}</p>\n</li>\n</ol>\n","text":"【Topic Link】 :point_right:Frequent values 【类别】 RMQ,游程编码 【题意】 给出一个非降序的整数数组，你的任务是对于一系列询问，回答区间内出现最多的值的次数. 【题解】 题目给的数组是非降序的.所有相等的元素都会聚集到一起。这样就可以","link":"","raw":null,"photos":[],"categories":[{"name":"RLE","slug":"RLE","count":1,"path":"api/categories/RLE.json"},{"name":"RMQ","slug":"RLE/RMQ","count":1,"path":"api/categories/RLE/RMQ.json"},{"name":"UVa","slug":"RLE/RMQ/UVa","count":1,"path":"api/categories/RLE/RMQ/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"RLE","slug":"RLE","count":1,"path":"api/tags/RLE.json"},{"name":"RMQ","slug":"RMQ","count":1,"path":"api/tags/RMQ.json"}]},{"title":"python3学习 ThreadLocal线程局部变量","slug":"python3-threadloca","date":"2017-07-19T07:43:31.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-threadloca.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>局部变量传递,避免使用线程锁</strong> <strong>github:</strong></p>\n<ul>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/ThreadLocal.py\" target=\"_blank\" rel=\"noopener\">ThreadLocal.py</a></strong></li>\n</ul>\n<p>**#Thread-较量级线程</p>\n<p>#建议在多线程环境下用局部变量,但传递变量传递很麻烦</p>\n<p>‘’’<br>def process_student(name):<br>    std=Student(name)<br>    #std是局部变量,但是每个函数都要用它,因此必须传过去<br>    #一层一层的传<br>    do_task_1(std)<br>    do_task_2(std)</p>\n<p>def do_task_1(std):<br>    do_subtask_1(std)<br>    do_subtask_1(std)</p>\n<p>def do_task_2(std):<br>    do_subtask_2(std)<br>    do_subtask_2(std)<br>‘’’</p>\n<p>#考虑,以每层的thread对象作为key,值为操作对象</p>\n<p>class Student:<br>    def __init__(self,name):<br>        self.name=name</p>\n<p>global_dict = {}<br>def std_thread(name):<br>    std=Student(name)<br>    #吧std放到全局变量中dict中<br>    global_dict[threading.current_thread()]=std<br>    do_task_1()<br>    do_task_2()</p>\n<p>def do_task_1():<br>    #不传入std,而是根据当前线程查找<br>    std=global_dict[threading,current_thread()]<br>    #…</p>\n<p>def do_task_2():<br>    #任何函数都可以根据当前线程查找<br>    std=global_dict[threading,current_thread()]<br>    #…</p>\n<p>#ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事<br>import threading</p>\n<p>#创建全局ThreadLocal对象:<br>local_school=threading.local()<br>def process_student():<br>    #获取当前县城关联的student<br>    std=local_school.student<br>    print(‘Hello,%s (in %s)\\n’ % (std,threading.current_thread().name))</p>\n<p>def process_thread(name):<br>    #绑定ThreadLocal的student:<br>    local_school.student=name<br>    process_student()</p>\n<p>t1=threading.Thread(target=process_thread,args=(‘Alice’,),name=’Thread_A’)<br>t2=threading.Thread(target=process_thread,args=(‘Bob’,),name=’Thread_B’)<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()</p>\n<p>#ThreadLocal解决了线程锁的问题,把所有的变量都处理成局部变量,互不影响**</p>\n","text":"【Source Code】 局部变量传递,避免使用线程锁 github:ThreadLocal.py**#Thread-较量级线程#建议在多线程环境下用局部变量,但传递变量传递很麻烦‘’’<br>def process_student(name):<br>    std=Stud","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}]}