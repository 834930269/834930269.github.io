{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"POJ 3094","slug":"poj-3094","date":"2017-04-03T07:28:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3094.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>字符串处理问题</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=400;</strong> <strong>int mp[255],sum;</strong> <strong>char str[maxn];</strong> <strong>inline void init(){</strong> <strong>fill(mp);</strong> **    for(int i=0;i&lt;=26;++i)** <strong>mp[i+’A’]=i+1;</strong> <strong>}</strong> <strong>int main(){</strong> **    init();** **    for(;;){** **        scanf(“\\n%[^\\n]“,str);** <strong>sum=0;</strong> **        if(str[0]==’#’) break;** **        for(int i=1;str[i-1]!=’\\0’;++i)** <strong>sum+=mp[str[i-1]]*i;</strong> <strong>printf(“%d\\n”,sum);</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 字符串处理问题 【Code】#include&lt;bits/stdc++.h&gt; #define fill(x) memset(x,0,sizeof(x)) using namespace std; const int maxn=400; int mp[255]","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"字符串处理","slug":"POJ/字符串处理","count":1,"path":"api/categories/POJ/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2255","slug":"poj-2255","date":"2017-04-03T07:07:43.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-2255.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>前序中序求后序</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream>  ** *<em>#include <cstring>  *</cstring></em> *<em>using namespace std;  *</em> *<em>char TF[27];  *</em> *<em>char TM[27];  *</em> *<em>void TL( int p1, int p2, int q1, int q2, int root )  *</em> *<em>{  *</em> **    if ( p1 &gt; p2 ) return;  ** **//q1,前序第一个,即根,root为中序中的根下标</iostream></strong> **    for ( root = q1 ; TM[root] != TF[p1] ; ++ root );** **    //root-q1=左子树节点个数,因为有前序,所以不需要root** **    //变量,这里的root做使用变量处理.** **    //第一个递归,前两个变量是前序中左子树的区间,** **    //后两个变量是中序中左子树的区间  ** **    TL( p1+1, p1+root-q1, q1, root-1, 0 );** **    //前两个是前序中** **    //右子树的区间,后两个是中序中右子树的区间  ** **    TL( p1+root-q1+1, p2, root+1, q2, 0 );  ** **    printf(“%c”,TM[root]);  ** *<em>}  *</em> *<em>int main()  *</em> *<em>{  *</em> **    while (~scanf(“%s%s”,TF,TM)) {  ** **        int L = strlen(TF)-1;  ** **        TL( 0, L, 0, L, 0 );  ** **        printf(“\\n”);  ** **    }  ** **    return 0;  ** *<em>} *</em></p>\n</blockquote>\n<p><strong>【补充】</strong> <strong>修改题意为根据后序中序求先序.</strong></p>\n<blockquote>\n<p><strong>#include <iostream>  ** *<em>#include <cstring>  *</cstring></em>  *<em>using namespace std;  *</em>  **char TA[27];  //后序</iostream></strong> <strong>char TM[27];  //中序</strong>  <strong>void TL( int p1, int p2, int q1, int q2 )  ** *<em>{  *</em> **    if ( p1 &gt; p2 ) return;  ** **    printf(“%c”,TA[p2]);</strong> **    int i;    ** <strong>for ( i =  q1; TM[i] != TA[p2] ; ++ i );</strong> **    TL( p1, p2-q2+i-1, q1, i-1);** **    TL( p2-q2+i, p2-1, i+1, q2 );  **  *<em>}  *</em>  *<em>int main()  *</em> *<em>{  *</em> **    while (~scanf(“%s%s”,TA,TM)) {  ** **        int L = strlen(TA)-1;  ** **        TL( 0, L, 0, L);  ** **        printf(“\\n”);  ** **    }  ** **    return 0;  ** *<em>} *</em></p>\n</blockquote>\n","text":"【Tip】 前序中序求后序 【Code】#include   ** *#include   * *using namespace std;  * *char TF[27];  * *char TM[27];  * *void TL( int p1, int p2, int q1,","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"Tree","slug":"POJ/Tree","count":1,"path":"api/categories/POJ/Tree.json"},{"name":"数据结构","slug":"POJ/Tree/数据结构","count":1,"path":"api/categories/POJ/Tree/数据结构.json"}],"tags":[{"name":"binary_tree","slug":"binary-tree","count":1,"path":"api/tags/binary-tree.json"}]},{"title":"POJ 3006","slug":"poj-3006","date":"2017-04-03T04:06:39.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3006.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Dirichlet’s Theorem  狄利赫勒定理</strong> <strong>Arithmetic 算术,等差数列</strong> <strong>Progressions 级数,推进</strong> <strong>Arithmetic Progressions 等差数列</strong> <strong>Arithmetic Progressions of prime 质数等差数列</strong> <strong>If <em>a</em> and <em>d</em> are relatively prime… 如果a和b是互质数</strong> <strong>arithmetic sequence 等差数列</strong> <strong>increasing by 增加了</strong> <strong><a href=\"http://dict.youdao.com/search?q=increasing%20monotonically%20by%20degree&keyfrom=chrome.extensioneng\" target=\"_blank\" rel=\"noopener\">increasing monotonically by degree</a> 单调递增</strong> <strong>infinitely 无穷,无限的</strong> <strong>is known as 被称为</strong> <strong>your mission 你的使命/任务</strong> <strong>Your mission, should you decide to accept it, 你的使命使你决定去接受(证明？)它</strong> <strong>datasets 数据集</strong> <strong>separated by 用…来分隔？</strong> <strong>assume 假定</strong> <strong>composed of 由…组成</strong> <strong>extra 临时的,特别的,额外的</strong> <strong>characters 特性,字符</strong> <strong>corresponding 相应的,一致的</strong> <strong>【Tip】</strong> <strong>为啥都是素数？</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=1000010;</strong> <strong>bool is_prime[maxn];</strong> <strong>int prime[maxn],p,a,b,n;</strong> <strong>inline void sieve(){</strong> **    memset(is_prime,true,sizeof(is_prime));** **    p=0;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;maxn;++i)** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;maxn;j+=i)*</em> **                is_prime[j]=false;** **        }** <strong>}</strong> <strong>int main(){</strong> **    sieve();** **    while(~scanf(“%d%d%d”,&amp;a,&amp;b,&amp;n) &amp;&amp; a+b+n){** **        int sum=0,c;** **        for(int i=0,t=0;t&lt;n;++i){** **            c=a+i<em>b;*</em> **            if(is_prime[c]) t++;** **        }** **        printf(“%d\\n”,c);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Dirichlet’s Theorem  狄利赫勒定理 Arithmetic 算术,等差数列 Progressions 级数,推进 Arithmetic Progressions 等差数列 Arithmetic Progressions of prime 质数等差数列 ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 1503","slug":"poj-1503","date":"2017-04-02T10:37:07.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-1503.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【不用看单词…】</strong> <strong>java大数搞…</strong> <strong>【推荐相关博客】</strong> <strong><a href=\"http://m.blog.csdn.net/article/details?id=39718433\" target=\"_blank\" rel=\"noopener\">java中BigInteger</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>import java.util.Scanner;</strong> <strong>import java.math.*;</strong> <strong>public class Main{</strong> **    public static void main(String[] rgs){** **        //系统输出的** **        Scanner cin=new Scanner(System.in);** **        BigInteger b=BigInteger.valueOf(0);** **        while(cin.hasNext()){//等同于!=EOF** **            BigInteger c;** **            c=cin.nextBigInteger();** **            b=b.add(c);** **        }** **        System.out.println(b);** **    }** <strong>}</strong></p>\n</blockquote>\n","text":"【不用看单词…】 java大数搞… 【推荐相关博客】 java中BigInteger 【Code】import java.util.Scanner; import java.math.*; public class Main{ **    public static void m","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2262","slug":"poj-2262","date":"2017-04-02T09:45:52.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/poj-2262.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Goldbach 哥德巴赫</strong> <strong>Conjecture 推测,猜想</strong> <strong>Christian 基督教徒</strong> <strong>amateur 爱好者,业余爱好者</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=1000010;</strong> <strong>int N;</strong> <strong>int is_prime[maxn+1];</strong> <strong>int prime[maxn+1],p;</strong> <strong>void sieve(int t){</strong> **    memset(is_prime,1,sizeof(is_prime));** **    p=0;** **    is_prime[0]=is_prime[1]=0;** **    for(int i=2;i&lt;=t;++i){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=t;j+=i)*</em> **                is_prime[j]=0;** **        }    ** **    }** <strong>}</strong> <strong>void solve(){</strong> <strong>//这个循环是 &lt;= 因为6=3+3,而不是&lt;</strong> **    for(int i=0;i&lt;p &amp;&amp; prime[i]&lt;=N/2 ;++i)** **        if(is_prime[N-prime[i]]){** **            printf(“%d = %d + %d\\n”,N,prime[i],N-prime[i]);** **            return;** **        }** **    printf(“Goldbach’s conjecture is wrong.\\n”);    ** <strong>}</strong> <strong>int main(){</strong> **    //1000000正解,而不是预处理到一半,这道题不同于上一道题** <strong>//可以出现大于N/2 的解.</strong> **    sieve(1000010);** **    while(~scanf(“%d”,&amp;N) &amp;&amp; N){** **        solve();** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Goldbach 哥德巴赫 Conjecture 推测,猜想 Christian 基督教徒 amateur 爱好者,业余爱好者 【Code】#include #include #include #include #include #define fill(x) mems","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 1083","slug":"poj-1083","date":"2017-04-02T05:52:22.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-1083.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Advanced 先进的,高级的,晚期的,前进,增加</strong> <strong>Company 公司</strong> <strong>rented 租用,撕裂</strong> <strong>shape 形象,身材,具体化,模型</strong> <strong>following 下面的,接下来的,一批追随者,下列</strong> <strong>figure 图像,人形</strong> <strong>whose shape is in the following figure. 如下图所示.</strong> <strong>Corridor 走廊</strong> <strong>north side 北侧,北边,北区</strong> <strong>sorth side 南侧,南区,南边</strong> <strong>along the … 沿着 …</strong> <strong>【题意&amp;题解】</strong> <strong><a href=\"http://www.cnblogs.com/hrlnw/archive/2013/03/12/2955158.html\" target=\"_blank\" rel=\"noopener\">题意&amp;题解,仅参考思路</a></strong> <strong>注意,输入中的start和end可能出现start&gt;end的情况.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=300;</strong> <strong>int corridor[maxn],N,T;</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        fill(corridor);** **        int max=0;** **        scanf(“%d”,&amp;N);** **        for(int i=0;i&lt;N;++i){** **            int stay,to;** **            scanf(“%d%d”,&amp;stay,&amp;to);** **            //原地交换,需要注意的是,如果输入stay&gt;to的话** <strong>//无法处理区间,所以需要转换成标准形式.</strong> **            if(stay&gt;to){** **                stay=stay^to;** **                to=to^stay;** **                stay=stay^to;** **            }** **            for(int i=(stay-1)/2;i&lt;=(to-1)/2;++i){** **                corridor[i]+=10;** **                if(corridor[i]&gt;max) max=corridor[i];** **            }** **        }** **        printf(“%d\\n”,max);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Advanced 先进的,高级的,晚期的,前进,增加 Company 公司 rented 租用,撕裂 shape 形象,身材,具体化,模型 following 下面的,接下来的,一批追随者,下列 figure 图像,人形 whose shape is in the fo","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2739","slug":"poj-2739","date":"2017-04-02T04:46:21.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-2739.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Consecutive 连贯的,连续不断的</strong> <strong>represented 代表,表现,描写</strong> <strong>such 这样的</strong> <strong>【Tip】</strong> <strong>不能全部预处理,一旦发现往下加就退出循环,否则会TLE.当然,可以更加优化,不过过了= =///.</strong>   <strong>12：50 搜了一下题解,好吧,是尺取法.思路和我的差不多,选定好右端点,然后通过不断扩大左端点来寻找解.一旦脱离了最大范围,就退出循环.</strong> <strong>PS:这道题尺取法也可以继续优化..只需要遍历到5000就可以了,5000以后通过判断is_prime? it[i]+1 : it[i];来搞定?</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>const int maxn=20000;</strong> <strong>bool is_prime[maxn+1];</strong> <strong>int prime[maxn],p;</strong> <strong>void sieve(int n){</strong> **    p=0;** **    for(int i=0;i&lt;=n;i++) is_prime[i]=true;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;=n;i++){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=n;j+=i)*</em> **                is_prime[j]=false;** **        }** **    }** <strong>}</strong> <strong>int it[maxn];</strong> <strong>void init(int N){</strong> **    memset(it,0,sizeof(it));** **    //&amp;&amp; prime[i]&lt;N** **    for(int i=0;i&lt;p;++i){** **        int t=i;** **        while(t&gt;=0){** **            long long ans=0;** **            for(int j=t;j&lt;=i;++j)** **                ans+=prime[j];** **            if(ans&gt;=10000)** **                break;** **            it[ans]++;** **            t–;** **        }** **    }** <strong>}</strong> <strong>int main(){</strong> **    sieve(10000);** **    init(5000);** **    int T;** **    while(~scanf(“%d”,&amp;T) &amp;&amp; T){** <strong>//        if(T&lt;5000)</strong> **            printf(“%d\\n”,it[T]);** <strong>//        else if(is_prime[T])</strong> <strong>//            printf(“%d\\n”,it[T]+1);</strong> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Consecutive 连贯的,连续不断的 represented 代表,表现,描写 such 这样的 【Tip】 不能全部预处理,一旦发现往下加就退出循环,否则会TLE.当然,可以更加优化,不过过了= =///.   12：50 搜了一下题解,好吧,是尺取法.思路和我","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"pta 5-13 肿瘤诊断   (30分)","slug":"pta-5-13","date":"2017-04-01T05:11:08.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/pta-5-13.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>BFS</strong> <strong>3 4 5 2</strong> <strong>注意只有6个方向,而不是26个方向</strong> <strong>1,0,0  ,-1,0,0  ,0,1,0  ,0,-1,0  ,0,0,1  ,0,0,-1</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cmath></cmath></strong> <strong>#include<queue></queue></strong> <strong>#define fill(x) memset(x,0,sizeof(x));</strong> <strong>using namespace std;</strong> <strong>struct Node{</strong> <strong>int x,y,z;</strong> <strong>};</strong> <strong>int M,N,L,T,cnt;//LMN</strong> <strong>int mp[62][1300][150];</strong> <strong>int order[6][3]={1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1};</strong> <strong>queue<node> q;</node></strong> <strong>int bfs(int x,int y,int z){</strong> **    q.push((Node){x,y,z});** **    mp[x][y][z]=0;** **    int pnt=0;** **    while(!q.empty()){** <strong>pnt++;</strong> **        Node a=q.front();** **        q.pop();** <strong>//操作只有 1,0,0  -1,0,0  0,1,0  0,-1,0  0,0,1  0,0,-1</strong> <strong>//不能用下面这个循环 下面这个等价于一个球的遍历</strong> <strong>//        for(int i=-1;i&lt;=1;++i)</strong> <strong>//            for(int j=-1;j&lt;=1;++j)</strong> <strong>//                for(int k=-1;k&lt;=1;++k)</strong> <strong>//                    if(mp[a.x+i][a.y+j][a.z+k]){</strong> <strong>//                        q.push((Node){a.x+i,a.y+j,a.z+k});</strong> <strong>//                        mp[a.x+i][a.y+j][a.z+k]=0;  ** **//                    }</strong> <strong>//    }</strong> **        for(int i=0;i&lt;6;++i)** **            if(mp[a.x+order[i][0]][a.y+order[i][1]][a.z+order[i][2]]){** **                q.push((Node){a.x+order[i][0],a.y+order[i][1],a.z+order[i][2]});** **                mp[a.x+order[i][0]][a.y+order[i][1]][a.z+order[i][2]]=0;** <strong>}</strong> **    }** **    if(pnt&gt;=T) return pnt;** <strong>else return 0;</strong> <strong>}</strong>  <strong>int main(){</strong> **    scanf(“%d%d%d%d”,&amp;M,&amp;N,&amp;L,&amp;T);** **    fill(mp);** <strong>cnt=0;</strong> **    for(int i=1;i&lt;=L;++i)** **        for(int j=1;j&lt;=M;++j)** **            for(int k=1;k&lt;=N;++k)** **                scanf(“%d”,&amp;mp[i][j][k]);** **    for(int i=1;i&lt;=L;++i)** **        for(int j=1;j&lt;=M;++j)** **            for(int k=1;k&lt;=N;++k)** **                if(mp[i][j][k])** **                    cnt+=bfs(i,j,k);** <strong>printf(“%d\\n”,cnt);</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 BFS 3 4 5 2 注意只有6个方向,而不是26个方向 1,0,0  ,-1,0,0  ,0,1,0  ,0,-1,0  ,0,0,1  ,0,0,-1 【Code】#include #include #include #include #include #inc","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[{"name":"pta","slug":"pta","count":2,"path":"api/tags/pta.json"}]},{"title":"POJ 3299","slug":"poj-3299","date":"2017-04-01T03:40:48.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-3299.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Adapted 适合,适应,改编</strong> <strong>free 自由,免费</strong> <strong>encyclopedia 百科全书</strong> <strong>dew point 露点</strong> <strong>【Tip】</strong> <strong>dewpoint的公式要推出来.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cmath></cmath></strong> <strong>#include<iostream></iostream></strong> <strong>using namespace std;</strong> <strong>double D,H,T;</strong> <strong>char get;</strong> <strong>int main(){</strong> <em>*    for(;;){** **        D=H=T=200;** **        for(int i=0;i&lt;2;++i){** **            cin&gt;&gt;get;** **            if(get==’E’) return 0;** **            if(get==’T’) cin&gt;&gt;T;** **            if(get==’H’) cin&gt;&gt;H;** **            if(get==’D’) cin&gt;&gt;D;** **        }** **        if(T==200)** **            T=H-0.5555</em>(6.11*exp(5417.7530*((1/273.16)-(1/(D+273.16))))-10.0);<em>* **        else if(H==200)** **            H=T+0.5555</em>(6.11*exp(5417.7530*((1/273.16)-(1/(D+273.16))))-10.0);** **        else if(D==200)** **            D=1/(1/273.16-log(((H-T)/0.5555+10.0)/6.11)/5417.7530)-273.16;** **        printf(“T %.1lf D %.1lf H %.1lf\\n”,T,D,H);** **    }    **  **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Adapted 适合,适应,改编 free 自由,免费 encyclopedia 百科全书 dew point 露点 【Tip】 dewpoint的公式要推出来. 【Code】#include #include #include #include #include #i","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"LA 3708","slug":"la-3708","date":"2017-03-31T15:25:38.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/la-3708.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题解】</strong> <strong>蓝书P8</strong> <strong>题意是原本n个墓碑均匀分布在一个周长为10000的圆周上，现在加入m个，如果要使得n+m个墓碑都均匀分布的话，那么原来的墓碑最少的移动总距离是多少。</strong> <strong>因为加入m个之后m+n个墓碑的位置是固定的，要是移动距离最少必定会有一个墓碑不动，将圆周分成m+n段，分别标上0,1,2,3,4。。然后需要移动的墓碑坐标就是数轴上面的非整数点，两边的值靠近哪个就选哪个，之后再等比例扩大即可。</strong> <strong>放大倍数:10000/(M+N)</strong> <strong>原先N的坐标在放入M后的位置:</strong> <strong>//设距离L</strong> <strong>//i_(10000/N)=L_</strong> <em><strong>//L/(10000/(M+N))=pos</strong> <strong>//pos=i</strong></em><strong>(10000/N)/(10000/(M+N))</strong> <strong>//pos=i*(M+N)/N</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>int N,M;</strong> <strong>int main(){</strong> <em>*    while(scanf(“%d%d”,&amp;N,&amp;M)!=EOF) {** **        double ans=0.0;** **        for(int i=1;i&lt;N;++i){** **            double pos=(double)i/N</em>(N+M);<em>* **            //原先N的坐标在原来的位置是哪里** <strong>//设距离L</strong> **            //i</em>(10000/N)=L<em>* **            //L/(10000/(M+N))=pos** **//pos=i</em>(10000/N)/(10000/(M+N))<em>* **//pos=i</em>(M+N)/N** **            ans+=fabs(pos-floor(pos+0.5))/(N+M);** **            //floor()向下取整,这里等价于找两边距离最近** <strong>//的那个点.</strong> <strong>}</strong> **        printf(“%.4lf\\n”,ans<em>10000);  *</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>与上面题解同理(没那么奇葩的写法的Code)</strong></p>\n<blockquote>\n<p>**#include <cstdio></cstdio></p>\n<p>#include <cstring></cstring></p>\n<p>#include <algorithm></algorithm></p>\n<p>using namespace std;</p>\n<p>int main() {<br>    int n,m;<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)) {<br>        double ans = 0;<br>        for(int i = 1;i &lt; n;i++) {<br>            double pos = (double)i * (m + n) / n;<br>            ans += min(pos - (int)pos,(int)(pos + 1) - pos);<br>                        //取离两边距离最近的那个点<br>        }<br>        printf(“%.4lf\\n”,ans * 10000 / (m + n));<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【题解】 蓝书P8 题意是原本n个墓碑均匀分布在一个周长为10000的圆周上，现在加入m个，如果要使得n+m个墓碑都均匀分布的话，那么原来的墓碑最少的移动总距离是多少。 因为加入m个之后m+n个墓碑的位置是固定的，要是移动距离最少必定会有一个墓碑不动，将圆周分成m+n段，分别标上","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"}],"tags":[{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]}]}