{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"HDU 1849","slug":"hdu-1849","date":"2018-01-24T10:35:08.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1849.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg","content":"<p>【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" alt></a> 原题说我们需要将每个格子内的棋子进行移动,当所有棋子都位于最左边编号为0的格子时,游戏结束. 首先我们将棋盘竖起来(自己画的,所以会少一点,但大体意思一样). <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124182908.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124182908.png\" alt></a> 然后我们将其中的棋子分开来: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124183152.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124183152.png\" alt></a> 这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时,即代表石子已取空. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int K;\n    while(~scanf(&quot;%d&quot;,&amp;K)){\n        if(K==0) break;\n        int ans=0;\n        while(K--){\n            int a;\n            scanf(&quot;%d&quot;,&amp;a);\n            ans^=a;\n        }\n        if(ans==0)puts(&quot;Grass Win!&quot;);\n        else puts(&quot;Rabbit Win!&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图:  [Figure]  这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 1847","slug":"hdu-1847","date":"2018-01-24T09:54:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1847.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"博弈论-sg函数\">【博弈论 - SG函数】</span></h1><h2><span id=\"题目\">题目:</span></h2><h3><span id=\"good-luck-in-cet-4-everybody\">Good Luck in CET-4 Everybody!</span></h3><p>Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 11483 Accepted Submission(s): 7446 大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。 “升级”？“双扣”？“红五”？还是“斗地主”？ 当然都不是！那多俗啊~ 作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的： 1、 总共n张牌; 2、 双方轮流抓牌； 3、 每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…） 4、 抓完牌，胜负结果也出来了：最后抓完牌的人为胜者； 假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？ 当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。 Good luck in CET-4 everybody!</p>\n<h2><span id=\"input\">Input</span></h2><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p>\n<h2><span id=\"output\">Output</span></h2><p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p>\n<h2><span id=\"sampleinput\">SampleInput</span></h2><p>1 3</p>\n<h2><span id=\"sampleoutput\">SampleOutput</span></h2><p>Kiki Cici</p>\n<h2><span id=\"题解\">题解</span></h2><p>首先我们要知道SG函数代表的是当前状态的数值.如果是0,则为先手必败(SG函数值为可到达状态中未出现的最小的整数).然后我们从SG函数延伸一下– 1.我们假设当n=0时,先手必败. 2.当n=1时,因为S(0)=0，所以当前状态是非奇异局势.先手必胜,即,你可以通过拿走一定的牌使下一个拿牌的人的局势变成奇异局势(必败态). 即转移给下一个抽牌者状态为S(0). 3.当n=2是,因为S(0)=0，S(1)=1.所以当前状态是非奇异局势,先手必胜. 即你可以把下一个抽牌者状态转换成S(0). 4.当n=3时,可到达状态为S(3-1)=S(2)=1.S(3-2)=S(1)=1.因为无论往那个状态走,都会使对方先手必胜,所以该局势为奇异局势.先手必败. 故我们可以根据以上推理过程将全部的1000个状态是否必胜预处理处来.其预处理过程为<strong>检查可以到达的状态是否存在奇异局势,如果存在,则该局势为非奇异局势,即先手必胜态</strong>. 因为可拿牌数都是2^n.所以预处理复杂度为O(nlg(n)). PS…:其实预处理完以后你会发现.每当n%3==0时,为奇异局势. Code:</p>\n<pre><code>//SG函数\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nbool game[1001];\n\nvoid init(){\n    memset(game,false,sizeof(game));\n    for(int i=1;i&lt;=1000;++i){\n        int t=1;\n        while(i-t&gt;=0){\n            //如果i-t是奇异局势,则先手必胜\n            if(!game[i-t]){\n                game[i]=true;\n                break;\n            }\n            t&lt;&lt;=1;\n        }\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(game[n]){\n            printf(&quot;Kiki\\n&quot;);\n        }else{\n            printf(&quot;Cici\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【博弈论 - SG函数】题目:Good Luck in CET-4 Everybody!Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submissio","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"POJ 1067","slug":"poj-1067","date":"2018-01-24T09:11:04.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/poj-1067.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【威佐夫博弈】</p>\n<pre><code>//威佐夫博弈\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main(){\n    int n,m;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        int k=max(n,m)-min(n,m);\n        int ak=k*(1+sqrt(5))/2;\n        int bk=ak+k;\n        if(min(n,m)==ak&amp;&amp;max(n,m)==bk){\n            printf(&quot;0\\n&quot;);\n        }else{\n            printf(&quot;1\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【威佐夫博弈】//威佐夫博弈#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int n,m;    while(~sc","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"博弈论","slug":"POJ/博弈论","count":1,"path":"api/categories/POJ/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"HDU 1846","slug":"hdu-1846","date":"2018-01-24T08:33:41.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1846.json","excerpt":"","keywords":null,"cover":null,"content":"<p>裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        if((n)%(m+1)==0) printf(&quot;second\\n&quot;);\n        else printf(&quot;first\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ ","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"巴什博奕","slug":"巴什博奕","count":1,"path":"api/tags/巴什博奕.json"}]},{"title":"HDU 2149","slug":"hdu-2149","date":"2018-01-24T08:16:55.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2149.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"巴什博奕\">【巴什博奕】</span></h1><h2><span id=\"题目\">题目:</span></h2><p>虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。 后来发现，整个拍卖会只有Lele和他的死对头Yueyue。 通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。 Lele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。 由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候， Lele要出多少才能保证自己买得到这块地呢？</p>\n<h2><span id=\"input\">Input:</span></h2><p>本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。 每组测试包含两个整数M和N(含义见题目描述，0&lt;N，M&lt;1100)</p>\n<h2><span id=\"output\">Output:</span></h2><p>对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。 如果Lele在第一次无论如何出价都无法买到这块土地，就输出”none”。</p>\n<h2><span id=\"sample-input\">Sample Input:</span></h2><p>4 2 3 2 3 5</p>\n<h2><span id=\"sample-output\">Sample Output:</span></h2><p>1 none 3 4 5</p>\n<h2><span id=\"题解\">题解</span></h2><p>我们知道,在巴士博弈中,n=0为先手必输态,之后n=m+1为下一个先手必输态. 而当Lele在竞拍的时候,如果他所在的初始状态是如上所述的这样一个奇异局势(即先手必输局势),那他一定输(none). 当Lele在竞拍处于非奇异局势时,在选择最优的情况下,他一定可以赢得竞拍.即他只需要通过增价将对手置于奇异状态即可. 所以当我们想要找出Lele第一次出家的可能性时,只需要先找出Lele的第一个置对方为奇异局势的 价格 .然后在寻找下一个的时候只需要依次++,直到下一次加价会给对方一个 非奇异局势前 结束循环. 当然,存在一种可能性就是,初次加价可能会溢出n的价格范围.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n,m;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        if(n%(m+1)==0) printf(&quot;none\\n&quot;);\n        else{\n            int next=0;\n            while(1){\n                next++;\n                if((n-next)%(m+1)==0){\n                    printf(&quot;%d&quot;,next);\n                    break;\n                }\n            }\n            while(next&lt;m){\n                next++;\n                if((n-next)%(m+1)==0 || next&gt;=n){\n                    printf(&quot; %d&quot;,next);\n                }else{\n                    break;\n                }\n            }\n            printf(&quot;\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】题目:虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2188","slug":"hdu-2188","date":"2018-01-24T07:49:43.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-2188.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"巴什博奕\">【巴什博奕】</span></h1><p>可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    while(~scanf(&quot;%d&quot;,&amp;T)){\n        while(T--){\n            scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n            if((n)%(m+1)==0) printf(&quot;Rabbit\\n&quot;);\n            else printf(&quot;Grass\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int T,n,m;    while(~s","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"博弈论","slug":"game","date":"2018-01-24T03:05:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/game.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg","content":"<p>[toc]</p>\n<h1><span id=\"博弈论\">博弈论</span></h1><h2><span id=\"博弈树\">博弈树</span></h2><p>重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。</p>\n<h2><span id=\"sg函数\">SG函数</span></h2><h3><span id=\"基本概念\">基本概念</span></h3><p>在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个状态,则两点间有一条有向边,这样就得到了一个状态图.</p>\n<h3><span id=\"巴什博奕\">巴什博奕</span></h3><p>以巴什博奕为例,一共有n个物品,两人轮流取,一次最少取走1个最多去走m个，最后取光的人获胜。下图展示了n=6,m=3的时候的状态图,节点内的数字表示当前状态剩下的物品的个数. <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" alt></a> 假设游戏不会出现平局,即状态图是无环图的话,所有的状态可以分为两种,P态和N态。P态表示该状态对于前一个玩家来说是必胜态,而N态表示该状态对于下一个玩家来说是必胜态。例如对于n=6,m=3的巴什博奕来说,0个物品显然是P态,而还剩1、2或3个物品的状态都是N态。 一个状态被称为终止状态,如果当前状态下游戏不能再继续进行,譬如巴什博奕种物品都已经被取光了,在大部分游戏规则中,终止状态都是P态,所以如果不加特殊说明,一下都假设P态为终止状态. 从定义可知,任意一个P态,他要么是终止状态,要么他所有可以转移到的状态都是N态,而对于任意一个N态,他至少有一个后继状态是P态.</p>\n<h3><span id=\"sg函数\">SG函数</span></h3><p>SG函数是这样定义的:对于任意状态x,他的SG函数值g(x)=mex{g(y)|y是x的后续状态},其中mex是一个对于非负整数集合S的运算, mex(S)为S中没有出现的最小负整数 。对于一个终止状态,因为他没有后继状态,所以他的SG函数值是0. 还是以上面的巴什博奕为例: n=6,m=3.用Si表示还剩i个物品的状态。S0是终止状态,所以g(S0)=0。S1的唯一后继状态是S0,所以g(S1)=1,S2可以转移到S1和S0，所以g(S2)是2.因为S3可以转移到S0,S1,S2,所以g(S3)=3.对于S4来说,它可以转移到S1，S2，S3(1，2，3),所以g(S4)=0.以此类推可以知道g(S5)=1，g(S6)=2. 如果知道一个状态SG函数值,则可以快速的判断当前状态时P态还是N态.对于一个函数,如果状态值是0则是P态,否则就是N态. g(S4),P态,先手必败(后继都是N态);g(S5)，N态(后继有P态),先手必胜.</p>\n<h1><span id=\"kuangbin介绍博弈\">KuangBin介绍博弈</span></h1><h2><span id=\"一巴什博奕bash-game\">（一）巴什博奕（Bash Game）：</span></h2><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个， 后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果 n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的 取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十 个，谁能报到100者胜。</p>\n<h2><span id=\"二威佐夫博奕wythoff-game\">（二）威佐夫博奕（Wythoff Game）：</span></h2><p>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示 两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6， 10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有 如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1 ，而 bk= ak + k &gt; ak -1 + k-1 = bk-1 &gt; ak-1 。所以性质1。成立。 2。任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其 他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由 于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了 奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局 势；如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab + ak个物体,变为奇异局 势（ ab – ak , ab – ak+ b – ak）；如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余 的数量a – ak 即可；如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k） ,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – a j 即可。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜 ；反之，则后拿者取胜。 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 奇妙的是其中出现了黄金分割数（1+√5）/2 = 1。618…,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。</p>\n<h3><span id=\"威佐夫博弈的几点判断\">威佐夫博弈的几点判断:</span></h3><h4><span id=\"非奇异局势时先手一方只需要将当前局势变成奇异局势即可必胜\">非奇异局势时,先手一方只需要将当前局势变成奇异局势即可必胜</span></h4><h4><span id=\"奇异局势时后手一方只需要将非奇异局势变成奇异局势必胜\">奇异局势时,后手一方只需要将非奇异局势变成奇异局势必胜</span></h4><h2><span id=\"三尼姆博奕nimm-game\">（三）尼姆博奕（Nimm Game）：</span></h2><p>有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首 先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是 （0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一 下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情 形。 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示 这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结 果： 1 =二进制01 2 =二进制10 3 =二进制11 （+） ——————— 0 =二进制00 （注意不进位） 对于奇异局势（0，n，n）也一样，结果也是0。 任何奇异局势（a，b，c）都有a（+）b（+）c =0。 <strong>如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b &lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果: a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（a（+）b）即可。</strong> 例1。（14，21，39），14（+）21=27，39-27=12，所以从39中拿走12个物体即可达 到奇异局势（14，21，27）。 例2。（55，81，121），55（+）81=102，121-102=19，所以从121中拿走19个物品 就形成了奇异局势（55，81，102）。 例3。（29，45，58），29（+）45=48，58-48=10，从58中拿走10个，变为（29，4 5，48）。</p>\n<pre><code>例4。我们来实际进行一盘比赛看看：\n    甲:(7,8,9)-&gt;(1,8,9)奇异局势\n    乙:(1,8,9)-&gt;(1,8,4)\n    甲:(1,8,4)-&gt;(1,5,4)奇异局势\n    乙:(1,5,4)-&gt;(1,4,4)\n    甲:(1,4,4)-&gt;(0,4,4)奇异局势\n    乙:(0,4,4)-&gt;(0,4,2)\n    甲:(0.4,2)-&gt;(0,2,2)奇异局势\n    乙:(0,2,2)-&gt;(0,2,1)\n    甲:(0,2,1)-&gt;(0,1,1)奇异局势\n    乙:(0,1,1)-&gt;(0,1,0)\n    甲:(0,1,0)-&gt;(0,0,0)奇异局势\n    甲胜。</code></pre><h2><span id=\"拓展\">拓展</span></h2><h3><span id=\"斐波那契博弈\">斐波那契博弈</span></h3><p>1、问题模型： 有一堆个数为n的石子，游戏双方轮流取石子，满足： （1）先手不能在第一次把所有的石子取完； （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。 2、解决思路： 当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 证明：根据“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。如n=83 = 55+21+5+2，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，那么一定是先手取走这5颗石子中的最后一颗，同理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。 反证：如果n是Fibonacci数，如n=89：记先手一开始所取的石子数为y （1）若y&gt;=34颗（也就是89的向前两项），那么一定后手赢，因为89-34=55=34+21&lt;2*34。 （2）y&lt;34时剩下的石子数x介于55到89之间，它一定不是一个Fibonacci数，把x分解成Fibonacci数：x=55+f[i]+…+f[j]，若，如果f[j]&lt;=2y，那么对B就是面临x局面的先手，所以根据之前的分析，后手只要先取f[j]个即可，以后再按之前的分析就可保证必胜。</p>\n<h3><span id=\"公平组合博弈impartial-combinatori-games\">公平组合博弈（Impartial Combinatori Games）</span></h3><p>1、定义： （1）两人参与。 （2）游戏局面的状态集合是有限。 （3）对于同一个局面，两个游戏者的可操作集合完全相同 （4）游戏者轮流进行游戏。 （5）当无法进行操作时游戏结束，此时不能进行操作的一方算输。 （6）无论游戏如何进行，总可以在有限步数之内结束。 2、模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有公平组合游戏（Impartial Combinatori Games）的抽象模型。其实，任何一个ICG都可以通过把每个局势看成一个顶点，对每个局势和它的子局势连一条有向边来抽象成这个“有向图游戏”。 3、解决思路： 现在，假定我们给出两个游戏G1 和 G2。如果我们只知道单个游戏的P-状态和N-状态我们能够正确地玩好游戏和G1 + G2吗？答案是否定的。不难看出两个P-状态的和总是P-状态，P-状态和N-状态的和总是N-状态。但是两个N-状态的和既可能是P-状态也可能是N-状态。因此，只知道单个游戏的P-状态和N-状态是不够的。 为了正确地玩好游戏和我们需要推广P-状态和N-状态，它就是Sprague-Grudy函数（或者简称为g函数） 4、Sprague-Grudy定理： 令N = {0, 1, 2, 3, …} 为自然数的集合。Sprague-Grundy 函数给游戏中的每个状态分配了一个自然数。结点v的Grundy值等于没有在v的后继的Grundy值中出现的最小自然数. 形式上：给定一个有限子集 S ⊂ N,令mex S(最小排斥值)为没有出现在S中的最小自然数。定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。 5、性质： （1）所有的终结点所对应的顶点，其SG值为0，因为它的后继集合是空集——所有终结点是必败点（P点）。 （2）对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0——无论如何操作，从必败点（P点）都只能进入必胜点（N点）//对手走完又只能把N留给我们。 （3）对于一个g(x)!=0的顶点，必定存在一个后继点y满足g(y)=0——从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）//就是那种我们要走的方法。 6、应用： （1）可选步数为1-m的连续整数，直接取模即可，SG(x) = x % (m+1); （2）可选步数为任意步，SG(x) = x; （3）可选步数为一系列不连续的数，用mex(计算每个节点的值)</p>\n","text":"[toc]博弈论博弈树重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。SG函数基本概念在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个","link":"","raw":null,"photos":[],"categories":[{"name":"博弈论","slug":"博弈论","count":3,"path":"api/categories/博弈论.json"},{"name":"算法学习","slug":"博弈论/算法学习","count":1,"path":"api/categories/博弈论/算法学习.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"第八届ACM省赛 K CF","slug":"acm-k-cf","date":"2018-01-18T07:35:38.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/acm-k-cf.json","excerpt":"","keywords":null,"cover":"http://acm.sdut.edu.cn/image/3903.png","content":"<h3><span id=\"cf\">CF</span></h3><p><strong>sdut 3903</strong> Time Limit: 1000MS Memory Limit: 65536KB</p>\n<h4><span id=\"problem-description\">Problem Description</span></h4><p><img src=\"http://acm.sdut.edu.cn/image/3903.png\" alt> LYD loves codeforces since there are many Russian contests. In an contest lasting for <em>T</em> minutes there are <em>n</em> problems, and for the <em>i__th</em> problem you can get <em>a__i_−_d__i_∗_t__i</em> points, where <em>a__i</em> indicates the initial points, <em>d__i</em> indicates the points decreased per minute (count from the beginning of the contest), and <em>t__i</em> stands for the passed minutes when you solved the problem (count from the begining of the contest).<br>Now you know LYD can solve the <em>i__th</em> problem in <em>c__i</em> minutes. He can’t perform as a multi-core processor, so he can think of only one problem at a moment. Can you help him get as many points as he can?</p>\n<h4><span id=\"input\">Input</span></h4><p>The first line contains two integers <em>n</em>,<em>T</em>(0≤<em>n</em>≤2000,0≤<em>T</em>≤5000).<br>The second line contains <em>n</em> integers <em>a</em>1,<em>a</em>2,..,<em>a__n</em>(0&lt;<em>a__i_≤6000).<br>The third line contains _n</em> integers <em>d</em>1,<em>d</em>2,..,<em>d__n</em>(0&lt;<em>d__i_≤50).<br>The forth line contains _n</em> integers <em>c</em>1,<em>c</em>2,..,<em>c__n</em>(0&lt;_c__i_≤400).</p>\n<h4><span id=\"output\">Output</span></h4><p>Output an integer in a single line, indicating the maximum points LYD can get.</p>\n<h4><span id=\"example-input\">Example Input</span></h4><p>3 10<br>100 200 250<br>5 6 7<br>2 4 10</p>\n<h4><span id=\"example-output\">Example Output</span></h4><p>254</p>\n<h4><span id=\"题意\"><strong>题意</strong></span></h4><p>有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题的分数便会减少 di ，而我们可以在 ci 时间内做出这道题而得到分数，求在时间 T 内最多可以获得的分数。</p>\n<h4><span id=\"题解\"><strong>题解</strong></span></h4><p>首先可以感觉出这是道0-1背包问题,然后我们需要知道,当我们做题时,会一两个角度来选择题目,其一是选择做题速度最快的,其二是选择做分值降低速度最快的.那么我们的衡量标准就可以看成先做单位时间内做题最多的那道. 然后我们根据上述规则排一下序. 在用排序后的数组进行0-1背包.在背包过程中记录最大值,即为最后的结果.</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=3000;\n\nstruct pro{\n    int a,d,c;\n    //按单位时间内减少分值排序\n    bool operator &lt;(const pro &amp;pt)const{\n        return 1.0*d/c&gt;(1.0*pt.d/pt.c);\n    }\n};\n\nint n,T;\npro p[maxn];\nint dp[5010];\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;T)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].a);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].d);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].c);\n        }\n        sort(p,p+n);\n        int mx=-1;\n        for(int i=0;i&lt;n;++i){\n            for(int j=T;j&gt;=0;--j){\n                if(j&gt;=p[i].c){\n                    dp[j]=max(dp[j],dp[j-p[i].c]+p[i].a-j*p[i].d);\n                }\n                mx=max(mx,dp[j]);\n            }\n        }\n        printf(&quot;%d\\n&quot;,mx);\n    }\n    return 0;\n}</code></pre>","text":"CFsdut 3903 Time Limit: 1000MS Memory Limit: 65536KBProblem Description [Figure] 2 4 10Example Output254题意有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"动态规划","slug":"Sdut/动态规划","count":2,"path":"api/categories/Sdut/动态规划.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/动态规划/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/动态规划/第八届ACM山东省赛.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"Tarjan 强连通分量算法","slug":"tarjan-scc-algorithm","date":"2018-01-17T10:03:54.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/tarjan-scc-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg","content":"<p>Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.</p>\n<h2><span id=\"学习契机-hdu-6038\">学习契机: </span></h2><p>首先介绍下:</p>\n<h2><span id=\"强连通分量\">强连通分量:</span></h2><p>画图以明志 -- <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" alt></a> <code>Tarjan</code>算法的时间复杂度是线性的,而kos算法则需要计算图的转置.该算法由Tarjan于1972年提出,是SCC<code>(Strongly Connected Componenet,强连通分量)</code>的第一个线性算法,Tarjan算法借助于DFS,但它并不需要靠遍历顺序(Kos算法的思想)来分离SCC,而是允许SCC并存于同一颗DFS树中,然后通过某种手段将他们分开.</p>\n<h2><span id=\"dag\">DAG:</span></h2><p>如果把一个集合看成一个点,那么所有的SCC构成了一个SCC图.这个SCC图不会存在有向环,因此是一个DAG<code>(Directed Acyclic Graph,有向无环图)</code>. 那他喵的什么是DAG呢?我把上面的那个强连通分量图给DAG化: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" alt></a></p>\n<h2><span id=\"算法流程\">算法流程</span></h2><p>考虑强连通分量C,设其中第一个被发现的点为x,则C中其他点都是x的后代.我们希望在x dfs访问完成后立即输出C.这样,就可以在一棵DFS树中区分开所有SCC了.因此,问题的关键是如何发现每个SCC的第一个点.</p>\n<h3><span id=\"如何判断是否是scc顶点\">如何判断是否是SCC顶点</span></h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" alt></a> 假设我们正在判断u是否为某SCC的第一个被发现节点.如果我们发现<code>从u的子节点出发可以达到u的祖先w,显然u就不是SCC的顶点.</code>反之,如果SCC最远的顶点可以到u,则u是SCC的顶点.图中虚线表示一条或多条边和点. 我们使用两个数组来记录每个节点的状态.pre[]和lowlink[]. 当递归回溯时如果这两个数组的值相同,则表明该节点为某SCC顶点.</p>\n<h2><span id=\"证明\">证明</span></h2><p>见: <a href=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" title=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/keyboarderqq/article/details/71308102</a></p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1><span id=\"此致画个图你就知道low数组的具体作用了\">此致:画个图你就知道low数组的具体作用了.</span></h1>","text":"Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.学习契机: 首先介绍下:强连通分量:画图以明志 --  [Figure]  假设我们正在判断u是否为某SCC的第一个被发现节点.","link":"","raw":null,"photos":[],"categories":[{"name":"Tarjan","slug":"Tarjan","count":1,"path":"api/categories/Tarjan.json"},{"name":"图论","slug":"Tarjan/图论","count":1,"path":"api/categories/Tarjan/图论.json"},{"name":"算法学习","slug":"Tarjan/图论/算法学习","count":1,"path":"api/categories/Tarjan/图论/算法学习.json"},{"name":"连通分量","slug":"Tarjan/图论/算法学习/连通分量","count":1,"path":"api/categories/Tarjan/图论/算法学习/连通分量.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]},{"title":"Java STL & JDK8 聚合","slug":"java-stl-jdk8-juhe","date":"2018-01-17T03:01:17.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-stl-jdk8-juhe.json","excerpt":"","keywords":null,"cover":null,"content":"<p>JDK8的聚合和C#的Fluent API基本一样,每次操作后返回的类型和之前的一样,股可以继续操作. 至于STL,和C++比一下就是一些单词不一样罢了. 排序时需要实现Comparable接口. 这节水过去= =. 其中泛型如果需要支持一个类的子类.需要这样写. 使用<code>? extends 类型</code>名.</p>\n<pre><code>ArrayList&lt;? extends Hero&gt; heroList = apHeroList;</code></pre><p>泛型通配符: <code>?</code></p>\n","text":"JDK8的聚合和C#的Fluent API基本一样,每次操作后返回的类型和之前的一样,股可以继续操作. 至于STL,和C++比一下就是一些单词不一样罢了. 排序时需要实现Comparable接口. 这节水过去= =. 其中泛型如果需要支持一个类的子类.需要这样写. 使用? ext","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]}]}