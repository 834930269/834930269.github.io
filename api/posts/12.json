{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"组合数学","slug":"combinatorics","date":"2018-01-25T13:04:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/combinatorics.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png","content":"<blockquote>\n<p>因为组合数学涉及面广,采取边学边更新.</p>\n<blockquote>\n<p>预计大部分会摘自《组合数学》</p>\n</blockquote>\n</blockquote>\n<h1 id=\"【鸽巢定理】\"><a href=\"#【鸽巢定理】\" class=\"headerlink\" title=\"【鸽巢定理】\"></a>【鸽巢定理】</h1><p>也叫作<code>狄利克雷抽屉原理</code>以及<code>鞋盒原理</code>. 对于鸽巢定理的简单阐释,粗略的说就是如果有许多鸽子飞进不够多的鸽巢内。那么至少要有一个鸽巢被两个或多个鸽子占据.</p>\n<h2 id=\"简单形式\"><a href=\"#简单形式\" class=\"headerlink\" title=\"简单形式\"></a>简单形式</h2><p>很通俗的定理 : 如果要把n+1个物体放进n个盒子内,那么至少有一个盒子包含两个或更多的物体.</p>\n<h2 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h2><blockquote>\n<ol>\n<li><p>在13个人中存在两个人,他们的生日在同一个月份里.</p>\n</li>\n<li><p>设有n对已婚夫妻,至少从这2n个人中选出n+1个人可以保证有一对夫妻.</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"应用3\"><a href=\"#应用3\" class=\"headerlink\" title=\"应用3\"></a>应用3</h2><h3 id=\"这一条要拿出来-因为比较重要\"><a href=\"#这一条要拿出来-因为比较重要\" class=\"headerlink\" title=\"这一条要拿出来,因为比较重要\"></a>这一条要拿出来,因为比较重要</h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png\" alt></p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>考虑$$m$$个和: $$a_1,a_1+a_2,a_1+a_2+a_3,…,a_1+a_2+a_3+…+a_m$$ 如果这些和当中的任意一个可被$$m$$整除,那么结论就成立。因此,我们可以假设这些和中的每一个除以$$m$$都有一个非零余数,余数等于$$1,2,3,4,…,m-1$$中的一个数。因为有$$m$$个和,而只有$$m-1$$个余数,所以必然有两个序列的和除以$$m$$有相同的余数.因此,存在整数$$k,l,k \\&lt; l$$,使得$$a_1+a_2+…+a_k$$和$$a_1+a_2+…+a_l$$除以$$m$$有相同的余数$$r$$: $$a_1+a_2+…+a_k = bm+r,a_1+a_2+…+a_l = cm+r$$ 二式相减,我们发现$$ a_{k+1} $$+$$a_{k+2}+…+a_l = (c-b)m$$。 从而推断出,$$m$$个正整数的序列.一定存在一组序列的和为$$m$$的整数倍. <strong>上面的Latex公示如果没显示完全看下面的图片(PS:Latex公式好麻烦,而且支持也好麻烦):</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180125215217.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215217.png\" alt></a></p>\n<h3 id=\"具体应用POJ2356\"><a href=\"#具体应用POJ2356\" class=\"headerlink\" title=\"具体应用POJ2356\"></a>具体应用POJ2356</h3><p>题意:输入N个正整数,选择序列中的一些数字,使其和为$$N\\*k$$(k为正整数). 代码:</p>\n<pre><code>//问从N个数中选取多少个数,使得这些数的和%N==0\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=10000+10;\nint num[maxn],sum[maxn];\nint r[maxn];\nint main(){\n    int N,ans=0,k=0,l=1;\n    memset(r,-1,sizeof(r));\n    scanf(&quot;%d&quot;,&amp;N);\n    sum[0]=0;\n\n    for(int i=1;i&lt;=N;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n        sum[i]=sum[i-1]+num[i];\n\n        int remainder=sum[i]%N;\n        if(remainder==0){\n            ans=i;\n            k=0;\n            l=i;\n        }else if(r[remainder]!=-1){\n            ans=i-r[remainder];\n            k=r[remainder];\n            l=i;\n        }else r[remainder]=i;\n    }\n    printf(&quot;%d\\n&quot;,ans);\n    for(int i=k+1;i&lt;=l;++i){\n        printf(&quot;%d\\n&quot;,num[i]);\n    }\n    return 0;\n}</code></pre><h1 id=\"基本计数方法\"><a href=\"#基本计数方法\" class=\"headerlink\" title=\"基本计数方法\"></a>基本计数方法</h1><h2 id=\"加法原理\"><a href=\"#加法原理\" class=\"headerlink\" title=\"加法原理\"></a>加法原理</h2><blockquote>\n<p>做一件事情有n种方法,第i中方法有Pi种方案,则一共有P1+P2+P3+…+Pn种方法.</p>\n</blockquote>\n<h2 id=\"乘法原理\"><a href=\"#乘法原理\" class=\"headerlink\" title=\"乘法原理\"></a>乘法原理</h2><blockquote>\n<p>做一件事情有n个步骤,第i个步骤有Pi种方案,则一共有P1P2P3…Pn中方案.</p>\n</blockquote>\n<h2 id=\"容斥原理\"><a href=\"#容斥原理\" class=\"headerlink\" title=\"容斥原理\"></a>容斥原理</h2><blockquote>\n<p>最基本的公式:</p>\n<blockquote>\n<p>|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|</p>\n</blockquote>\n</blockquote>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><h4 id=\"错位排列\"><a href=\"#错位排列\" class=\"headerlink\" title=\"错位排列\"></a>错位排列</h4><blockquote>\n<p>待填充</p>\n</blockquote>\n<h1 id=\"组合问题\"><a href=\"#组合问题\" class=\"headerlink\" title=\"组合问题\"></a>组合问题</h1><blockquote>\n<p>有n个不同的数,选出k个(顺序无关),每个数最多选一次,有多少种选法?</p>\n<blockquote>\n<p>记答案为C(n,k)。把n选k的排列问题看成两个步骤,首先选出k个数的组合,然后把这k个数进行全排列.由乘法原理知:</p>\n<blockquote>\n<p>P(n,k)=C(n,k)*P(k,k) 即<br>C(n,k)=n!/((n-k)!k!)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"性质1\"><a href=\"#性质1\" class=\"headerlink\" title=\"性质1\"></a>性质1</h2><blockquote>\n<p>C(n,0)=C(n,n)=1</p>\n</blockquote>\n<h2 id=\"性质2\"><a href=\"#性质2\" class=\"headerlink\" title=\"性质2\"></a>性质2</h2><blockquote>\n<p>C(n,k)=C(n,n-k)</p>\n</blockquote>\n<h2 id=\"性质3\"><a href=\"#性质3\" class=\"headerlink\" title=\"性质3\"></a>性质3</h2><blockquote>\n<p>C(n,k)+C(n,k+1)=C(n+1,k+1) 通常用于预处理C(n+1,…)</p>\n</blockquote>\n<h2 id=\"性质4\"><a href=\"#性质4\" class=\"headerlink\" title=\"性质4\"></a>性质4</h2><blockquote>\n<p>C(n,k+1)=C(n,k)*(n-k)/(k+1) 使用这个公式可以在O(n)的时间内求出C(n) 但注意不要发生乘法溢出.及后面的除法溢出</p>\n</blockquote>\n<h3 id=\"性质4通常运用-gt-二项式展开\"><a href=\"#性质4通常运用-gt-二项式展开\" class=\"headerlink\" title=\"性质4通常运用 =&gt; 二项式展开\"></a>性质4通常运用 =&gt; 二项式展开</h3><blockquote>\n<p>问题:</p>\n<blockquote>\n<p>求(a+b)^n展开式的各项系数</p>\n<blockquote>\n<p>二项式定理 (a+b)^n=Sigma(k=0~n)C(n,k)a^(n-k)b^k</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"其余三个问题\"><a href=\"#其余三个问题\" class=\"headerlink\" title=\"其余三个问题\"></a>其余三个问题</h2><h2 id=\"有重复元素的全排列\"><a href=\"#有重复元素的全排列\" class=\"headerlink\" title=\"有重复元素的全排列\"></a>有重复元素的全排列</h2><blockquote>\n<p>有重复元素的全排列</p>\n<blockquote>\n<p>有k个元素,其中第i个元素有Ni个,求全排列个数.</p>\n<blockquote>\n<p>直接看结论,可以简单证得 N1!*N2!*N3!<em>…\\</em>Nn!*ans=N! (移项即可)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"可重复选择的组合\"><a href=\"#可重复选择的组合\" class=\"headerlink\" title=\"可重复选择的组合\"></a>可重复选择的组合</h2><blockquote>\n<p>可重复选择的组合</p>\n<blockquote>\n<p>有n个不同的元素,每个元素可以选择多次,一共选k个元素,有多少种选法?</p>\n<blockquote>\n<p>例如n=3,k=2有6种</p>\n<blockquote>\n<p>(1,1)、(1,2)、(1,3)、(2,2)、(2,3)、(3,3)</p>\n</blockquote>\n</blockquote>\n<p>分析:</p>\n<blockquote>\n<p>设第i个元素选xi个,问题转化为求方程x1+x2+…+x3=k的非负整数解的个数. 令yi=xi+1,则答案为 y1+y2+y3+…+yn=k+n</p>\n</blockquote>\n</blockquote>\n<p>没太搞懂,直接放答案吧 C(k+n-1,n-1) =C(n+k-1,k)(性质2)</p>\n</blockquote>\n<h2 id=\"单色三角形\"><a href=\"#单色三角形\" class=\"headerlink\" title=\"单色三角形\"></a>单色三角形</h2><blockquote>\n<p>给定空间内的n(n&lt;=1000)个点,其中没有三点共线,每两个点之间都用红色或黑色线段链接.求三条边同色的三角形个数.</p>\n<blockquote>\n<p>考虑非单色三角形. 如果第i个点连接了ai条红边和n-1-ai条黑边,则这些边属于ai(n-1-ai)个非单色三角形。每个非单色三角形被考虑了两次,所以最终答案除以2 即 1/2*Sigma(i=1~n) ai(n-1-ai) 用总三角形减去非单色即为单色三角形个数</p>\n</blockquote>\n</blockquote>\n<h1 id=\"生成函数\"><a href=\"#生成函数\" class=\"headerlink\" title=\"生成函数\"></a>生成函数</h1><blockquote>\n<p>母函数是用于解决组合问题计数的一种方法。 在了解它之前我们先看看熟悉的杨辉三角。</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170611212741764.jpg\" alt></p>\n<blockquote>\n<p>杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)^n的展开式从低项到高项的各项系数，也可以表示为组合数的形式C(i,n)。如果将两者联系起来我们会发现，(1+x)可以看成对于一件取舍，1=x^0就是不取，x就是取。这样在(1+x)^n的展开式中x^i项的系数就是从n件物品选取i件的方案数。</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>给定数列a0,a1,a2…an，构造函数</p>\n<blockquote>\n<p>G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)</p>\n<blockquote>\n<p>其中G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)为标志函数。 母函数主要有两种形式：普通型母函数和指数型母函数。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"普通型母函数\"><a href=\"#普通型母函数\" class=\"headerlink\" title=\"普通型母函数\"></a>普通型母函数</h3><blockquote>\n<p>先看一个例题：HDU 1085</p>\n<blockquote>\n<p>普通型母函数的标志函数一般为x^0,x^1,x^2…x^n</p>\n</blockquote>\n<p>因为每个硬币有个数限制，但是也不难构造出</p>\n<blockquote>\n<p>G(x)=(1+x+x^2+x^3+…+x^num1)(1+x^2+x^4+…+x^(2∗num2))(1+x^5+x^10+…+x^(5∗num5)) 。</p>\n</blockquote>\n<p>将多项式展开后，x^i项对应的系数就是组成面值为i的方案数。 例题: 51nod 1383</p>\n</blockquote>\n<h3 id=\"指数型母函数\"><a href=\"#指数型母函数\" class=\"headerlink\" title=\"指数型母函数\"></a>指数型母函数</h3><blockquote>\n<p>再看一个例题：HDU 1521</p>\n<blockquote>\n<p>指数型母函数的标志函数一般为x^0/0!,x^1/1!,x^2/2!…x^n/n!，对于x^i/i!表示在一个方案中某个元素出现了i次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！</p>\n</blockquote>\n<p>对于这道题就不难构造出母函数为</p>\n<blockquote>\n<p>G(x)=(1/0!+X/1!+X^2/2!+…+X^a1/a1!)(1/0!+X/1!+X^2/2!+…+X^a2/a2!)(1/0!+X/1!+X^2/2!+…+X^an/an!)</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Catalan数列\"><a href=\"#Catalan数列\" class=\"headerlink\" title=\"Catalan数列\"></a>Catalan数列</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h3 id=\"待整理\"><a href=\"#待整理\" class=\"headerlink\" title=\"待整理\"></a>待整理</h3><blockquote>\n<p>Catalan数列可以解决很多问题.</p>\n<blockquote>\n<p>比如51nod 1120</p>\n</blockquote>\n</blockquote>\n<h2 id=\"Catalan前几项\"><a href=\"#Catalan前几项\" class=\"headerlink\" title=\"Catalan前几项\"></a>Catalan前几项</h2><pre><code>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, 18367353072152, 69533550916004, 263747951750360, 1002242216651368, 3814986502092304, 14544636039226909, 55534064877048198, 212336130412243110, 812944042149730764, 3116285494907301262, 11959798385860453492, 45950804324621742364, ...</code></pre><h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"一个小链接\"><a href=\"#一个小链接\" class=\"headerlink\" title=\"一个小链接\"></a>一个小链接</h3><p><a href=\"https://www.cnblogs.com/yaoyueduzhen/p/5456490.html\" title=\"Catalan应用及介绍\" target=\"_blank\" rel=\"noopener\">Catalan应用及介绍</a></p>\n<h3 id=\"待整理-1\"><a href=\"#待整理-1\" class=\"headerlink\" title=\"待整理\"></a>待整理</h3><h2 id=\"三种方法求Catalan整合\"><a href=\"#三种方法求Catalan整合\" class=\"headerlink\" title=\"三种方法求Catalan整合\"></a>三种方法求Catalan整合</h2><h3 id=\"注-其中有牵扯Lucas-Lucas在下面-直接放代码-注释在代码中-有对各个类型进行耗时对比\"><a href=\"#注-其中有牵扯Lucas-Lucas在下面-直接放代码-注释在代码中-有对各个类型进行耗时对比\" class=\"headerlink\" title=\"注:其中有牵扯Lucas,Lucas在下面,直接放代码,注释在代码中,有对各个类型进行耗时对比\"></a>注:其中有牵扯Lucas,Lucas在下面,直接放代码,注释在代码中,有对各个类型进行耗时对比</h3><h3 id=\"注2-求逆元中牵扯到了费马求逆元和欧拉求逆元\"><a href=\"#注2-求逆元中牵扯到了费马求逆元和欧拉求逆元\" class=\"headerlink\" title=\"注2:求逆元中牵扯到了费马求逆元和欧拉求逆元\"></a>注2:求逆元中牵扯到了费马求逆元和欧拉求逆元</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int maxn=1000000+10;\nLL h[10100];\n\n//函数功能: 预处理前N向Catalan\n//函数参数: n为项数\n//适合N比较小的情况\nvoid Catalan(int n){\n    h[0] = h[1] = 1;        //h(0)和h(1)\n    for(int i = 2; i &lt;= n; i++)    //依次计算h(2),h(3)...h(n)\n    {\n        h[i] = 0;\n        for(int j = 0; j &lt; i; j++) //根据递归式计算 h(i)= h(0)*h(i-1)+h(1)*h(i-2) + ... + h(i-1)h(0)\n            h[i] = (h[i]+(h[j] * h[i-1-j])%mod)%mod;\n    }\n}\n\n///h(n)=C(2n,n)/(n+1) (n=0,1,2,...)\n///+逆元+Lucas组合数取模\n///预处理逆元的话,大小会被限制,直接求的话可能会有常数\n///但是N就可以大一点\n///返回第N个catalan数\nLL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}\n///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nLL N_L_Catalan(int N){\n    return Lucas(2*N,N,mod)*inv[N+1]%mod;\n}\n\n///第三种方法\n///h(n)=C(2n,n)-C(2n,n+1)\n///由上式子可以直接两个Lucas+同余定理解决\n///复杂度可能会比第二种方法换成直接求逆元要高点\nLL T_Catalan(int N){\n    return (Lucas(2*N,N,mod)-Lucas(2*N,N+1,mod)+mod)%mod;\n}\n\n\n///第四种方法\n///直接求逆元(扩展欧几里得求逆元)+Lucas\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inverse(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nLL F_Catalan(int N){\n    return Lucas(2*N,N,mod)*inverse(1ll*N+1,1ll*mod)%mod;\n}\n\n///第五种\n///欧拉定理求逆元+Lucas\n///mod是素数且与N互质\nlong long Pow(long long a,long long b){\n    long long ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%mod;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%mod;\n    }\n    return ans;\n}\n\nlong long euler(int p)\n{\n    long long ans=p,a=p;\n    long long i;\n    for(i=2;i*i&lt;=a;i++)\n    {\n        if(a%i==0)\n        {\n            ans=ans/i*(i-1);\n            while(a%i==0)\n                a/=i;\n        }\n    }\n    if(a&gt;1)\n        ans=ans/a*(a-1);\n    return ans;\n}\n\nlong long eu=euler(mod)-1;\n\nlong long Einv(long long a)\n{\n    return Pow(a,eu);\n}\n\nLL Fi_Catalan(int N){\n    return Lucas(2*N,N,mod)*Einv(1ll*(N+1))%mod;\n}\n\nint main(){\n    Catalan(10000);\n    init();//初始化逆元\n    int k;\n    while(cin&gt;&gt;k){\n        if(k&lt;=10000)\n            cout&lt;&lt;&quot;第一种方法(预处理): &quot;&lt;&lt;h[k]&lt;&lt;endl;\n        if(k&lt;=1000000)\n            cout&lt;&lt;&quot;第二种方法(h(n)=C(2n,n)/(n+1),预处理逆元+Lucas): &quot;&lt;&lt;N_L_Catalan(k)&lt;&lt;endl;\n        clock_t startTime,endTime;\n        startTime = clock();\n        cout&lt;&lt;&quot;第三种方法(h(n)=C(2n,n)-C(2n,n+1),Lucas): &quot;&lt;&lt;T_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第四种方法(h(n)=C(2n,n)/(n+1),Lucas+扩欧求逆元): &quot;&lt;&lt;F_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第五种方法(h(n)=C(2n,n)/(n+1),Lucas+欧拉定理求逆元): &quot;&lt;&lt;Fi_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n    }\n    return 0;\n}</code></pre><h1 id=\"Lucas\"><a href=\"#Lucas\" class=\"headerlink\" title=\"Lucas\"></a>Lucas</h1><h2 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>Lucas定理用于对组合数求模</p>\n<blockquote>\n<p>因为组合数是一个大式子,无法直接求模,所以用到了Lucas</p>\n</blockquote>\n</blockquote>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><pre><code>///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}</code></pre>","text":"因为组合数学涉及面广,采取边学边更新.预计大部分会摘自《组合数学》【鸽巢定理】也叫作狄利克雷抽屉原理以及鞋盒原理. 对于鸽巢定理的简单阐释,粗略的说就是如果有许多鸽子飞进不够多的鸽巢内。那么至少要有一个鸽巢被两个或多个鸽子占据.简单形式很通俗的定理 : 如果要把n+1个物体放进n","link":"","raw":null,"photos":[],"categories":[{"name":"组合数学","slug":"组合数学","count":1,"path":"api/categories/组合数学.json"}],"tags":[{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"}]},{"title":"HDU 1849","slug":"hdu-1849","date":"2018-01-24T10:35:08.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1849.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg","content":"<p>【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" alt></a> 原题说我们需要将每个格子内的棋子进行移动,当所有棋子都位于最左边编号为0的格子时,游戏结束. 首先我们将棋盘竖起来(自己画的,所以会少一点,但大体意思一样). <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124182908.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124182908.png\" alt></a> 然后我们将其中的棋子分开来: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124183152.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124183152.png\" alt></a> 这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时,即代表石子已取空. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int K;\n    while(~scanf(&quot;%d&quot;,&amp;K)){\n        if(K==0) break;\n        int ans=0;\n        while(K--){\n            int a;\n            scanf(&quot;%d&quot;,&amp;a);\n            ans^=a;\n        }\n        if(ans==0)puts(&quot;Grass Win!&quot;);\n        else puts(&quot;Rabbit Win!&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图:  [Figure]  这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 1847","slug":"hdu-1847","date":"2018-01-24T09:54:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1847.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"【博弈论-SG函数】\"><a href=\"#【博弈论-SG函数】\" class=\"headerlink\" title=\"【博弈论 - SG函数】\"></a>【博弈论 - SG函数】</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h2><h3 id=\"Good-Luck-in-CET-4-Everybody\"><a href=\"#Good-Luck-in-CET-4-Everybody\" class=\"headerlink\" title=\"Good Luck in CET-4 Everybody!\"></a>Good Luck in CET-4 Everybody!</h3><p>Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 11483 Accepted Submission(s): 7446 大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。 “升级”？“双扣”？“红五”？还是“斗地主”？ 当然都不是！那多俗啊~ 作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的： 1、 总共n张牌; 2、 双方轮流抓牌； 3、 每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…） 4、 抓完牌，胜负结果也出来了：最后抓完牌的人为胜者； 假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？ 当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。 Good luck in CET-4 everybody!</p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p>\n<h2 id=\"SampleInput\"><a href=\"#SampleInput\" class=\"headerlink\" title=\"SampleInput\"></a>SampleInput</h2><p>1 3</p>\n<h2 id=\"SampleOutput\"><a href=\"#SampleOutput\" class=\"headerlink\" title=\"SampleOutput\"></a>SampleOutput</h2><p>Kiki Cici</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>首先我们要知道SG函数代表的是当前状态的数值.如果是0,则为先手必败(SG函数值为可到达状态中未出现的最小的整数).然后我们从SG函数延伸一下– 1.我们假设当n=0时,先手必败. 2.当n=1时,因为S(0)=0，所以当前状态是非奇异局势.先手必胜,即,你可以通过拿走一定的牌使下一个拿牌的人的局势变成奇异局势(必败态). 即转移给下一个抽牌者状态为S(0). 3.当n=2是,因为S(0)=0，S(1)=1.所以当前状态是非奇异局势,先手必胜. 即你可以把下一个抽牌者状态转换成S(0). 4.当n=3时,可到达状态为S(3-1)=S(2)=1.S(3-2)=S(1)=1.因为无论往那个状态走,都会使对方先手必胜,所以该局势为奇异局势.先手必败. 故我们可以根据以上推理过程将全部的1000个状态是否必胜预处理处来.其预处理过程为<strong>检查可以到达的状态是否存在奇异局势,如果存在,则该局势为非奇异局势,即先手必胜态</strong>. 因为可拿牌数都是2^n.所以预处理复杂度为O(nlg(n)). PS…:其实预处理完以后你会发现.每当n%3==0时,为奇异局势. Code:</p>\n<pre><code>//SG函数\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nbool game[1001];\n\nvoid init(){\n    memset(game,false,sizeof(game));\n    for(int i=1;i&lt;=1000;++i){\n        int t=1;\n        while(i-t&gt;=0){\n            //如果i-t是奇异局势,则先手必胜\n            if(!game[i-t]){\n                game[i]=true;\n                break;\n            }\n            t&lt;&lt;=1;\n        }\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(game[n]){\n            printf(&quot;Kiki\\n&quot;);\n        }else{\n            printf(&quot;Cici\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【博弈论 - SG函数】题目:Good Luck in CET-4 Everybody!Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submissio","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"POJ 1067","slug":"poj-1067","date":"2018-01-24T09:11:04.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/poj-1067.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【威佐夫博弈】</p>\n<pre><code>//威佐夫博弈\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main(){\n    int n,m;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        int k=max(n,m)-min(n,m);\n        int ak=k*(1+sqrt(5))/2;\n        int bk=ak+k;\n        if(min(n,m)==ak&amp;&amp;max(n,m)==bk){\n            printf(&quot;0\\n&quot;);\n        }else{\n            printf(&quot;1\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【威佐夫博弈】//威佐夫博弈#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int n,m;    while(~sc","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"博弈论","slug":"POJ/博弈论","count":1,"path":"api/categories/POJ/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"HDU 1846","slug":"hdu-1846","date":"2018-01-24T08:33:41.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1846.json","excerpt":"","keywords":null,"cover":null,"content":"<p>裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        if((n)%(m+1)==0) printf(&quot;second\\n&quot;);\n        else printf(&quot;first\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ ","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"巴什博奕","slug":"巴什博奕","count":1,"path":"api/tags/巴什博奕.json"}]},{"title":"HDU 2149","slug":"hdu-2149","date":"2018-01-24T08:16:55.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2149.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"【巴什博奕】\"><a href=\"#【巴什博奕】\" class=\"headerlink\" title=\"【巴什博奕】\"></a>【巴什博奕】</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h2><p>虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。 后来发现，整个拍卖会只有Lele和他的死对头Yueyue。 通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。 Lele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。 由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候， Lele要出多少才能保证自己买得到这块地呢？</p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input:\"></a>Input:</h2><p>本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。 每组测试包含两个整数M和N(含义见题目描述，0&lt;N，M&lt;1100)</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output:\"></a>Output:</h2><p>对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。 如果Lele在第一次无论如何出价都无法买到这块土地，就输出”none”。</p>\n<h2 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h2><p>4 2 3 2 3 5</p>\n<h2 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h2><p>1 none 3 4 5</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>我们知道,在巴士博弈中,n=0为先手必输态,之后n=m+1为下一个先手必输态. 而当Lele在竞拍的时候,如果他所在的初始状态是如上所述的这样一个奇异局势(即先手必输局势),那他一定输(none). 当Lele在竞拍处于非奇异局势时,在选择最优的情况下,他一定可以赢得竞拍.即他只需要通过增价将对手置于奇异状态即可. 所以当我们想要找出Lele第一次出家的可能性时,只需要先找出Lele的第一个置对方为奇异局势的 价格 .然后在寻找下一个的时候只需要依次++,直到下一次加价会给对方一个 非奇异局势前 结束循环. 当然,存在一种可能性就是,初次加价可能会溢出n的价格范围.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n,m;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        if(n%(m+1)==0) printf(&quot;none\\n&quot;);\n        else{\n            int next=0;\n            while(1){\n                next++;\n                if((n-next)%(m+1)==0){\n                    printf(&quot;%d&quot;,next);\n                    break;\n                }\n            }\n            while(next&lt;m){\n                next++;\n                if((n-next)%(m+1)==0 || next&gt;=n){\n                    printf(&quot; %d&quot;,next);\n                }else{\n                    break;\n                }\n            }\n            printf(&quot;\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】题目:虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2188","slug":"hdu-2188","date":"2018-01-24T07:49:43.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-2188.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"【巴什博奕】\"><a href=\"#【巴什博奕】\" class=\"headerlink\" title=\"【巴什博奕】\"></a>【巴什博奕】</h1><p>可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    while(~scanf(&quot;%d&quot;,&amp;T)){\n        while(T--){\n            scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n            if((n)%(m+1)==0) printf(&quot;Rabbit\\n&quot;);\n            else printf(&quot;Grass\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int T,n,m;    while(~s","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"博弈论","slug":"game","date":"2018-01-24T03:05:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/game.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg","content":"<p>[toc]</p>\n<h1 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h1><h2 id=\"博弈树\"><a href=\"#博弈树\" class=\"headerlink\" title=\"博弈树\"></a>博弈树</h2><p>重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。</p>\n<h2 id=\"SG函数\"><a href=\"#SG函数\" class=\"headerlink\" title=\"SG函数\"></a>SG函数</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个状态,则两点间有一条有向边,这样就得到了一个状态图.</p>\n<h3 id=\"巴什博奕\"><a href=\"#巴什博奕\" class=\"headerlink\" title=\"巴什博奕\"></a>巴什博奕</h3><p>以巴什博奕为例,一共有n个物品,两人轮流取,一次最少取走1个最多去走m个，最后取光的人获胜。下图展示了n=6,m=3的时候的状态图,节点内的数字表示当前状态剩下的物品的个数. <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" alt></a> 假设游戏不会出现平局,即状态图是无环图的话,所有的状态可以分为两种,P态和N态。P态表示该状态对于前一个玩家来说是必胜态,而N态表示该状态对于下一个玩家来说是必胜态。例如对于n=6,m=3的巴什博奕来说,0个物品显然是P态,而还剩1、2或3个物品的状态都是N态。 一个状态被称为终止状态,如果当前状态下游戏不能再继续进行,譬如巴什博奕种物品都已经被取光了,在大部分游戏规则中,终止状态都是P态,所以如果不加特殊说明,一下都假设P态为终止状态. 从定义可知,任意一个P态,他要么是终止状态,要么他所有可以转移到的状态都是N态,而对于任意一个N态,他至少有一个后继状态是P态.</p>\n<h3 id=\"SG函数-1\"><a href=\"#SG函数-1\" class=\"headerlink\" title=\"SG函数\"></a>SG函数</h3><p>SG函数是这样定义的:对于任意状态x,他的SG函数值g(x)=mex{g(y)|y是x的后续状态},其中mex是一个对于非负整数集合S的运算, mex(S)为S中没有出现的最小负整数 。对于一个终止状态,因为他没有后继状态,所以他的SG函数值是0. 还是以上面的巴什博奕为例: n=6,m=3.用Si表示还剩i个物品的状态。S0是终止状态,所以g(S0)=0。S1的唯一后继状态是S0,所以g(S1)=1,S2可以转移到S1和S0，所以g(S2)是2.因为S3可以转移到S0,S1,S2,所以g(S3)=3.对于S4来说,它可以转移到S1，S2，S3(1，2，3),所以g(S4)=0.以此类推可以知道g(S5)=1，g(S6)=2. 如果知道一个状态SG函数值,则可以快速的判断当前状态时P态还是N态.对于一个函数,如果状态值是0则是P态,否则就是N态. g(S4),P态,先手必败(后继都是N态);g(S5)，N态(后继有P态),先手必胜.</p>\n<h1 id=\"KuangBin介绍博弈\"><a href=\"#KuangBin介绍博弈\" class=\"headerlink\" title=\"KuangBin介绍博弈\"></a>KuangBin介绍博弈</h1><h2 id=\"（一）巴什博奕（Bash-Game）：\"><a href=\"#（一）巴什博奕（Bash-Game）：\" class=\"headerlink\" title=\"（一）巴什博奕（Bash Game）：\"></a>（一）巴什博奕（Bash Game）：</h2><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个， 后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果 n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的 取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十 个，谁能报到100者胜。</p>\n<h2 id=\"（二）威佐夫博奕（Wythoff-Game）：\"><a href=\"#（二）威佐夫博奕（Wythoff-Game）：\" class=\"headerlink\" title=\"（二）威佐夫博奕（Wythoff Game）：\"></a>（二）威佐夫博奕（Wythoff Game）：</h2><p>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示 两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6， 10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有 如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1 ，而 bk= ak + k &gt; ak -1 + k-1 = bk-1 &gt; ak-1 。所以性质1。成立。 2。任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其 他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由 于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了 奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局 势；如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab + ak个物体,变为奇异局 势（ ab – ak , ab – ak+ b – ak）；如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余 的数量a – ak 即可；如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k） ,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – a j 即可。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜 ；反之，则后拿者取胜。 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 奇妙的是其中出现了黄金分割数（1+√5）/2 = 1。618…,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。</p>\n<h3 id=\"威佐夫博弈的几点判断\"><a href=\"#威佐夫博弈的几点判断\" class=\"headerlink\" title=\"威佐夫博弈的几点判断:\"></a>威佐夫博弈的几点判断:</h3><h4 id=\"非奇异局势时-先手一方只需要将当前局势变成奇异局势即可必胜\"><a href=\"#非奇异局势时-先手一方只需要将当前局势变成奇异局势即可必胜\" class=\"headerlink\" title=\"非奇异局势时,先手一方只需要将当前局势变成奇异局势即可必胜\"></a>非奇异局势时,先手一方只需要将当前局势变成奇异局势即可必胜</h4><h4 id=\"奇异局势时-后手一方只需要将非奇异局势变成奇异局势必胜\"><a href=\"#奇异局势时-后手一方只需要将非奇异局势变成奇异局势必胜\" class=\"headerlink\" title=\"奇异局势时,后手一方只需要将非奇异局势变成奇异局势必胜\"></a>奇异局势时,后手一方只需要将非奇异局势变成奇异局势必胜</h4><h2 id=\"（三）尼姆博奕（Nimm-Game）：\"><a href=\"#（三）尼姆博奕（Nimm-Game）：\" class=\"headerlink\" title=\"（三）尼姆博奕（Nimm Game）：\"></a>（三）尼姆博奕（Nimm Game）：</h2><p>有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首 先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是 （0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一 下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情 形。 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示 这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结 果： 1 =二进制01 2 =二进制10 3 =二进制11 （+） ——————— 0 =二进制00 （注意不进位） 对于奇异局势（0，n，n）也一样，结果也是0。 任何奇异局势（a，b，c）都有a（+）b（+）c =0。 <strong>如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b &lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果: a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（a（+）b）即可。</strong> 例1。（14，21，39），14（+）21=27，39-27=12，所以从39中拿走12个物体即可达 到奇异局势（14，21，27）。 例2。（55，81，121），55（+）81=102，121-102=19，所以从121中拿走19个物品 就形成了奇异局势（55，81，102）。 例3。（29，45，58），29（+）45=48，58-48=10，从58中拿走10个，变为（29，4 5，48）。</p>\n<pre><code>例4。我们来实际进行一盘比赛看看：\n    甲:(7,8,9)-&gt;(1,8,9)奇异局势\n    乙:(1,8,9)-&gt;(1,8,4)\n    甲:(1,8,4)-&gt;(1,5,4)奇异局势\n    乙:(1,5,4)-&gt;(1,4,4)\n    甲:(1,4,4)-&gt;(0,4,4)奇异局势\n    乙:(0,4,4)-&gt;(0,4,2)\n    甲:(0.4,2)-&gt;(0,2,2)奇异局势\n    乙:(0,2,2)-&gt;(0,2,1)\n    甲:(0,2,1)-&gt;(0,1,1)奇异局势\n    乙:(0,1,1)-&gt;(0,1,0)\n    甲:(0,1,0)-&gt;(0,0,0)奇异局势\n    甲胜。</code></pre><h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><h3 id=\"斐波那契博弈\"><a href=\"#斐波那契博弈\" class=\"headerlink\" title=\"斐波那契博弈\"></a>斐波那契博弈</h3><p>1、问题模型： 有一堆个数为n的石子，游戏双方轮流取石子，满足： （1）先手不能在第一次把所有的石子取完； （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。 2、解决思路： 当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 证明：根据“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。如n=83 = 55+21+5+2，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，那么一定是先手取走这5颗石子中的最后一颗，同理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。 反证：如果n是Fibonacci数，如n=89：记先手一开始所取的石子数为y （1）若y&gt;=34颗（也就是89的向前两项），那么一定后手赢，因为89-34=55=34+21&lt;2*34。 （2）y&lt;34时剩下的石子数x介于55到89之间，它一定不是一个Fibonacci数，把x分解成Fibonacci数：x=55+f[i]+…+f[j]，若，如果f[j]&lt;=2y，那么对B就是面临x局面的先手，所以根据之前的分析，后手只要先取f[j]个即可，以后再按之前的分析就可保证必胜。</p>\n<h3 id=\"公平组合博弈（Impartial-Combinatori-Games）\"><a href=\"#公平组合博弈（Impartial-Combinatori-Games）\" class=\"headerlink\" title=\"公平组合博弈（Impartial Combinatori Games）\"></a>公平组合博弈（Impartial Combinatori Games）</h3><p>1、定义： （1）两人参与。 （2）游戏局面的状态集合是有限。 （3）对于同一个局面，两个游戏者的可操作集合完全相同 （4）游戏者轮流进行游戏。 （5）当无法进行操作时游戏结束，此时不能进行操作的一方算输。 （6）无论游戏如何进行，总可以在有限步数之内结束。 2、模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有公平组合游戏（Impartial Combinatori Games）的抽象模型。其实，任何一个ICG都可以通过把每个局势看成一个顶点，对每个局势和它的子局势连一条有向边来抽象成这个“有向图游戏”。 3、解决思路： 现在，假定我们给出两个游戏G1 和 G2。如果我们只知道单个游戏的P-状态和N-状态我们能够正确地玩好游戏和G1 + G2吗？答案是否定的。不难看出两个P-状态的和总是P-状态，P-状态和N-状态的和总是N-状态。但是两个N-状态的和既可能是P-状态也可能是N-状态。因此，只知道单个游戏的P-状态和N-状态是不够的。 为了正确地玩好游戏和我们需要推广P-状态和N-状态，它就是Sprague-Grudy函数（或者简称为g函数） 4、Sprague-Grudy定理： 令N = {0, 1, 2, 3, …} 为自然数的集合。Sprague-Grundy 函数给游戏中的每个状态分配了一个自然数。结点v的Grundy值等于没有在v的后继的Grundy值中出现的最小自然数. 形式上：给定一个有限子集 S ⊂ N,令mex S(最小排斥值)为没有出现在S中的最小自然数。定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。 5、性质： （1）所有的终结点所对应的顶点，其SG值为0，因为它的后继集合是空集——所有终结点是必败点（P点）。 （2）对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0——无论如何操作，从必败点（P点）都只能进入必胜点（N点）//对手走完又只能把N留给我们。 （3）对于一个g(x)!=0的顶点，必定存在一个后继点y满足g(y)=0——从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）//就是那种我们要走的方法。 6、应用： （1）可选步数为1-m的连续整数，直接取模即可，SG(x) = x % (m+1); （2）可选步数为任意步，SG(x) = x; （3）可选步数为一系列不连续的数，用mex(计算每个节点的值)</p>\n","text":"[toc]博弈论博弈树重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。SG函数基本概念在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个","link":"","raw":null,"photos":[],"categories":[{"name":"博弈论","slug":"博弈论","count":3,"path":"api/categories/博弈论.json"},{"name":"算法学习","slug":"博弈论/算法学习","count":1,"path":"api/categories/博弈论/算法学习.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"第八届ACM省赛 K CF","slug":"acm-k-cf","date":"2018-01-18T07:35:38.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/acm-k-cf.json","excerpt":"","keywords":null,"cover":"http://acm.sdut.edu.cn/image/3903.png","content":"<h3 id=\"CF\"><a href=\"#CF\" class=\"headerlink\" title=\"CF\"></a>CF</h3><p><strong>sdut 3903</strong> Time Limit: 1000MS Memory Limit: 65536KB</p>\n<h4 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h4><p><img src=\"http://acm.sdut.edu.cn/image/3903.png\" alt> LYD loves codeforces since there are many Russian contests. In an contest lasting for <em>T</em> minutes there are <em>n</em> problems, and for the <em>i__th</em> problem you can get <em>a__i_−_d__i_∗_t__i</em> points, where <em>a__i</em> indicates the initial points, <em>d__i</em> indicates the points decreased per minute (count from the beginning of the contest), and <em>t__i</em> stands for the passed minutes when you solved the problem (count from the begining of the contest).<br>Now you know LYD can solve the <em>i__th</em> problem in <em>c__i</em> minutes. He can’t perform as a multi-core processor, so he can think of only one problem at a moment. Can you help him get as many points as he can?</p>\n<h4 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h4><p>The first line contains two integers <em>n</em>,<em>T</em>(0≤<em>n</em>≤2000,0≤<em>T</em>≤5000).<br>The second line contains <em>n</em> integers <em>a</em>1,<em>a</em>2,..,<em>a__n</em>(0&lt;<em>a__i_≤6000).<br>The third line contains _n</em> integers <em>d</em>1,<em>d</em>2,..,<em>d__n</em>(0&lt;<em>d__i_≤50).<br>The forth line contains _n</em> integers <em>c</em>1,<em>c</em>2,..,<em>c__n</em>(0&lt;_c__i_≤400).</p>\n<h4 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h4><p>Output an integer in a single line, indicating the maximum points LYD can get.</p>\n<h4 id=\"Example-Input\"><a href=\"#Example-Input\" class=\"headerlink\" title=\"Example Input\"></a>Example Input</h4><p>3 10<br>100 200 250<br>5 6 7<br>2 4 10</p>\n<h4 id=\"Example-Output\"><a href=\"#Example-Output\" class=\"headerlink\" title=\"Example Output\"></a>Example Output</h4><p>254</p>\n<h4 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a><strong>题意</strong></h4><p>有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题的分数便会减少 di ，而我们可以在 ci 时间内做出这道题而得到分数，求在时间 T 内最多可以获得的分数。</p>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a><strong>题解</strong></h4><p>首先可以感觉出这是道0-1背包问题,然后我们需要知道,当我们做题时,会一两个角度来选择题目,其一是选择做题速度最快的,其二是选择做分值降低速度最快的.那么我们的衡量标准就可以看成先做单位时间内做题最多的那道. 然后我们根据上述规则排一下序. 在用排序后的数组进行0-1背包.在背包过程中记录最大值,即为最后的结果.</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=3000;\n\nstruct pro{\n    int a,d,c;\n    //按单位时间内减少分值排序\n    bool operator &lt;(const pro &amp;pt)const{\n        return 1.0*d/c&gt;(1.0*pt.d/pt.c);\n    }\n};\n\nint n,T;\npro p[maxn];\nint dp[5010];\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;T)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].a);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].d);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].c);\n        }\n        sort(p,p+n);\n        int mx=-1;\n        for(int i=0;i&lt;n;++i){\n            for(int j=T;j&gt;=0;--j){\n                if(j&gt;=p[i].c){\n                    dp[j]=max(dp[j],dp[j-p[i].c]+p[i].a-j*p[i].d);\n                }\n                mx=max(mx,dp[j]);\n            }\n        }\n        printf(&quot;%d\\n&quot;,mx);\n    }\n    return 0;\n}</code></pre>","text":"CFsdut 3903 Time Limit: 1000MS Memory Limit: 65536KBProblem Description [Figure] 2 4 10Example Output254题意有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"动态规划","slug":"Sdut/动态规划","count":2,"path":"api/categories/Sdut/动态规划.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/动态规划/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/动态规划/第八届ACM山东省赛.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"Tarjan 强连通分量算法","slug":"tarjan-scc-algorithm","date":"2018-01-17T10:03:54.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/tarjan-scc-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg","content":"<p>Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.</p>\n<h2 id=\"学习契机-HDU-6038\"><a href=\"#学习契机-HDU-6038\" class=\"headerlink\" title=\"学习契机: HDU 6038\"></a>学习契机: <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6038\" title=\"HDU 6038\" target=\"_blank\" rel=\"noopener\">HDU 6038</a></h2><p>首先介绍下:</p>\n<h2 id=\"强连通分量\"><a href=\"#强连通分量\" class=\"headerlink\" title=\"强连通分量:\"></a>强连通分量:</h2><p>画图以明志 -- <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" alt></a> <code>Tarjan</code>算法的时间复杂度是线性的,而kos算法则需要计算图的转置.该算法由Tarjan于1972年提出,是SCC<code>(Strongly Connected Componenet,强连通分量)</code>的第一个线性算法,Tarjan算法借助于DFS,但它并不需要靠遍历顺序(Kos算法的思想)来分离SCC,而是允许SCC并存于同一颗DFS树中,然后通过某种手段将他们分开.</p>\n<h2 id=\"DAG\"><a href=\"#DAG\" class=\"headerlink\" title=\"DAG:\"></a>DAG:</h2><p>如果把一个集合看成一个点,那么所有的SCC构成了一个SCC图.这个SCC图不会存在有向环,因此是一个DAG<code>(Directed Acyclic Graph,有向无环图)</code>. 那他喵的什么是DAG呢?我把上面的那个强连通分量图给DAG化: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" alt></a></p>\n<h2 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h2><p>考虑强连通分量C,设其中第一个被发现的点为x,则C中其他点都是x的后代.我们希望在x dfs访问完成后立即输出C.这样,就可以在一棵DFS树中区分开所有SCC了.因此,问题的关键是如何发现每个SCC的第一个点.</p>\n<h3 id=\"如何判断是否是SCC顶点\"><a href=\"#如何判断是否是SCC顶点\" class=\"headerlink\" title=\"如何判断是否是SCC顶点\"></a>如何判断是否是SCC顶点</h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" alt></a> 假设我们正在判断u是否为某SCC的第一个被发现节点.如果我们发现<code>从u的子节点出发可以达到u的祖先w,显然u就不是SCC的顶点.</code>反之,如果SCC最远的顶点可以到u,则u是SCC的顶点.图中虚线表示一条或多条边和点. 我们使用两个数组来记录每个节点的状态.pre[]和lowlink[]. 当递归回溯时如果这两个数组的值相同,则表明该节点为某SCC顶点.</p>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><p>见: <a href=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" title=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/keyboarderqq/article/details/71308102</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1 id=\"此致-画个图你就知道low数组的具体作用了\"><a href=\"#此致-画个图你就知道low数组的具体作用了\" class=\"headerlink\" title=\"此致:画个图你就知道low数组的具体作用了.\"></a>此致:画个图你就知道low数组的具体作用了.</h1>","text":"Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.学习契机: HDU 6038首先介绍下:强连通分量:画图以明志 --  [Figure]  假设我们正在判断u是否为某SCC的第","link":"","raw":null,"photos":[],"categories":[{"name":"Tarjan","slug":"Tarjan","count":1,"path":"api/categories/Tarjan.json"},{"name":"图论","slug":"Tarjan/图论","count":1,"path":"api/categories/Tarjan/图论.json"},{"name":"算法学习","slug":"Tarjan/图论/算法学习","count":1,"path":"api/categories/Tarjan/图论/算法学习.json"},{"name":"连通分量","slug":"Tarjan/图论/算法学习/连通分量","count":1,"path":"api/categories/Tarjan/图论/算法学习/连通分量.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]}]}