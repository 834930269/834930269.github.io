{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"计划:技术栈完善2-实战Java高并发程序设计-Category","slug":"plan-category","date":"2018-06-17T06:38:13.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-category.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>更新到第三章</p>\n</blockquote>\n<h1 id=\"第一章-Done\"><a href=\"#第一章-Done\" class=\"headerlink\" title=\"第一章 (Done)\"></a>第一章 (Done)</h1><p><strong>2018/6/16</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/16/plan-two/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第一章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第一章</a></p>\n<h1 id=\"第二章-Done\"><a href=\"#第二章-Done\" class=\"headerlink\" title=\"第二章 (Done)\"></a>第二章 (Done)</h1><p><strong>2018/6/17</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/17/plan-two-2/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第一章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第二章</a></p>\n<h1 id=\"第三章-Done\"><a href=\"#第三章-Done\" class=\"headerlink\" title=\"第三章 (Done)\"></a>第三章 (Done)</h1><p><strong>2018/6/19</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/19/plan-three/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第三章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第三章</a></p>\n<h1 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h1><h1 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h1><h1 id=\"第六章\"><a href=\"#第六章\" class=\"headerlink\" title=\"第六章\"></a>第六章</h1><h1 id=\"第七章\"><a href=\"#第七章\" class=\"headerlink\" title=\"第七章\"></a>第七章</h1><h1 id=\"第八章\"><a href=\"#第八章\" class=\"headerlink\" title=\"第八章\"></a>第八章</h1>","text":"更新到第三章第一章 (Done)2018/6/16 计划:技术栈完善2-实战JAVA高并发程序设计-第一章第二章 (Done)2018/6/17 计划:技术栈完善2-实战JAVA高并发程序设计-第二章第三章 (Done)2018/6/19 计划:技术栈完善2-实战JAVA高并发程","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善2-实战Java高并发程序设计-第一章","slug":"plan-two","date":"2018-06-16T07:28:51.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-two.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/89864d67883030d36838db52c72af586.png","content":"<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><blockquote>\n<p>如图 同步是链式进行:只有当一个任务结束后才可以继续下一个 而异步则是前进-&gt;等待消息返回(同时继续前进进行其他的任务)-&gt;消息返回,继续前进.</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/89864d67883030d36838db52c72af586.png\" alt></p>\n<h2 id=\"并发-Concurrency-和并行-Parallelism\"><a href=\"#并发-Concurrency-和并行-Parallelism\" class=\"headerlink\" title=\"并发(Concurrency)和并行(Parallelism)\"></a>并发(Concurrency)和并行(Parallelism)</h2><blockquote>\n<p>如图 并发是以时间片为单位看似同步进行 并行是实际上的同步进行(一般为多核) <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/a580d15d23bbcbaa2c928b770d15b275.png\" alt></p>\n</blockquote>\n<h2 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h2><blockquote>\n<p>即可以有多个线程来使用它,但同一时刻只能有一个线程来使用它. 一但临界区被一个线程占用,其他线程就必须等待.</p>\n</blockquote>\n<h2 id=\"阻塞-Blocking-和非阻塞-Non-Blocking\"><a href=\"#阻塞-Blocking-和非阻塞-Non-Blocking\" class=\"headerlink\" title=\"阻塞(Blocking)和非阻塞(Non-Blocking)\"></a>阻塞(Blocking)和非阻塞(Non-Blocking)</h2><blockquote>\n<p>阻塞: 一个线程占用了临界区资源,那么<code>其他所有</code>需要这个资源的线程就必须在这个临界区中进行等待. 非阻塞: 任何线程都不会阻碍其他线程的执行,所有的线程都会尝试不断向前继续执行.</p>\n</blockquote>\n<h2 id=\"死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock\"><a href=\"#死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock\" class=\"headerlink\" title=\"死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)\"></a>死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/892f79594c910e601ccc98a27ec395f0.png\" alt></p>\n<blockquote>\n<p><code>死锁</code>: 如上图,在专业课程中,我们所学到的死锁经常会这样描述-</p>\n<blockquote>\n<p>单行道(堵塞/等待):</p>\n<blockquote>\n<p>线程A需求资源B,占用资源A(资源A最大为1个) 线程B需求资源A,占用资源B(资源B最大为1个) 他俩同时锁住了这两个资源并等待想要的资源.卡掉了.</p>\n</blockquote>\n<p>N个同理.大家都不想放掉自己的资源,又想要别人的.</p>\n</blockquote>\n<p><code>饥饿</code>: 在每一个线程都有优先级的时候,如果一个线程的优先级始终在下面,他就永远得不到资源了，当然,不一定只有这种情况.</p>\n<blockquote>\n<p>与死锁相比,姐还是有可能在一段时间后自行解决的</p>\n</blockquote>\n<p><code>活锁</code>: 两人互相谦让,死脑筋的想着从相同的口出/进就是活锁,本来有机会解锁的…</p>\n</blockquote>\n<h2 id=\"并发级别\"><a href=\"#并发级别\" class=\"headerlink\" title=\"并发级别\"></a>并发级别</h2><blockquote>\n<p>由于临界区的存在,多线程之间的并发必须受到控制。根据控制并发的策略,我们可以把并发的级别进行分类,大致可以分为阻塞、无饥饿、无障碍、无锁、无等待几种.</p>\n</blockquote>\n<h3 id=\"阻塞-Blocking\"><a href=\"#阻塞-Blocking\" class=\"headerlink\" title=\"阻塞(Blocking)\"></a>阻塞(Blocking)</h3><blockquote>\n<p>当我们使用synchronized关键字,或者重入锁时,我们得到的就是阻塞的线程. 无论哪种情况,都会在试图执行后续代码前,得到的是临界区的锁,如果得不到,都会被挂起等待,知道占用了所需资源为止.</p>\n<blockquote>\n<p>PS:以上均未遇见,书上说在后面</p>\n</blockquote>\n</blockquote>\n<h3 id=\"无饥饿-Starvation-Free\"><a href=\"#无饥饿-Starvation-Free\" class=\"headerlink\" title=\"无饥饿(Starvation-Free)\"></a>无饥饿(Starvation-Free)</h3><blockquote>\n<p>如果线程有优先级,而<code>选用的线程调度算法</code>允许插队,成为非公平,如下图,那么最下面的很大可能会产生饥饿</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/552bc58e0ac12208199b9fad12fc3a04.png\" alt></p>\n<blockquote>\n<p>如果线程是公平的,就不会产生饥饿,不管来的线程优先级多么的高,要想获得资源,就必须 乖 ♂ 乖 ♂ 站 ♂ 好 ♂,所有的线程都会执行.</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/5a479a4139398cbca7e9b73bd2d8cfa5.png\" alt></p>\n<h3 id=\"无障碍-Obstruction-Free\"><a href=\"#无障碍-Obstruction-Free\" class=\"headerlink\" title=\"无障碍(Obstruction-Free)\"></a>无障碍(Obstruction-Free)</h3><blockquote>\n<p>不对临界区设任何门栏,任何线程想进就进,想出就出,如果出现数据混乱了怎么办</p>\n<blockquote>\n<p>一旦检测到了数据改坏了,就会对自己所做的修改进行回滚.确保数据安全.如果没有竞争发生,数据就会很安全的离开临界区.</p>\n</blockquote>\n<p>故如果有严重的错误时,所有的线程都会不断地会滚自己的操作.导致没有一个线程可以走出来,顾我们会希望至少有一个县城可以安全地走出来. <code>一致性标记</code>:线程在操作之前,先读取并保存这个标记,在操作完成后,再次读取,检查这个标记是否被更改过.如果两者一致,说明资源访问没又发生冲突,安全.如果不一致,需要重试操作.而任何尝试修改数据的线程,都需要在修改前更改这个一致性标记,表示这个数据不再安全.</p>\n<blockquote>\n<p>如下图</p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0982523d459a08c27cc6a2f902333ce0.png\" alt></p>\n<h3 id=\"无锁-Lock-Free\"><a href=\"#无锁-Lock-Free\" class=\"headerlink\" title=\"无锁(Lock-Free)\"></a>无锁(Lock-Free)</h3><blockquote>\n<p>所有线程都可以尝试对临界区进行访问,但不同的是,无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区. 无锁是一个无穷循环。在这个循环中,线程会不断尝试修改共享变量,如果没有冲突,修改成功,则退出,否则继续尝试修改,但无论如何,无锁一定会有一个线程可以胜出.</p>\n<blockquote>\n<p>但是无锁会出现类似于饥饿的情况.</p>\n</blockquote>\n<p>例:</p>\n</blockquote>\n<pre><code>while(!atomicVar.compareAndSet(localVar,localVal+1)){\n    localVar=atomicVar.get();\n}</code></pre><h3 id=\"无等待-Wait-Free\"><a href=\"#无等待-Wait-Free\" class=\"headerlink\" title=\"无等待(Wait-Free)\"></a>无等待(Wait-Free)</h3><blockquote>\n<p>无等待是无锁++</p>\n<blockquote>\n<p>它要求所有的线程都需要在有限步内完成,这样就不会引起饥饿问题。如果限制这个步骤上限,还可以进一步分解成有界无等待和线程数无关的无等待几种,他们之间的区别只是对循环次数的限制不同.</p>\n</blockquote>\n<p>一种常用的方法是RCU(Read-Copy-Update)。它的基本思想是,对数据的读写可以不加控制。因此所有的读线程都是无等待的。</p>\n<blockquote>\n<p>怎么处理数据混乱问题呢?</p>\n<blockquote>\n<p>拿走需要修改的数据的Copy那部分,然后寻找合适的时机回写数据.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"有关并行的两个重要定律\"><a href=\"#有关并行的两个重要定律\" class=\"headerlink\" title=\"有关并行的两个重要定律\"></a>有关并行的两个重要定律</h2><blockquote>\n<p>主要作用,提高性能</p>\n</blockquote>\n<h3 id=\"Amdahl定律\"><a href=\"#Amdahl定律\" class=\"headerlink\" title=\"Amdahl定律\"></a>Amdahl定律</h3><p>加速比定义: <strong>加速比 = 优化前系统耗时 / 优化后系统耗时</strong> 加速比越高,表明优化效果越明显 T: 时间 T1: 一个处理器优化前耗时 Tn: n个处理器优化后的耗时 n: 处理器个数1 F: 程序中只能串行执行的比例 公式推导: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/22598c64eec40f893a98249a57670466.png\" alt> 通俗来讲: 1/n(1-F)就是将多核时一个核的比 加速比,当n-&gt;无穷,那么加速比与系统的串行率成反比,如果系统中必须有50%的代码串行执行,那么系统的最大加速比为2. 例: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f615f003b46f7c5ae3b6529423fb83b9.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/14a787b8048fee067f5ebdcc8387bd3d.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/3bc7ff881f0402493d61271248e5384f.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/4a703832b4c17c8c9b4b3cefe141296b.png\" alt></p>\n<h3 id=\"Gustafson定律\"><a href=\"#Gustafson定律\" class=\"headerlink\" title=\"Gustafson定律\"></a>Gustafson定律</h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2cbd7c085f349d05f504677421c14862.png\" alt> 可以发现Gf定律是通过时间来推导的.</p>\n<h2 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h2><blockquote>\n<p>JVM是Java虚拟机 而JMM是Java的内存模型 故JMM多用于线程/进程管理</p>\n<blockquote>\n<p>JMM是围绕着多线程的原子性,可见性和有序性来建立的</p>\n</blockquote>\n</blockquote>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>原子性是指一个程序不可中断,一旦开始执行,就不会被其他线程干扰. 值得一提的是,int是原子性的,而long在32位JVM上的读取和输入是非原子性的.</p>\n<pre><code>public class p11 {\n\n    public static long t=0;\n    public static class ChangeT implements Runnable{\n        private long to;\n        public ChangeT(long to){\n            this.to=to;\n        }\n        @Override\n        public void run(){\n            while(true){\n                p11.t=to;\n                Thread.yield();\n            }\n        }\n    }\n\n    public static class ReadT implements Runnable{\n        @Override\n        public void run(){\n            while(true){\n                long tmp=p11.t;\n                if(tmp!=111L &amp;&amp; tmp!=-999L &amp;&amp; tmp!=333L &amp;&amp; tmp!=-444L)\n                    System.out.println(tmp);\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new Thread(new ChangeT(111L)).start();\n        new Thread(new ChangeT(-999L)).start();\n        new Thread(new ChangeT(333L)).start();\n        new Thread(new ChangeT(444L)).start();\n        new Thread(new ReadT()).start();\n    }\n}</code></pre><p>输出: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/db56fde22062e276c391e1a6f6c9fc9b.png\" alt> 会发现根本就不是输入的四个值中的一个,因为他们互相影响了. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2dbc843299c02770553d5e4c1ffa322b.png\" alt></p>\n<h3 id=\"可见性-Visibility\"><a href=\"#可见性-Visibility\" class=\"headerlink\" title=\"可见性(Visibility)\"></a>可见性(Visibility)</h3><p>可见性是当一个线程修改了变量后,其他线程是否能够立即知道这个修改,显然,对于船型程序而言,可见性是不存在的.因为你在任何一个操作步骤中修改了某个变量,那么在后续步骤中,读取的这个变量,一定是修改后的(临界区被占用). 但在并行程序中就不同了.有可能知道,也可能不知道. 如: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/627ac143df47fe3a851b7eb87fb4f1b8.png\" alt> CPU2和CPU1在一开始读取了cache上的数据,但CPU2在某条路径上更快的修改了cache,而CPU1无法得知,故CPU1内还是一个旧的值.修改则一定会发生错误. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/db7630826e2f662dd9a063f26a3e7bce.png\" alt> 故<code>无法保证</code>能够从一个线程中观察另一个线程的变量.</p>\n<h3 id=\"编译器的向前优化\"><a href=\"#编译器的向前优化\" class=\"headerlink\" title=\"编译器的向前优化\"></a>编译器的向前优化</h3><p>一个复杂一点的例子 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/810eb542db9f9f179f5f486d0416bf03.png\" alt> 对于大部分编译器而言,可能会对线程1进行向前替换优化,也就是r5=r1.x这条指令会被直接替换成r5=r2.因为他们都读取了r1.x,又发生在同一个线程中,因此,编译器可能会认为没必要二次读取. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6456a7a1fec8e84fcec9d166bea5254d.png\" alt></p>\n<h3 id=\"有序性-Ordering\"><a href=\"#有序性-Ordering\" class=\"headerlink\" title=\"有序性(Ordering)\"></a>有序性(Ordering)</h3><p>程序在执行时,会出现指令重排,重拍后的指令与原指令未必一致. 这就导致了有可能出现在前面的代码后执行，在后面的代码先执行. 如: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/34204dc9edb67299da132429d63009d8.png\" alt></p>\n<h4 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h4><p>可以保证与串行语义一致,但没义务保证多线程间的语义也一致. 为什么要进行指令重排呢? 指令的执行分以下几步: - 取值 IF - 译码和去寄存器操作数 ID - 执行或者有效地址计算 EX - 存储器访问 MEM - 写回 WB 汇编指令也不是一步就可以执行完的. ALU:算数逻辑单元,是CPU的执行单元,是CPU的核心组成部分,主要功能是进行二进制算术运算. 因为指令执行的每一步都使用不同的硬件完成,聪明的工程师就发明了流水线技术. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/e0c81a1d89a95441a84f3253a391e34a.png\" alt></p>\n<h4 id=\"防止流水线中断\"><a href=\"#防止流水线中断\" class=\"headerlink\" title=\"防止流水线中断\"></a>防止流水线中断</h4><p>流水线满载时,性能很不错,但是一旦中断,所有的硬件设备都会进入一个停顿期,再次满载又需要几个周期.因此,性能的损失蛮大的. 而指令重排则是防止流水线中断的一种方式. 我们来以一个例子看看中断到底是什么意思. 下图展示的是 A=B+C 这个操作的执行过程: LW: load LW R1,B 将B加载到R1寄存器中 ADD: 加法 ADD R3,R1,R2 将R1+R2的值放到R3寄存器中 SW: store 存储,就是将R3寄存器的值保存到变量A中. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/606348f53bcc59044914f16b1f54f201.png\" alt> 那两个<code>大X</code>代表的是等待R2的值,因为R2还未MEM,WB,所以R2寄存器内还没有值, 这就是一个中断,会直接的导致后面的慢一拍.</p>\n<blockquote>\n<p>如何防止呢?</p>\n</blockquote>\n<p>一个更复杂的例子: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/4802b1724ff994decb93bf9f43eeb03a.png\" alt> 好多中断是吧.为了减少中断,我们将将对程序没有影响的代码放到中断之前,将中断代码往后移一个单位即可,即充分利用时间. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ab4078495c1184503f0097c6e18f0a36.png\" alt> 重排后的结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/94dd41a67f8b3bded551e4ce0d6567e0.png\" alt></p>\n<h4 id=\"哪些指令不能重排-Happen-Before-规则\"><a href=\"#哪些指令不能重排-Happen-Before-规则\" class=\"headerlink\" title=\"哪些指令不能重排: Happen-Before 规则\"></a>哪些指令不能重排: Happen-Before 规则</h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/5b5ebdca081ab4893f7b990c4b05dcdb.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ac2718210f9da072c0b9f966bed59f6a.png\" alt></p>\n<h1 id=\"第一章结束\"><a href=\"#第一章结束\" class=\"headerlink\" title=\"第一章结束\"></a>第一章结束</h1>","text":"第一章同步与异步如图 同步是链式进行:只有当一个任务结束后才可以继续下一个 而异步则是前进-&gt;等待消息返回(同时继续前进进行其他的任务)-&gt;消息返回,继续前进. [Figure] 第一章结束","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划","slug":"my-plan","date":"2018-06-14T08:45:55.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/my-plan.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/fabc862147ac8e0ad3ed25d6bfa9c7e5.png","content":"<p>[toc]</p>\n<h1 id=\"课外知识\"><a href=\"#课外知识\" class=\"headerlink\" title=\"课外知识:\"></a><strong>课外知识:</strong></h1><blockquote>\n<p>需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？</p>\n</blockquote>\n<blockquote>\n<p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？ 好，下面在浏览器中输入你的网站域名（<a href=\"http://www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。\" target=\"_blank\" rel=\"noopener\">www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。</a> 浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。 那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。 重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？ 这就是为什么，越是大中型的web应用，他们越是要解耦。理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。 如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。（注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~） 此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？ 正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。</p>\n</blockquote>\n<h1 id=\"JSONP-Done\"><a href=\"#JSONP-Done\" class=\"headerlink\" title=\"JSONP(Done)\"></a>JSONP(Done)</h1><blockquote>\n<p>当我们尝试彻底分离开前后端时,会出现跨域的问题.人类很有趣,想出了将它作为函数来解决的方法. 一般而言我们可以在后台为每一个Response提供一个</p>\n<blockquote>\n<p>access-Control-Allow-Origin: *</p>\n</blockquote>\n<p>这个字段来欲盖弥彰,但这种手段会出现API滥用或者XSS攻击等情况.</p>\n</blockquote>\n<h2 id=\"实现JSONP\"><a href=\"#实现JSONP\" class=\"headerlink\" title=\"实现JSONP\"></a>实现JSONP</h2><h3 id=\"Python-突击后台\"><a href=\"#Python-突击后台\" class=\"headerlink\" title=\"Python 突击后台\"></a>Python 突击后台</h3><pre><code># coding:utf-8\nfrom flask import Flask\nfrom flask import request\nfrom flask import json\napp=Flask(__name__)\n\n@app.route(&quot;/us&quot;)\ndef ruin():\n    return request.args.get(&apos;callback&apos;)+&quot;({a:1,b:2})&quot;\n\nif __name__ == &apos;__main__&apos;:\n    app.run(port=8888,debug=True)</code></pre><h3 id=\"Jquery接到命令\"><a href=\"#Jquery接到命令\" class=\"headerlink\" title=\"Jquery接到命令\"></a>Jquery接到命令</h3><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;a&lt;/title&gt;\n        &lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js&quot;&gt;&lt;/script&gt;   \n&lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;script&gt;\n    function AB(obj){\n        console.log(obj);\n    }\n    $.getScript(&quot;http://127.0.0.1:8888/us?callback=AB&quot;,function(data){\n        console.log(data);\n    });\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre><h3 id=\"控制台告诉我答案\"><a href=\"#控制台告诉我答案\" class=\"headerlink\" title=\"控制台告诉我答案\"></a>控制台告诉我答案</h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/fabc862147ac8e0ad3ed25d6bfa9c7e5.png\" alt></p>\n<h1 id=\"Maven-Done\"><a href=\"#Maven-Done\" class=\"headerlink\" title=\"Maven(Done)\"></a>Maven(Done)</h1><blockquote>\n<p>学习记录贴</p>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn/index.php/2018/06/20/maven/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/20/maven/</a></p>\n<h1 id=\"OAuth-、-微服务-、-Socket、NIO、Redis、消息队列\"><a href=\"#OAuth-、-微服务-、-Socket、NIO、Redis、消息队列\" class=\"headerlink\" title=\"OAuth 、 微服务 、 Socket、NIO、Redis、消息队列\"></a>OAuth 、 微服务 、 Socket、NIO、Redis、消息队列</h1>","text":"[toc]课外知识:需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"学堂在线-TSU-操作系统笔记","slug":"tsu-os","date":"2018-06-02T07:00:45.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/tsu-os.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"1-linux相关\"><a href=\"#1-linux相关\" class=\"headerlink\" title=\"1-linux相关\"></a>1-linux相关</h1><p>mkdir [name] -新建文件夹 pwd -显示当前目录 mv ../README.md~ . -移到当前目录下 rm [文件路径] -删除 ls -l -全部个数</p>\n","text":"1-linux相关mkdir [name] -新建文件夹 pwd -显示当前目录 mv ../README.md~ . -移到当前目录下 rm [文件路径] -删除 ls -l -全部个数","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"第二届ACM山东省赛","slug":"2-acm-shandong","date":"2018-04-24T01:58:31.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/2-acm-shandong.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"A-Nim-Bash-博弈\"><a href=\"#A-Nim-Bash-博弈\" class=\"headerlink\" title=\"A: Nim+Bash 博弈\"></a>A: Nim+Bash 博弈</h1><blockquote>\n<p>Nim博弈可以看做只考虑取二进制化后的数的位数上的1,结合Bash就变成了从几堆中取相应的1 答案是 统计二进制位数,如果全部取模(3+1)等于0,则是必败态</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=11000;\n\nint a[maxn],N,T,K,max_tot;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        memset(a,0,sizeof(a));\n        max_tot=0;\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;K);\n            int tot=0;\n            while(K){\n                if(K&amp;1) a[tot++]++;\n                else tot++;\n                K&gt;&gt;=1;\n            }\n            max_tot=max(max_tot,tot);\n        }\n        //printf(&quot;max: %d\\n&quot;,max_tot);\n        bool flag=true;\n        for(int i=0;i&lt;max_tot;++i){\n            if(a[i]%4){\n                flag=false;\n                break;\n            }\n        }\n        printf(flag?&quot;No\\n&quot;:&quot;Yes\\n&quot;);\n    }\n    return 0;\n}</code></pre><h1 id=\"B-排序模拟\"><a href=\"#B-排序模拟\" class=\"headerlink\" title=\"B:排序模拟\"></a>B:排序模拟</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nstruct team{\n    char name[40];\n    bool all_girls;\n    int solved;\n    int pe;\n    int id;\n\n    bool operator&lt;(const team&amp; A) const{\n        if(solved==A.solved){\n            return pe&gt;A.pe;\n        }else return solved&lt;A.solved;\n    }\n};\n\nstruct Name{\n    char name[40];\n    int id;\n    bool operator&lt;(const Name&amp; A) const{\n        return id&lt;A.id;\n    }\n};\n\nint T,kase=1;\nint N,M;\nchar str[1000];\npriority_queue&lt;team&gt; pt;\nvector&lt;Name&gt; ans;\n\nvoid init(){\n    while(!pt.empty()) pt.pop();\n    ans.clear();\n}\n\nteam get_team(int id){\n    char name[40];\n    bool all_girls;\n    int solved;\n    int pe;\n    team t;\n\n    sscanf(str,&quot;%s %d %d %d&quot;,name,&amp;all_girls,&amp;solved,&amp;pe);\n    strcpy(t.name,name);\n    t.all_girls=all_girls;\n    t.solved=solved;\n    t.pe=pe;\n    t.id=id;\n    return t;\n}\n\nName new_me(char str[40],int ind){\n    Name me;\n    strcpy(me.name,str);\n    me.id=ind;\n    return me;\n}\n\nvoid can(){\n    bool has_girl=false;\n    while(!pt.empty()){\n        team a=pt.top();pt.pop();\n        if(a.solved&lt;=0) break;\n        if(a.all_girls) has_girl=true;\n        ans.push_back(new_me(a.name,a.id));\n        M--;\n        if(M==0)break;\n    }\n    if(M==0){\n        if(!has_girl){\n            while(!pt.empty()){\n                team a=pt.top();pt.pop();\n                if(a.solved&lt;=0) break;\n                if(a.all_girls){\n                    ans.push_back(new_me(a.name,a.id));\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid cant(){\n    while(!pt.empty()){\n        team a=pt.top();pt.pop();\n        ans.push_back(new_me(a.name,a.id));\n    }\n}\n\nvoid print(){\n    sort(ans.begin(),ans.end());\n    for(int i=0;i&lt;ans.size();++i){\n        printf(&quot;%s\\n&quot;,ans[i].name);\n    }\n    puts(&quot;&quot;);\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        init();\n        scanf(&quot;%d%d\\n&quot;,&amp;N,&amp;M);\n        int low=0;\n        for(int i=0;i&lt;N;++i){\n            gets(str);\n            team a=get_team(i);\n            if(a.solved&gt;=1) low++;\n            pt.push(a);\n        }\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        if(low&gt;=M) can();\n        else cant();\n        print();\n    }\n    return 0;\n}</code></pre><h1 id=\"C-水\"><a href=\"#C-水\" class=\"headerlink\" title=\"C:水\"></a>C:水</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=200;\nchar str[maxn];\nint T;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        bool is=true;\n        gets(str);\n        int len=strlen(str);\n        if(isalpha(str[0]) || str[0]==&apos;_&apos;){\n            for(int i=1;i&lt;len;++i){\n                if(!(isalpha(str[i]) || isdigit(str[i]) || str[i]==&apos;_&apos;)){\n                    printf(&quot;No\\n&quot;);\n                    is=false;\n                    break;\n                }\n            }\n        }else{\n            printf(&quot;No\\n&quot;);\n            is=false;\n        }\n        if(is) printf(&quot;Yes\\n&quot;);\n    }\n\n    return 0;\n}</code></pre><h1 id=\"D-求组合数模-可以大数-可以打表\"><a href=\"#D-求组合数模-可以大数-可以打表\" class=\"headerlink\" title=\"D: 求组合数模,可以大数,可以打表\"></a>D: 求组合数模,可以大数,可以打表</h1><pre><code>///1000*1000的数据直接打表就好\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\nusing namespace std;\nconst int mod=10000003;\nconst int N=1002;\nint c[N][N];\n\nvoid init()//递推打表\n{\n    memset(c,0,sizeof(c));\n    c[0][0]=c[1][0]=c[1][1]=1;\n    for(int i=2;i&lt;N;i++)\n    {\n        c[i][i]=c[i][0]=1;\n        for(int j=0;j&lt;i;j++)\n        {\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//不会越界\n        }\n    }\n}\nint main()\n{\n    init();\n    int k;cin&gt;&gt;k;\n    int a,b;\n    while(k--)\n    {\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;c[a][b]&lt;&lt;endl;//直接输出\n    }\n}</code></pre><h1 id=\"E-快速幂模-数组模拟trie\"><a href=\"#E-快速幂模-数组模拟trie\" class=\"headerlink\" title=\"E:快速幂模+数组模拟trie\"></a>E:快速幂模+数组模拟trie</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int maxn=1e6+7;\n\nint mp[11][11][11];\nchar res[11][11][11];\nchar str[maxn];\n\nll mod_pow(ull x,ull n,int mod){\n    ull res=1;\n    while(n&gt;0){\n        if(n&amp;1) res=res*x%mod;\n        x=x*x%mod;\n        n&gt;&gt;=1;\n    }\n    return res;\n}\n\nvoid f(int id,int n){\n    int ans=mod_pow(id,n,997);\n    //cout&lt;&lt;ans&lt;&lt;endl;\n    int cnt=0;\n    int dt[3]={0,0,0};\n    while(ans){\n        dt[cnt++]=ans%10;\n        ans/=10;\n    }\n    mp[dt[2]][dt[1]][dt[0]]++;\n    res[dt[2]][dt[1]][dt[0]]=(char)id;\n}\n\nvoid init(int n){\n    memset(mp,0,sizeof(mp));\n    ///处理数字\n    for(int i=0;i&lt;10;++i)\n        f(&apos;0&apos;+i,n);\n    ///处理lowalpha\n    for(int i=0;i&lt;27;++i)\n        f(&apos;a&apos;+i,n);\n    ///处理upperalpha\n    for(int i=0;i&lt;27;++i)\n        f(&apos;A&apos;+i,n);\n}\n\nint main(){\n    int T,K;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        scanf(&quot;%d\\n%s&quot;,&amp;K,str);\n        init(K);\n        int len=strlen(str);\n        if(len%3){\n            printf(&quot;No Solution\\n&quot;);\n            continue;\n        }\n        bool flag=true;\n        string ans;\n        for(int i=0;i&lt;len;i+=3){\n            int x=str[i]-&apos;0&apos;,y=str[i+1]-&apos;0&apos;,z=str[i+2]-&apos;0&apos;;\n            //cout&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;mp[x][y][z]&lt;&lt;endl;\n            if(mp[x][y][z]&gt;1 || mp[x][y][z]==0){\n                flag=false;\n                break;\n            }\n            ans+=res[x][y][z];\n        }\n        if(flag) cout&lt;&lt;ans&lt;&lt;endl;\n        else cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;\n    }\n\n    return 0;\n}</code></pre><h1 id=\"I-区间DP\"><a href=\"#I-区间DP\" class=\"headerlink\" title=\"I: 区间DP\"></a>I: 区间DP</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\nconst int maxn=1010;\ntypedef long long LL;\nLL dp[maxn];\nLL sum[maxn],num;\nint T,N,M;\n\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        sum[0]=0ll;\n        dp[0]=0ll;\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;M);\n        for(int i=1;i&lt;=N;++i){\n            scanf(&quot;%lld&quot;,&amp;num);\n            sum[i]=sum[i-1]+num;\n            dp[i]=sum[i]*sum[i];\n        }\n\n        for(int i=2;i&lt;=M;++i){\n            ///枚举区间,j为i划分倒推的一维\n            for(int j=N-M+i;j&gt;=i;--j){\n                for(int k=1;k&lt;j;++k){\n                    dp[j]=min(dp[j],dp[k]+(sum[j]-sum[k])*(sum[j]-sum[k]));\n                }\n            }\n        }\n        printf(&quot;%lld\\n&quot;,dp[N]);\n    }\n    return 0;\n}</code></pre>","text":"A: Nim+Bash 博弈Nim博弈可以看做只考虑取二进制化后的数的位数上的1,结合Bash就变成了从几堆中取相应的1 答案是 统计二进制位数,如果全部取模(3+1)等于0,则是必败态#include&lt;bits/stdc++.h&gt;using namespace st","link":"","raw":null,"photos":[],"categories":[{"name":"第二届ACM山东省塞","slug":"第二届ACM山东省塞","count":1,"path":"api/categories/第二届ACM山东省塞.json"}],"tags":[{"name":"第二届ACM山东省塞","slug":"第二届ACM山东省塞","count":1,"path":"api/tags/第二届ACM山东省塞.json"}]},{"title":"POJ 2186","slug":"poj-2186","date":"2018-04-22T15:05:21.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/poj-2186.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Tarjan</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;stack&gt;\nusing namespace std;\nconst int maxn=100000+10;\n/*\n　　有n只牛，牛之间存在一些关系，比如a认为b很受欢迎\n，b认为c很受欢迎，这样呢，a也会认为c很受欢迎，问根据\n给出的关系，有多少头牛被其他所有的牛都认为是受欢迎的？\n\n解:\n　　对于一个有向无环图来说，其中有且仅有一个点出度为零\n，那么这个特殊的点，可以由其他任何点到达。那么接下来我\n们直接对所给的图进行强连通分量划分，然后把每个强连通分\n量看做一个点，判定出度为零的点有几个，如果有一个就输出\n这个点对应的强连通分量含有的节点个数，否则为零。\n*/\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint vis[maxn];\n\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    ///如果点从1开始计数,这里改成-1即可\n    G[u-1].push_back(v-1);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    ///缩点,同一scc缩到同一点中\n    for(int i=0;i&lt;n;++i){\n        for(int j=0;j&lt;G[i].size();++j){\n            ///如果i到G[i][j]这条边不在强连通分量中\n            ///说明是一个连接外面的点\n            if(sccno[i]!=sccno[G[i][j]]){\n                vis[sccno[i]]++;\n            }\n        }\n    }\n\n    int sum=0,ans=0,cnt=0;\n    for(int i=1;i&lt;=scc_cnt;++i){\n        if(!vis[i]){\n            ///如果出度是0,则是一个边界点\n            sum++;\n            ans=i;\n        }\n    }\n    ///如果只有一个点的话,代表存在一个万人敬仰团体\n    if(sum==1){\n        for(int i=0;i&lt;n;++i){\n            if(sccno[i]==ans){\n                cnt++;\n            }\n        }\n        printf(&quot;%d\\n&quot;,cnt);\n    }else{\n        printf(&quot;0\\n&quot;);\n    }\n    return 0;\n}\n/*\n3 3\n1 2\n2 1\n2 3\n\n1\n*/</code></pre>","text":"Tarjan#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"Tarjan","slug":"POJ/Tarjan","count":1,"path":"api/categories/POJ/Tarjan.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]},{"title":"第五届山东省ACM","slug":"five-shandong-acm","date":"2018-04-18T05:52:29.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/five-shandong-acm.json","excerpt":"","keywords":null,"cover":null,"content":"<p>D<br>=</p>\n<h2 id=\"类型-线段树-区间更新\"><a href=\"#类型-线段树-区间更新\" class=\"headerlink\" title=\"类型: 线段树 区间更新\"></a>类型: 线段树 区间更新</h2><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q,T;\n\nLL lazy[maxn];\nLL sum[maxn];\nbool flag[maxn];\n\nvoid init(){\n    memset(lazy,0,sizeof(lazy));\n    memset(sum,0,sizeof(sum));\n    memset(flag,false,sizeof(flag));\n}\n\nvoid PushDown(int p,int m){\n    if(flag[p]){\n        lazy[p&lt;&lt;1]=lazy[p&lt;&lt;1|1]=0;\n        sum[p&lt;&lt;1]=sum[p&lt;&lt;1|1]=sum[p]=0;\n        flag[p&lt;&lt;1]=flag[p&lt;&lt;1|1]=true;\n        flag[p]=false;\n    }\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nvoid setf(int p,int l,int r,int L,int R,int c){\n\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]=0;\n        sum[p]=0;\n        flag[p]=true;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) setf(p&lt;&lt;1,l,mid,L,R,c);\n    if(R&gt;mid) setf(p&lt;&lt;1|1,mid+1,r,L,R,c);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nint main(){\n    cin&gt;&gt;T;\n    while(T--){\n        init();\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n        int t,l,r,last=0;\n        LL ans=0;\n        for(int i=1;i&lt;=Q;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;t,&amp;l,&amp;r);\n            ///先更新全部区间的值\n            update(1,1,N,t-last,1,N);\n            ///然后查询所需区间内的和\n            ans+=Query(1,1,N,l,r);\n            ///最后将所需区间内的值置为0\n            setf(1,1,N,l,r,0);\n            last=t;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"D<br>=类型: 线段树 区间更新#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const in","link":"","raw":null,"photos":[],"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"线段树","slug":"数据结构/线段树","count":1,"path":"api/categories/数据结构/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"词云: Python爬取国际时事","slug":"wordcloud-python","date":"2018-04-01T11:30:24.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/wordcloud-python.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190628.jpg","content":"<h1 id=\"前置工具\"><a href=\"#前置工具\" class=\"headerlink\" title=\"前置工具\"></a>前置工具</h1><blockquote>\n<p>python wordcloud jieba BeautifulSoup matplotlib scipy</p>\n</blockquote>\n<h1 id=\"第一步-爬取国际时事列表\"><a href=\"#第一步-爬取国际时事列表\" class=\"headerlink\" title=\"第一步: 爬取国际时事列表\"></a>第一步: 爬取国际时事列表</h1><h2 id=\"待爬地址-http-m-sohu-com-cr-57-page-1-amp-v-2\"><a href=\"#待爬地址-http-m-sohu-com-cr-57-page-1-amp-v-2\" class=\"headerlink\" title=\"待爬地址: http://m.sohu.com/cr/57/?page=1&amp;v=2\"></a>待爬地址: <a href=\"http://m.sohu.com/cr/57/?page=1&amp;v=2\" target=\"_blank\" rel=\"noopener\">http://m.sohu.com/cr/57/?page=1&amp;v=2</a></h2><blockquote>\n<p>首先我们可以观察到,每点击列表中的下一页时, page 会加一</p>\n<blockquote>\n<p>然后我们就可以确认,想获取多少条信息,直接替换page属性的值即可</p>\n</blockquote>\n<p>然后我们观察想要爬取的内容:</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190628.jpg\" alt></p>\n<h2 id=\"审查元素\"><a href=\"#审查元素\" class=\"headerlink\" title=\"审查元素:\"></a>审查元素:</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190805.jpg\" alt></p>\n<blockquote>\n<p>我们发现文本都是在 div(class=”bd3 pb1”) -&gt; div -&gt; p -&gt; a 标签下的:</p>\n</blockquote>\n<h2 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h2><blockquote>\n<p>爬取数据并保存在<strong>data.txt</strong>中:</p>\n</blockquote>\n<pre><code># coding: utf-8\n\nfrom wordcloud import WordCloud\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        pass\n\ndef has_p_a(tag):\n    pass\n\ndef getWannaData(stockURL,res):\n    html = getHTMLText(stockURL)\n    soup = BeautifulSoup(html,&apos;html.parser&apos;)\n    p = soup.find(&apos;div&apos;,class_=&quot;bd3 pb1&quot;).find_all(&apos;a&apos;)\n    for q in p:\n        res.append(q.text)\n\nres = []\nmaxn = 100\nfor i in range(1,maxn):\n    getWannaData(&apos;http://m.sohu.com/cr/57/?page=&apos;+str(i)+&apos;&amp;v=2&apos;,res)\n\nfile = open(&apos;data.txt&apos;,&apos;a+&apos;)\nfor q in res:\n    file.write(q+&apos;\\n&apos;)</code></pre><blockquote>\n<p>其中maxn是控制爬取多少页的</p>\n</blockquote>\n<h2 id=\"data-txt-部分内容\"><a href=\"#data-txt-部分内容\" class=\"headerlink\" title=\"data.txt 部分内容:\"></a>data.txt 部分内容:</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401191238.jpg\" alt></p>\n<h1 id=\"第二步-生成词云\"><a href=\"#第二步-生成词云\" class=\"headerlink\" title=\"第二步: 生成词云\"></a>第二步: 生成词云</h1><h2 id=\"前置\"><a href=\"#前置\" class=\"headerlink\" title=\"前置\"></a>前置</h2><blockquote>\n<p>因为要进行中文分词,所以要用jieba 注意再打开<strong>data.txt</strong>时<strong>编码</strong>问题 还有ttf不能保存在有中文的路径下</p>\n</blockquote>\n<h2 id=\"背景图片\"><a href=\"#背景图片\" class=\"headerlink\" title=\"背景图片\"></a>背景图片</h2><blockquote>\n<p>我们选择 <strong>水伊布.png</strong></p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/timg.jpg\" alt></p>\n<h2 id=\"生成词云\"><a href=\"#生成词云\" class=\"headerlink\" title=\"生成词云\"></a>生成词云</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/yb.png\" alt> <strong>容我说一句,在中国相对封闭的网络环境中,已经可以看到世界如此的乱了,全部的词条大部分是消极的…看起来大规模战争结束的时间太久了…(还是说,世界就没有安宁过)</strong></p>\n<blockquote>\n<p>这张图可以找到安倍</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/yb2.png\" alt></p>\n","text":"前置工具python wordcloud jieba BeautifulSoup matplotlib scipy第一步: 爬取国际时事列表待爬地址: http://m.sohu.com/cr/57/?page=1&amp;v=2首先我们可以观察到,每点击列表中的下一页时, pa","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"爬虫","slug":"Python/爬虫","count":2,"path":"api/categories/Python/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"redis启动","slug":"redis-undo","date":"2018-03-26T06:40:22.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/redis-undo.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>cmd-</p>\n<blockquote>\n<p>redis-server.exe (redis.windows.conf) 第二个参数可以写也可以不写</p>\n</blockquote>\n<p>开启</p>\n<blockquote>\n<p>redis-cli.exe -h 127.0.0.1 -p 6379</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Java-SpringBoot使用Redis\"><a href=\"#Java-SpringBoot使用Redis\" class=\"headerlink\" title=\"Java-SpringBoot使用Redis\"></a>Java-SpringBoot使用Redis</h1><h2 id=\"RedisConfig\"><a href=\"#RedisConfig\" class=\"headerlink\" title=\"RedisConfig\"></a>RedisConfig</h2><p>其中Bean代表由Spring管理,当Resouorce的name和Bean的name一样时,就会自动通过Bean创建实例. @Value的字段是在application.properties中,有’.’的话要加${} 这里调用的只是Redis的一个构造函数,传入ip和端口号.</p>\n<pre><code>package com.mall.concurrency.cache;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport redis.clients.jedis.JedisPool;\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean(name=&quot;redisPool&quot;)\n    public JedisPool jedispool(@Value(&quot;${jedis.host}&quot;) String host,@Value(&quot;${jedis.port}&quot;) int port){\n        return new JedisPool(host,port);\n    }\n}</code></pre><h2 id=\"RedisClient\"><a href=\"#RedisClient\" class=\"headerlink\" title=\"RedisClient\"></a>RedisClient</h2><p>类似于Orm的操作方式.用完即扔.</p>\n<pre><code>package com.mall.concurrency.cache;\n\nimport javax.annotation.Resource;\n\nimport org.springframework.stereotype.Component;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n//http://redis.cn/\n@Component\npublic class RedisClient {\n    @Resource(name=&quot;redisPool&quot;)\n    private JedisPool jedisPool;\n\n    public void set(String key,String value)throws Exception{\n        Jedis jedis=null;\n        try{\n            jedis = jedisPool.getResource();\n            jedis.set(key, value);\n        }finally {\n            if(jedis!=null){\n                jedis.close();\n            }\n        }\n    }\n\n    public String get(String key)throws Exception{\n        Jedis jedis=null;\n        try{\n            jedis = jedisPool.getResource();\n            return jedis.get(key);\n        }finally {\n            if(jedis!=null){\n                jedis.close();\n            }\n        }\n    }\n}</code></pre><h2 id=\"CacheController\"><a href=\"#CacheController\" class=\"headerlink\" title=\"CacheController\"></a>CacheController</h2><p>其中@Autowired和@Resource的区别是: - @Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配 - @Resource(import javax.annotation.Resource;)是J2EE的注解，@Autowired( import org.springframework.beans.factory.annotation.Autowired;)是Spring的注解</p>\n<pre><code>package com.mall.concurrency.cache;\n\nimport javax.annotation.Resource;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\n@RequestMapping(&quot;/cache&quot;)\npublic class CacheController {\n    @Autowired\n    private RedisClient redisClient;\n\n    @RequestMapping(&quot;/set&quot;)\n    @ResponseBody\n    public String set(@RequestParam(&quot;k&quot;) String k,@RequestParam(&quot;v&quot;) String v)throws Exception{\n        redisClient.set(k, v);\n        return &quot;SUCCESS&quot;;\n    }\n\n    @RequestMapping(&quot;/get&quot;)\n    @ResponseBody\n    public String get(@RequestParam(&quot;k&quot;) String k)throws Exception{\n        return redisClient.get(k);\n    }\n\n}</code></pre><h2 id=\"application-properties的书写格式\"><a href=\"#application-properties的书写格式\" class=\"headerlink\" title=\"application.properties的书写格式\"></a>application.properties的书写格式</h2><pre><code># redis\njedis.host=127.0.0.1\njedis.port=6379</code></pre>","text":"cmd-redis-server.exe (redis.windows.conf) 第二个参数可以写也可以不写开启redis-cli.exe -h 127.0.0.1 -p 6379Java-SpringBoot使用RedisRedisConfig其中Bean代表由Spring管","link":"","raw":null,"photos":[],"categories":[{"name":"redis","slug":"redis","count":1,"path":"api/categories/redis.json"},{"name":"技术","slug":"redis/技术","count":1,"path":"api/categories/redis/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"},{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}]},{"title":"DotNet","slug":"dotnet","date":"2018-03-20T11:12:35.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/dotnet.json","excerpt":"","keywords":null,"cover":null,"content":"<pre><code>SQL:\n工厂模式创建DbCommand\n    /// &lt;summary&gt;\n    /// 创建新的连接对象\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static DbCommand CreateCommand()\n    {\n        string dataProviderName = BalloonShopConfiguration.DbProviderName;\n        string connectionString = BalloonShopConfiguration.DbConnectionString;\n        ///工厂模式下新建名字为dataProviderName的连接\n        DbProviderFactory factory = DbProviderFactories.GetFactory(dataProviderName);\n        DbConnection conn = factory.CreateConnection();\n        ///项数据工厂设置连接字符串\n        conn.ConnectionString = connectionString;\n        ///创建特定于某数据库的command对象\n        DbCommand comm = conn.CreateCommand();\n        comm.CommandType = CommandType.StoredProcedure;\n        return comm;\n    }\n\n执行查询:\n    /// &lt;summary&gt;\n    /// 执行查询语句\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;command&quot;&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static DataTable ExecuteSelectCommand(DbCommand command)\n    {\n        ///将返回的Datatable\n        DataTable table;\n        try\n        {\n            //执行该命令\n            command.Connection.Open();\n            DbDataReader dr = command.ExecuteReader();\n            table = new DataTable();\n            table.Load(dr);\n            dr.Close();\n        }\n        catch (Exception e)\n        {\n            Utilities.LogError(e);\n            throw;\n        }\n        finally\n        {\n            command.Connection.Close();\n        }\n        return table;\n    }</code></pre><blockquote>\n<p>返回Datatable是因为可以使用更少的时间</p>\n</blockquote>\n","text":"SQL:工厂模式创建DbCommand    /// &lt;summary&gt;    /// 创建新的连接对象    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static D","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]}]}