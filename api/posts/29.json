{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"VJ SWPU-ACM省赛集训赛ONE A  Easy Math","slug":"vj-swpu-acmone-a-easy-math","date":"2017-04-20T06:39:20.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmone-a-easy-math.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>直觉只要有一个不是平方根就输出No,直觉是对的…</strong> <strong>可以当做结论?</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N;</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        bool flag=true;** **        ll num;** **        while(N–){** **            SI(num);** **            ll t=sqrt(num);** **            if(t<em>t!=num)*</em> **                flag=false;** **        }** **        printf(flag?”Yes\\n”:”No\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 直觉只要有一个不是平方根就输出No,直觉是对的… 可以当做结论? 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3","link":"","raw":null,"photos":[],"categories":[{"name":"VJ","slug":"VJ","count":2,"path":"api/categories/VJ.json"}],"tags":[{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]},{"title":"第六届山东省ACM/ICPC J Single Round Math","slug":"dljaisdacmicpc-j-single-round-math","date":"2017-04-19T08:37:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dljaisdacmicpc-j-single-round-math.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>java大整数瞎搞,话说占用内存好高啊.</strong> <strong>【题目链接】</strong> <a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3260.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3260.html</a> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>import java.util.*;</strong> <strong>import java.math.*;</strong> <strong>public class J{</strong> **    public static void main(String args[]){** **        Scanner cin=new Scanner(System.in);** **        int T;** **        BigInteger a,b,c=new BigInteger(“11”),d=new BigInteger(“0”);** **        T=cin.nextInt();** **        while((T–)!=0){** **            a=cin.nextBigInteger();** **            b=cin.nextBigInteger();** **            if(a.compareTo(c)&lt;0 || b.compareTo(c)&lt;0) System.out.println(“NO”);** **            else if(a.compareTo(b)!=0) System.out.println(“NO”);** **            else if(d.compareTo(a.remainder(c))==0) System.out.println(“YES”);** **            else System.out.println(“NO”);** **        }** **    }** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 java大整数瞎搞,话说占用内存好高啊. 【题目链接】 http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3260.html 【Code】import java.util","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"第六届ACM山东省赛","slug":"Sdut/第六届ACM山东省赛","count":2,"path":"api/categories/Sdut/第六届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第六届ACM山东省赛","slug":"第六届ACM山东省赛","count":3,"path":"api/tags/第六届ACM山东省赛.json"}]},{"title":"第六届山东省ACM/ICPC B Lowest Unique Price","slug":"dljaisdsacmicpc-b-lowest-unique-price","date":"2017-04-18T15:31:58.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/dljaisdsacmicpc-b-lowest-unique-price.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>set,映射</strong> <strong>【Tip】</strong> <strong>题目上给的数据范围是 x∈[1,106]</strong> <strong>但是我写代码时把映射空间开到100000才A了过去.?????? WTF??</strong> <strong>另外,一开始我用map动态搜索,输出时遍历查找最少价值为一次的结果,果不其然,TLE.</strong> <strong>所以改成了set动态更新第一个节点.即最小点.实现不需要遍历直接插入瞎搞的算法.</strong> <strong>PS:真心搞不懂为啥映射数组要开10W啊？？？？？？？</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define cle(a,val) memset(a,(val),sizeof(a)) #define SI(N) scanf(“%d”,&amp;(N)) #define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M)) #define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K)) #define rep(i,b) for(int i=0;i&lt;(b);i++) #define rez(i,a,b) for(int i=(a);i&lt;=(b);i++) #define red(i,a,b) for(int i=(a);i&gt;=(b);i–) const ll LINF = 0x3f3f3f3f3f3f3f3f; #define PU(x) puts(#x); #define PI(A) cout&lt;&lt;(A)&lt;&lt;endl; #define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl; #define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl; #define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl; #define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl; #define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;} const double EPS = 1e-9 ; int reg[100000]; char readchar(){ char c=getchar(); while(c!=’b’ &amp;&amp; c!=’q’ &amp;&amp; c!=’c’) c=getchar(); return c; } int main(){ int T; scanf(“%d”,&amp;T); while(T–){ set<int> se; cle(reg,0); int N; SI(N); rep(i,N){ char a; int b; a=readchar(); if(a==’b’){ SI(b); reg[b]++; if(reg[b]==1) se.insert(b); else se.erase(b); } if(a==’c’){ SI(b); if(reg[b]&gt;0){ reg[b]–; if(reg[b]==1) se.insert(b); else se.erase(b); } } if(a==’q’){ if(se.empty()) puts(“none”); else printf(“%d\\n”,*(se.begin())); } } } return 0; }</int></strong></p>\n</blockquote>\n","text":"【类型】 set,映射 【Tip】 题目上给的数据范围是 x∈[1,106] 但是我写代码时把映射空间开到100000才A了过去.?????? WTF?? 另外,一开始我用map动态搜索,输出时遍历查找最少价值为一次的结果,果不其然,TLE. 所以改成了set动态更新第一个节点.","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"STL","slug":"Sdut/STL","count":2,"path":"api/categories/Sdut/STL.json"},{"name":"第六届ACM山东省赛","slug":"Sdut/STL/第六届ACM山东省赛","count":1,"path":"api/categories/Sdut/STL/第六届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第六届ACM山东省赛","slug":"第六届ACM山东省赛","count":3,"path":"api/tags/第六届ACM山东省赛.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"}]},{"title":"第六届山东省ACM/ICPC A Nias and Tug-of-War","slug":"dljsdssacmicpc-a-nias-and-tug-of-war","date":"2017-04-18T14:45:52.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dljsdssacmicpc-a-nias-and-tug-of-war.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>重载小于号,排序</strong> <strong>【题目链接】</strong> <strong><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3251.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3251.html</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct star{</strong> **    double height,weight;** **    bool operator&lt;(const star A)const{** **        return height&lt;A.height;** **    }** <strong>}person[200];</strong> <strong>int main(){</strong> **    int T,N;** **    double ansr=0.0,ansb=0.0;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        ansr=0.0,ansb=0.0;** **        scanf(“%d”,&amp;N);** **        rep(i,N)** **            scanf(“%lf %lf”,&amp;person[i].height,&amp;person[i].weight);** **        sort(person,person+N);** **        int con=1;** **        rep(i,N){** **            if(con==1){** **                con=0;** **                ansr+=person[i].weight;** **            }else{** **                con=1;** **                ansb+=person[i].weight;** **            }** **        }** **        if(ansb&gt;ansr)** **            printf(“blue\\n”);** **        else if(ansr&gt;ansb)** **            printf(“red\\n”);** **        else   printf(“fair\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 重载小于号,排序 【题目链接】 http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3251.html 【Code】#include &lt;bits/stdc++.h&g","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"第六届ACM山东省赛","slug":"Sdut/第六届ACM山东省赛","count":2,"path":"api/categories/Sdut/第六届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第六届ACM山东省赛","slug":"第六届ACM山东省赛","count":3,"path":"api/tags/第六届ACM山东省赛.json"}]},{"title":"第七届山东省ACM/ICPC K Reversed Words","slug":"qjsdaikacmicpc-k-reversed-words","date":"2017-04-18T12:52:16.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/qjsdaikacmicpc-k-reversed-words.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>我太菜辣,没有1A  ……F</strong>k** <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>char str[10000];</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d\\n”,&amp;T);** **    while(T–){** **        int star=-1;** **        gets(str);** **        int len=strlen(str);** **        for(int i=0;i&lt;len+1;++i){** **            if(str[i]==’ ‘ || str[i]==’\\0’ || str[i]==’\\n’){** **                for(int j=i-1;j&gt;star;–j)** **                    putchar(str[j]);** **                star=i;** **                if(str[i]==’ ‘)putchar(str[i]);** **            }** **        }** **        putchar(‘\\n’);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 我太菜辣,没有1A  ……Fk** 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; char str[10000]; int main(){ **    int T;** **    scanf(“%d","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/第七届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"第七届山东省ACM/ICPC H Memory Leak","slug":"qjsdaihacmicpc-h-memory-leak","date":"2017-04-18T12:25:42.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/qjsdaihacmicpc-h-memory-leak.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>模拟,感受一下什么叫绝望吧…</strong> <strong>【Tip】</strong> <strong>F</strong>k!…..QNMD鲁棒性….QAQ** <strong>后记…发现自己的代码可以过…但是忘了关freopean..所以才WA…尴尬//= // =//</strong> <strong>【Code】</strong> <strong>鲁棒形比我好,一点的,代码.</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int T;</strong> <strong>char name[10010],stri[10010];</strong> <strong>int num;</strong> <strong>struct Star{</strong> **    char s[2000];** **    char contain[10010];** **    int ind;** **    bool has_end;** <strong>};</strong> <strong>Star S[10010];</strong> <strong>int main(){</strong> ** //   #ifndef DEF** ** //    freopen(“in.txt”,”r”,stdin);** ** //    freopen(“out.txt”,”w”,stdout);** ** //  #endif // DEF** **    scanf(“%d”,&amp;T);** **        while(T–){** **            char op[100],def[10100];** **            num=0;** **            while(scanf(“%s”,op)){** **                if(op[3]==’u’){** **                    scanf(“%<em>s”);*</em> **                    break;** **                }** **                if(op[3]==’r’){** **                    while(scanf(“%s”,def)){** **                        int flag=1,star_num=0,ind_num=0,len=strlen(def);** **                        for(int i=0;i&lt;len;++i){** **                            if(flag==1 &amp;&amp; def[i]!=’[‘){** **                                S[num].s[star_num++]=def[i];** **                            }** **                            if(def[i]==’[‘){** **                                S[num].s[star_num]=0;** **                                flag=2;** **                                continue;** **                            }** **                            if(flag==2 &amp;&amp; def[i]!=’]‘){** **                                ind_num=ind_num<em>10+(def[i]-‘0’);*</em> **                            }** **                            if(def[i]==’]‘){** **                                S[num].contain[0]=0;//初始化** **                                S[num].has_end=true;** **                                S[num].ind=ind_num;** **                                star_num=0;** **                                ind_num=0;** **                                num++;** **                                continue;** **                            }** **                        }** **                        if(def[len-1]==’;’) break;** **                    }** **                }** **                if(op[3]==’s’){** **                    scanf(“%s%<em>c”,name);*</em> **                    gets(stri);** **                    int index=num;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    int len=strlen(stri);** **                    if(len&gt;=S[index].ind){** **                        S[index].has_end=false;** **                        stri[S[index].ind]=0;//‘\\0’** **                    }else S[index].has_end=true;** **                    strcpy(S[index].contain,stri);** **                }** **                if(op[3]==’t’){** **                    scanf(“%s”,name);** **                    int index=num;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    for(int i=index;i&lt;num;++i){** **                        printf(“%s”,S[i].contain);** **                        if(S[i].has_end) break;** **                    }** **                    printf(“\\n”);** **                }** **            }** **        }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>我的代码</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int T;</strong> <strong>char name[10010],stri[10010];</strong> <strong>int num=0;</strong> <strong>struct Star{</strong> **    char s[2000];** **    char contain[10010];** **    int ind;** **    bool has_end;** <strong>};</strong> <strong>Star S[10010];</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF  //&lt;-F</strong>k U** **  //   freopen(“in.txt”,”r”,stdin);** **  //   freopen(“out.txt”,”w”,stdout);** ** //  #endif // DEF** **    scanf(“%d”,&amp;T);** **        while(T–){** **            char op[10],def[10100];** **            num=0;** **            while(scanf(“%s”,op)){** **                scanf(“ “);** **                if(op[3]==’u’){** **                    scanf(“%<em>s”);*</em> **                    break;** **                }** **                if(op[3]==’r’){** **                    int flag=1,star_num=0,ind_num=0;** **                    gets(def);** **                    for(int i=0,start=0;def[i]!=’\\0’;++i){** **                        if(def[i]==’ ‘ || def[i]==’,’) continue;** **                        if(flag==1 &amp;&amp; def[i]!=’[‘){** **                            S[num].s[star_num++]=def[i];** **                        }else if(def[i]==’[‘){** **                            S[num].s[star_num]=0;** **                            flag=2;** **                        }else if(flag==2 &amp;&amp; def[i]!=’]‘){** **                            ind_num=ind_num<em>10+(def[i]-‘0’);*</em> **                        }else if(def[i]==’]‘){** **                            S[num].contain[0]=0;//初始化** **                            S[num].has_end=true;** **                            S[num].ind=ind_num;** **                            star_num=0;** **                            ind_num=0;** **                            num++;** **                            flag=1;** **                        }else if(def[i]==’;’)** **                            break;** **                    }** **                }** **                if(op[3]==’s’){** **                    scanf(“%s%<em>c”,name);*</em> **                    gets(stri);** **                    int index;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    int len=strlen(stri);** **                    if(len&gt;=S[index].ind){** **                        S[index].has_end=false;** **                        stri[S[index].ind]=0;//‘\\0’** **                    }else S[index].has_end=true;** **                    strcpy(S[index].contain,stri);** **                }** **                if(op[3]==’t’){** **                    scanf(“ “);** **                    gets(name);** **                    int index;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    for(int i=index;i&lt;num;++i){** **                        printf(“%s”,S[i].contain);** **                        if(S[i].has_end) break;** **                    }** **                    printf(“\\n”);** **                }** **            }** **        }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 模拟,感受一下什么叫绝望吧… 【Tip】 Fk!…..QNMD鲁棒性….QAQ** 后记…发现自己的代码可以过…但是忘了关freopean..所以才WA…尴尬//= // =// 【Code】 鲁棒形比我好,一点的,代码.#include&lt;bits/stdc++.","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"模拟","slug":"Sdut/模拟","count":1,"path":"api/categories/Sdut/模拟.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/模拟/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/模拟/第七届ACM山东省赛.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"第七届山东省ACM/ICPC  F  Feed the monkey","slug":"shandongacmacmicpc-f-feed-the-monkey","date":"2017-04-18T08:49:52.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/shandongacmacmicpc-f-feed-the-monkey.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>DP</strong> <strong>【题目链接】</strong> <strong><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565</a></strong> <strong>【题解】</strong> <strong>用dp[i][j][k][t]表示剩余i个第一种物品,j个第二种物品,k个第三种物品.以第t种物品为结尾的安排饲养表的种数.</strong> <strong>递归的思想来合并所有的情况,不过是减了所有的重复枝.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>const ll mod=1000000007;</strong> <strong>const int maxn=55;</strong> <strong>ll dp[maxn][maxn][maxn][4];</strong> <strong>int N1,N2,N3,D1,D2,D3,T;</strong> <strong>int main(){</strong> **    while(~SI(T)){** **        while(T–){** **            cle(dp,0);** **            SIII(N1,N2,N3);** **            SIII(D1,D2,D3);** **            red(i,N1,0) red(j,N2,0) red(k,N3,0){** **                rez(s,1,min(i,D1)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i-s][j][k][0]=(dp[i-s][j][k][0]+1)%mod;** **                    else** **                        dp[i-s][j][k][0]=((dp[i-s][j][k][0]+dp[i][j][k][1])%mod+dp[i][j][k][2])%mod;** **                }** **                rez(s,1,min(j,D2)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i][j-s][k][1]=(dp[i][j-s][k][1]+1)%mod;** **                    else** **                        dp[i][j-s][k][1]=((dp[i][j-s][k][1]+dp[i][j][k][0])%mod+dp[i][j][k][2])%mod;** **                }** **                rez(s,1,min(k,D3)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i][j][k-s][2]=(dp[i][j][k-s][2]+1)%mod;** **                    else** **                        dp[i][j][k-s][2]=((dp[i][j][k-s][2]+dp[i][j][k][0])%mod+dp[i][j][k][1])%mod;** **                }** **            }** **            ll ans=0;** **            ans=((dp[0][0][0][0]+dp[0][0][0][1])%mod+dp[0][0][0][2])%mod;** **            printf(“%lld\\n”,ans);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 DP 【题目链接】 http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565 【题解】 用dp[i][j][k][t]表示剩余i个第一种物品,j","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"动态规划","slug":"Sdut/动态规划","count":2,"path":"api/categories/Sdut/动态规划.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/动态规划/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/动态规划/第七届ACM山东省赛.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"HDU 2098","slug":"hdu-2098","date":"2017-04-18T04:25:02.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/hdu-2098.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>数位dp入门</strong> <strong>【Tip】</strong> <strong><a href=\"http://www.cnblogs.com/wenruo/p/4725005.html\" target=\"_blank\" rel=\"noopener\">一个blog</a></strong> <strong><a href=\"https://wenku.baidu.com/view/9de41d51168884868662d623.html\" target=\"_blank\" rel=\"noopener\">一个ppt</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 数位dp入门 【Tip】 一个blog 一个ppt 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"动态规划","slug":"HDU/动态规划","count":1,"path":"api/categories/HDU/动态规划.json"},{"name":"数位DP","slug":"HDU/动态规划/数位DP","count":1,"path":"api/categories/HDU/动态规划/数位DP.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"}]},{"title":"UVa 1658","slug":"uva-1658","date":"2017-04-18T02:19:05.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-1658.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>SPFA最小费用最大流,构图</strong> <strong>【Tip】</strong> <strong>这道题说每个节点只能访问一次,所以只需要把每个节点分为两个节点i和i’,且这两个节点的容量为1,费用为0.然后题目要求求两条不相交的路径使得权和最小,所以只需要求1~v的流量为2的最小费用即可.添加一个超级节点0-&gt;1和超级节点v-&gt;2*v+1.且这两条边的容量为2,费用为0.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=5000,maxm=50000;</strong> <strong>int v,e;</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];//maxm最大边数** **    int nume;** **    int src,sink;** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    queue<int> que;** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        while(!que.empty()) que.pop();** **        que.push(src);** **        cle(dist,63);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    ll mincostflow(){** **        ll cur=0;** **        while(Spfa()){** **            cur+=augment();** **  //          if(cur&lt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>};</strong> <strong>int main(){</strong> **    while(~SII(v,e)){** **        MCMF mcmf;** **        mcmf.init();** **        mcmf.src=1;** **        mcmf.sink=2<em>v+1;*</em> **        int a,b,c;** **        rez(i,2,v-1)** **            mcmf.Addedge(i,i+v,1,0);** **        mcmf.Addedge(0,1,2,0);//限制流量为2** **        mcmf.Addedge(v,2<em>v+1,2,0);*</em> **        rep(i,e){** **            SIII(a,b,c);** **            if(a!=1 &amp;&amp; a!=v)** **                mcmf.Addedge(a+v,b,1,c);** **            else mcmf.Addedge(a,b,1,c);** **        }** **        printf(“%lld\\n”,mcmf.mincostflow());** **    }** **    return 0;** <strong>}</strong></int></p>\n</blockquote>\n","text":"【类型】 SPFA最小费用最大流,构图 【Tip】 这道题说每个节点只能访问一次,所以只需要把每个节点分为两个节点i和i’,且这两个节点的容量为1,费用为0.然后题目要求求两条不相交的路径使得权和最小,所以只需要求1~v的流量为2的最小费用即可.添加一个超级节点0-&gt;1和超","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"最小费用最大流","slug":"UVa/最小费用最大流","count":1,"path":"api/categories/UVa/最小费用最大流.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"path":"api/tags/最小费用最大流.json"}]},{"title":"POJ 2195","slug":"poj-2195","date":"2017-04-17T15:49:19.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-2195.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>SPFA 最小费用最大流</strong> <strong>【Tip】</strong> <strong>注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<vector></vector></strong> <strong>#include<queue></queue></strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>//最多房子/人为100</strong> <strong>//最大节点数为100+100+2</strong> <strong>//最大边数为(100+100+100*100)*2=20400;AC!</strong> <strong>const int maxn=300,maxm=20410;</strong> <strong>int max_num,home_sum;</strong> <strong>char s[maxn];</strong> <strong>typedef struct{</strong> **    int x,y;** <strong>}point;</strong> <strong>point man[maxn+10],home[maxn+10];</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];** **    int nume;** **    int src,sink;//源点,汇点** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        queue<int> que;** **        que.push(src);** **        cle(dist,INF);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    int mincostflow(){** **        int cur=0;//原板子有一个ans=0** **        while(Spfa()){** **            cur+=augment();** **     //     cout&lt;&lt;cur&lt;&lt;endl;** **          //原板子  if(cur&gt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>}mcmf;</strong> <strong>int main(){</strong> <strong>#ifndef ONLINE_JUDGE</strong> **    freopen(“in.txt”, “r”, stdin);** **    freopen(“out.txt”, “w”, stdout);** <strong>#endif</strong> **    int N,M;** **    while(~SII(N,M) &amp;&amp; N+M){** **        getchar();** **        mcmf.init();** **        max_num=home_sum=0;** **        rez(i,1,N){** **            gets(s);** **            rep(j,M){** **                if(s[j]==’m’){** **                    man[max_num].x=i;** **                    man[max_num++].y=j+1;** **                }else if(s[j]==’H’){** **                    home[home_sum].x=i;** **                    home[home_sum++].y=j+1;** **                }** **            }** **        }** **        mcmf.src=0;** **        mcmf.sink=2<em>max_num+1;*</em> **        rep(i,max_num){** **            mcmf.Addedge(0,i+1,1,0);** **            mcmf.Addedge(max_num+i+1,mcmf.sink,1,0);** **            rep(j,home_sum)** **                mcmf.Addedge(i+1,max_num+j+1,1,abs(man[i].x-home[j].x)+abs(man[i].y-home[j].y));** **        }** **    //    rep(i,mcmf.nume){** **    //        printf(“%d %d %d %d\\n”,mcmf.e[i].v,mcmf.e[i].f,mcmf.e[i].w,mcmf.e[i].nxt);** **     //   }** **        printf(“%d\\n”,mcmf.mincostflow());** **    }** **    return 0;** <strong>}</strong></int></p>\n</blockquote>\n","text":"【类型】 SPFA 最小费用最大流 【Tip】 注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数. 【Code】#include  #include #include #include #include #include #i","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"最大流","slug":"POJ/最大流","count":2,"path":"api/categories/POJ/最大流.json"},{"name":"最小费用最大流","slug":"POJ/最大流/最小费用最大流","count":1,"path":"api/categories/POJ/最大流/最小费用最大流.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"最大流","slug":"最大流","count":2,"path":"api/tags/最大流.json"},{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"path":"api/tags/最小费用最大流.json"}]}]}