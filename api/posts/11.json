{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"2018全国多校算法寒假练习赛(三) D","slug":"2018mutippd","date":"2018-02-08T07:30:29.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/2018mutippd.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>这道题以前在lrj上见过,不过没注意.</p>\n</blockquote>\n<h1><span id=\"link\">Link</span></h1><p><a href=\"https://www.nowcoder.net/acm/contest/75/D\" title=\"https://www.nowcoder.net/acm/contest/75/D\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/75/D</a></p>\n<h1><span id=\"type-博弈论\">Type: 博弈论</span></h1><h1><span id=\"题目\">题目</span></h1><blockquote>\n<p>链接：<a href=\"https://www.nowcoder.net/acm/contest/75/D\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/75/D</a> 来源：牛客网</p>\n<blockquote>\n<p>小牛和小客玩石子游戏，他们用n个石子围成一圈，小牛和小客分别从其中取石子，谁先取完谁胜，每次可以从一圈中取一个或者相邻两个，每次都是小牛先取，请输出胜利者的名字（小牛获胜输出XiaoNiu，小客获胜输出XiaoKe）（1 2 3 4 取走 2 13 不算相邻）</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"约束\">约束</span></h1><blockquote>\n<p>输入包括多组测试数据 每组测试数据一个n（1≤n≤1e9）</p>\n</blockquote>\n<h1><span id=\"输出\">输出</span></h1><blockquote>\n<p>每组用一行输出胜利者的名字（小牛获胜输出XiaoNiu，小客获胜输出XiaoKe）</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>我直接说推出的结论了 很明显的是:</p>\n<blockquote>\n<p>n=0时,先手必败,n=1,2时,先手必胜</p>\n</blockquote>\n<p>然后我们看n&gt;=3:</p>\n<blockquote>\n<ol>\n<li><p>n=3时很明显先手必败</p>\n</li>\n<li><p>n=4时,无论先手者取1还是2,只需要和他取一样的即可,把当前的石子堆分成两部分,每部分有一样的石子,可以发现,该情况下先手必败(只需要和先手者操作一样即可获胜).</p>\n<blockquote>\n<p>然后我们可以发现只要是偶数都可以这样乱搞</p>\n</blockquote>\n</li>\n<li><p>n=5时,无论先手者取1还是2,只需要和他取相反的即可,其余和以上一样,同样将石子堆分为两堆.</p>\n<blockquote>\n<p>然后我们发现只要是奇数都可以这样乱搞</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>/**\n\n                                                                       :;LaEaHKEEGpPXU7;,\n                                                                  .:75pKH11252U252XapZgRQgD6XJscLr;,.\n                                                               :LXpRgGaX521JLw1JswJJsJs22XHPPEZEGDOMMRDOa7.\n                                                           .r2EDDZEpZPZP6KpHX5SXH5XXa5KwaXaSX5UJ1c77sLs2GMQQ6r                                       .\n                                                        ,LpgOGpEZGZEZEpZKpHHU5wP5HEDgpXpHa2SSa5aSXULr7rrirrJXRBp;                                   ;B\n                                                     ,J6MRZH6EgEEZE6E6EZZPZXXwSSGQXr::aPpP5USUHaHaKa5Lvrr7ri;rLHBB2:                                Kc\n                                                   rpQDOpPPOGGZOGOZG6GEOEOEDPPGBa.  .PaSSUXSUUUaUSaKXKS177r7rrrirSBBR7                             .O,\n                                                :UBQOKPK6ZOOOEDEO6GZE6EpEpDgDBR:   UBpXHa5aSaUS5SUS5XapPHJc7rrv7rr7sgBBs                           .g.\n                                              ;gBMPXpO6GEOEOEOEGEOEE6EZEEDRGBB    EB5pKSXpHKaHSX552S5aUHHEX17c7vr7777s5RBS:                        .R;\n                                           .sQBPXpDZOODOgODGOGgEDEOEOGgGgOOMB:   LBKKSXSHa52aaKXHXKaa5aSaaHXSJLcL7vcc777JDBBg2;.                    Qi\n                                         ;2ggp2EDDOggGEDGgDDOgGGZDOOZOGg6gEBX    vBZaHUKaaUXXXSXXKXpXHXH5wwaa52U1wssLsLJccv1UDQBQ67.                O7\n                                       :ZZUU5PROOEOZOZGGOODZOGgODZOOgOggRgRB; ;:..R6XaKKpP6PGppKPHpHpPX5aU21UUa5Sw52UwUJJv77L77sSpQMDU;            ;B5\n                                     ,SRJ7sSHGggEOZOEG6OODpOZgggOQQBBBBBQBBQ.,;;. LBOgOgDRDDZODMgQRgRDaa552a252UUa25w5UaU2sLvccs7r7sJZBBMr       ,XQJ:\n                                    LQHr77J6RGOZDZOEGEDGgDRORQBBBQRDPU1Jscwa7.,::.:J7r;::::.  ..,:;i7UOgRRRgDPH5SUSU52U2HHa1JJJLJLccLr71RBB,    7R2,\n                                  :RZv;77JSgGOZEODEDGOEggQBBBMS7;:,:,,.,.,.:7L;:,;.:  ,: . .....       .:;rJU6GgGRggEZHPaKXX2S221Js1Lc7r:7QB. .XX:\n                                 7g1;;7rcXG6gpGDZGgZOOQBBQpr.   ::::;:;:::Jr::sr;::;:.:vs,:::::::::::,,         ,:7L5HGOggRgZUUU5wSUaJLc7r7BOiDr  ...\n                               .XX;;;irLHGKpZZZEKgDRBBB6i    ,;;:;;;;r;;:s177:,;L7:;7:.rHi,:::::::::::::::::,.         .,;7ZRQgO6KUUJsLwsJ7KBM. .....\n                               JZ:;rrrc5EPHp6XgpRBBBE;     :i:;;;;;:;;;:c7::r7;,::::::::rv:,:::::::::::,:,:,:,,,,            .;sORQRGX21wsXU:  .... .\n                              .Br;iir72EHPHZ6EgBBR7.   ..;ii:;;;;;;;;;:71r::.:7,  .::7;:;H;.::,:::::::,:::::,,,::,,,              ,7wEDRZBMr  .......\n                              1D;:r;rwOPXPKH6BBX,   .:;:;;;:::;:;;;;;::Ls,;ss..r.  ,c77;sLU,:,:::,:::,:,:,:,,,:,,,:::.                  .:.rP:.......\n                              D2:i;rJpKHXHXgg7    .,,::::;:::::;:;:;;:;SL7sS2, :.   ::::,:U7.:::,:::,:,,,,,:,,.,,,.,:,                    ;L:. .. ...\n                             :Qc;i7LGZPa6gBM,  ...,,::::::::::::;;::;.JJ;ic:         ;:::,v1,.:::;7,,,:,:,:,,,,.:,,,,..                :2wr.  .......\n                             sRr:rrwZGgBQR7.  .,,::::::::::::::;::;:::Hr:7i          ,;;:::U: .,,,:r.,,:,:,:,,,:,,,.....             7K2:. ..........\n                             OX:irsXgQZ:.   .,,:::,,:::,::::::::;;;::r5;r7:           :;;;:7L ..,.,;:,:,:,,,:,:,,,,......        .rU6w;..............\n                            .BJ71EK5;.   .,,::,:,:,,,:,:,::::::::;:;.Ls;r7             :;:::s, ..,,,r:.:.,,,.:, .,..... .    .;s5XJr,..,.............\n                            1Mv::.     .:,:,,,,,,,:::::::,;:::;:;::..J7;c:          ,. ,rri:27  , .,:;. ,:,:,,:..,....    .rpPL;:.. ... .............\n                       ..7Ls:        .,,,:,,,:,:,:::,:,:::::,:::::: .Srrr,  .,:;;;::::..:7r;r1    .: :E:..,,:,...,,.., ..XBQ7, ................... ..\n                  ,;7v7r7:,         ,,,,:.,,,,,,:,,::,:,,.::.,:.,:, :Jrr; ,r7,:..        ,:::L:  .  .7RJ .,.:.,......,,:MBs   ..............,........\n            .:;vJs7i,              ,,,., ..,,:,,,:,,,:,:.,rs,,.:,,  ;J;c,                .,::;;     Lr.E: .,...,....:,:1Z:  .........,.,...........:,.\n   .;,,:r7J1wv;,.               ....,.:. .,.,,:,,,:,,::::,sS;.:::,  cLrr.     .       .,. .,..:    ;;  r5 ........,,:;s7. ....,.,.,...........,.,.,,.\n   ,BBs:::                   . ........,.,,,,,.:,,,:,:,,.;s7r,,,,,  cc7;         ,.,,.      .:7rrJGMPOEL1, ..... ,,:rSr, : ,.,.,.,.,.........,,,,,. ..\n     rZL.                   ....... ..,,,.,,,..,,,.,;,...7J:s: ..  .wr7,        ...    .rJpQBBBBBBBQgKP77s  ..  .,7S2,,....,....,.,.,......,,.,. .:cX2\n       ;SH7,               . . . .. .,.,.,.,,,...,..r, ::Ur;7L .   .57;.           .rPBBQBBBPws:;r::::.,:P.    .;S5;,..,...,.,.,.,.... ..,,, ..,7HSJvr\n          r7r;:             . ... ..........,...,.. 7L;,rS;;ivr .   1r:       .  .rZBBK7;.JL,::Jrs;.:;,:;J, .,;LDv..:.,...,.,.,.,...,.,,:,, ,7sKGwc77;\n             .:7L7:,            . ,r,..,.,,,...,..:iLL  7s;r;cv:    U7.         :vi;:. .. :Er:::.Ls. . ,7::::vHEi ,:,,.,,,.,.,,,,,,::::, .:1QBKJJUsssc\n                .:rvw1JsL7;,      ,;..........,.:ir :r .ELr77v:,.   Pr          ..      .  Ls    ,w.   rr.r:JPr. ::,..,,,.,,,,:,:::,:,..7XgRE52US25w1c\n                      .:;7JRQpX:   ; .........,i:  .,J ;gri;7r  :   1;                     .X:    .   ,v :aK1, ,,:.,,,.,,,,:::::,;::::cOBB6K55UXUX5XUw\n                           ;J,XQB7,:    . ...,:   .:7Z.7Zi7;r:   ,  v,                      :w:;,.,:::7LUsc:..:,:.:,,,,,:,:::::::,:;c5BBPS5wSUSUaUaUa2\n                           J7  rEBBg..,. ..... .  ,L1PLKr:,:;r;;::, :,                       :;SXsJU1XLLr....:,,,,,,::::,::::::,::LL,,rZXUJU25552aUUUU\n                           JL .:sXBB:... ., .    ,OH777;,rZRBBBQL ..r,                     ,:r7::r:,;;....:,,,,,,,,.::::;::;:::.7gL    UK2UUS1aw2wU25J\n                           U7 .r71BB;  . :.. .. :QJ;.;1pBBBBBGRBRi  i:                   .      .w7.   ..,,:,,,,,:,:,:::::::,.,2BR:   .DSaUSUUS525w5U1\n                           2r :7rJBQ7   .;. .   KL::JGBBBgE6Hp6XMQ;     .                    ... ,2s    ,,,,:::::,:::::::,,.:sQQB2    ;DHa5U52S2U25USJ\n                           a: :7;1BB2   .v,    sL;LPQgDBPH6KPQBpGBG    .                   ... ..  aP:. .. ,::,:::::,,,,.;rSgBQDa;    :gSSwSUUU525US2U\n                           5; ;;r2QBB,  .s:  :a7:PBZ2,:BEaZPKgBZOgB,                        .   ...:LEHri::,:.,,.,,,::rsXRBgGKEJi,    2GH252SUS5S11wH5\n                           U: ;:rwDBBr  .c, rB6r 167.,,RQPpEP6OpKEBc      .,                 .   : ::sS7;cKB6HHa1XOQRRQBRgEZDBH; ..  ;RZUPSSU525USSpK2\n                           s; ;::aBg,   .; .Gv,H::,,::,;BQDOGHPXpKBs      .,.                 . .,.  .r:;:6gOEBQRRRDggQgOHgMGL,    .;PEHHXaaKaPXPKPaXS\n                           s7.:,sBa     :..S,  vE::::;  7BBMgZH6pQBr             .             ,:,   ,.,r2RHSSpMZPKRRZpgggav,    ;UpEZaaaKHHUHPPaUJHGO\n                           a;.775:    .::rU.    gR:,:.   :;:BBBBQar                         .  ,,   ,.,7rggJwU6DDGMgOGgXc:,   ,rPGOpKSXSXSKUKHU1UHgOEP\n                          1i :SZJrLXpBBMRB:  .v  Ba,.       :sv:                             .        irsBUSpEEGPPpg65r:..,;sKZDZHSX5XaHU55K2wUGMRZ6Z6\n                         :K  :7asvwc2MgEQB, :gg.:iB7  .,,,:.                      ...,.   .     ..   .:iM6GEpSSXZOEs:...;spZpKKXXSX5Xa5Ja5wwKGQDEpp6OZ\n                         w; ,LXLr77sLwL5aR. gRgQgaQBi ,vJwvi,.                 .;;:;7:   .   .  ,...  rRDRJUSXpgas:,.:;U66SaHa2X5aUa552X12SgQgpZpEpGOD\n                         H: ;XJ;77rv7rJUaQ;rgaPgXXHBB;        . .              .ri:;;          ,: . :6QZEKHXpXXL:,::r1PKXaa2XSS5a5S5UJ22aOBgEpOppZOOgG\n                         iwsJsr7rsLrrLcJ2gQGXHwa1SUHBB:  . ... .                 ..,           :   1BRKpOEGp2Jr;::rsXP1Uaa2U5a5aUa5SsSpgQRZGZEEZZOOgDg\n                           ,cs5aXaP552ssLwRSHXaSS5asXBB.      . .                             .  LBBgGgZHsr;vrr;rcXpP5UUS5X5S2XS5SS1URBggpEZgDDGOGggRD\n                              ,;irrs2KgQRPJJJSUXKXSHJpBM   . . .                                ZBBOUsr;:.  ,,,rHgZPUaSaUSUSSXaUPXsSBB6ZZp6EEGOOGDEggO\n                                       ;BBQQZaSJ5J15SJDQ7                                    .iEBL:.  . .,:,:;SRQGZXPXXSHaS2UUSUSswQB6OZgG6pZZGODEOGDE\n                                      JgUri1aGEpEpXSS5LBQ,                              .rLap2Jr     ;712OO6ZggRDZXHXpKK2211LLLc7wgBa2PODRGE6OZgDgGDGD\n                                    7QB; ,Jc76DaZXOZgDPEBBX,                       :c1HEZ1c;:,.,:;cHDgQQggMZgGOZO6OEGpXsLLsJXHPOBBBc;vss5EMggZDODOgED6\n                                   LZJ::iwrrr72EPgXU5OBBBBBBBp7:               .i5P6wL;,   .:LS6DMgMgZKgEOPOGGDDGEXULvLSOBBBBBQBgDQDJ5rrr7JOQQDDZGEgDD\n                                   wp rR5,       .HQRX7r72RQBBBBBQBMEK6Uc7sc7cHOU:,     .:LHgOQg6ZOPZpZGGEDERZPwcr7LKDDaJr:.      rBX;;:r:ir1DBQMgRgDp\n                                   7D,sw:      ,   Z.      .LgBBQBBOsJaQBBBBBBXrr.  .:rwZBBQgROgDgDOERRMgROOScrLsPP5r,             7Qs,::::::rUgRgZOG6\n                                   ,Q57:r  ,:  ,r  U:         .;;   .vL7L;r:UG7.:sr;JSgQBgDEZXXUSXpHa21svr7r7s2v:.                  iQK...:,:::;LLJJws\n                                    OBHs;.  :;;,v  H:             :6X;       rpL;7pSrrr7r;::,....,,:;iirrvvvr,                       :BBPs;;:,,,,::;::\n                                    ::rPDEL:..7:c;7r              pK  .:      :KL.:r:..     ..:icsS5sr:,.                              JgGgBQDOSJss77r\n                                         :r;:::  ,                PH r,       ,;5: ,::::;7Ls7Lc7;:                                         ,:7JP17rJUs\n                                                                  .:J: :;  .,:K6BQS7:.,.,.\n                                                                    :r7Ji;r7;::;;.**/\n                                                                        .\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n;\n    while(cin&gt;&gt;n){\n        if(n&lt;=2)cout&lt;&lt;&quot;XiaoNiu&quot;&lt;&lt;endl;\n        else cout&lt;&lt;&quot;XiaoKe&quot;&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"这道题以前在lrj上见过,不过没注意.Linkhttps://www.nowcoder.net/acm/contest/75/DType: 博弈论题目链接：https://www.nowcoder.net/acm/contest/75/D 来源：牛客网小牛和小客玩石子游戏，他们用","link":"","raw":null,"photos":[],"categories":[{"name":"博弈论","slug":"博弈论","count":3,"path":"api/categories/博弈论.json"},{"name":"牛客练习赛","slug":"博弈论/牛客练习赛","count":1,"path":"api/categories/博弈论/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"}]},{"title":"HDU 1431","slug":"hdu-1431","date":"2018-02-06T14:37:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1431.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1431\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>\n<h1><span id=\"type-二分线性素数筛\">type: 二分,线性素数筛</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>先用线筛打1000W的表,然后二分查找a的下标,暴力a到b内素数是否是回文数即可.</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000000+10;\nint a,b,tot=0;\n\nbool valid[maxn];\nint prime[maxn];\nvoid init(int n,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint query(int len,int key){\n    int left=1;\n    int right=len;\n    int mid;\n    while(left&lt;=right){\n        mid=(left+right)&gt;&gt;1;\n        if(key&lt;prime[mid]){\n            right=mid-1;\n        }else if(key&gt;prime[mid]){\n            left=mid+1;\n        }else return mid;\n    }\n    return -1;\n}\n\nbool check(int n){\n    if((n/10)==0) return true;\n    int str[20];\n    int len=0,l=n;\n    for(;l&gt;0;){\n        ++len;\n        str[len]=l%10;\n        l/=10;\n    }\n    for(int i=1;i&lt;=len;++i){\n        if(str[i]!=str[len-i+1]) return false;\n    }\n    return true;\n}\n\nint main(){\n    init(10000000,prime);\n    while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b)){\n        int id=query(tot,a);\n        for(int i=id;prime[i]&lt;=b &amp;&amp; prime[i];++i){\n            if(check(prime[i])){\n                printf(&quot;%d\\n&quot;,prime[i]);\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttp://acm.hdu.edu.cn/showproblem.php?pid=1431type: 二分,线性素数筛题意题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.题解先用线筛打1000W的表,然后二分","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"二分搜索","slug":"HDU/二分搜索","count":1,"path":"api/categories/HDU/二分搜索.json"},{"name":"数论","slug":"HDU/二分搜索/数论","count":1,"path":"api/categories/HDU/二分搜索/数论.json"},{"name":"线性素数筛法","slug":"HDU/二分搜索/数论/线性素数筛法","count":1,"path":"api/categories/HDU/二分搜索/数论/线性素数筛法.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"数论","slug":"number-theory","date":"2018-02-06T07:59:57.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/number-theory.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>对于这一个知识点的学习,我大概会通过 《ACM国际大学生程序设计竞赛:知识与入门》 以及 lrj的蓝书以及《ACM/ICPC数论及应用》来学习.</p>\n</blockquote>\n<h1><span id=\"素数\">素数</span></h1><h2><span id=\"素数筛法\">素数筛法</span></h2><h3><span id=\"艾氏筛法onloglogn\">艾氏筛法(O(nloglogn))</span></h3><blockquote>\n<p>通常使用艾氏筛法,而艾氏筛法的思想也可用于很多地方.</p>\n</blockquote>\n<h3><span id=\"线性筛法\">线性筛法</span></h3><h4><span id=\"伪码表述\">伪码表述</span></h4><blockquote>\n<p>算法: 线性的素数筛法 输出: 一个集合S,表示1~n以内的素数集合 具体流程:</p>\n<blockquote>\n<p>(1) 将S初始化为{2,…,n} (2) 维护当前确定的素数的列表L,并初始化为空 (3) 对于 2 到 n 的每一个i</p>\n<blockquote>\n<p>(3.1) 如果当前i∈S,将i加入L (3.2) 对于L中的每一个元素p</p>\n<blockquote>\n<p>(3.2.1) 若i×p&gt;n,结束循环 (3.2) (3.2.2) 将i×p移出S (3.2.3) 如果p整除i,结束循环 (3.2)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4><span id=\"代码1亿数据量1s\">代码(1亿数据量1s)</span></h4><blockquote>\n<p>实锤完毕…我的电脑竟然可以存下1亿的数组…</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100001000\nusing namespace std;\n\nbool valid[maxn];\nint prime[maxn];\n/*素数筛法 O(n),对于每个素数只标记一次*/\nvoid getPrime(int n,int &amp;tot,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint main(){\n    clock_t t1 = clock();\n    int tot=0;\n    getPrime(100000000,tot,prime);\n    clock_t t2 = clock();\n\n    cout&lt;&lt;tot&lt;&lt;endl;\n    cout&lt;&lt;prime[5760000]&lt;&lt;endl;\n    cout&lt;&lt;&quot;总运行时间为: &quot;&lt;&lt;(double)(t2-t1)/ CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;&lt;&lt;endl;\n    return 0;\n}</code></pre><h2><span id=\"素数估计\">素数估计</span></h2><blockquote>\n<p>如果我们设Pi(x)表示不超过x的素数的个数.可以用</p>\n<blockquote>\n<p>x/lnx对Pi(x)进行估计</p>\n</blockquote>\n<p>不到万不得已别用,误差蛮大的</p>\n</blockquote>\n<h2><span id=\"素数判定miller-rabin\">素数判定(*Miller-Rabin)</span></h2><blockquote>\n<p>朴素的素数判定法是通过枚举从2到n^0.5内所有的整数,看他是否能整除n.时间复杂度为O(n^0.5) 此外有一个基于概率的常数时间的素数判定法</p>\n<blockquote>\n<p>Miller-Rabin素数判定</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"欧几里得算法\">欧几里得算法</span></h1><blockquote>\n<p>求gcd(a,b),欧几里得的一个结论是</p>\n<blockquote>\n<p>gcd(a,b)=gcd(b,a%b) 求得最后结果即可</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"gcd性质\">gcd性质</span></h2><pre><code> gcd(a,b)=gcd(b,a) （交换律）\ngcd(-a,b)=gcd(a,b)\ngcd(a,a)=|a|\ngcd(a,0)=|a|\ngcd(a,1)=1\ngcd(a,b)=gcd(b, a mod b)\ngcd(a,b)=gcd(b, a-b)\n如果有附加的一个自然数m,\n则: gcd(ma,mb)=m * gcd(a,b) (分配律)\ngcd(a+mb ,b)=gcd(a,b)\n如果m是a和b的最大公约数，\n则： gcd(a/m ,b/m)=gcd(a,b)/m\n在乘法函数中有：\ngcd(ab,m)=gcd(a,m) * gcd(b,m)\n两个整数的最大公约数主要有两种寻找方法：\n* 两数各分解质因数，然后取出同样有的质因数乘起来\n*辗转相除法（扩展版）\n和最小公倍数（lcm）的关系：\ngcd(a, b) * lcm(a, b) = ab\na与b有最大公约数，\n两个整数的最大公因子可用于计算两数的最小公倍数，或分数化简成最简分数。\n两个整数的最大公因子和最小公倍数中存在分配律：\n* gcd(a, lcm(b, c)) = lcm(gcd(a, b), gcd(a, c))\n* lcm(a, gcd(b, c)) = gcd(lcm(a, b), lcm(a, c))\n在坐标里，将点(0, 0)和(a, b)连起来，通过整数坐标的点的数目（除了(0, 0)一点之外）就是gcd(a, b)。</code></pre><h2><span id=\"扩展欧几里得\">扩展欧几里得</span></h2><blockquote>\n<p>扩展算法可以求出两个整数x和y,使得ax+by=gcd(a,b)。在此前提下|x|+|y|取最小值。 对此证明: <a href=\"http://blog.csdn.net/qq_20200047/article/details/71159677\" title=\"http://blog.csdn.net/qq_20200047/article/details/71159677\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20200047/article/details/71159677</a></p>\n<blockquote>\n<p>即可以证明a和b的最大公约数可以写成a和b的线性表示.</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"代码\">代码</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a,LL b){\n    return b ==0?a:gcd(b,a%b);\n}\n\n//求整数x和y,使得ax+by=d,在此前提下|x|+|y|取最小值.\n//即使a,b在int范围内,也可能超出int\nvoid exgcd(LL a,LL b,LL &amp;d,LL &amp;x,LL &amp;y){\n    if(!b){d=a;x=1;y=0;}\n    else {exgcd(b,a%b,d,y,x);y-=x*(a/b);}\n}\n\nint main(){\n\n    return 0;\n}</code></pre><h1><span id=\"一些性质\">一些性质</span></h1><blockquote>\n<p>记(a,b)为gcd(a,b)</p>\n<blockquote>\n<p>则</p>\n<blockquote>\n<p>(a,b)=(b,a) 且 (a,b,c)=((a,b),c)=(a,(b,c))</p>\n</blockquote>\n</blockquote>\n<p>记[a,b]为lcm(a,b)</p>\n<blockquote>\n<p>有同上结论</p>\n</blockquote>\n<p>(a,b)*[a,b]=ab (gcd求lcm的由来)</p>\n</blockquote>\n<h1><span id=\"唯一分解定理\">唯一分解定理</span></h1><blockquote>\n<p>简单说吧,对于任意一个整数,都可以化简成素数次幂乘积的形式.</p>\n</blockquote>\n<h2><span id=\"确定正整数n的正约数个数\">确定正整数n的正约数个数</span></h2><blockquote>\n<p>由唯一分解定理得到的所有素数的幂可以推出约数个数 设第i个素数的幂为{ai}</p>\n<blockquote>\n<p>count=(a1+1)<em>(a2+1)</em>(a3+1)<em>…</em>(as+1)</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"而这玩意也有一个玄学快速分解算法\">而这玩意也有一个玄学快速分解算法</span></h2><h3><span id=\"pollards-rho\">Pollard’s Rho</span></h3><blockquote>\n<p>因为目前题目出现的概率很低,所以延迟学习,先学其他的.</p>\n</blockquote>\n<h1><span id=\"不定方程\">不定方程</span></h1><h2><span id=\"基本概念\">基本概念</span></h2><blockquote>\n<p>变量个数多于方程个数,并且只考虑整数解的方程被称之为不定方程。典型的二元一次不定式形式为ax+by=c,其中a、b、c皆为已知整数,a、b都不为0,x、y为未知数.</p>\n</blockquote>\n<h2><span id=\"性质\">性质</span></h2><blockquote>\n<p>我们清楚以上方程的形式相当于前面提到过的扩展欧几里得式. 以下我们用python中的整除 ‘//‘ 代表数学记号整除 1.二元一次方程ax+by=c有解的充要条件:</p>\n<blockquote>\n<p>(a,b)//c 并且当(a,b)//c的时候该方程等价于</p>\n<blockquote>\n<p>(a/(a,b))*x+(b/(a,b))*y=(c/(a,b))</p>\n</blockquote>\n</blockquote>\n<p>2.假设二元一次不定方程ax+by=c有解,并且x0、y0为方程的一组解,则他的所有解可以表示为:</p>\n<blockquote>\n<p>x=x0-(b/(a,b))*t y=y0+(a/(a,b))*t t为任意整数</p>\n</blockquote>\n<p>3.不定方程非负解 暂略</p>\n</blockquote>\n<h1><span id=\"同余方程与欧拉定理\">同余方程与欧拉定理</span></h1><h2><span id=\"同余方程\">同余方程</span></h2><blockquote>\n<p>假设m≠0.若m//(a-b)则称a同余于b模m,记为</p>\n<blockquote>\n<p>a≡b(mod m)</p>\n<blockquote>\n<p>证:</p>\n<blockquote>\n<p>a=rm+d b=km+d a-b=(r-k)m mod m = 0</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3><span id=\"定理1\">定理1</span></h3><blockquote>\n<p>a≡b(mod m),当且仅当m//(a-b)</p>\n</blockquote>\n<h3><span id=\"定理2\">定理2</span></h3><blockquote>\n<p>a≡b(mod m),当且仅当存在整数k,使得a=b+km</p>\n</blockquote>\n<h3><span id=\"定理3\">定理3</span></h3><blockquote>\n<p>同余关系是等价关系,即满足以下三条:</p>\n<blockquote>\n<ol>\n<li>自反性 a≡a(mod m)</li>\n<li>对称性 a≡b(mod m),b≡a(mod m)</li>\n<li>传递性 a≡b(mod m),b≡c(mod m),则a≡c(mod m)</li>\n</ol>\n</blockquote>\n</blockquote>\n<h3><span id=\"剩余系\"><strong>※</strong>剩余系</span></h3><blockquote>\n<p>指对于一个正整数n,一个整数集合中的数mod n所得的余数域.</p>\n</blockquote>\n<h4><span id=\"完全剩余系\">完全剩余系</span></h4><blockquote>\n<p>如果一个整数集合的剩余系包含 1~n-1 所有n可能的余数,则该剩余系被称为完全剩余系,我们简记为 Zn.</p>\n<blockquote>\n<p>比如 Z6={0,1,2,3,4,5}</p>\n</blockquote>\n</blockquote>\n<h5><span id=\"缩系\">缩系</span></h5><blockquote>\n<p>指在模n意义下完全剩余系中与n互素的剩余系,简记为Zn*.</p>\n</blockquote>\n<h4><span id=\"zn的同余等价类\">Zn的同余等价类</span></h4><blockquote>\n<p>Zn中的每个元素都代表所有与他同余的整数,比如n=5时,Z5中的元素”3”实际上代表了3,3+5,3+10…,所有这些整数除以5的余数都是3.</p>\n<blockquote>\n<p>我们把满足同余关系的所有整数看成一个同余等价类,比如 3,8,13,18 都属于”模5等于3” 这个同余等价类</p>\n</blockquote>\n</blockquote>\n<h4><span id=\"关于取余等式-kab-的一些性质\"><strong>※</strong>关于取余等式 k=a%b 的一些性质</span></h4><h5><span id=\"即abn等zn同于等价类意义下四则运算\">即(a+b)%n等,Zn同于等价类意义下四则运算</span></h5><blockquote>\n<p>加法</p>\n<blockquote>\n<p>(a+b)%n = ((a%n)+(b%n))%n</p>\n</blockquote>\n<p>减法</p>\n<blockquote>\n<p>(a-b)%n = ((a%n)-(b%n)+n)%n</p>\n</blockquote>\n<p>乘法</p>\n<blockquote>\n<p>ab%n=(a%n)(b%n)%n</p>\n</blockquote>\n<p>异或</p>\n<blockquote>\n<p>(a^b)%n=((a%n)^b)%n</p>\n</blockquote>\n</blockquote>\n<h4><span id=\"zn意义下的除法模乘法的逆-逆元\"><strong>※</strong>Zn意义下的除法(模乘法的逆、<strong>逆元</strong>)</span></h4><blockquote>\n<p>首先说下用处,通常在大整数 a/b 时,或者 c/d<em>p/x…但最后结果*</em>一定是整数**时,并且对ans%n,为了避免中间除法运算,我们会用逆元(刚开始学,只知道这些用途,如有缺漏,欢迎补充). 那么向下进行吧</p>\n<blockquote>\n<p>模乘法的逆:</p>\n<blockquote>\n<p>在某些情况下 Zn中的两个元素a和b满足 Zn意义下 ab=1,即ab≡1(mod n).比如</p>\n<blockquote>\n<p>在 Z15 中,7*13=1</p>\n<blockquote>\n<p>即(7*13)%15=1</p>\n</blockquote>\n</blockquote>\n<p>在这种情况下,我们称a和b互为乘法的逆,记为 b=a(-1),a=b(-1) [-1代表上标]. 这个逆的运算很像”倒数”,因为在剩余系中,模n意义下当a(-1)存在时,”除以”一个数a等价于乘以他的乘法逆a(-1),比如在 Z15 中 7(-1)=13,因此3/7=3*7(-1)=3*13=9</p>\n<blockquote>\n<p>这时我们会产生疑问,3/7甚至不是整数,怎么可能等于9? 请注意:</p>\n<blockquote>\n<p>1 我们是在模n意义下对除法进行运算. 2 剩余系中每个元素对应一个同余等价类, 3/7=9的实际含义是”假定有两个整数a和b,其中a/b是整数,且a和b除以15的余数分别为3和7,则a/b除以15的余数等于 9”</p>\n<blockquote>\n<p>比如a=528,b=22就是一例</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h5><span id=\"除法逆元合理性证明\">除法逆元合理性证明</span></h5><blockquote>\n<p>设我们要求 （a / b） mod p 且 b * k ≡ 1 (mod p),即k为b的逆元</p>\n<blockquote>\n<p>注意这里我们可以用扩展欧几里得求出是否存在k,以及k的值 即 答案为 (a * k) mod p 因为 b * k ≡ 1 (mod p) 则有 b * k = p* x+1 得到 k = (p * x + 1) / b 将 k 代入(a * k) mod p</p>\n<blockquote>\n<p>得到： (a * (p * x + 1) / b) mod p =((a * p * x) / b + a / b) mod p =[((a * p * x) / b) mod p +(a / b)] mod p =[(p * ((a * x) / b)) mod p +(a / b)] mod p =(0 + (a / b)) mod p = (a/b) mod p</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3><span id=\"定理4\">定理4</span></h3><blockquote>\n<p>若a,b,c是整数,m是正整数,且 a≡b(mod m) ,则</p>\n<blockquote>\n<p>(1) a+c ≡ b+c(mod m) (2) a-c ≡ b-c(mod m) (3) ac ≡ bc(mod m)</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"定理5\">定理5</span></h3><blockquote>\n<p>设a,b,c,d为整数,m为正整数,若a≡b(mod m),c≡d(mod m)则(注: 一下定理两边值不一定相等,只是mod m相等):</p>\n<blockquote>\n<p>(1) ax+cy≡bx+dy(mod m) 其中x,y为任意整数,即同余式可以相加 (2) ac≡bd(mod m) 即同余式可以相乘 (3) a^n≡b^n(mod m) 由上面那个可以推得,n&gt;0 (4) f(a)≡f(b)(mod m) 其中f(x)为任一整数系数多项式</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"定理6\">定理6</span></h3><blockquote>\n<p>设a,b,c,d为整数,m为正整数,则</p>\n<blockquote>\n<p>(1) 若 a≡b(mod m),且d//m,则a≡b(mod d) (2) 若 a≡b(mod m),则gcd(a,m)≡gcd(b,m) (3) a≡b(mod mi)(1&lt;=i&lt;=n)同时成立,当且仅当 a≡b(mod[m1,m2,m3…mn])</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"定理7\">定理7</span></h3><blockquote>\n<p>若ac≡bc(mod m),且gcd(c,m)=d,则a≡b(mod m/d) 证:</p>\n<blockquote>\n<p>记 c=dc1,m=dm1,其中c1,m1互素</p>\n<blockquote>\n<p>由 ac≡bc(mod m) 得 m//(ac-bc) 即 dm1//d(a-b)c1 故 m1//(a-b)c1 由下面那个整除的性质,因为 m1,c1 互质 则 m1//(a-b) 得 a≡b(mod m1) 即 a≡b(mod m/d)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4><span id=\"整除的性质\">整除的性质</span></h4><blockquote>\n<p>若m | nk, 且m与k互素, 则m | n</p>\n</blockquote>\n<h1><span id=\"欧拉函数\">欧拉函数</span></h1><blockquote>\n<p>以前写过一次: 连接: <a href=\"http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/\" title=\"http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/</a></p>\n</blockquote>\n","text":"对于这一个知识点的学习,我大概会通过 《ACM国际大学生程序设计竞赛:知识与入门》 以及 lrj的蓝书以及《ACM/ICPC数论及应用》来学习.素数素数筛法艾氏筛法(O(nloglogn))通常使用艾氏筛法,而艾氏筛法的思想也可用于很多地方.线性筛法伪码表述算法: 线性的素数筛法","link":"","raw":null,"photos":[],"categories":[{"name":"数论","slug":"数论","count":1,"path":"api/categories/数论.json"},{"name":"算法学习","slug":"数论/算法学习","count":1,"path":"api/categories/数论/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"UVa 11806","slug":"uva-11806","date":"2018-02-05T09:48:17.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11806.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVA-11806\" title=\"https://vjudge.net/problem/UVA-11806\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11806</a></p>\n<h1><span id=\"type\">Type:</span></h1><blockquote>\n<p>组合数学,排列预处理,容斥原理,减法取模公式</p>\n</blockquote>\n<h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,</p>\n<blockquote>\n<p>问最上边,最左边,最下边,最右边都有石子的种数为多少?</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>我们可以将问题转化为:</p>\n<blockquote>\n<p>全集|S|-至少有一条边上没有棋子的种类个数. 并且我们可以发现,当四条边上都没有棋子时的种类个数为</p>\n<blockquote>\n<p>C((m-2)*(n-2),k).</p>\n</blockquote>\n<p>我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,D为下边没有石子. 则(我们设~A为非A集合):</p>\n<blockquote>\n<p>ans=|(<del>A)∩(</del>B)∩(<del>C)∩(</del>D)|</p>\n</blockquote>\n<p>可以发现就是容斥原理 至于每个集合的计算,在图中就相当于少了一行或一列, 即:</p>\n<blockquote>\n<p>C(row*column,k)</p>\n</blockquote>\n<p>因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能 即 可以用四位2进制表示</p>\n<blockquote>\n<p>0000 0001 0010</p>\n</blockquote>\n<p>我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行)) 等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0</p>\n</blockquote>\n<p>答案为全部的和.</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11806\nType: 组合数学,排列预处理,容斥原理,减法取模公式\n题意: 给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,\n问最上边,最左边,最下边,最右边都有石子的种数为多少?\n\n题解:\n我们可以将问题转化为:\n全集|S|-至少有一条边上没有棋子的种类个数.\n并且我们可以发现,当四条边上都没有棋子时的种类个数为\nC((m-2)*(n-2),k).\n我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,\nD为下边没有石子.\n则(我们设~A为非A集合):\nans=|(~A)∩(~B)∩(~C)∩(~D)|\n可以发现就是容斥原理\n至于每个几何的计算,在图中就相当于少了一行或一列,\n即:\nC(row*column,k)\n因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能\n即 可以用四位2进制表示\n0000\n0001\n0010\n我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行))\n等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0\n答案为全部的和.\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11806Type:组合数学,排列预处理,容斥原理,减法取模公式题意给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,问最上边,最左边,最下边,最右边都有石子的种数为多少?题解我们可以将","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"容斥原理","slug":"UVa/容斥原理","count":1,"path":"api/categories/UVa/容斥原理.json"},{"name":"数论","slug":"UVa/容斥原理/数论","count":1,"path":"api/categories/UVa/容斥原理/数论.json"},{"name":"组合数学","slug":"UVa/容斥原理/数论/组合数学","count":1,"path":"api/categories/UVa/容斥原理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11401","slug":"uva-11401","date":"2018-02-04T10:10:32.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11401.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVA-11401\" title=\"https://vjudge.net/problem/UVA-11401\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11401</a></p>\n<h1><span id=\"type\">type</span></h1><p>组合数学,加法原理,三角形三边定理</p>\n<h1><span id=\"题意\">题意</span></h1><p>给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>考虑三角形三边定理.</p>\n<blockquote>\n<p>设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条边. 则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边) 考虑y的取值,确定z的取值.</p>\n<blockquote>\n<p>y∈[1,x-1] 当y取1时,z无值.当y取2时,z有唯一值x-1 当y取3时,z可以取(x-1),(x-2). 故y取x-1时,z可以取的种数为x-2种.</p>\n<blockquote>\n<p>根据等差数列求和公式: 总种类数Sn = 0+1+2+…+(x-2)</p>\n</blockquote>\n<p>Sn = (x-2)(x-1)/2(种) 但这个值并不等于c(x) 因为:</p>\n<blockquote>\n<p>1.对于每个三角形都计数了两遍 =&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2 2.以上的计算方式存在y=z的情况 (这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z) =&gt; 比如x=7 y=4时,z就可以取到4</p>\n<blockquote>\n<p>对于第二种问题的解决很简单. 对于每个x考虑y==z的情况: 设t为c(x)中y=z时的情况总数: 则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.</p>\n</blockquote>\n<p>故t=(x-1)-(x/2+1)+1=x-1-(int)x/2</p>\n</blockquote>\n</blockquote>\n<p>故c(x)=(Sn-t)/2</p>\n<blockquote>\n<p>又因为c(x)是最长边为x时的种类数.</p>\n</blockquote>\n<p>故设f(n)为最长边不超过n时的种类数 根据加法原理,因为互无交集 故 f(n)=c(1)+c(2)+c(3)+…+c(n)</p>\n</blockquote>\n<p>化成递推: f(n)=f(n-1)+c(n)</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11401\ntype: 组合数学,加法原理,三角形三边定理\n题意: 给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形\n\n题解:\n考虑三角形三边定理.\n设c(x)为以x为最长边的可拼成三角形的数目.\n设y,z为另外两条边.\n则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边)\n考虑y的取值,确定z的取值.\ny∈[1,x-1]\n当y取1时,z无值.当y取2时,z有唯一值x-1\n当y取3时,z可以取(x-1),(x-2).\n故y取x-1时,z可以取的种数为x-2种.\n根据等差数列求和公式:\n总种类数Sn\n= 0+1+2+...+(x-2)\n= (x-2)(x-1)/2(种)\n但这个值并不等于c(x)\n因为:\n1.对于每个三角形都计数了两遍\n=&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2\n2.以上的计算方式存在y=z的情况\n(这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z)\n=&gt; 比如x=7 y=4时,z就可以取到4\n对于第二种问题的解决很简单.\n对于每个x考虑y==z的情况:\n设t为c(x)中y=z时的情况总数:\n则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.\n故t=(x-1)-(x/2+1)+1=x-1-(int)x/2\n故c(x)=(Sn-t)/2\n又因为c(x)是最长边为x时的种类数.\n故设f(n)为最长边不超过n时的种类数\n根据加法原理,因为互无交集\n故 f(n)=c(1)+c(2)+c(3)+...+c(n)\n化成递推: f(n)=f(n-1)+c(n)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nlong long sum[maxn];\nint n;\ninline void init(){\n    long long Sn,Cn,t;\n    memset(sum,0,sizeof(sum));\n    for(long long i=4;i&lt;=1000000;++i){\n        Sn=(i-2)*(i-1)/2;\n        t=i-1-i/2;\n        Cn=(Sn-t)&gt;&gt;1;\n        int id=(int)i;\n        sum[id]=sum[id-1]+Cn;\n    }\n}\nint main(){\n    init();\n    while(cin&gt;&gt;n){\n        if(n&lt;3)break;\n        cout&lt;&lt;sum[n]&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11401type组合数学,加法原理,三角形三边定理题意给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形题解考虑三角形三边定理.设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11538","slug":"uva-11538","date":"2018-02-04T04:55:35.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11538.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"题目连接\">题目连接：</span></h1><p><a href=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" title=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" target=\"_blank\" rel=\"noopener\">https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087</a> PS: 蓝书P105，书上有一个错误的地方,Sigma(1<del>n-1) i(i-1)那里书上得到的结果是2*Sigma(1</del>n-1) i(i-1)的结果.我在代码中标注了.</p>\n<h1><span id=\"link\">Link:</span></h1><p><a href=\"https://vjudge.net/problem/UVA-11538\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11538</a> type: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6</p>\n<h1><span id=\"题意\">题意:</span></h1><p>有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.</p>\n<h1><span id=\"题解\">题解:</span></h1><blockquote>\n<p>分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线</p>\n<blockquote>\n<p>同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1) 同一列: 合同一行类似,结果是nm(n-1) 同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)</p>\n<blockquote>\n<p>可以观测到所有’/‘方向的斜线长度为: 1,2,3,…,n,n,n,n-1,n-2…,2,1 其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可) 其中每条斜线上的取法种数 = i<em>(i-1) diagonal=Sigma(1~n-1) i(i-1) =&gt; i==1时确实是0种可能,因为皇后是放在块内而不是点上的. 则 All_diagonal = 2(2*diagonal+(m-n+1)*n</em>(n-1)) =&gt; 这里的乘2是因为有两种斜线’/‘和’\\‘的可能 其中</p>\n<blockquote>\n<p>diagonal =Sigma(1<del>n-1) i^2 - Sigma(1</del>n-1) i =n(n-1)(2n-1)/6 - n(n-1)/2 =n(n-1)(2n-4)/6 All_diagonal = 2(2<em>(n(n-1)(2n-4)/6)+(m-n+1)*n\\</em>(n-1)) = 2n(n-1)(3m-n-1)/3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>这三种情况互不相交,最终答案就等于三者和.</p>\n</blockquote>\n<p>Code:</p>\n<pre><code>/*\nLink: https://vjudge.net/problem/UVA-11538\ntype: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6\n\n题意: 有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.\n\n题解: 分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线\n\n同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1)\n同一列: 合同一行类似,结果是nm(n-1)\n同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)\n    可以观测到所有&apos;/&apos;方向的斜线长度为: 1,2,3,...,n,n,n,n-1,n-2...,2,1\n    其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可)\n    其中每条斜线上的取法种数 = i*(i-1)\n    diagonal=Sigma(1~n-1) i(i-1)   =&gt;   i==1时确实是0种可能,因为皇后是放在块内而不是点上的.\n    则   All_diagonal = 2(2*diagonal+(m-n+1)*n*(n-1))  =&gt; 这里的乘2是因为有两种斜线&apos;/&apos;和&apos;\\&apos;的可能\n    其中diagonal=Sigma(1~n-1) i^2 - Sigma(1~n-1) i  =&gt;n方和展开公式,等差数列求和\n                =n(n-1)(2n-1)/6 - n(n-1)/2\n                =n(n-1)(2n-4)/6\n\n        All_diagonal = 2(2*(n(n-1)(2n-4)/6)+(m-n+1)*n*(n-1))\n                     = 2n(n-1)(3m-n-1)/3\n\n这三种情况互不相交,最终答案就等于三者和.\n*/\n\n//Code\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nunsigned long long N,M;\nint main(){\n    while(cin&gt;&gt;N&gt;&gt;M){\n        if(N==0&amp;&amp;M==0)break;\n        unsigned long long row=N*M*(M-1);\n        unsigned long long column=N*M*(N-1);\n\n        if(N&gt;M) swap(N,M);\n        cout&lt;&lt;row+column+2*N*(N-1)*(3*M-N-1)/3&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"题目连接：https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087 PS: 蓝书P105，书上有一个错误的地方,Sigma(1n-1) i(i-1)那里书上得到的结果是2*Sigma(1n-","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"机器学习实战(一) K-近邻","slug":"machine-learning-knn","date":"2018-01-27T14:04:15.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/machine-learning-knn.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180127214341.jpg","content":"<h1><span id=\"k临近算法概述\">K临近算法概述</span></h1><p>简单地说,k临近算法就是采用不同的特征值之间的距离方法进行分类. 通过数据与数据集间的距离进行分类,以及断定新数据的类别. 这里我们选择使用欧氏距离来当做两点间的距离.</p>\n<h2><span id=\"实现knn算法\">实现KNN算法</span></h2><h3><span id=\"伪码\">伪码</span></h3><blockquote>\n<p>对未知类别属性的数据集中的每个点依次执行以下操作</p>\n<blockquote>\n<p>计算已知类别数据集中的点 按照距离递增次序排序 选取与当前点距离最小的k个点 确定前k个点所在的类别的出现频率 返回前k个点出现频率最高的类别作为当前点的预测分类</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"实现算法前\">实现算法前</span></h3><p>我们来学习一下需要用到的一些库函数.</p>\n<h4><span id=\"numpy\">numpy</span></h4><p>1.list转array</p>\n<pre><code>from numpy import *\narray([1,1])</code></pre><p>2.zeros()初始化向量</p>\n<pre><code>import numpy\nfrom numpy import *\na=(3,4)\nzeros(a)\n# 初始化一个3行四列的0矩阵</code></pre><p>3.矩阵操作</p>\n<pre><code>import numpy\nfrom numpy import *\n\nMat = array([[1,2],[3,4]])\n\n# 每行最小\nMat.min(0)\n# 每列最小\nMat.min(1)\n# 每行和\nMat.sum(0)\n# 上面传递的参数都是axis=1 or 0,0代表行,1代表列\n\n# shape返回一个tuple,代表矩阵的行数和列数\nMat.shape</code></pre><p>3.1矩阵排序argsort()</p>\n<pre><code>import numpy\nfrom numpy import *\n\nk = array([1,2,8.5,-1,0])\nt = k.argsort()\n# 输出升序排序后每位数字的下标数组</code></pre><p>输出升序排序后每位数字的下标数组,比如上面那个输出是:</p>\n<pre><code>array([3,4,0,1,2],dtype=int64)\n# 第一个是k[3],第二个是k[4]</code></pre><p>4.tile</p>\n<pre><code>import numpy\nfrom numpy import *\n\n# 有两个参数,第一个参数是初始矩阵,第二个参数是一个tuple,代表\n# 向行拓展次数,以及向列拓展次数,具体调用一下就知道了\ntile([1,2],(1))# 原矩阵\ntile([1,2],(2,2))# 行两倍,列两倍</code></pre><p>5.运算 直接使用运算符号,是相当于每行与每列进行运算. 真正的矩阵运算需要通过库来实现.</p>\n<h4><span id=\"数据读取\">数据读取</span></h4><p>与本例相关的数据集地址: <a href=\"http://be-sunshine.cn:9011/static/file/datingTestSet2.txt\" title=\"datingTestSet2.txt\" target=\"_blank\" rel=\"noopener\">datingTestSet2.txt</a></p>\n<pre><code># 打开数据文件\nfr = open(&apos;datingTestSet2.txt&apos;)\n# 按行读取\narrayOfLines = fr.readlines()\narrayOfLines\n\nfrom numpy import *\nnumberOfLines = len(arrayOfLines)\n# 生成与数据集相同列数的矩阵\nreturnMat = zeros((numberOfLines,3))\nreturnMat\n# 格式化读入,存储到矩阵中\nfor line in arrayOfLines:\n    line = line.strip()\n    print(line.split(&apos;\\t&apos;))\n    print(int(line.split(&apos;\\t&apos;)[-1]))</code></pre><h4><span id=\"matplotlib散点图\">matplotlib散点图</span></h4><pre><code>import matplotlib\nimport matplotlib.pyplot as plt\nimport numpy\nfrom numpy import *\n# 生成plt\nfig = plt.figure()\n# 规定最多111个点\nax = fig.add_subplot(111)\n# 创建一个矩阵,第三个代表类别\nMat = array([[1,123,2],[10,256,1],[7,321,3]])\n# 获取类别矩阵\nLabel = Mat[:,2]\n# 第一个参数横坐标,第二个参数纵坐标,第三个参数,颜色矩阵,第三个参数,大小矩阵\nax.scatter(Mat[:,0],Mat[:,1],15.0*Label,15.0*Label)\n# 绘制\nplt.show()</code></pre><h3><span id=\"代码实现\">代码实现</span></h3><h4><span id=\"对于代码的解释我都注释在代码中了\">对于代码的解释我都注释在代码中了</span></h4><pre><code># K-近邻\n&apos;&apos;&apos;\n算法思想:\n\n计算已知类别数据集中的点\n\n按照距离递增次序排序\n\n选取与当前点距离最小的k个点\n\n确定前k个点所在的类别的出现频率\n\n返回前k个点出现频率最高的类别作为当前点的预测分类\n&apos;&apos;&apos;\n\ndef classify0(inX,dataSet,labels,k):\n    &apos;&apos;&apos;\n    k-邻近算法\n    inX:测试数据 - array\n    dataSet:样本数据集 - array\n    labels:标签向量 - array\n    k: 选举前k个 - int\n    &apos;&apos;&apos;\n    # 获取数据集的列数\n    dataSetSize = dataSet.shape[0]\n    # 新建一个矩阵,将测试数据inX复制到每列上,以便计算距离\n    diffMat = tile(inX,(dataSetSize,1)) - dataSet\n    # 对每个指标的距离进行平方\n    sqDiffMat = diffMat**2\n    # 把每个指标的差方相加\n    sqDistance = sqDiffMat.sum(0)\n    # 计算inX与每个点的距离\n    distance = sqDistance**0.5\n    # 升序排序,返回排序后的下标矩阵\n    sortedDistIndicies = distance.argsort()\n\n    # 选择距离最小的k个点\n    classCount = {}\n    for i in range(k):\n        # 选取前k个距离最近的点中的第i个\n        voteIlabel = labels[sortedDistIndicies[i]]\n        # 映射到dict中,其中get的第二个参数是如果不存在的默认值\n        classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1\n    # dict.items()返回一个字典列表(dict_items)类型,即dict的原始插入顺序的list\n    # 可以直接用sorted排序\n    # 升序,其中operator.itemgetter(index)代表按照待排列表的第几个元素排序.\n    # reverse=True即变成了降序\n    sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True)\n    # 返回分类中频率最高的那个的标签\n    return sortedClassCount[0][0]</code></pre><h3><span id=\"可视化分析\">可视化分析</span></h3><pre><code>import numpy\nfrom numpy import *\n# 将测试数据转换为需要的类型\ndef file2matrix(filename):\n    &apos;&apos;&apos;\n    对于datingTestSet2.txt返回值类型\n    returnMat: [里程数,百分比,公升数]\n    --每年获得的飞行常客里程数\n    --玩视频游戏所耗时间百分比\n    --每周消耗的冰淇淋公升数\n    classLabelVector: [标签]\n    --1,2,3分别代表最好,其次,最次\n    &apos;&apos;&apos;\n    fr = open(filename)\n    arrayOLines = fr.readlines()\n    # 得到文件行数\n    numberOfLines = len(arrayOLines)\n    # 新建(文件行数,3列)的0 array\n    returnMat = zeros((numberOfLines,3))\n    classLabelVector = []\n    index = 0\n    # 处理数据\n    for line in arrayOLines:\n        line = line.strip()\n        listFromLine = line.split(&apos;\\t&apos;)\n        # 将数据加入返回的列表中\n        returnMat[index,:] = listFromLine[:3]\n        # 标签列表\n        classLabelVector.append(int(listFromLine[-1]))\n        index+=1\n    return returnMat,classLabelVector\n\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndatingDataMat,datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)\n\nfig = plt.figure()\nax = fig.add_subplot(111)\nax.scatter(datingDataMat[:,0],datingDataMat[:,1],15.0*array(datingLabels),15.0*array(datingLabels))\nplt.show()</code></pre><p>最后的结果如下: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180127214341.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180127214341.jpg\" alt></a></p>\n<h3><span id=\"归一化数值\">归一化数值</span></h3><p>我们可以发现,在数据集中,每种类的数据极差差距都很大,比如飞行常客里程数的极差,和每周消费冰淇淋公升数的极差相距交大. 所以我们尝试将不同的数据集按照相同的区间范围进行计算. 计算公式(和百分制化为150分制的道理一样): <strong>newValue = (OldValue-min)/(max-min)</strong> 其中min和max代表数据集中的最小特征值和最大特征值. 是用这个公式后的数值将统一变成0<del>1或者-1</del>1之间.</p>\n<h4><span id=\"代码\">代码</span></h4><pre><code>def autoNorm(dataSet):\n    &apos;&apos;&apos;\n    归一化数值\n    返回值\n    normDataSet:归一化后数值 - array\n    ranges:每类特征极差 - array\n    minVals:每类特征最小值 - array\n    &apos;&apos;&apos;\n    # numpy数组 .min(0)每列最小值\n    # .min(1)每行最小值\n    minVals = dataSet.min(0)\n    maxVals = dataSet.max(0)\n    ranges = maxVals - minVals\n    normDataSet = zeros(shape(dataSet))\n    m = dataSet.shape[0]\n    normDataSet = dataSet - tile(minVals,(m,1))\n    normDataSet = normDataSet/tile(ranges,(m,1))\n    return normDataSet,ranges,minVals</code></pre><h3><span id=\"对约会网站的测试\">对约会网站的测试</span></h3><p>最后我们对之前的datingTestSet2.txt进行误差测试 其中hoRatio代表对数据集的测试普及率. 这里用<strong>0.1即1000*0.1=100个</strong>样本数据进行测试.</p>\n<pre><code>def datingClassTest():\n    hoRatio = 0.10\n    datingDataMat,datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)\n    normMat,ranges,minVals = autoNorm(datingDataMat)\n    m = normMat.shape[0]\n    numTestVecs = int(m*hoRatio)\n    errorCount = 0.0\n    for i in range(numTestVecs):\n        classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],\\\n                                    datingLabels[numTestVecs:m],3)\n        print(&apos;the classifier came back with: %d,the real answer is: %d&apos;\\\n              % (classifierResult,datingLabels[i]))\n        if(classifierResult != datingLabels[i]): errorCount += 1.0\n    print(&apos;the total error rate is: %f&apos; % (errorCount/float(numTestVecs)))\n\ndatingClassTest()</code></pre><p>测试结果:</p>\n<pre><code>the classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 2,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 2,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe total error rate is: 0.600000</code></pre><h1><span id=\"doneand-thank-you-for-watching\">Done,And thank you for watching!</span></h1>","text":"K临近算法概述简单地说,k临近算法就是采用不同的特征值之间的距离方法进行分类. 通过数据与数据集间的距离进行分类,以及断定新数据的类别. 这里我们选择使用欧氏距离来当做两点间的距离.实现KNN算法伪码对未知类别属性的数据集中的每个点依次执行以下操作计算已知类别数据集中的点 按照距","link":"","raw":null,"photos":[],"categories":[{"name":"K-邻近","slug":"K-邻近","count":1,"path":"api/categories/K-邻近.json"},{"name":"Python","slug":"K-邻近/Python","count":1,"path":"api/categories/K-邻近/Python.json"},{"name":"机器学习","slug":"K-邻近/Python/机器学习","count":1,"path":"api/categories/K-邻近/Python/机器学习.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"},{"name":"K-邻近","slug":"K-邻近","count":1,"path":"api/tags/K-邻近.json"}]},{"title":"牛客练习赛11","slug":"nklxs11","date":"2018-01-26T15:39:55.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/nklxs11.json","excerpt":"","keywords":null,"cover":"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2","content":"<h1><span id=\"a假的线段树\">A:假的线段树</span></h1><h2><span id=\"题目\">题目</span></h2><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/A</a> 来源：牛客网 给你一个长为n的序列a，有m次操作 1.把区间[l,r]内所有x变成y 2.查询区间[l,r]内第k小值 对于100%的数据，1 &lt;= n, m , ai &lt;= 1000</p>\n<h2><span id=\"输入描述\">输入描述</span></h2><p>第一行两个数n,m 第二行n个数表示序列a 后面m行 1 l r x y :把区间[l,r]中所有x变成y 2 l r k :查询区间[l,r]中的第k小值</p>\n<h2><span id=\"输出描述\">输出描述</span></h2><p>对于每个询问，输出一个数表示答案</p>\n<h2><span id=\"示例输入\">示例输入</span></h2><p>3 3 2 3 3 2 1 3 1 1 1 3 3 1 2 1 3 2</p>\n<h2><span id=\"示例输出\">示例输出</span></h2><p>2 1</p>\n<h2><span id=\"题解\">题解</span></h2><p>数据量小.1000*1000的复杂度,可以暴力过.第K小直接排序即可.</p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1010;\nint n,m;\nint num[maxn];\n\nvoid solve1(){\n    int l,r,x,y;\n    scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;r,&amp;x,&amp;y);\n    for(int i=l;i&lt;=r;++i){\n        if(num[i]==x)num[i]=y;\n    }\n}\n\nvoid solve2(){\n    int l,r,k;\n    scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);\n    int copy[maxn];\n    for(int i=l;i&lt;=r;++i){\n        copy[i]=num[i];\n    }\n    sort(copy+l,copy+r+1);\n    printf(&quot;%d\\n&quot;,copy[l+k-1]);\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n    }\n    int query;\n    for(int i=0;i&lt;m;++i){\n        scanf(&quot;%d&quot;,&amp;query);\n        if(query==1) solve1();\n        else solve2();\n    }\n\n    return 0;\n}</code></pre><h1><span id=\"d求距离\">D:求距离</span></h1><h2><span id=\"题目\">题目</span></h2><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/D\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/D</a> 来源：牛客网 给你一个1 -&gt; n的排列，现在有一次机会可以交换两个数的位置，求交换后最小值和最大值之间的最大距离是多少？</p>\n<h2><span id=\"水题\">水题</span></h2><p>输入输出格式看链接吧</p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn=110;\nint num[maxn];\nint main(){\n    int n,mi=1,ma=1;\n    num[0]=0;\n    scanf(&quot;%d&quot;,&amp;n);\n    scanf(&quot;%d&quot;,&amp;num[1]);\n    for(int i=2;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n        if(num[i]&lt;num[mi]) mi=i;\n        if(num[i]&gt;num[ma]) ma=i;\n    }\n    int min_id=min(mi,ma),max_id=max(mi,ma);\n    int a=n-min_id,b=min_id-1,c=n-max_id,d=max_id-1;\n    printf(&quot;%d\\n&quot;,max(a,max(b,max(c,d))));\n    return 0;\n}</code></pre><h1><span id=\"e求最值\">E:求最值</span></h1><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/E\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/E</a> 来源：牛客网 给你一个长为n的序列a 定义f(i,j)=(i-j)2+g(i,j)2 g是这样的一个函数 <a href=\"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2\" target=\"_blank\" rel=\"noopener\"><img src=\"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2\" alt></a> 求最小的f(i,j)的值，i!=j</p>\n<h2><span id=\"题解\">题解</span></h2><p>这道题数据水,可以直接枚举距离1和距离2水过.</p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\n#define TREE_SIZE (1&lt;&lt;(20))\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn=100010;\nlong long sum_z[maxn],sum_f[maxn];\nint n,num[maxn];\n\ninline long long g(int i,int j){\n    register long long sum=0;\n    long long k=min(i,j),l=max(i,j);\n    sum=sum_z[n]-(sum_z[k]+sum_f[j+1]);\n    return sum;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    sum_z[0]=0;\n    for(int i=1;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n\n        sum_z[i]=sum_z[i-1]+num[i];\n    }\n    sum_f[n]=0;\n    for(int i=n;i&gt;=1;--i){\n        sum_f[i]=sum_f[i+1]+num[i];\n    }\n    long long res=1000000000;\n    for(int i=2;i&lt;=n;++i){\n        int T=min(1000,i);\n        for(int j=1;j&lt;T;++j){\n            long long reg=g(i-j,i);\n            //printf(&quot;i:%d,j:%d,reg:%d\\n&quot;,i,j,reg);\n            long long ans=j*j+reg*reg;\n            res=min(res,ans);\n        }\n    }\n    printf(&quot;%lld\\n&quot;,res);\n    return 0;\n}</code></pre><h2><span id=\"但是这道题是平面最近点对\">但是这道题是平面最近点对</span></h2>","text":"A:假的线段树题目链接：https://www.nowcoder.com/acm/contest/59/A 来源：牛客网 给你一个长为n的序列a，有m次操作 1.把区间[l,r]内所有x变成y 2.查询区间[l,r]内第k小值 对于100%的数据，1 &lt;= n, m , a","link":"","raw":null,"photos":[],"categories":[{"name":"牛客练习赛","slug":"牛客练习赛","count":2,"path":"api/categories/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"}]},{"title":"poj 3370","slug":"poj-3370","date":"2018-01-26T07:47:40.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-3370.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【鸽巢原理】 题意: 给你两个整数c和n,以及n个整数,问这n个整数中是否有一些整数和为c的倍数. 同样可以证明,当c&lt;=n时,同样可以使用鸽巢原理证明有连续的序列和为c的倍数. 另外有一点是,Sigma ai最大可能100000^2.所以要用long long存. PS:这道题用G++提交就超时了…C++提交无事.WTF</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000+10;\nlong long sum[maxn];\nint num;\nint r[maxn];\nint c,n;\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;c,&amp;n)&amp;&amp;c&amp;&amp;n){\n        memset(r,0,sizeof(r));\n        int k=0,l=1;\n        sum[0]=0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;num);\n            sum[i]=sum[i-1]+num;\n\n            int remainder=sum[i]%c;\n            if(remainder==0){\n                k=0;\n                l=i;\n            }else if(r[remainder]){\n                k=r[remainder];\n                l=i;\n            }else r[remainder]=i;\n        }\n        printf(&quot;%d&quot;,k+1);\n        for(int i=k+2;i&lt;=l;++i){\n            printf(&quot; %d&quot;,i);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【鸽巢原理】 题意: 给你两个整数c和n,以及n个整数,问这n个整数中是否有一些整数和为c的倍数. 同样可以证明,当c&lt;=n时,同样可以使用鸽巢原理证明有连续的序列和为c的倍数. 另外有一点是,Sigma ai最大可能100000^2.所以要用long long存. PS:","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"组合数学","slug":"POJ/组合数学","count":1,"path":"api/categories/POJ/组合数学.json"},{"name":"鸽巢原理","slug":"POJ/组合数学/鸽巢原理","count":1,"path":"api/categories/POJ/组合数学/鸽巢原理.json"}],"tags":[{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"鸽巢原理","slug":"鸽巢原理","count":1,"path":"api/tags/鸽巢原理.json"}]},{"title":"组合数学","slug":"combinatorics","date":"2018-01-25T13:04:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/combinatorics.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png","content":"<blockquote>\n<p>因为组合数学涉及面广,采取边学边更新.</p>\n<blockquote>\n<p>预计大部分会摘自《组合数学》</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"鸽巢定理\">【鸽巢定理】</span></h1><p>也叫作<code>狄利克雷抽屉原理</code>以及<code>鞋盒原理</code>. 对于鸽巢定理的简单阐释,粗略的说就是如果有许多鸽子飞进不够多的鸽巢内。那么至少要有一个鸽巢被两个或多个鸽子占据.</p>\n<h2><span id=\"简单形式\">简单形式</span></h2><p>很通俗的定理 : 如果要把n+1个物体放进n个盒子内,那么至少有一个盒子包含两个或更多的物体.</p>\n<h2><span id=\"简单应用\">简单应用</span></h2><blockquote>\n<ol>\n<li><p>在13个人中存在两个人,他们的生日在同一个月份里.</p>\n</li>\n<li><p>设有n对已婚夫妻,至少从这2n个人中选出n+1个人可以保证有一对夫妻.</p>\n</li>\n</ol>\n</blockquote>\n<h2><span id=\"应用3\">应用3</span></h2><h3><span id=\"这一条要拿出来因为比较重要\">这一条要拿出来,因为比较重要</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png\" alt></p>\n<h3><span id=\"证明\">证明</span></h3><p>考虑$$m$$个和: $$a_1,a_1+a_2,a_1+a_2+a_3,…,a_1+a_2+a_3+…+a_m$$ 如果这些和当中的任意一个可被$$m$$整除,那么结论就成立。因此,我们可以假设这些和中的每一个除以$$m$$都有一个非零余数,余数等于$$1,2,3,4,…,m-1$$中的一个数。因为有$$m$$个和,而只有$$m-1$$个余数,所以必然有两个序列的和除以$$m$$有相同的余数.因此,存在整数$$k,l,k \\&lt; l$$,使得$$a_1+a_2+…+a_k$$和$$a_1+a_2+…+a_l$$除以$$m$$有相同的余数$$r$$: $$a_1+a_2+…+a_k = bm+r,a_1+a_2+…+a_l = cm+r$$ 二式相减,我们发现$$ a_{k+1} $$+$$a_{k+2}+…+a_l = (c-b)m$$。 从而推断出,$$m$$个正整数的序列.一定存在一组序列的和为$$m$$的整数倍. <strong>上面的Latex公示如果没显示完全看下面的图片(PS:Latex公式好麻烦,而且支持也好麻烦):</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180125215217.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215217.png\" alt></a></p>\n<h3><span id=\"具体应用poj2356\">具体应用POJ2356</span></h3><p>题意:输入N个正整数,选择序列中的一些数字,使其和为$$N\\*k$$(k为正整数). 代码:</p>\n<pre><code>//问从N个数中选取多少个数,使得这些数的和%N==0\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=10000+10;\nint num[maxn],sum[maxn];\nint r[maxn];\nint main(){\n    int N,ans=0,k=0,l=1;\n    memset(r,-1,sizeof(r));\n    scanf(&quot;%d&quot;,&amp;N);\n    sum[0]=0;\n\n    for(int i=1;i&lt;=N;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n        sum[i]=sum[i-1]+num[i];\n\n        int remainder=sum[i]%N;\n        if(remainder==0){\n            ans=i;\n            k=0;\n            l=i;\n        }else if(r[remainder]!=-1){\n            ans=i-r[remainder];\n            k=r[remainder];\n            l=i;\n        }else r[remainder]=i;\n    }\n    printf(&quot;%d\\n&quot;,ans);\n    for(int i=k+1;i&lt;=l;++i){\n        printf(&quot;%d\\n&quot;,num[i]);\n    }\n    return 0;\n}</code></pre><h1><span id=\"基本计数方法\">基本计数方法</span></h1><h2><span id=\"加法原理\">加法原理</span></h2><blockquote>\n<p>做一件事情有n种方法,第i中方法有Pi种方案,则一共有P1+P2+P3+…+Pn种方法.</p>\n</blockquote>\n<h2><span id=\"乘法原理\">乘法原理</span></h2><blockquote>\n<p>做一件事情有n个步骤,第i个步骤有Pi种方案,则一共有P1P2P3…Pn中方案.</p>\n</blockquote>\n<h2><span id=\"容斥原理\">容斥原理</span></h2><blockquote>\n<p>最基本的公式:</p>\n<blockquote>\n<p>|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"常见问题\">常见问题</span></h3><h4><span id=\"错位排列\">错位排列</span></h4><blockquote>\n<p>待填充</p>\n</blockquote>\n<h1><span id=\"组合问题\">组合问题</span></h1><blockquote>\n<p>有n个不同的数,选出k个(顺序无关),每个数最多选一次,有多少种选法?</p>\n<blockquote>\n<p>记答案为C(n,k)。把n选k的排列问题看成两个步骤,首先选出k个数的组合,然后把这k个数进行全排列.由乘法原理知:</p>\n<blockquote>\n<p>P(n,k)=C(n,k)*P(k,k) 即<br>C(n,k)=n!/((n-k)!k!)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2><span id=\"性质1\">性质1</span></h2><blockquote>\n<p>C(n,0)=C(n,n)=1</p>\n</blockquote>\n<h2><span id=\"性质2\">性质2</span></h2><blockquote>\n<p>C(n,k)=C(n,n-k)</p>\n</blockquote>\n<h2><span id=\"性质3\">性质3</span></h2><blockquote>\n<p>C(n,k)+C(n,k+1)=C(n+1,k+1) 通常用于预处理C(n+1,…)</p>\n</blockquote>\n<h2><span id=\"性质4\">性质4</span></h2><blockquote>\n<p>C(n,k+1)=C(n,k)*(n-k)/(k+1) 使用这个公式可以在O(n)的时间内求出C(n) 但注意不要发生乘法溢出.及后面的除法溢出</p>\n</blockquote>\n<h3><span id=\"性质4通常运用-gt-二项式展开\">性质4通常运用 =&gt; 二项式展开</span></h3><blockquote>\n<p>问题:</p>\n<blockquote>\n<p>求(a+b)^n展开式的各项系数</p>\n<blockquote>\n<p>二项式定理 (a+b)^n=Sigma(k=0~n)C(n,k)a^(n-k)b^k</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2><span id=\"其余三个问题\">其余三个问题</span></h2><h2><span id=\"有重复元素的全排列\">有重复元素的全排列</span></h2><blockquote>\n<p>有重复元素的全排列</p>\n<blockquote>\n<p>有k个元素,其中第i个元素有Ni个,求全排列个数.</p>\n<blockquote>\n<p>直接看结论,可以简单证得 N1!*N2!*N3!<em>…\\</em>Nn!*ans=N! (移项即可)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2><span id=\"可重复选择的组合\">可重复选择的组合</span></h2><blockquote>\n<p>可重复选择的组合</p>\n<blockquote>\n<p>有n个不同的元素,每个元素可以选择多次,一共选k个元素,有多少种选法?</p>\n<blockquote>\n<p>例如n=3,k=2有6种</p>\n<blockquote>\n<p>(1,1)、(1,2)、(1,3)、(2,2)、(2,3)、(3,3)</p>\n</blockquote>\n</blockquote>\n<p>分析:</p>\n<blockquote>\n<p>设第i个元素选xi个,问题转化为求方程x1+x2+…+x3=k的非负整数解的个数. 令yi=xi+1,则答案为 y1+y2+y3+…+yn=k+n</p>\n</blockquote>\n</blockquote>\n<p>没太搞懂,直接放答案吧 C(k+n-1,n-1) =C(n+k-1,k)(性质2)</p>\n</blockquote>\n<h2><span id=\"单色三角形\">单色三角形</span></h2><blockquote>\n<p>给定空间内的n(n&lt;=1000)个点,其中没有三点共线,每两个点之间都用红色或黑色线段链接.求三条边同色的三角形个数.</p>\n<blockquote>\n<p>考虑非单色三角形. 如果第i个点连接了ai条红边和n-1-ai条黑边,则这些边属于ai(n-1-ai)个非单色三角形。每个非单色三角形被考虑了两次,所以最终答案除以2 即 1/2*Sigma(i=1~n) ai(n-1-ai) 用总三角形减去非单色即为单色三角形个数</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"生成函数\">生成函数</span></h1><blockquote>\n<p>母函数是用于解决组合问题计数的一种方法。 在了解它之前我们先看看熟悉的杨辉三角。</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170611212741764.jpg\" alt></p>\n<blockquote>\n<p>杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)^n的展开式从低项到高项的各项系数，也可以表示为组合数的形式C(i,n)。如果将两者联系起来我们会发现，(1+x)可以看成对于一件取舍，1=x^0就是不取，x就是取。这样在(1+x)^n的展开式中x^i项的系数就是从n件物品选取i件的方案数。</p>\n</blockquote>\n<h2><span id=\"定义\">定义</span></h2><blockquote>\n<p>给定数列a0,a1,a2…an，构造函数</p>\n<blockquote>\n<p>G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)</p>\n<blockquote>\n<p>其中G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)为标志函数。 母函数主要有两种形式：普通型母函数和指数型母函数。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3><span id=\"普通型母函数\">普通型母函数</span></h3><blockquote>\n<p>先看一个例题：HDU 1085</p>\n<blockquote>\n<p>普通型母函数的标志函数一般为x^0,x^1,x^2…x^n</p>\n</blockquote>\n<p>因为每个硬币有个数限制，但是也不难构造出</p>\n<blockquote>\n<p>G(x)=(1+x+x^2+x^3+…+x^num1)(1+x^2+x^4+…+x^(2∗num2))(1+x^5+x^10+…+x^(5∗num5)) 。</p>\n</blockquote>\n<p>将多项式展开后，x^i项对应的系数就是组成面值为i的方案数。 例题: 51nod 1383</p>\n</blockquote>\n<h3><span id=\"指数型母函数\">指数型母函数</span></h3><blockquote>\n<p>再看一个例题：HDU 1521</p>\n<blockquote>\n<p>指数型母函数的标志函数一般为x^0/0!,x^1/1!,x^2/2!…x^n/n!，对于x^i/i!表示在一个方案中某个元素出现了i次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！</p>\n</blockquote>\n<p>对于这道题就不难构造出母函数为</p>\n<blockquote>\n<p>G(x)=(1/0!+X/1!+X^2/2!+…+X^a1/a1!)(1/0!+X/1!+X^2/2!+…+X^a2/a2!)(1/0!+X/1!+X^2/2!+…+X^an/an!)</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"catalan数列\">Catalan数列</span></h1><h2><span id=\"介绍\">介绍</span></h2><h3><span id=\"待整理\">待整理</span></h3><blockquote>\n<p>Catalan数列可以解决很多问题.</p>\n<blockquote>\n<p>比如51nod 1120</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"catalan前几项\">Catalan前几项</span></h2><pre><code>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, 18367353072152, 69533550916004, 263747951750360, 1002242216651368, 3814986502092304, 14544636039226909, 55534064877048198, 212336130412243110, 812944042149730764, 3116285494907301262, 11959798385860453492, 45950804324621742364, ...</code></pre><h2><span id=\"应用\">应用</span></h2><h3><span id=\"一个小链接\">一个小链接</span></h3><p><a href=\"https://www.cnblogs.com/yaoyueduzhen/p/5456490.html\" title=\"Catalan应用及介绍\" target=\"_blank\" rel=\"noopener\">Catalan应用及介绍</a></p>\n<h3><span id=\"待整理\">待整理</span></h3><h2><span id=\"三种方法求catalan整合\">三种方法求Catalan整合</span></h2><h3><span id=\"注其中有牵扯lucaslucas在下面直接放代码注释在代码中有对各个类型进行耗时对比\">注:其中有牵扯Lucas,Lucas在下面,直接放代码,注释在代码中,有对各个类型进行耗时对比</span></h3><h3><span id=\"注2求逆元中牵扯到了费马求逆元和欧拉求逆元\">注2:求逆元中牵扯到了费马求逆元和欧拉求逆元</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int maxn=1000000+10;\nLL h[10100];\n\n//函数功能: 预处理前N向Catalan\n//函数参数: n为项数\n//适合N比较小的情况\nvoid Catalan(int n){\n    h[0] = h[1] = 1;        //h(0)和h(1)\n    for(int i = 2; i &lt;= n; i++)    //依次计算h(2),h(3)...h(n)\n    {\n        h[i] = 0;\n        for(int j = 0; j &lt; i; j++) //根据递归式计算 h(i)= h(0)*h(i-1)+h(1)*h(i-2) + ... + h(i-1)h(0)\n            h[i] = (h[i]+(h[j] * h[i-1-j])%mod)%mod;\n    }\n}\n\n///h(n)=C(2n,n)/(n+1) (n=0,1,2,...)\n///+逆元+Lucas组合数取模\n///预处理逆元的话,大小会被限制,直接求的话可能会有常数\n///但是N就可以大一点\n///返回第N个catalan数\nLL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}\n///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nLL N_L_Catalan(int N){\n    return Lucas(2*N,N,mod)*inv[N+1]%mod;\n}\n\n///第三种方法\n///h(n)=C(2n,n)-C(2n,n+1)\n///由上式子可以直接两个Lucas+同余定理解决\n///复杂度可能会比第二种方法换成直接求逆元要高点\nLL T_Catalan(int N){\n    return (Lucas(2*N,N,mod)-Lucas(2*N,N+1,mod)+mod)%mod;\n}\n\n\n///第四种方法\n///直接求逆元(扩展欧几里得求逆元)+Lucas\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inverse(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nLL F_Catalan(int N){\n    return Lucas(2*N,N,mod)*inverse(1ll*N+1,1ll*mod)%mod;\n}\n\n///第五种\n///欧拉定理求逆元+Lucas\n///mod是素数且与N互质\nlong long Pow(long long a,long long b){\n    long long ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%mod;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%mod;\n    }\n    return ans;\n}\n\nlong long euler(int p)\n{\n    long long ans=p,a=p;\n    long long i;\n    for(i=2;i*i&lt;=a;i++)\n    {\n        if(a%i==0)\n        {\n            ans=ans/i*(i-1);\n            while(a%i==0)\n                a/=i;\n        }\n    }\n    if(a&gt;1)\n        ans=ans/a*(a-1);\n    return ans;\n}\n\nlong long eu=euler(mod)-1;\n\nlong long Einv(long long a)\n{\n    return Pow(a,eu);\n}\n\nLL Fi_Catalan(int N){\n    return Lucas(2*N,N,mod)*Einv(1ll*(N+1))%mod;\n}\n\nint main(){\n    Catalan(10000);\n    init();//初始化逆元\n    int k;\n    while(cin&gt;&gt;k){\n        if(k&lt;=10000)\n            cout&lt;&lt;&quot;第一种方法(预处理): &quot;&lt;&lt;h[k]&lt;&lt;endl;\n        if(k&lt;=1000000)\n            cout&lt;&lt;&quot;第二种方法(h(n)=C(2n,n)/(n+1),预处理逆元+Lucas): &quot;&lt;&lt;N_L_Catalan(k)&lt;&lt;endl;\n        clock_t startTime,endTime;\n        startTime = clock();\n        cout&lt;&lt;&quot;第三种方法(h(n)=C(2n,n)-C(2n,n+1),Lucas): &quot;&lt;&lt;T_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第四种方法(h(n)=C(2n,n)/(n+1),Lucas+扩欧求逆元): &quot;&lt;&lt;F_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第五种方法(h(n)=C(2n,n)/(n+1),Lucas+欧拉定理求逆元): &quot;&lt;&lt;Fi_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n    }\n    return 0;\n}</code></pre><h1><span id=\"lucas\">Lucas</span></h1><h2><span id=\"介绍\">介绍</span></h2><blockquote>\n<p>Lucas定理用于对组合数求模</p>\n<blockquote>\n<p>因为组合数是一个大式子,无法直接求模,所以用到了Lucas</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"code\">Code</span></h2><pre><code>///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}</code></pre>","text":"因为组合数学涉及面广,采取边学边更新.预计大部分会摘自《组合数学》【鸽巢定理】也叫作狄利克雷抽屉原理以及鞋盒原理. 对于鸽巢定理的简单阐释,粗略的说就是如果有许多鸽子飞进不够多的鸽巢内。那么至少要有一个鸽巢被两个或多个鸽子占据.简单形式很通俗的定理 : 如果要把n+1个物体放进n","link":"","raw":null,"photos":[],"categories":[{"name":"组合数学","slug":"组合数学","count":1,"path":"api/categories/组合数学.json"}],"tags":[{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"}]}]}