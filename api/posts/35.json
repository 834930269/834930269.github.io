{"total":369,"pageSize":10,"pageCount":37,"data":[{"title":"UVa 514","slug":"uva-514","date":"2017-01-24T13:11:51.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-514.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构,栈,STL 【Tip】 印象中好像可以不模拟栈的操作,根据定义来判断？(雾 水题. 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>#include<cstring></cstring></em> <em>#include<stack></stack></em> <em>#define maxn 2000</em> <em>using namespace std;</em> <em>int N,target[maxn],B;</em> <em>bool locked;</em> <em>int main(){</em> _    while(scanf(“%d”,&amp;N),N){_ _        while(scanf(“%d”,&amp;target[0]),target[0]){_ _            stack<int> s;_ _            locked=false;_ _            B=target[0]+1;//B用来记录入栈后最大的那个元素,之后入栈以它为下限._ _            for(int i=1;i&lt;target[0];++i)_ _                s.push(i);_ _            for(int i=1;i&lt;N;++i){_ _                scanf(“%d”,&amp;target[i]);_ _                if(!s.empty() &amp;&amp; !locked){_ _                    if(s.top()==target[i]) s.pop();_ _                    else if(target[i]&lt;s.top()) locked=true;_ _                    else if(target[i]&gt;s.top() &amp;&amp; B){_ _                        for(int j=B;j&lt;target[i];++j)_ _                            s.push(j);_ _                        B=target[i]+1;_ _                    }_ _                }else if(!locked){_ _                    for(int j=B;j&lt;target[i];++j)_ _                            s.push(j);_ _                    B=target[i]+1;_ _                }_ _            }_ _            printf(“%s\\n”,locked?”No”:”Yes”);_ _        }_ _        printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></int></p>\n</blockquote>\n","text":"【类型】 数据结构,栈,STL 【Tip】 印象中好像可以不模拟栈的操作,根据定义来判断？(雾 水题. 【Code】#include #include #include #include #include #define maxn 2000 using namespace std","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 210","slug":"uva-210","date":"2017-01-24T06:09:29.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-210.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构&lt;双端队列&gt;,STL 【Tip】 deque容器的介绍.这里我看的是C++标准程序库P160.队头操作用 <strong>front();队尾</strong>back(); 【题意】 紫书P139 给定n个程序，每种程序有五种操作，分别为 var = constant(赋值)，print var (打印)， lock, unlock，end 变量用小写字母表示，初始化为0，为程序所公有（一个程序里对某个变量修改可以会影响其他程序里的这个变量）， 常数小于100（也就是说最多两位数）。 每个时刻都只能有一个程序处于运行状态，其他的都在等待，上述五种操作用时分别是t1, t2, t3, t4, t5。运行中的程序， 每次最多能运行q个时间，当q个时间被用完后，它会被放在等待队列的尾部，然后再从首部取出一个程序运行，初始等待队列按输入顺序， 但是lock和unlock会改变顺序，它们总是成对出现，不会出现嵌套。如果某个程序已经执行了lock，后面还有程序执行lock， 那么这个程序就会马上被放到一个阻止队列的尾部（当然如果运行时间还没用完也就浪费了）。当unlock结束后，阻止队列中的第一个程序进入等待队列的首部。 (敲一遍就知道什么意思了.) 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<queue></queue></em> <em>#include<cstring></cstring></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>const int maxn=1000;</em> <em>deque<int> readyQ;</int></em> <em>queue<int> blockQ;</int></em> <em>int n,quantum,c[5],var[26],ip[maxn];//ip为指令的位置</em> <em>bool locked;</em> <em>char prog[maxn][10];//指令</em> <em>void run(int pid){</em> _    int q=quantum;_ _    while(q&gt;0){_ _        char* p=prog[ip[pid]];_ _        switch(p[2]){_ _            case ‘=’://var=constant_ _                var[p[0]-‘a’]=isdigit(p[5])?(p[4]-‘0’)*10+p[5]-‘0’ : p[4]-‘0’;_ _                q-=c[0];_ _                break;_ _            case ‘i’://print_ _                printf(“%d: %d\\n”,pid+1,var[p[6]-‘a’]);_ _                q-=c[1];_ _                break;_ _            case ‘c’://lock_ _                if(locked) { blockQ.push(pid); return; }_ _                locked=true;_ _                q-=c[2];_ _                break;_ _            case ‘l’://unlock_ _                locked=false;_ _                if(!blockQ.empty()){_ _                    int pid2=blockQ.front(); blockQ.pop();_ _                    readyQ.push_front(pid2);_ _                }_ _                q-=c[3];_ _                break;_ _            case ‘d’://end_ _                return;_ _        }_ _        ip[pid]++;_ _    }_ _    readyQ.push_back(pid);_ <em>}</em> <em>int main(){</em> _    int T;_ _    scanf(“%d”,&amp;T);_ _    while(T–){_ _            scanf(“%d %d %d %d %d %d %d\\n”,&amp;n,&amp;c[0],&amp;c[1],&amp;c[2],&amp;c[3],&amp;c[4],&amp;quantum);_ _            memset(var, 0, sizeof(var));_ _            int line=0;_ _            for(int i=0;i&lt;n;++i){_ _                fgets(prog[line++],maxn,stdin);_ _                ip[i]=line-1;_ _                while(prog[line-1][2]!=’d’)_ _                    fgets(prog[line++],maxn,stdin);_ _                readyQ.push_back(i);_ _            }_ _            locked=false;_ _            while(!readyQ.empty()){_ _                int pid=readyQ.front(); readyQ.pop_front();_ _                run(pid);_ _            }_ _          if(T) printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>Save</p>\n","text":"【类型】 数据结构&lt;双端队列&gt;,STL 【Tip】 deque容器的介绍.这里我看的是C++标准程序库P160.队头操作用 front();队尾back(); 【题意】 紫书P139 给定n个程序，每种程序有五种操作，分别为 var = constant(赋值)，pr","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 12230","slug":"uva-12230","date":"2017-01-21T13:53:33.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-12230.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数学期望 【Tip】 每个船的位置都是均匀随机分布,数学期望=∑(i=1,n)每个概率*每个概率的权. 这道题里,用数学期望的线性.过每条河的时间为L/v到3L/v(船过来了,才可以上?)的均匀分布.因此期望过河时间为2L/v.把所有的2L/v加起来,再加上在陆地上行走的时间D-sum(L)即为所求期望. 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>int n,D,ca=1;</em> <em>double p,L,v;</em> <em>int main(){</em> _    while(~scanf(“%d%d”,&amp;n,&amp;D),n+D){_ _        double time=0;_ _        for(int i=0;i&lt;n;++i){_ _            cin&gt;&gt;p&gt;&gt;L&gt;&gt;v;_ _            if(p!=D){_ _                time+=2.0*L/v;_ _                D-=L;_ _            }_ _        }_ _        time+=D;_ _        printf(“Case %d: %.3lf\\n”,ca++,time);_ _        printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n","text":"【类型】 数学期望 【Tip】 每个船的位置都是均匀随机分布,数学期望=∑(i=1,n)每个概率*每个概率的权. 这道题里,用数学期望的线性.过每条河的时间为L/v到3L/v(船过来了,才可以上?)的均匀分布.因此期望过河时间为2L/v.把所有的2L/v加起来,再加上在陆地上行走","link":"","raw":null,"photos":[],"categories":[{"name":"数学期望","slug":"数学期望","count":1,"path":"api/categories/数学期望.json"}],"tags":[{"name":"数学期望","slug":"数学期望","count":1,"path":"api/tags/数学期望.json"}]},{"title":"POJ 1321 && 2251","slug":"poj-1321-2251","date":"2017-01-21T13:39:02.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-1321-2251.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 dfs,bfs,搜索基础 【来源】 <a href=\"https://vjudge.net/contest/148331#overview\" target=\"_blank\" rel=\"noopener\">[kuangbin带你飞]专题一 简单搜索 [Cloned]</a> 【Tip】 摘自网上一个blog,一般求最大或者总的xx(方案,步数…)的时候,一般用bfs,如果用dfs的话,你要写很多if来判断. 【Code】 1321</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>#include<cstring></cstring></em> <em>using namespace std;</em> <em>int chess[15][15];</em> <em>int vichess[15]={0};</em> <em>int n,k,cnt,num=0;</em> <em>char elem;</em> <em>void dfs(int i){</em> _    if(num==k){_ _        cnt++;_ _        return;_ _    }_ _    for(int t=i;t&lt;=n;++t)_ _        for(int j=1;j&lt;=n;++j)_ _            if(chess[t][j] &amp;&amp; !vichess[j]){_ _                vichess[j]=1;_ _                num++;_ _                dfs(t+1);_ _                vichess[j]=0;_ _                num–;_ _            }_ <em>}</em> <em>int main(){</em> _    while(~scanf(“%d %d”,&amp;n,&amp;k) &amp;&amp; n!=-1 &amp;&amp; k!=-1){_ _         memset(chess,0,sizeof(chess));_ _         cnt=0;_ _         for(int i=1;i&lt;=n;++i){_ _            for(int j=1;j&lt;=n;++j){_ _                cin&gt;&gt;elem;_ _                if(elem==’#’)_ _                    chess[i][j]=1;_ _            }_ _         }_ _        dfs(1);_ _        printf(“%d\\n”,cnt);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>2251</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<queue></queue></em> <em>#include<cstdio></cstdio></em> <em>#include<cstring></cstring></em> <em>#define maxn 40</em> <em>using namespace std;</em> <em>struct Node{</em> _    int x,y,z,t;_ _    Node(int i,int j,int m,int n):x(i),y(j),z(m),t(n){}//构造_ _    Node(){}_ <em>}pre;</em> <em>char ma[maxn][maxn][maxn];</em> <em>int vi[maxn][maxn][maxn];</em> <em>int L,R,C,sx,sy,sz,ex,ey,ez;</em> <em>int toward[6][3]={1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1};//六种走向</em> <em>bool judge(int xx,int yy,int zz){</em> _    if(xx&lt;=0 || xx&gt;L || yy&lt;=0 || yy&gt;R || zz&lt;=0 || zz&gt;C)_ _        return false;_ _    return true;_ <em>}</em> <em>void bfs(){</em> _    memset(vi,0,sizeof(vi));_ _    queue<node> que;_ _    que.push(Node(sx,sy,sz,0));_ _    vi[sx][sy][sz]=1;_ _    while(!que.empty()){_ _        pre=que.front(); que.pop();_ _        if(pre.x==ex &amp;&amp; pre.y==ey &amp;&amp; pre.z==ez){_ _            printf(“Escaped in %d minute(s).\\n”,pre.t);_ _            return;_ _        }_ _        for(int i=0;i&lt;6;++i){_ _            int xx=pre.x+toward[i][0];_ _            int yy=pre.y+toward[i][1];_ _            int zz=pre.z+toward[i][2];_ _            if(judge(xx,yy,zz) &amp;&amp; !vi[xx][yy][zz] &amp;&amp; ma[xx][yy][zz]!=’#’){_ _                vi[xx][yy][zz]=1;_ _                que.push(Node(xx,yy,zz,pre.t+1));_ _            }_ _        }_ _    }_ _    printf(“Trapped!\\n”);_ <em>}</em> <em>int main(){</em> _    while(~scanf(“%d%d%d”,&amp;L,&amp;R,&amp;C),L+R+C){_ _        for(int i=1;i&lt;=L;++i)_ _            for(int j=1;j&lt;=R;++j)_ _                scanf(“%s”,ma[i][j]+1);_ _        for(int i=1;i&lt;=L;++i)_ _            for(int j=1;j&lt;=R;++j)_ _                for(int z=1;z&lt;=C;++z)_ _                    if(ma[i][j][z]==’S’)_ _                        sx=i,sy=j,sz=z;_ _                    else if(ma[i][j][z]==’E’)_ _                        ex=i,ey=j,ez=z;_ _         bfs();_ _    }_ _    return 0;_ <em>}</em></node></p>\n</blockquote>\n","text":"【类型】 dfs,bfs,搜索基础 【来源】 [kuangbin带你飞]专题一 简单搜索 [Cloned] 【Tip】 摘自网上一个blog,一般求最大或者总的xx(方案,步数…)的时候,一般用bfs,如果用dfs的话,你要写很多if来判断. 【Code】 1321#includ","link":"","raw":null,"photos":[],"categories":[{"name":"搜索","slug":"搜索","count":2,"path":"api/categories/搜索.json"}],"tags":[{"name":"搜索","slug":"搜索","count":2,"path":"api/tags/搜索.json"}]},{"title":"UVa 11181 + UVa 10491","slug":"uva-11181-uva-10491","date":"2017-01-15T15:14:56.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-11181-uva-10491.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 第一题:dfs 全概率 回溯 第二题:全概率 【Tip】 条件概率: P(A|B)=P(AB)|P(B).  P(A|B)指.在事件B的前提下,发生A的概率. P(AB)指两个时间A和B同时发生的概率.P(AB)=P(A)P(B). 全概率: P(A)=P(A|B1)_P(B1)+P(A|B2)_P(B2)+…+P(A|Bn)*P(Bn). 【Code】 11181:</p>\n<blockquote>\n<p><em>#include &lt;stdio.h&gt;</em> <em>#include &lt;string.h&gt;</em> <em>const int N = 30;</em> <em>int n;</em> <em>double p[N], ans[N];</em> <em>double dfs(int c, int k, double pi) {</em> _    if (c &gt; n) return k ? 0 : pi;_ _    double sum = 0;_ _       if (k) {_ _        sum += dfs(c + 1, k - 1, pi * p[c]);//选择_ _        ans[c] += sum;_ _    }_ _    sum += dfs(c + 1, k, pi * (1 - p[c])); //回溯_ _    return sum;_ <em>}</em> <em>int main () {</em> _    int r, cas = 1;_ _    while (scanf(“%d%d”, &amp;n, &amp;r), n + r) {_ _        for (int i = 1; i &lt;= n; i++)_ _            scanf(“%lf”, &amp;p[i]);_ _        memset(ans, 0, sizeof(ans));_ _        printf(“Case %d:\\n”, cas++);_ _        double P = dfs(1, r, 1);_ _        for (int i = 1; i &lt;= n; i++)_ _            printf(“%.6lf\\n”, ans[i] / P);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>10491：</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>int main(){</em> _    int a,b,c;_ _    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c){_ _        printf(“%.5lf\\n”,1.0<em>(a*b+b\\</em>(b-1))/((a+b-c-1)*(a+b)));_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n","text":"【类型】 第一题:dfs 全概率 回溯 第二题:全概率 【Tip】 条件概率: P(A|B)=P(AB)|P(B).  P(A|B)指.在事件B的前提下,发生A的概率. P(AB)指两个时间A和B同时发生的概率.P(AB)=P(A)P(B). 全概率: P(A)=P(A|B1)_","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"玲珑杯 R8 E","slug":"llb-r8-e","date":"2017-01-14T16:11:16.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/llb-r8-e.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Code】 签到题.</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;</cstring></p>\n<p>typedef long long LL;<br>LL sum[100010];<br>LL a[100010];<br>LL maxn[10000];<br>LL b[100010];<br>LL n,q,ca=1;</p>\n<p>void solve(){<br>    char str;<br>    getchar();<br>    for(int i=1;i&lt;=n;++i){<br>        str=’\\0’;<br>        LL res;<br>        while(str!=’ ‘ &amp;&amp; str!=’\\n’){<br>            scanf(“%c”,&amp;str);<br>            if((str==’ ‘ || str==’\\n’) &amp;&amp; !a[i]){ str=’\\0’;continue;}<br>            if((str==’ ‘ || str==’\\n’) &amp;&amp; a[i])break;<br>            sum[i]+=(str-‘0’);<br>            res=a[i]*10+str-‘0’;<br>            a[i]=res;<br>        }<br>        if(maxn[sum[i]]){<br>            b[i]=maxn[sum[i]];<br>            if(maxn[sum[i]]&lt;a[i])<br>                maxn[sum[i]]=a[i];<br>        }else{<br>            maxn[sum[i]]=a[i];<br>        }<br>    }<br>    while(q–){<br>        LL j;<br>        scanf(“%lld”,&amp;j);<br>        if(b[j]&gt;0 &amp;&amp; j&gt;0 &amp;&amp; j&lt;=n)<br>            printf(“%lld\\n”,b[j]);<br>        else<br>            printf(“-1\\n”);<br>    }<br>}</p>\n<p>int main(){<br>    LL T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        memset(maxn,0,sizeof(maxn));<br>        memset(b,0,sizeof(maxn));<br>        memset(a,0,sizeof(maxn));<br>        memset(sum,0,sizeof(maxn));<br>        printf(“Case #%d:\\n”,ca++);<br>        scanf(“%lld %lld”,&amp;n,&amp;q);<br>        solve();<br>    }<br>    return 0;<br>}</p>\n","text":"【Code】 签到题.#include#include#include#include<br>using namespace std;typedef long long LL;<br>LL sum[100010];<br>LL a[100010];<br>LL maxn[1000","link":"","raw":null,"photos":[],"categories":[{"name":"玲珑杯","slug":"玲珑杯","count":2,"path":"api/categories/玲珑杯.json"}],"tags":[{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"UVa 1636","slug":"uva-1636","date":"2017-01-14T16:07:54.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-1636.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 概率论 【思路】 水题一发. 紫书 P326.</p>\n<blockquote>\n<p>第一个</p>\n<blockquote>\n<p>A: 第二枪无子弹 B: 第一枪无子弹 第二种情况是随机转到0的概率是多大</p>\n<blockquote>\n<p>即 0的个数/n</p>\n</blockquote>\n<p>P(A|B)=P(AB) / P(B) = 00个数/0个数</p>\n</blockquote>\n</blockquote>\n<p>【Code】</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    char str[200];\n    while(scanf(&quot;%s&quot;,str)!=EOF){\n        int a=0,b=0;\n        int len=strlen(str);\n        for(int i=0;i&lt;len;++i){\n            if(str[i]==&apos;0&apos;){\n                b++;\n                if(str[(i+1)%len]==&apos;0&apos;) a++;\n            }\n        }\n        if(a*len==b*b) printf(&quot;EQUAL\\n&quot;);\n        if(a*len&gt;b*b) printf(&quot;SHOOT\\n&quot;);\n        if(a*len&lt;b*b) printf(&quot;ROTATE\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【类型】 概率论 【思路】 水题一发. 紫书 P326.第一个A: 第二枪无子弹 B: 第一枪无子弹 第二种情况是随机转到0的概率是多大即 0的个数/nP(A|B)=P(AB) / P(B) = 00个数/0个数【Code】#include&lt;iostream&gt;#inc","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"},{"name":"算法学习","slug":"UVa/概率论/算法学习","count":1,"path":"api/categories/UVa/概率论/算法学习.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"POJ 1061","slug":"poj-1061","date":"2017-01-13T15:53:30.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-1061.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 扩展欧几里得 【思路】 根据题意得方程:设跳t次遇见 (1) (x+mt)-(y+nt)=kL(因为一定是整数解(因为是整数解,所以符合扩欧)) (2)移项得:(n-m)t+kL=x-y &lt;=&gt; at+bL=z (3)扩欧定理中:a,b互质,只有整数解. (4)尝试z mod gcd(a,b)是否为0,如果为0则有解,不为0,则无解. (5)最后解得的t可能存在t&lt;0. (6)最后留下的一个疑问.为什么要 mod L/gcd(a,b)? 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;</algorithm></p>\n<p>typedef long long LL;</p>\n<p>LL gcd(LL a,LL b){<br>    if(b==0)return a;<br>    else return gcd(b,a%b);<br>}</p>\n<p>void exgcd(LL a,LL b,LL &amp;x,LL &amp;y){<br>    if(!b) x=1,y=0;<br>    else {exgcd(b,a%b,y,x); y-=x<em>(a/b);}<br>}<br>int main(){<br>    long long x,y,m,n,L,d,K,t,a,z,b;<br>    cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;L;<br>    if(m==n){<br>        cout&lt;&lt;”Impossible\\n”;<br>        return 0;<br>    }<br>    a=n-m;<br>    z=x-y;<br>    b=L;<br>    d=gcd(a,b);<br>    if((x-y)%d){<br>        cout&lt;&lt;”Impossible\\n”;<br>        return 0;<br>    }<br>    a/=d;<br>    b/=d;<br>    z/=d;<br>    exgcd(a,b,t,K);<br>    K</em>=z;//z=(x-y)/gcd(a,b)-&gt;即扩大倍数k,这句等价于KL<br>    t*=z;//狮子等比扩大z倍;<br>    t=(t%b+b)%b;<br>    cout&lt;&lt;t&lt;&lt;”\\n”;<br>    return 0;<br>}</p>\n","text":"【类型】 扩展欧几里得 【思路】 根据题意得方程:设跳t次遇见 (1) (x+mt)-(y+nt)=kL(因为一定是整数解(因为是整数解,所以符合扩欧)) (2)移项得:(n-m)t+kL=x-y &lt;=&gt; at+bL=z (3)扩欧定理中:a,b互质,只有整数解. (","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"扩展欧几里得","slug":"UVa/扩展欧几里得","count":1,"path":"api/categories/UVa/扩展欧几里得.json"},{"name":"数论","slug":"UVa/扩展欧几里得/数论","count":1,"path":"api/categories/UVa/扩展欧几里得/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1262","slug":"uva-1262","date":"2017-01-13T15:45:11.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1262.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 组合数学 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-1262\" target=\"_blank\" rel=\"noopener\">UVa-1262-Password</a> 【思路】 见紫书P323例10-8 【WA Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;</cstring></p>\n<p>char m[8][8];<br>char a[8][8];<br>int reg[8][8]={0},n;</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=reg[i][0];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=reg[i][0];<br>        j=n/tot;<br>        printf(“%c”,reg[i][j+1]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        memset(reg,0,sizeof(reg));<br>        int flag=1;<br>        cin&gt;&gt;n;<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>for(int i=1;i&lt;=6;++i)\n        scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\nfor(int j=1;j&lt;=5;++j)\n    for(int t=1;t&lt;=6;++t)\n        for(int i=1;i&lt;=6;++i)\n            if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\]){\n                reg\\[j\\]\\[++reg\\[j\\]\\[0\\]\\]=a\\[t\\]\\[j\\];\n                break;\n            }\n\nfor(int t=1;t&lt;=5;++t){\n    if(reg\\[t\\]\\[0\\]==0) flag=0;\n    sort(&amp;reg\\[t\\]\\[1\\],&amp;reg\\[t\\]\\[reg\\[t\\]\\[0\\]+1\\]);\n}</code></pre><p> /*<br>        for(int t=1;t&lt;=5;++t){<br>            for(int q=1;q&lt;=reg[t][0];++q)<br>                printf(“%c “,reg[t][q]);<br>            printf(“\\n”);<br>        }<br>        */</p>\n<pre><code>    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n<p>【AC Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>char m[10][10];<br>char a[10][10];<br>int n,k[10];<br>vector<char> v[10];</char></p>\n<p>bool init(){</p>\n<p>}</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=k[i];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=k[i];<br>        j=n/tot;<br>        printf(“%c”,v[i][j]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    scanf(“%d”,&amp;N);<br>    while(N–){<br>        for(int i=1;i&lt;=5;++i) v[i].clear();<br>        int flag=1;<br>        scanf(“%d”,&amp;n);<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>    for(int i=1;i&lt;=6;++i)\n            scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\n    for(int j=1;j&lt;=5;++j)\n        for(int t=1;t&lt;=6;++t)\n            for(int i=1;i&lt;=6;++i)\n                if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\])\n                    v\\[j\\].push_back(a\\[t\\]\\[j\\]);\n\n    for(int i=1;i&lt;=5;++i){\n        if(v\\[i\\].empty()){\n            flag=0;\n            break;\n        }\n        sort(v\\[i\\].begin(),v\\[i\\].end());\n        unique(v\\[i\\].begin(),v\\[i\\].end());\n        k\\[i\\]=0;\n        while(k\\[i\\]&lt;v\\[i\\].size()-1 &amp;&amp; v\\[i\\]\\[k\\[i\\]+1\\]&gt;v\\[i\\]\\[k\\[i\\]\\]) k\\[i\\]++;\n        k\\[i\\]++;\n    }\n\n    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n","text":"【类型】 组合数学 【题目来源】 UVa-1262-Password 【思路】 见紫书P323例10-8 【WA Code】#include#include#include#include<br>using namespace std;char m[8][8];<br>char ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10820","slug":"uva-10820","date":"2017-01-11T15:47:56.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10820.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 欧拉函数值,素数筛法,打表 【题目来源】 算法竞赛入门 P322 例题10-7 <a href=\"https://vjudge.net/problem/UVA-10820\" target=\"_blank\" rel=\"noopener\">UVa-10820-Send a Table</a> 【思路】 运用素数筛法的思想对1~50000内的数打表得到每个数的欧拉phi函数值. 然后处理表,使得从3开始往后每个phi[i]都等于前面的phi[i]的和加上phi[i]. 题目说可以通过f(x,y)计算f(x_k,y_k)即其意思就是要求的表内x,y必须互素. 其答案是2*f(n)+1,特判n=1. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cmath><br>using namespace std;<br>int phi[50010]={0};</cmath></p>\n<p>void init(){<br>    int n=50003;<br>    for(int i=2;i&lt;=n;++i) phi[i]=0;<br>    phi[1]=1;<br>    for(int i=2;i&lt;=n;++i)<br>        if(!phi[i])<br>            for(int j=i;j&lt;=n;j+=i){<br>                if(!phi[j])<br>                    phi[j]=j;<br>                phi[j]=phi[j]/i*(i-1);<br>            }<br>    for(int i=3;i&lt;=n;++i)<br>        phi[i]+=phi[i-1];<br>}</p>\n<p>int main(){<br>    init();<br>    int M;<br>    while(scanf(“%d”,&amp;M),M){<br>        M==1?printf(“1\\n”):printf(“%d\\n”,2*phi[M]+1);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 欧拉函数值,素数筛法,打表 【题目来源】 算法竞赛入门 P322 例题10-7 UVa-10820-Send a Table 【思路】 运用素数筛法的思想对1~50000内的数打表得到每个数的欧拉phi函数值. 然后处理表,使得从3开始往后每个phi[i]都等于前面的p","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"欧拉函数","slug":"UVa/数论/欧拉函数","count":1,"path":"api/categories/UVa/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}