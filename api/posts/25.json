{"total":370,"pageSize":10,"pageCount":37,"data":[{"title":"python3学习 多态和继承","slug":"python3-inheritance-and-polymorphisn","date":"2017-07-15T16:44:40.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/python3-inheritance-and-polymorphisn.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Inheritance_and_polymorphisn.py\" target=\"_blank\" rel=\"noopener\">Inheritance_and_polymorphisn.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[5]:</p>\n<p>‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称为子类（Subclass），而被继<br>承的class称为基类、父类或超类（Base class、Super class）。<br>‘’’</p>\n<p>#比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：<br>class Animal(object):<br>    def run(self):<br>        print(‘Animal is running…’)</p>\n<p>#当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：<br>class Dog(Animal):<br>    pass<br>class Cat(Animal):<br>    pass<br>‘’’<br>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是<br>它的子类。Cat和Dog类似。</p>\n<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由<br>于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什<br>么事也没干，就自动拥有了run()方法：<br>‘’’<br>dog=Dog()<br>dog.run()<br>cat=Cat()<br>cat.run()</p>\n<p>#当子类和父类都存在相同的run()方法时，我们说，</p>\n<p>#子类的run()覆盖了父类的run()，在代码运行的时候，</p>\n<p>#总是会调用子类的run()。这样，我们就获得了继承的</p>\n<p>#另一个好处：多态。<br>class Puppy(Animal):<br>    def run(self):<br>        print(‘Puppy is running…’)<br>class Shark(Animal):<br>    def run(self):<br>        print(‘Shark is running…’)<br>puppy=Puppy()<br>puppy.run()</p>\n<p># In[7]:</p>\n<p>#判断一个变量是否是某个类型可以用isinstance()判断：</p>\n<p>#可以发现,puppy可以使Animal也可以是Puppy.<br>print(isinstance(puppy,Animal))<br>print(isinstance(puppy,Puppy))<br>b=Animal()<br>print(isinstance(b,Puppy))</p>\n<p>#所以，在继承关系中，如果一个实例的数据类型是某个子类</p>\n<p>#，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p>\n<p># In[12]:</p>\n<p>#要理解多态的好处，我们还需要再编写一个函数，这个函数接受</p>\n<p>#一个Animal类型的变量：<br>def run_twice(animal):<br>    animal.run()<br>    animal.run()<br>run_twice(Dog())<br>run_twice(Puppy())<br>run_twice(Shark())</p>\n<p># In[ ]:</p>\n<p>‘’’<br>多态的好处在于:</p>\n<p>新增一个Animal的子类，不必对  –run_twice()–<br>做任何修改，实际上，任何依赖Animal作为参数的函<br>数或者方法都可以不加修改地正常运行，原因就在于<br>多态。</p>\n<p>著名的“开闭”原则：</p>\n<p>对扩展开放：允许新增Animal子类；</p>\n<p>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则<br>传入的对象必须是Animal类型或者它的子类，否则，将无法调用<br>run()方法。</p>\n<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。<br>我们只需要保证传入的对象有一个run()方法就可以了：</p>\n<p>class Timer(object):<br>    def run(self):<br>        print(‘Start…’)</p>\n<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一<br>个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看<br>做是鸭子。<br>‘’’**</p>\n","text":"【Source Code】 github: Inheritance_and_polymorphisn.py **# coding: utf-8# In[5]:‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 Class私有成员访问限制","slug":"python3-class-vt","date":"2017-07-15T16:20:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-class-vt.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Visit_limit.py\" target=\"_blank\" rel=\"noopener\">Visit_limit.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[3]:</p>\n<p>‘’’<br>如果要让内部属性不被外部访问，可以把属性的名称前加上<br>两个下划线<strong>，在Python中，实例的变量名如果以</strong>开头，<br>就变成了一个私有变量（private），只有内部可以访问，外<br>部不能访问，<br>‘’’<br>class student(object):<br>    def __init__(self,name,score):<br>        self.<strong>name=name<br>        self.</strong>score=score<br>    def print_score(self):<br>        print(‘%s: %s’ %(self.__name,self.__score))<br>‘’’<br>改完后，对于外部代码来说，没什么变动，但是已经无法从外部<br>访问实例变量.__name和实例变量.__score了:只能通过类内的方法<br>才可以调用这些私有变量<br>‘’’<br>bart = student(‘Bart Simpson’, 98)<br>bart.print_score()<br>print(bart.__name)</p>\n<p># In[4]:</p>\n<p>‘’’<br>如果外部想要获取name和score怎么办,<br>给student类添加get_name和get_score<br>外部想要修改怎么办,set_score</p>\n<p>需要注意的是，在Python中，变量名类似__xxx__的，<br>也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，<br>特殊变量是可以直接访问的，不是private变量，所以，不能用<br>__name__、__score__这样的变量名。</p>\n<p>有些时候，你会看到以一个下划线开头的实例变量名，比如_name<br>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，<br>当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，<br>请把我视为私有变量，不要随意访问”。</p>\n<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。<br>不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，<br>所以，仍然可以通过_Student__name来访问__name变量：<br>‘’’<br>print(bart._student__name)#好神奇</p>\n<p>#但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。</p>\n<p># In[5]:</p>\n<p>#所以如果外界对实例化对象设置私有变量的值,因为上面说了</p>\n<p>#私有变量会被改名为 _student__name这样,所以如果使用</p>\n<p>#bart.__name=’New Name’,则表示在该对象内新建一个变量</p>\n<p>#不影响本来的<strong>name<br>bart.</strong>name=’New name’<br>bart.print_score()</p>\n<p>#out[]: Bart Simpson: 98</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: Visit_limit.py **# coding: utf-8# In[3]:‘’’<br>如果要让内部属性不被外部访问，可以把属性的名称前加上<br>两个下划线，在Python中，实例的变量名如果以开头，<br>就变成了一个私有变量","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"玲珑杯 Round#18 C","slug":"round18-c","date":"2017-07-15T10:45:01.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/round18-c.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1146\" target=\"_blank\" rel=\"noopener\">1146 - 图论你先敲完模板</a></strong> <strong>【题解】</strong> <strong>首先我们可以想到一个简单的dp方程</strong> <strong>dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a</strong> <strong>1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算.</strong> <strong>所以我们可以从i-1往回(1)递推,如果某一点距离差大于30.则直接退出循环即可.</strong> <strong>最终结果为dp[n].且结果需要用long long存.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20C.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 C.cpp</a></strong></p>\n<hr>\n<p> **#include&lt;bits/stdc++.h&gt;</p>\n<p>#define fill(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f</p>\n<p>#pragma comment(linker, “/STACK:102400000,102400000”)<br>using namespace std;<br>const int maxn=100000+10;<br>int n;<br>long long dp[maxn],a,dt[100000+10];<br>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%lld”,&amp;n,&amp;a);<br>        for(int i=1;i&lt;=n;++i){<br>            dp[i]=1000000000000000000;<br>            scanf(“%lld”,&amp;dt[i]);<br>            for(int j=i-1;j&gt;=1;–j){<br>                long long t;<br>                if(dt[i]-dt[j]&gt;30)break;<br>                if(dp[j]!=1000000000000000000) t=dp[j];<br>                else t=0;<br>                dp[i]=min(dp[i],t+(1&lt;&lt;(dt[i]-dt[j]))+a);<br>            }<br>        }<br>        printf(“%lld\\n”,dp[n]);<br>    }<br>    return 0;<br>}**</p>\n","text":"【Topic Link】 1146 - 图论你先敲完模板 【题解】 首先我们可以想到一个简单的dp方程 dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a 1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算. 所","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"玲珑杯 Round#18 A","slug":"llb-round18-a","date":"2017-07-15T10:23:43.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/llb-round18-a.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1143\" target=\"_blank\" rel=\"noopener\">1143 - 计算几何你瞎暴力</a></strong> <strong>【题解】</strong> <strong>用vis统计每个点上有多少教室.可以发现,最大的距离是30.</strong> <strong>然后枚举所有的点求出两点之间的距离以及所有的组合总数.</strong> <strong>1.如果两点是同一个点.先判断该点是否存在房子.如果存在,就用等差数列求和公式: N-1+N-2+…+1=(1+N-1)*(N-1)/2  计算出组合种数记录在d[0].</strong> <strong>2.如果两点不同一点,判断两点教室数都不为0,然后计算组合种数: S*S2 计算组合种数记录在d[dist(S,S2)].</strong> <strong>3.由于计算的时候每个点都在点一和点二计算过一次.所以最终统计的时候之前统计得值需要除以二.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20A.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 A.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;</p>\n<p>#define cle(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f<br>using namespace std;</p>\n<p>const int maxn=50000+10;<br>int T,n,q,d[1420];<br>char str[200];<br>long long vis[20][20][20];<br>bool vi[1420];</p>\n<p>int main(){<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        cle(d),cle(vis),cle(vi);<br>        scanf(“%d%d”,&amp;n,&amp;q);<br>        for(int i=0;i&lt;n;++i){<br>            int x,y,z;<br>            scanf(“%d%d%d”,&amp;x,&amp;y,&amp;z);<br>            vis[x][y][z]++;<br>        }<br>        for(int i=0;i&lt;=10;i++)<br>        {<br>            for(int j=0;j&lt;=10;j++)<br>            {<br>                for(int k=0;k&lt;=10;k++)<br>                {<br>                    for(int x=0;x&lt;=10;x++)<br>                    {<br>                        for(int y=0;y&lt;=10;y++)<br>                        {<br>                            for(int z=0;z&lt;=10;z++) {<br>                                int dis=abs(i-x)+abs(j-y)+abs(k-z);<br>                                if(i==x&amp;&amp;j==y&amp;&amp;k==z) {<br>                                    if(vis[i][j][k]-1&gt;=0){<br>                                        d[dis]+=(vis[i][j][k])<em>(vis[i][j][k]-1)/2;<br>                                        vi[dis]=true;<br>                                    }<br>                                }<br>                                else if(vis[i][j][k]</em>vis[x][y][z]&gt;0)<br>                                {<br>                                    d[dis]+=vis[i][j][k]<em>vis[x][y][z];<br>                                    vi[dis]=true;<br>                                }<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        for(int i=1;i&lt;=30;++i)d[i]=d[i-1]+d[i]/2;<br>        for(int i=0;i&lt;q;++i){<br>            int R;<br>            scanf(“%d”,&amp;R);<br>            R=min(30,R);<br>            printf(“%lld\\n”,d[R]);<br>        }<br>    }<br>    return 0;<br>}*</em></p>\n","text":"【Topic Link】 1143 - 计算几何你瞎暴力 【题解】 用vis统计每个点上有多少教室.可以发现,最大的距离是30. 然后枚举所有的点求出两点之间的距离以及所有的组合总数. 1.如果两点是同一个点.先判断该点是否存在房子.如果存在,就用等差数列求和公式: N-1+N-","link":"","raw":null,"photos":[],"categories":[{"name":"枚举","slug":"枚举","count":1,"path":"api/categories/枚举.json"},{"name":"玲珑杯","slug":"枚举/玲珑杯","count":1,"path":"api/categories/枚举/玲珑杯.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"python3学习 class","slug":"python3-class","date":"2017-07-15T03:52:34.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-class.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/class_.py\" target=\"_blank\" rel=\"noopener\">class_.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[13]:</p>\n<p>class student(object):<br>    #绑定实例属性<br>    #__init__方法的第一个参数永远是self,即实例本身<br>    def __init__(self,name,score):<br>        self.name = name<br>        self.score = score<br>    def print_score(self):<br>        print(“%s: %s” % (self.name,self.score))<br>    def get_grade(self):<br>        if self.score &gt;= 90:<br>            return ‘A’<br>        elif self.score &gt;= 60:<br>            return ‘B’<br>        else:<br>            return ‘C’</p>\n<p>bart=student(‘Bart Simpson’,59)<br>print(bart.name,bart.score,bart)<br>bart.print_score()<br>print(bart.get_grade())</p>\n<p># In[14]:</p>\n<p>#另一种访问方式<br>def pt_score(std):<br>    print(‘%s: %s’ % (std.name,std.score))<br>pt_score(bart)</p>\n<p># In[19]:</p>\n<p>‘’’<br>要定义一个方法，除了第一个参数是self外，其他<br>和普通函数一样。要调用一个方法，只需要在实例<br>变量上直接调用，除了self不用传递，其他参数正常传入：<br>‘’’</p>\n<p>‘’’<br>和静态语言不同，Python允许对实例变量绑定任何数据，也就<br>是说，对于两个实例变量，虽然它们都是同一个类的不同实例，<br>但拥有的变量名称都可能不同：<br>‘’’<br>bart = student(‘Bart Simpson’, 59)<br>lisa = student(‘Lisa Simpson’, 87)<br>bart.age = 8<br>print(bart.age)<br>print(lisa.age)#抛异常</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: class_.py **# coding: utf-8# In[13]:class student(object):<br>    #绑定实例属性<br>    #__init__方法的第一个参数永远是self,即实例本身<br>   ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"UVa 11825","slug":"uva-11825","date":"2017-07-14T16:41:09.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-11825.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-11825\" target=\"_blank\" rel=\"noopener\">Hackers’ Crackdown</a></strong> <strong>【题意】</strong> <strong>有N台机器，每台机器上有N个服务</strong> <strong>你可以对每台机器选择关闭他以及和他相邻的机器的一种服务</strong> <strong>当所有机器不能运行一个服务时，就是摧毁了一种服务</strong> <strong>问你最多能摧毁多少个服务</strong> <strong>【题解】</strong> <strong>就是把n台电脑看成n个集合,每个集合的成员就是这台电脑,以及和这台电脑相邻的电脑;</strong> <strong>我们就是要求把这些集合合并成尽量多的大集合,使每个集合都等于全集;也就是因为最开始的小集合,我们可以让它里面全部电脑的某一项服务全部失误,那如果合并成一个大集合,则这个大集合的某一项服务可以全部失效;所以能合并成几个等于全集的大集合,就可以让几项服务失效;</strong> <strong>【Tip】</strong> <strong>状态压缩,异或操作是相同得0,不同得1.LRJ这道题的位运算用的好…</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2011825.cpp\" target=\"_blank\" rel=\"noopener\">Uva 11825.cpp</a></strong></p>\n<hr>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int N,T,P[1&lt;&lt;17],f[1&lt;&lt;17],cover[1&lt;&lt;17],ca=1;<br>int main(){<br>    while(~scanf(“%d”,&amp;N),N){<br>        ///初始化第i台计算机的相邻集合<br>        for(int i=0;i&lt;N;++i){<br>            int n,m;<br>            scanf(“%d”,&amp;n);<br>            P[i]=1&lt;&lt;i;<br>            for(int j=0;j&lt;n;++j){<br>                scanf(“%d”,&amp;m);<br>                P[i] |= 1&lt;&lt;m;<br>            }<br>        }<br>        ///S是N个计算机的所有组合的集合,二进制表示,cover[S]是集合的并<br>        for(int S=0;S&lt;(1&lt;&lt;N);++S){<br>            cover[S]=0;<br>            for(int i=0;i&lt;N;++i){<br>                if(S &amp; (1&lt;&lt;i)) cover[S] |= P[i];///第i台机器选/不选<br>            }<br>        }<br>        f[0]=0;<br>        int ALL=(1&lt;&lt;N)-1;///全集二进制表示<br>        for(int S=1;S&lt;(1&lt;&lt;N);++S){<br>            f[S]=0;<br>            ///筛出S的子集进行动态规划<br>            for(int S0=S;S0;S0=(S0-1)&amp;S){<br>                if(cover[S0]==ALL)///如果子集S的子集的并是全集<br>                    f[S]=max(f[S],f[S^S0]+1);<br>            }<br>        }<br>        printf(“Case %d: %d\\n”,ca++,f[ALL]);<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Hackers’ Crackdown 【题意】 有N台机器，每台机器上有N个服务 你可以对每台机器选择关闭他以及和他相邻的机器的一种服务 当所有机器不能运行一个服务时，就是摧毁了一种服务 问你最多能摧毁多少个服务 【题解】 就是把n台电脑看成n个集合,每","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"动态规划","slug":"UVa/位操作/动态规划","count":1,"path":"api/categories/UVa/位操作/动态规划.json"},{"name":"状态压缩","slug":"UVa/位操作/动态规划/状态压缩","count":1,"path":"api/categories/UVa/位操作/动态规划/状态压缩.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}]},{"title":"python3学习 偏函数Partial_function+args+kw","slug":"python3-partial-functionargskw","date":"2017-07-14T07:20:06.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-partial-functionargskw.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/Partial_function/Partial_function.py\" target=\"_blank\" rel=\"noopener\">github: Partial_Function.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[2]:</p>\n<p>#Partial function包含在functools中</p>\n<p>#int可以将字符串转换成整形<br>print(‘十进制: ‘,int(‘123456’),’\\n’)</p>\n<p># In[12]:</p>\n<p>#但int()函数还提供额外的base参数，默认值为10。</p>\n<p>#如果传入base参数，就可以做N进制的转换：<br>print(‘十六进制转十进制: ‘,int(‘E123456’,16),’\\n’)</p>\n<p># In[13]:</p>\n<p>#假设要转换大量的二进制字符串，每次都传入int(x, base=2)</p>\n<p>#非常麻烦，于是，我们想到，可以定义一个int2()的函数，默</p>\n<p>#认把base=2传进去：<br>def int2(x, base=2):<br>    return int(x, base)<br>print(‘二进制转十进制: ‘,int2(‘1000000’))<br>print(‘二进制转十进制: ‘,int2(‘1010101’))</p>\n<p># In[14]:</p>\n<p>#functools.partial就是帮助我们创建一个偏函数的，不需要我</p>\n<p>#们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：<br>import functools<br>int3=functools.partial(int,base=2)<br>print(‘二进制转十进制: ‘,int3(‘1000000’))<br>print(‘二进制转十进制: ‘,int3(‘1010101’))</p>\n<p># In[22]:</p>\n<p>‘’’<br>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：</p>\n<p>int2 = functools.partial(int, base=2)</p>\n<p>实际上固定了int()函数的关键字参数base，也就是：</p>\n<p>int2(‘10010’)</p>\n<p>相当于：</p>\n<p>kw = { ‘base’: 2 }<br>int(‘10010’, **kw)</p>\n<p>当传入：</p>\n<p>max2 = functools.partial(max, 10)</p>\n<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>\n<p>max2(5, 6, 7)</p>\n<p>相当于：</p>\n<p>args = (10, 5, 6, 7)<br>max(*args)</p>\n<p>‘’’</p>\n<p>max2 = functools.partial(max)<br>args = (10, 5, 6, 7)<br>print(max2(*args))</p>\n<p>#out:10<br>max3 = functools.partial(max,102)<br>args = (10, 5, 6, 7)<br>print(max3(*args))</p>\n<p>#OUT:102**</p>\n","text":"【Source Code】 github: Partial_Function.py **# coding: utf-8# In[2]:#Partial function包含在functools中#int可以将字符串转换成整形<br>print(‘十进制: ‘,int(‘12345","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 装饰器Decorator+log(日志输出)+functools+args","slug":"python3-decoratorlog-functoolsargs","date":"2017-07-14T03:08:37.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-decoratorlog-functoolsargs.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Record】</strong> <strong>函数是对象,也有其属性,比如 f.</strong>name** 获取f控制的函数的名字.** <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/Decorator/Decorator.py\" target=\"_blank\" rel=\"noopener\">Decorator.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#函数也是一个对象,所以可以赋值给变量<br>def now():<br>    print(‘1997-02-10’)<br>f=now<br>f()</p>\n<p># In[3]:</p>\n<p>#函数对象有一个__name__属性,可以拿到其名字<br>print(f.__name__)</p>\n<p># In[5]:</p>\n<p>‘’’<br>现在，假设我们要增强now()函数的功能，比如，<br>在函数调用前后自动打印日志，但又不希望修改<br>now()函数的定义，这种在代码运行期间动态增<br>加功能的方式，称之为“装饰器”（Decorator）。<br>‘’’</p>\n<p>#本质上，decorator就是一个返回函数的高阶函数</p>\n<p>#。所以，我们要定义一个能打印日志的decorator，可以定义如下：<br>def log(func):<br>    def wrapper(*args,**kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args,**kw)<br>    return wrapper<br>‘’’<br>观察上面的log，因为它是一个decorator，所以接受<br>一个函数作为参数，并返回一个函数。我们要借助<br>Python的@语法，把decorator置于函数的定义处：</p>\n<p>调用now()函数，不仅会运行now()函数本身，还会在<br>运行now()函数前打印一行日志：<br>‘’’<br>@log<br>def now2():<br>    print(‘1997-12-11’)<br>now2() </p>\n<p># In[16]:</p>\n<p>#把@log放到now()函数的定义处，相当于执行了语句：</p>\n<p>#now=log(now)<br>‘’’<br>1.wrapper()函数的参数定义是(*args, **kw)，因此，<br>wrapper()函数可以接受任意参数的调用。在wrapper()<br>函数内，首先打印日志，再紧接着调用原始函数。</p>\n<p>2.如果decorator本身需要传入参数，那就需要编写一个返<br>回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>\n<p>‘’’<br>def log2(text):<br>    def decorator(func):<br>        def wrapper(*args,**kw):<br>            print(‘%s %s():’ %(text,func.__name__))<br>            return func(*args,**kw)<br>        return wrapper<br>    return decorator</p>\n<p>#这个3层嵌套的decorator用法如下：<br>@log2(‘execute’)<br>def now3():<br>    print(‘2015-3-25’)<br>now3()</p>\n<p>#三层嵌套是这样的:now = log(‘execute’)(now)</p>\n<p># In[17]:</p>\n<p>‘’’<br>我们来剖析上面的语句，首先执行log(‘execute’)，<br>返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>\n<p>以上两种decorator的定义都没有问题，但还差最后一步。<br>因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数<br>，它们的__name__已经从原来的’now’变成了’wrapper’：<br>‘’’<br>print(now.__name__)</p>\n<p># In[20]:</p>\n<p>‘’’<br>因为返回的那个wrapper()函数名字就是’wrapper’，所以，<br>需要把原始函数的__name__等属性复制到wrapper()函数中，<br>否则，有些依赖函数签名的代码执行就会出错。</p>\n<p>不需要编写wrapper.__name__ = func.__name__这样的代码，<br>Python内置的functools.wraps就是干这个事的，所以，一个<br>完整的decorator的写法如下：<br>‘’’<br>import functools</p>\n<p>def log3(func):<br>    @functools.wraps(func)<br>    def wrapper(*args, **kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args, **kw)<br>    return wrapper</p>\n<p>#或者针对带参数的decorator：<br>def log4(text):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(*args, **kw):<br>            print(‘%s %s():’ % (text, func.__name__))<br>            return func(*args, **kw)<br>        return wrapper<br>    return decorator</p>\n<p># In[22]:</p>\n<p>#题目<br>‘’’<br>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。<br>OOP的装饰模式需要通过继承和组合来实现，而Python除了能支<br>持OOP的decorator外，直接从语法层次支持decorator。Python<br>的decorator可以用函数实现，也可以用类实现。</p>\n<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使<br>用起来非常灵活和方便。</p>\n<p>请编写一个decorator，能在函数调用的前后打印出’begin call’<br>和’end call’的日志。</p>\n<p>再思考一下能否写出一个@log的decorator，使它既支持：</p>\n<p>@log<br>def f():<br>    pass</p>\n<p>又支持：</p>\n<p>@log(‘execute’)<br>def f():<br>    pass<br>‘’’<br>def log5(<em>args1):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(\\</em>args,**kw):<br>            print(‘args1 num =%d’ %len(args1))<br>            print(‘begin %s():’ % func.__name__)<br>            func()<br>            print(‘end %s().\\n’ % func.__name__)<br>        return wrapper<br>    return decorator</p>\n<p>@log5(‘123’,’a’)<br>def dream():<br>    print(‘My Dream.’)</p>\n<p>@log5()<br>def future():<br>    print(‘Must..’)</p>\n<p>dream()<br>future()</p>\n<p>‘’’<br>Out:<br>args1 num =2<br>begin dream():<br>My Dream.<br>end dream().</p>\n<p>args1 num =0<br>begin future():<br>Must..<br>end future().<br>‘’’</p>\n<p># In[ ]:**</p>\n","text":"【Record】 函数是对象,也有其属性,比如 f.name** 获取f控制的函数的名字.** 【Source Code】 github: Decorator.py**# coding: utf-8# In[1]:#函数也是一个对象,所以可以赋值给变量<br>def now():","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"UVa 10891","slug":"uva-10891","date":"2017-07-13T16:42:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10891.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10891\" target=\"_blank\" rel=\"noopener\">Game of Sum</a></strong> <strong>【题意】</strong> <strong>给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B).</strong> <strong>【题解】</strong> <strong>因为任意时刻游戏的状态都是连续子序列.</strong> <strong>用d(i,j)表示原序列的第i~j个元素组成的子序列.在双方都采取最优策略的情况下,先手得分的最大值.</strong> <strong>状态转移时,我们考虑从左取和从右取多少个.等价于枚举给对方剩下怎样的子序列.是(k,end)(begin&lt;k&lt;=end),还是(begin,k)(begin&lt;=k&lt;end).</strong> <strong>状态转移方程:d(begin,end)=sum(begin,end)-min{d(begin+1,end),d(begin+2,end),…,d(end,end), d(begin,end-1),d(begin,end-2),…,d(begin,begin),0}</strong> <strong>0代表全取完,所以不需要边界处理.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVa%2010891.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10891.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=100+20;<br>int A[maxn],vis[maxn][maxn],S[maxn],d[maxn][maxn];</p>\n<p>int dp(int b,int e){<br>    if(vis[b][e]) return d[b][e];///记忆化搜索<br>    vis[b][e]=1;<br>    int m=0;<br>    ///从b-&gt;e选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b+1;k&lt;=e;++k) m=min(m,dp(k,e)); ///从e-&gt;b选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b;k&lt;e;++k) m=min(m,dp(b,k));<br>    d[b][e]=S[e]-S[b-1]-m;<br>    return d[b][e];<br>}</p>\n<p>int main(){<br>    int n;S[0]=0;<br>    while(~scanf(“%d”,&amp;n) &amp;&amp; n){<br>        for(int i=1;i&lt;=n;++i){**<br> <strong>scanf(“%d”,&amp;A[i]);</strong><br> <strong>S[i]=S[i-1]+A[i];</strong><br> <strong>}</strong><br> <strong>memset(vis,0,sizeof(vis));</strong><br> <strong>printf(“%d\\n”,2*dp(1,n)-S[n]);///=&gt;dp(1,n)-(S[n]-dp(1,n))<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Game of Sum 【题意】 给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B). 【题解】 因为任意时刻游戏的状态都是连续子序列. 用d(i,j)","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"python3学习 sorted","slug":"python3-sorted","date":"2017-07-13T09:03:34.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-sorted.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/sorted/sorted.py\" target=\"_blank\" rel=\"noopener\">sorted.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>print(sorted([36, 5, -12, 9, -21]))</p>\n<p>#此外，sorted()函数也是一个高阶函数，它还可</p>\n<p>#以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：<br>print(sorted([36, 5, -12, 9, -21], key=abs))</p>\n<p>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’]))</p>\n<p>#我们给sorted传入key–函数–，即可实现忽略大小写的排序：<br>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower))</p>\n<p>#要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：<br>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower, reverse=True))</p>\n<p># In[5]:</p>\n<p>L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]</p>\n<p>#key是排序规则函数</p>\n<p># In[6]:</p>\n<p>#按名字排序<br>def by_name(t):<br>    return t[0]<br>L2 = sorted(L, key=by_name)<br>print(L2)</p>\n<p>#按成绩从高到低排序<br>def by_score(t):<br>    return -t[1]<br>L2 = sorted(L, key=by_score)<br>print(L2)</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: sorted.py **# coding: utf-8# In[1]:print(sorted([36, 5, -12, 9, -21]))#此外，sorted()函数也是一个高阶函数，它还可#以接收一个key函数来实现自定义的排序，例","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}]}