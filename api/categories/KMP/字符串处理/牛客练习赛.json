{"name":"牛客练习赛","slug":"KMP/字符串处理/牛客练习赛","count":1,"postlist":[{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） C KMP-Next数组","slug":"5-c-kmp","date":"2018-02-27T12:23:59.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/5-c-kmp.json","excerpt":"","keywords":null,"cover":null,"content":"<p>[toc]</p>\n<blockquote>\n<p>Next数组</p>\n</blockquote>\n<h1 id=\"自己写的卡在-95-00的代码\"><a href=\"#自己写的卡在-95-00的代码\" class=\"headerlink\" title=\"自己写的卡在%95.00的代码\"></a>自己写的卡在%95.00的代码</h1><p>我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nmap&lt;int,int&gt; ex;\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=1;i&lt;=len;++i){\n        printf(&quot;%d &quot;,Next[i]);\n    }\n}\n\nvoid solve(){\n    ex.clear();\n    getNext();\n    //print();\n    int bef=Next[len],now,max_len=0;\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    while(bef!=0){\n        now=bef;\n        bef=Next[bef];\n    }\n\n    for(int i=1;i&lt;=len;++i){\n        if(Next[i] &amp;&amp; Next[i]%now==0){\n            int k=Next[i]/now;\n            for(int j=1;j&lt;=k;++j){\n                ex[j*now]++;\n            }\n        }\n    }\n    map&lt;int,int&gt;::iterator it;\n    for(it=ex.begin();it!=ex.end();it++){\n        if(it-&gt;second&gt;1) max_len=max(max_len,it-&gt;first);\n    }\n    if(max_len){\n        max_len=min(max_len,Next[len]);\n        for(int i=0;i&lt;max_len;++i){\n            printf(&quot;%c&quot;,str[i]);\n        }\n    }else printf(&quot;Just a legend&quot;);\n    printf(&quot;\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><blockquote>\n<p>AC代码</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nint exist[maxn];\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid solve(){\n    memset(exist,0,sizeof(exist));\n    getNext();\n    int bef=Next[len];\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    //忽略第一个和最后一个\n    for(int i=2;i&lt;len;++i){\n        exist[Next[i]]++;\n    }\n\n    while(bef&gt;0){\n        if(exist[bef]){\n            for(int i=0;i&lt;bef;++i){\n                printf(&quot;%c&quot;,str[i]);\n            }\n            printf(&quot;\\n&quot;);\n            return;\n        }\n        bef=Next[bef];\n    }\n    printf(&quot;Just a legend\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1 id=\"当然-还有一种方法是比较特别的-比较直观-把每个可能子串KMP一下-如果匹配成功了-就直接输出就好了\"><a href=\"#当然-还有一种方法是比较特别的-比较直观-把每个可能子串KMP一下-如果匹配成功了-就直接输出就好了\" class=\"headerlink\" title=\"当然,还有一种方法是比较特别的(比较直观),把每个可能子串KMP一下,如果匹配成功了,就直接输出就好了\"></a>当然,还有一种方法是比较特别的(比较直观),把每个可能子串KMP一下,如果匹配成功了,就直接输出就好了</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nchar a[1000005],b[1000005];\nint next[1000006];\nvoid getnext(char *c)\n{\n    next[0]=next[1]=0;\n    int i,j,len=strlen(c);\n    for(i=1,j=0;i&lt;len;i++)\n    {\n        while(c[i]!=c[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(c[i]==c[j])j++;\n        next[i+1]=j;\n    }\n}\nint kmp(char *o,char *f)\n{\n    int cont=0;\n    int i,j,len1=strlen(o),len2=strlen(f);\n    for(i=0,j=0;i&lt;len1;i++)\n    {\n        while(o[i]!=f[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(o[i]==f[j])j++;\n        if(j==len2)\n        {\n            cont++;\n            j=next[j];\n        }\n    }\n    return cont;\n}\nint main()\n{\n    int i;\n    scanf(&quot;%s&quot;,a);\n    getnext(a);\n    int len=next[strlen(a)];\n    if(len==0)\n    {\n        printf(&quot;Just a legend\\n&quot;);\n        return 0;\n    }\n    for(i=0;i&lt;len;i++)\n        b[i]=a[i];\n    b[i]=&apos;\\0&apos;;\n    int cont=kmp(a,b);\n    while(cont&lt;3)\n    {\n        len=next[len];\n        if(len==0)break;\n        for(i=0;i&lt;len;i++)\n            b[i]=a[i];\n        b[i]=&apos;\\0&apos;;\n        cont=kmp(a,b);\n    }\n    if(cont&gt;=3&amp;&amp;len)printf(&quot;%s\\n&quot;,b);\n    else printf(&quot;Just a legend\\n&quot;);\n    return 0;\n}</code></pre><p>1<br>=</p>\n<p>2<br>=</p>\n","text":"[toc]Next数组自己写的卡在%95.00的代码我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1001000;int Next[max","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"字符串处理","slug":"KMP/字符串处理","count":1,"path":"api/categories/KMP/字符串处理.json"},{"name":"牛客练习赛","slug":"KMP/字符串处理/牛客练习赛","count":1,"path":"api/categories/KMP/字符串处理/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"}]}]}