{"name":"ccf","slug":"ccf","count":2,"postlist":[{"title":"CCF 2016-12/4 & POJ 1738","slug":"ccf-2016-124-poj-1738","date":"2017-08-31T12:45:36.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2016-124-poj-1738.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 石子合并问题 算法: GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn),也可以用动态规划,等等学一下再补充. GarsiaWachs算法(摘自别人的blog):</p>\n<pre><code>具体的算法及证明可以参见《The Art of Computer Programming》第3卷6.2.2节Algorithm G和Lemma W,Lemma X,Lemma Y,Lemma Z。\n只能说一个概要吧：\n设一个序列是A[0..n-1]，每次寻找最小的一个满足A[k-1]&lt;=A[k+1]的k，（方便起见设A[-1]和A[n]等于正无穷大）\n那么我们就把A[k]与A[k-1]合并，之后找最大的一个满足A[j]&gt;A[k]+A[k-1]的j,把合并后的值A[k]+A[k-1]插入A[j]的后面。\n有定理保证，如此操作后问题的答案不会改变。\n举个例子：\n186 64 35 32 103\n因为35&lt;103，所以最小的k是3，我们先把35和32删除，得到他们的和67，并向前寻找一个第一个超过67的数，把67插入到他后面\n186 64（k=3,A[3]与A[2]都被删除了） 103\n186 67（遇到了从右向左第一个比67大的数，我们把67插入到他后面） 64 103\n186 67 64 103 （有定理保证这个序列的答案加上67就等于原序列的答案）\n现在由5个数变为4个数了，继续！\n186 （k=2,67和64被删除了）103\n186 131（就插入在这里） 103\n186 131 103\n现在k=2（别忘了，设A[-1]和A[n]等于正无穷大）\n234 186\n420\n最后的答案呢？就是各次合并的重量之和呗。420+234+131+67=852，哈哈，算对了。\n\n证明嘛，基本思想是通过树的最优性得到一个节点间深度的约束，之后\n证明操作一次之后的解可以和原来的解一一对应，并保证节点移动之后他所在的\n深度不会改变。详见TAOCP。\n\n具体实现这个算法需要一点技巧，精髓在于不停快速寻找最小的k，即维护一个“2-递减序列”\n朴素的实现的时间复杂度是O(n*n)，但可以用一个平衡树来优化（好熟悉的优化方法），使得最终复杂度为O(nlogn)\n\n\n解题思路:（这是我找到的一个关于GarsiaWachs算法的解释）\n\n      1. 这类题目一开始想到是DP, 设dp[i][j]表示第i堆石子到第j堆石子合并最小得分.\n\n         状态方程: dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);\n\n         sum[i]表示第1到第i堆石子总和. 递归记忆化搜索即可.\n\n      2. 不过此题有些不一样, 1&lt;=n&lt;=50000范围特大, dp[50000][50000]开不到这么大数组.\n\n         问题分析:\n\n         (1). 假设我们只对3堆石子a,b,c进行比较, 先合并哪2堆, 使得得分最小.\n\n              score1 = (a+b) + ( (a+b)+c )\n\n              score2 = (b+c) + ( (b+c)+a )\n\n              再次加上score1 &lt;= score2, 化简得: a &lt;= c, 可以得出只要a和c的关系确定,\n\n              合并的顺序也确定.\n\n         (2). GarsiaWachs算法, 就是基于(1)的结论实现.找出序列中满足stone[i-1] &lt;=\n\n              stone[i+1]最小的i, 合并temp = stone[i]+stone[i-1], 接着往前面找是否\n\n              有满足stone[j] &gt; temp, 把temp值插入stone[j]的后面(数组的右边). 循环\n\n              这个过程一直到只剩下一堆石子结束.\n\n        (3). 为什么要将temp插入stone[j]的后面, 可以理解为(1)的情况\n\n             从stone[j+1]到stone[i-2]看成一个整体 stone[mid],现在stone[j],\n\n             stone[mid], temp(stone[i-1]+stone[i-1]), 情况因为temp &lt; stone[j],\n\n             因此不管怎样都是stone[mid]和temp先合并, 所以讲temp值插入stone[j]\n\n             的后面是不影响结果.</code></pre><p>代码实现:</p>\n<pre><code>///186 64 35 32 103\n///GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn)\n/*\n设序列是stone[]，从左往右，找一个满足\nstone[k-1] &lt;= stone[k+1]的k，找到后合\n并stone[k]和stone[k-1]，再从当前位置\n开始向左找最大的j，使其满足\nstone[j] &gt; stone[k]+stone[k-1]，\n插到j的后面就行。一直重复，直到只剩下\n一堆石子就可以了。在这个过程中，可以假设\nstone[-1]和stone[n]是正无穷的。\n*/\n\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=50005;\n\nint stone[maxn];\nint N,ans,T;\n///186 64 35 32 103\nvoid combine(int k){\n    int tmp=stone[k]+stone[k-1];\n    ans+=tmp;\n    for(int i=k;i&lt;T-1;++i)\n        stone[i]=stone[i+1];\n    T--;\n    int j=0;\n    for(j=k-1;j&gt;0&amp;&amp;stone[j-1]&lt;tmp;--j)\n        stone[j]=stone[j-1];\n    stone[j]=tmp;\n    while(j&gt;=2&amp;&amp;stone[j]&gt;=stone[j-2]){\n        int d=T-j;\n        combine(j-1);\n        j=T-d;\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=0;i&lt;N;++i) scanf(&quot;%d&quot;,&amp;stone[i]);\n        T=1;\n        ans=0;\n        for(int i=1;i&lt;N;++i){\n            stone[T++]=stone[i];\n            while(T&gt;=3&amp;&amp;stone[T-3]&lt;=stone[T-1]){\n                combine(T-2);\n            }\n        }\n        while(T&gt;1)combine(T-1);\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}\n///186 64 35 32 103</code></pre>","text":"类型: 石子合并问题 算法: GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn),也可以用动态规划,等等学一下再补充. GarsiaWachs算法(摘自别人的blog):具体的算法及证明可以参见《The Art of Comput","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"GarsiaWachs","slug":"ccf/GarsiaWachs","count":1,"path":"api/categories/ccf/GarsiaWachs.json"},{"name":"POJ","slug":"ccf/GarsiaWachs/POJ","count":1,"path":"api/categories/ccf/GarsiaWachs/POJ.json"}],"tags":[{"name":"GarsiaWachs","slug":"GarsiaWachs","count":1,"path":"api/tags/GarsiaWachs.json"}]},{"title":"ccf 2017前四题","slug":"ccf-2017-pre-f","date":"2017-08-19T05:25:33.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2017-pre-f.json","excerpt":"","keywords":null,"cover":null,"content":"<p>第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *<em>要登录和会员 *</em> <a href=\"http://118.190.20.162/home.page\" target=\"_blank\" rel=\"noopener\">http://118.190.20.162/home.page</a> github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/tree/master/CCSP/2017-3\" title=\"CCF 2017-3 前四题\" target=\"_blank\" rel=\"noopener\">CCF 2017-3 前四题</a> 第一题:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    int N,K;\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;K)){\n        int ans=0,d,n=0;\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;d);\n            n+=d;\n            if(n&gt;=K){\n                n=0;\n                ans++;\n            }\n        }\n        if(n)ans++;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>第二题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint N,M;\nint I,J;\n\nlist&lt;int&gt; li;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        li.clear();\n        for(int i=1;i&lt;=N;++i){\n            li.push_back(i);\n        }\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%d%d&quot;,&amp;I,&amp;J);\n            if(J==0)continue;\n            list&lt;int&gt;::iterator it,it2;\n            for(it=li.begin();*it!=I;it++){}\n            it2=it;\n            int flag=J&gt;0?1:-1;\n            J=abs(J)+(flag&gt;0?1:0);\n            while(J){\n                J--;\n                flag&gt;0?it++:it--;\n            }\n            li.insert(it,I);\n            li.erase(it2);\n        }\n        list&lt;int&gt;::iterator it;\n        it=li.begin();\n        printf(&quot;%d&quot;,*it);\n        it++;\n        for(;it!=li.end();it++){\n            printf(&quot; %d&quot;,*it);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>第三题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define BUF_SS 101\n\nusing namespace std;\n\nchar buf[101];\nint pre=-1;\n\nint check_hl(int st){\n    char hr[100];\n    string tip;\n    int ind=st+1,cs=0,hs=0;\n    while(buf[ind]!=&apos;]&apos;){\n        if(buf[ind]==&apos;_&apos;){\n            tip+=&quot;&lt;em&gt;&quot;;\n            ind++;\n            while(buf[ind]!=&apos;_&apos;){\n                tip+=buf[ind];\n                ind++;\n            }\n            tip+=&quot;&lt;/em&gt;&quot;;\n            ind++;\n        }else{\n            tip+=buf[ind];\n            ind++;\n        }\n    }\n    ind+=2;\n    while(buf[ind]!=&apos;)&apos;){\n        hr[hs++]=buf[ind];\n        ind++;\n    }\n    hr[hs]=&apos;\\0&apos;;\n    printf(&quot;&lt;a href=\\&quot;%s\\&quot;&gt;&quot;,hr);\n    cout&lt;&lt;tip&lt;&lt;&quot;&lt;/a&gt;&quot;;\n    return ind-st;\n}\n\nint check_em(int st){\n    int ind=st+1;\n    printf(&quot;&lt;em&gt;&quot;);\n    while(buf[ind]!=&apos;_&apos;){\n        if(buf[ind]==&apos;[&apos;){\n            int ed=check_hl(ind);\n            ind+=(ed+1);\n        }else{\n            putchar(buf[ind]);\n            ind++;\n        }\n    }\n    printf(&quot;&lt;/em&gt;&quot;);\n    return ind-st;\n}\n\nvoid check_h(int sz){\n    int n,r=0;\n    char sts[20],ste[20];\n    while(buf[r]==&apos;#&apos;){\n        r++;\n    }\n    int s=r,e=sz-1;\n    sprintf(sts,&quot;&lt;h%d&gt;&quot;,r);\n    sprintf(ste,&quot;&lt;/h%d&gt;&quot;,r);\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;%s&quot;,sts);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;%s\\n&quot;,ste);\n}\n\nvoid check_u(int sz){\n    if(pre!=2)printf(&quot;&lt;ul&gt;\\n&quot;);\n    int s=1,e=sz-1;\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;&lt;li&gt;&quot;);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;&lt;/li&gt;\\n&quot;);\n}\n\nvoid check_p(int sz){\n    if(pre!=3)printf(&quot;&lt;p&gt;&quot;);\n    if(pre==3)putchar(&apos;\\n&apos;);\n    for(int i=0;buf[i]!=&apos;\\n&apos; &amp;&amp; i&lt;sz;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n}\n\nint main(){\n    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n    while(fgets(buf,BUF_SS,stdin)){\n        if(buf[0]==&apos;\\n&apos;){\n            if(pre==3){\n                printf(&quot;&lt;/p&gt;\\n&quot;);\n                pre=0;continue;\n            }else if(pre==2){\n                printf(&quot;&lt;/ul&gt;\\n&quot;);\n                pre=0;continue;\n            }\n            continue;\n        }\n        int sz=strlen(buf);\n        if(buf[0]==&apos;#&apos;) check_h(sz),pre=1;\n        else if(buf[0]==&apos;*&apos;) check_u(sz),pre=2;\n        else check_p(sz),pre=3;\n    }\n    if(pre==3)printf(&quot;&lt;/p&gt;\\n&quot;);\n    if(pre==2)printf(&quot;&lt;/ul&gt;\\n&quot;);\n    return 0;\n}</code></pre><p>写题的时候写了一组测试数据: In[1]:</p>\n<pre><code># Heading\n\n## Sub-heading\n\nParagraphs are separated\nby a blank line.\n\nText attributes _italic_.\n\nBullet list:\n\n*      apples\n* oranges\n* pears\n\nA _[NLJ6link616lins1](http://example.com)_.\n\n[NLJ6_link_616_lins_1](http://example.com)</code></pre><p>out[1]:</p>\n<pre><code>&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;h2&gt;Sub-heading&lt;/h2&gt;\n&lt;p&gt;Paragraphs are separated\nby a blank line.&lt;/p&gt;\n&lt;p&gt;Text attributes &lt;em&gt;italic&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Bullet list:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;apples&lt;/li&gt;\n&lt;li&gt;oranges&lt;/li&gt;\n&lt;li&gt;pears&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A &lt;em&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6link616lins1&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6&lt;em&gt;link&lt;/em&gt;616&lt;em&gt;lins&lt;/em&gt;1&lt;/a&gt;&lt;/p&gt;</code></pre><p>第四题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAX_M=200000+10;\nconst int maxn=200000+10;\nint N,M;\nint A,B,C;\n\nstruct Edge{\n    int from,to,dist;\n};\nstruct HeapNode{\n    int d,from,to;\n    bool operator&lt;(const HeapNode&amp; rhs)const{\n        return d&gt;rhs.d;\n    }\n};\n\nstruct Kruskal{\n    int n,m;///点数和边数\n    vector&lt;Edge&gt; edges;///边表\n    vector&lt;int&gt; G[maxn];///每个节点出发的边编号\n    priority_queue&lt;HeapNode&gt; Q;\n\n    ///并查集\n    int fa[maxn];///父亲\n    int ra[maxn];///高度\n    ///init:初始化(点数)\n    ///find_Root:查找树的根\n    ///unite:合并x和y所属集合\n    ///same:判断x和y是否是同一个集合\n    void init(int n){\n        this-&gt;n=n;\n        for(int i=0;i&lt;n;++i){\n            fa[i]=i;\n            ra[i]=0;\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    int find_Root(int x){\n        if(fa[x]==x){\n            return x;\n        }else{\n            return fa[x]=find_Root(fa[x]);\n        }\n    }\n    void unite(int x,int y){\n        x=find_Root(x);\n        y=find_Root(y);\n        if(x==y) return;\n\n        if(ra[x]&lt;ra[y]){\n            fa[x]=y;\n        }else{\n            fa[y]=x;\n        }\n    }\n    bool same(int x,int y){\n        return find_Root(x)==find_Root(y);\n    }\n\n    void AddEdge(int from,int to,int dist){\n        edges.push_back((Edge){from,to,dist});\n        m=edges.size()-1;\n        G[from].push_back(m-1);\n        Q.push((HeapNode){dist,from,to});\n    }\n\n    int kruskal(){\n        HeapNode h;\n        while(!Q.empty()){\n            if(find_Root(N)==find_Root(1))break;\n            h=Q.top();Q.pop();\n            if(find_Root(h.from)==find_Root(h.to))continue;\n            unite(h.from,h.to);\n        }\n        printf(&quot;%d\\n&quot;,h. d);\n    }\n}K;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        K.init(N);\n        for(int i=0;i&lt;M;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);\n            K.AddEdge(A,B,C);\n        }\n        K.kruskal();\n    }\n    return 0;\n}</code></pre>","text":"第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *要登录和会员 * http://118.190.20.162/home.page git","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"kruskal","slug":"ccf/kruskal","count":1,"path":"api/categories/ccf/kruskal.json"},{"name":"并查集","slug":"ccf/kruskal/并查集","count":1,"path":"api/categories/ccf/kruskal/并查集.json"},{"name":"模拟","slug":"ccf/kruskal/并查集/模拟","count":1,"path":"api/categories/ccf/kruskal/并查集/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"},{"name":"CCF","slug":"CCF","count":1,"path":"api/tags/CCF.json"}]}]}