{"name":"算法学习","slug":"算法学习","count":4,"postlist":[{"title":"算法学习-图论相关一些基础","slug":"base-graph","date":"2017-03-21T23:58:25.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/base-graph.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png","content":"<p><strong>【先贴上大神的代码截图】</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png\" alt></a>   <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/SFA.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/SFA.png\" alt=\"floyd&amp;spfa\"></a>   <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>struct node{</strong> **    node <em>next;*</em> **    int where;** **    int cost;** <strong>}a[10001],*first[1001];</strong> <strong>bool b[1001];</strong> <strong>inline void dfs(int now){</strong> **    b[now]=true;** **    for(node <em>x=first[now];x;x=x-&gt;next)*</em> **        if(!b[x-&gt;where])** **            dfs(x-&gt;where);** <strong>}</strong> <strong>inline void bfs(int S){</strong> **    int c[1001];** **    c[1]=S;** **    for(int k=1,l=1,l&lt;=k;++l){** **        int m=c[1];** **        for(node <em>x=first[m];x;x=x-&gt;next)*</em> **            if(!b[x-&gt;where])** **                b[x-&gt;where]=true,** **                c[++k]=x-&gt;where;    ** **    }** <strong>}</strong> <strong>//floyd只是一个模板</strong> <strong>inline void floyd(){</strong> **    for(int k=1;k&lt;=n;++k)** **        for(int i=1;i&lt;=n;++i)** **            for(int j=1;j&lt;=n;++j)** **                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);** <strong>}</strong> <strong>//可以处理负边</strong> <strong>inline void spfa(int S,int T){</strong> **    int c[1001],dist[1001];** **    c[1]=S;** **    memset(dist,127,sizeof(dist));** **    dist[S]=0;** **    for(int k=1,l=1;l&lt;=k;++l){** **        int m=c[1];** **        b[m]=false;** **        for(node <em>x=first[m];x;x=x-&gt;next)*</em> **            if(dist[m]+x-&gt;cost&lt;dist[x-&gt;where])** **            {** **                dist[x-&gt;where]=dist[m]+x-&gt;cost;** **                if(!b[x-&gt;where])** **                    b[x-&gt;where]=true,** **                    c[++k]=x-&gt;where;** **            }** **    }**   <strong>}</strong> <strong>int main(){</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【先贴上大神的代码截图】  [Figure]    【Code】#include #include #include using namespace std; struct node{ **    node next;* **    int where;** **    int ","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"Eratosthenes 筛法","slug":"eratosthenes-p312","date":"2016-12-23T03:30:31.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/eratosthenes-p312.json","excerpt":"","keywords":null,"cover":null,"content":"<p>俗称,埃氏筛法.这里是借用其思路. Problem: 给出正整数N和M,区间[N,M]内的”无平方因子”的数有多少个? 整数P无平方因子,当且仅当不存在k&gt;1,使得p是k^2的倍数,N,M∈[1,1e12],M-N&lt;=1e7. [分析]: 因为数据规模的限制,枚举肯定会超时. [思路]: 对于不超过sqrt(M)的所有素数p,筛掉[N,M]内p^2的倍数. [Code]:</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath></cmath></p>\n<p>#define maxn 10000000+10<br>using namespace std;</p>\n<p>bool squre[maxn];//m-n个是否是无平方因子<br>bool is_prime[maxn];//素数表<br>int prime[maxn];</p>\n<p>int sieve(int n){<br>    int p=0;<br>    for(int i=0;i&lt;=n;i++) is_prime[i]=true;<br>    is_prime[0]=is_prime[1]=false;</p>\n<pre><code>for(int i=2;i&lt;=n;++i){\n    if(is_prime\\[i\\])\n        prime\\[p++\\]=i;\n    for(int j=2*i;j&lt;=n;j+=i)\n        is_prime\\[j\\]=false;\n}\nreturn p;</code></pre><p>}</p>\n<p>int NonSquare(int n,int m){<br>    memset(squre, true, sizeof(squre));<br>    int p=0;<br>    for(int i=0;prime[i]<em>prime[i]&lt;=m;++i){<br>        int d=prime[i]</em>prime[i];<br>        for(int j=1;j<em>d&lt;=m;++j)<br>            if(j</em>d&gt;=n)<br>                squre[j*d-n]=false;<br>    }<br>    for(int i=0;i&lt;=(m-n);++i)<br>        if(squre[i])p++;<br>    return p;<br>}</p>\n<p>int main(){<br>    int m,n,siv;<br>    sieve(1e7);<br>    while(cin&gt;&gt;n&gt;&gt;m){<br>        cout&lt;&lt;”[“&lt;&lt;n&lt;&lt;”,”&lt;&lt;m&lt;&lt;”]内无平方因子数为: “&lt;&lt;NonSquare(n,m)&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n<p>Save Save</p>\n","text":"俗称,埃氏筛法.这里是借用其思路. Problem: 给出正整数N和M,区间[N,M]内的”无平方因子”的数有多少个? 整数P无平方因子,当且仅当不存在k&gt;1,使得p是k^2的倍数,N,M∈[1,1e12],M-N&lt;=1e7. [分析]: 因为数据规模的限制,枚举肯定","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[]},{"title":"代码级调试器gdb","slug":"gdb","date":"2017-03-25T11:22:57.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/gdb.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【编译】 假如编译 UVa 1339.cpp这个文件 c++ 编译:g++ -g -o “UVa 1339” “UVa 1339.cpp” 注:必须有-g,才可以用gdb调试. 【调试】 gdb “UVa 1339.exe” 注：如果文件名有字符,空格之类的,断点调试可能出错.上面就是一个教训. 【其他教程】 <a href=\"http://blog.csdn.net/txl199106/article/details/38405581\" target=\"_blank\" rel=\"noopener\">gdb教程</a></p>\n","text":"【编译】 假如编译 UVa 1339.cpp这个文件 c++ 编译:g++ -g -o “UVa 1339” “UVa 1339.cpp” 注:必须有-g,才可以用gdb调试. 【调试】 gdb “UVa 1339.exe” 注：如果文件名有字符,空格之类的,断点调试可能出错.上","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"矩阵类","slug":"matrix","date":"2016-12-20T12:52:03.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/matrix.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【任务】 实现矩阵的基本变换 【接口】 结构体:Matrix 成员变量: int n,m      矩阵大小 int a[][]    矩阵内容 重载运算符    +、-、* 成员函数: void clear() 清空矩阵 【代码】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cstdio><br>using namespace std;<br>const int MAXN=30;<br>const int MAXM=30;</cstdio></p>\n<p>/*<br>* Matrix类, + - *<br>*/</p>\n<p>struct Matrix{<br>    int n,m;//行,列<br>    int a[MAXN][MAXM];<br>    void clear(){<br>        n=m=0;<br>        memset(a,0,sizeof(a));<br>    }<br>    Matrix operator + (const Matrix &amp;b) const{<br>        Matrix tmp;<br>        tmp.n=n; tmp.m=m;<br>        for(int i=0;i&lt;n;++i)<br>            for(int j=0;j&lt;m;++j)<br>                tmp.a[i][j]=a[i][j]+b.a[i][j];<br>        return tmp;<br>    }<br>    Matrix operator - (const Matrix &amp;b) const{<br>        Matrix tmp;<br>        tmp.n=n;  tmp.m=m;<br>        for(int i=0;i&lt;n;++i)<br>            for(int j=0;j&lt;m;++j)<br>                tmp.a[i][j]=a[i][j]-b.a[i][j];<br>        return tmp;<br>    }<br>    Matrix operator * (const Matrix &amp;b) const{<br>        Matrix tmp;<br>        tmp.clear();<br>        tmp.n=n;  tmp.m=b.m;<br>        for(int i=0;i&lt;n;++i)<br>            for(int j=0;j&lt;b.m;++j)<br>                for(int k=0;k&lt;m;++k)<br>                    tmp.a[i][j]+=a[i][k]<em>b.a[k][j];<br>        return tmp;<br>    }<br>};<br>int main(){<br>  Matrix a,b,mut,sum,de;<br>  cout&lt;&lt;”请输入a和b的行和列数:”;<br>  cin&gt;&gt;a.n&gt;&gt;a.m;<br>  b.n=a.n,b.m=a.m;<br>  cout&lt;&lt;”请填充a:”&lt;&lt;endl;<br>  for(int i=0;i&lt;a.n;++i)<br>    for(int j=0;j&lt;a.m;++j)<br>        cin&gt;&gt;a.a[i][j];<br>  cout&lt;&lt;”请填充b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;a.n;++i)<br>    for(int j=0;j&lt;a.m;++j)<br>        cin&gt;&gt;b.a[i][j];<br>  mut=a</em>b;<br>  sum=a+b;<br>  de=a-b;<br>  cout&lt;&lt;”a+b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;sum.n;++i){<br>    for(int j=0;j&lt;sum.m;++j)<br>        cout&lt;&lt;sum.a[i][j]&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>  }<br>  cout&lt;&lt;”a-b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;de.n;++i){<br>    for(int j=0;j&lt;de.m;++j)<br>        cout&lt;&lt;de.a[i][j]&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>  }<br>  cout&lt;&lt;”a*b:”&lt;&lt;endl;<br>  for(int i=0;i&lt;mut.n;++i){<br>    for(int j=0;j&lt;mut.m;++j)<br>        cout&lt;&lt;mut.a[i][j]&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>  }<br>  return 0;<br>}</p>\n<p>Save Save</p>\n","text":"【任务】 实现矩阵的基本变换 【接口】 结构体:Matrix 成员变量: int n,m      矩阵大小 int a[][]    矩阵内容 重载运算符    +、-、* 成员函数: void clear() 清空矩阵 【代码】#include#include#include","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[]}]}