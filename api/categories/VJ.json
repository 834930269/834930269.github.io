{"name":"VJ","slug":"VJ","count":2,"postlist":[{"title":"VJ SWPU-ACM省赛集训赛ONE A  Easy Math","slug":"vj-swpu-acmone-a-easy-math","date":"2017-04-20T06:39:20.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmone-a-easy-math.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>直觉只要有一个不是平方根就输出No,直觉是对的…</strong> <strong>可以当做结论?</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N;</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        bool flag=true;** **        ll num;** **        while(N–){** **            SI(num);** **            ll t=sqrt(num);** **            if(t<em>t!=num)*</em> **                flag=false;** **        }** **        printf(flag?”Yes\\n”:”No\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 直觉只要有一个不是平方根就输出No,直觉是对的… 可以当做结论? 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3","link":"","raw":null,"photos":[],"categories":[{"name":"VJ","slug":"VJ","count":2,"path":"api/categories/VJ.json"}],"tags":[{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]},{"title":"VJ SWPU-ACM省赛集训赛ONE E Rectangle","slug":"vj-swpu-acmone-e-rectangle","date":"2017-04-20T06:44:53.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmone-e-rectangle.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>枚举长的长度,则对于长有N-i+1种情况.</strong> <strong>然后得出宽的取值范围为[1,tmp=(K-i)&lt;M?(K-i):M].防溢出.</strong> <strong>画图知在宽的取值范围内情况分别为:M,M-1,M-2…M-tmp+1.共tmp项.</strong> <strong>用等差数列求和公式得出该长下的宽的情况个数.</strong> <strong>乘积累加.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N,M,K;</strong> <strong>ll ans;</strong> <strong>int main(){</strong> **    while(~SIII(N,M,K)){** **        K&gt;&gt;=1;** **        ans=0;** **        for(int i=1;i&lt;=N &amp;&amp; K-i&gt;0;++i){** **            ll tmp=(K-i)&lt;M?(K-i):M;** **            ll sumC=N-i+1;** **            ll sumK=(M+M-tmp+1)<em>tmp/2;*</em> **            ans+=sumC<em>sumK;*</em> **        }** **        printf(“%lld\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 枚举长的长度,则对于长有N-i+1种情况. 然后得出宽的取值范围为[1,tmp=(K-i)&lt;M?(K-i):M].防溢出. 画图知在宽的取值范围内情况分别为:M,M-1,M-2…M-tmp+1.共tmp项. 用等差数列求和公式得出该长下的宽的情况个数. 乘积累加","link":"","raw":null,"photos":[],"categories":[{"name":"VJ","slug":"VJ","count":2,"path":"api/categories/VJ.json"}],"tags":[{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]}]}