{"name":"散列表","slug":"AOJ/散列表","count":1,"postlist":[{"title":"ALDS1_4_C Dictionary","slug":"alds1-4-c-dictionary","date":"2018-01-08T10:47:39.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/alds1-4-c-dictionary.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: <a href=\"https://vjudge.net/problem/Aizu-ALDS1_4_C\" title=\"https://vjudge.net/problem/Aizu-ALDS1_4_C\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/Aizu-ALDS1_4_C</a> 题型: 开放式散列表(可以用c++库函数做,但那样就忒没诚意了是啊吧 :triumph: ) PS:对于散列表性能影响最大的一般是散列函数.如果出现TLE,证明散列函数出问题了,改改试试. Code:</p>\n<pre><code>/*\n//alds1_4_c:Dictionary\n//算法:开放地址法散列表\n//Time: 2018/1/8 星期一\n*/\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nconst int M=1000003;\nconst int L=14;\n\nchar H[M][L];\n\n//对于每个字符返回的定义值\nint getChar(char ch){\n    if(ch==&apos;A&apos;) return 1;\n    if(ch==&apos;C&apos;) return 2;\n    if(ch==&apos;D&apos;) return 3;\n    if(ch==&apos;T&apos;) return 4;\n    return 0;\n}\n//对于字符串返回的初始散列值\nlong long getKey(char str[]){\n    long long len=strlen(str),sum=0,p=1;\n    for(int i=0;i&lt;len;++i){\n        sum+=p*getChar(str[i]);\n        //每次获取定义值后p*5,相当于转换成五进制,不会冲突\n        p*=5;\n    }\n    return sum;\n}\n\n//开放式散列值计算式: h(k,i)=(h1(k)+i*h2(k))%M\nint h1(int key){\n    return key%M;\n}\n//为了保证不会递归冲突(即往下算结果始终相同),必须使h2(key)与M互素\n//TLE最好的情况就是改这个函数= =\n//目前可以AC的: 1+(key%(M-1))\n//(1+key)%(M-1)\nint h2(int key){\n    return (1+key)%(M-1);\n}\n\n//查找\n//-1表示找到\n//h表示找到第一个可插入点\nint find(char str[]){\n    long long key=getKey(str),i,h;\n    for(i=0;;++i){\n        h=(h1(key)+i*h2(key))%M;\n        if(strcmp(H[h],str)==0) return -1;\n        else if(strlen(H[h])==0) return h;\n    }\n    return 0;\n}\n\n//插入\nvoid insert(char str[]){\n    int key=find(str);\n    if(key!=-1) strcpy(H[key],str);\n}\n\nint main(){\n    for(int i=0;i&lt;M;++i) H[M][0]=&apos;\\0&apos;;\n    char str[L],com[L];\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%s %s&quot;,com,str);\n\n        if(com[0]==&apos;i&apos;){\n            insert(str);\n        }else{\n            if(find(str)==-1)\n                printf(&quot;yes\\n&quot;);\n            else\n                printf(&quot;no\\n&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre>","text":"原题连接: https://vjudge.net/problem/Aizu-ALDS1_4_C 题型: 开放式散列表(可以用c++库函数做,但那样就忒没诚意了是啊吧 :triumph: ) PS:对于散列表性能影响最大的一般是散列函数.如果出现TLE,证明散列函数出问题了,改改试","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"散列表","slug":"AOJ/散列表","count":1,"path":"api/categories/AOJ/散列表.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"散列表","slug":"散列表","count":1,"path":"api/tags/散列表.json"}]}]}