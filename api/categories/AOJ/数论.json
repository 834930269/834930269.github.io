{"name":"数论","slug":"AOJ/数论","count":2,"postlist":[{"title":"AOJ NTL_1_D Euler's Phi Function & 欧拉函数相关","slug":"aoj-ntl-1-d-eulers-phi-function","date":"2017-11-25T07:35:20.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-ntl-1-d-eulers-phi-function.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg","content":"<p>欧拉函数: 提供1到N中与N互质的数的个数.</p>\n<h2 id=\"定义和简单性质\"><a href=\"#定义和简单性质\" class=\"headerlink\" title=\"定义和简单性质\"></a>定义和简单性质</h2><p>欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. <strong>对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).</strong></p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><blockquote>\n<p>1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(q-1)</p>\n<blockquote>\n<p>欧拉函数是积性函数,但不是完全积性函数.</p>\n</blockquote>\n</blockquote>\n<p>证明： 函数的积性即： 若m,n互质,则φ(mn)=φ(m)φ(n).由“m,n互质”可知m,n无公因数,所以: φ(m)φ(n)=m(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)·n(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 其中p1,p2,p3…pn为m的质因数,p1’,p2’,p3’…pn’为n的质因数,而m,n无公因数,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 互不相同,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 均为mn的质因数且为mn质因数的全集,所以: φ(mn)=mn(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 所以: φ(mn)=φ(m)φ(n). 即φ(mn)=φ(n)*φ(m)只在(n,m)=1时成立(n与m互质).</p>\n<blockquote>\n<p>2.对于一个正整数N的素数幂分解N=P1^q1_P2^q2_…*Pn^qn.</p>\n</blockquote>\n<pre><code>则 φ(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn).</code></pre><blockquote>\n<p>3.除了N=2,φ(N)都是偶数. 4.设N为正整数,∑φ(d)=N (d|N)(d是N的质因数).</p>\n</blockquote>\n<p>根据性质二,我们可以在O(sqrt(n))的时间内暴力求出一个数的欧拉函数值. 如果我们要求1000000以内所有数的欧拉函数,怎么办. 上面的方法复杂度将高达O(N*sqrt(N)). 暴力方法:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int a[10]={2,10,100,1000,5,7,9,11,12,13};\n    for(int i=0;i&lt;10;++i)\n        cout&lt;&lt;euler(a[i])&lt;&lt;endl;\n    return 0;\n}</code></pre><p>结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" alt></a> 我们可以将这个方法和筛法求素数的想法结合,试用筛法求出1~n内各个数字的euler(n). φ(n)=n_（1-1/p1)(1-1/p2)….(1-1/pk) 其中p1、p2…pk为n的所有素因子(这个素因子是由整数素分得来的)。 比如：φ(12)=12_(1-1/2)(1-1/3)=4。 比如求10以内所有数的φ值：</p>\n<blockquote>\n<p>1.设一数组phi[11]，赋初值phi[1]=1,phi[2]=2…phi[10]=10 2.然后从2开始循环</p>\n<blockquote>\n<p>把2的倍数的φ值<em>(1-1/2)，则phi[2]=2_1/2=1,phi[4]=4_1/2=2,phi[6]=6_1/2=3….； 再是3，3的倍数的φ值</em>(1-1/3)，则phi[3]=3_2/3=2,phi[6]=3*2/3=2，phi[9]=…..； 再5，再7…因为对每个素数都进行如此操作，因此任何一个n都得到了φ(n)=n*（1-1/p1)(1-1/p2)….(1-1/pk)的运算</p>\n</blockquote>\n</blockquote>\n<p>代码如下:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h2 id=\"AOJ-NTL-1-D-Euler’s-Phi-Function\"><a href=\"#AOJ-NTL-1-D-Euler’s-Phi-Function\" class=\"headerlink\" title=\"AOJ NTL_1_D Euler’s Phi Function\"></a>AOJ NTL_1_D Euler’s Phi Function</h2><p>这道题数值范围是1e10,没超过int.而且只需要求一个数的euler. O(lgn)暴力即可.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;euler(n)&lt;&lt;endl;\n\n    return 0;\n}</code></pre>","text":"欧拉函数: 提供1到N中与N互质的数的个数.定义和简单性质欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. 对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).性质1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"},{"name":"欧拉函数","slug":"AOJ/数论/欧拉函数","count":1,"path":"api/categories/AOJ/数论/欧拉函数.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"数论 -  幂乘以及取模相关推导","slug":"number-theory-pow-and-mod","date":"2017-11-25T06:21:18.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/number-theory-pow-and-mod.json","excerpt":"","keywords":null,"cover":null,"content":"<p>幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.</p>\n<blockquote>\n<p>mod相关</p>\n<blockquote>\n<p>:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由如下</p>\n</blockquote>\n</blockquote>\n<pre><code>设a除以M的余数和商分别为ar,aq.\nb除以M的余数和商分别为br,bq.\na*b =(aq*M+ar)*(bq*M+br)\n    =aq*bq*M^2+ar*bq*M+aq*br*M+ar*br\n    =(aq*bq*M^+ar*bq+aq*br)*M+ar*br\n\n故 (a*b)%M = ar*br\n             = a%M*b%M</code></pre><blockquote>\n<blockquote>\n<p>:arrow_forward:除法相对复杂,具体可以通过费小马定理求解.</p>\n</blockquote>\n</blockquote>\n<p>幂乘模板题: <code>NTL_1_B:Power</code></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst ull md=1000000007;\n\nll mod_pow(ull x,ull n,ull mod){\n    ull res=1;\n    while(n&gt;0){\n        if(n&amp;1) res=res*x%mod;\n        x=x*x%mod;\n        n&gt;&gt;=1;\n    }\n    return res;\n}\n\nint main(){\n    ull m,n;\n    scanf(&quot;%llu %llu&quot;,&amp;m,&amp;n);\n    printf(&quot;%lld\\n&quot;,mod_pow(m,n,md));\n    return 0;\n}</code></pre>","text":"幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.mod相关:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"}]}]}