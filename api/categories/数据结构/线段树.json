{"name":"线段树","slug":"数据结构/线段树","count":1,"postlist":[{"title":"第五届山东省ACM","slug":"five-shandong-acm","date":"2018-04-18T05:52:29.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/five-shandong-acm.json","excerpt":"","keywords":null,"cover":null,"content":"<p>D<br>=</p>\n<h2><span id=\"类型-线段树-区间更新\">类型: 线段树 区间更新</span></h2><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q,T;\n\nLL lazy[maxn];\nLL sum[maxn];\nbool flag[maxn];\n\nvoid init(){\n    memset(lazy,0,sizeof(lazy));\n    memset(sum,0,sizeof(sum));\n    memset(flag,false,sizeof(flag));\n}\n\nvoid PushDown(int p,int m){\n    if(flag[p]){\n        lazy[p&lt;&lt;1]=lazy[p&lt;&lt;1|1]=0;\n        sum[p&lt;&lt;1]=sum[p&lt;&lt;1|1]=sum[p]=0;\n        flag[p&lt;&lt;1]=flag[p&lt;&lt;1|1]=true;\n        flag[p]=false;\n    }\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nvoid setf(int p,int l,int r,int L,int R,int c){\n\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]=0;\n        sum[p]=0;\n        flag[p]=true;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) setf(p&lt;&lt;1,l,mid,L,R,c);\n    if(R&gt;mid) setf(p&lt;&lt;1|1,mid+1,r,L,R,c);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nint main(){\n    cin&gt;&gt;T;\n    while(T--){\n        init();\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n        int t,l,r,last=0;\n        LL ans=0;\n        for(int i=1;i&lt;=Q;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;t,&amp;l,&amp;r);\n            ///先更新全部区间的值\n            update(1,1,N,t-last,1,N);\n            ///然后查询所需区间内的和\n            ans+=Query(1,1,N,l,r);\n            ///最后将所需区间内的值置为0\n            setf(1,1,N,l,r,0);\n            last=t;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"D<br>=类型: 线段树 区间更新#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const in","link":"","raw":null,"photos":[],"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"线段树","slug":"数据结构/线段树","count":1,"path":"api/categories/数据结构/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]}]}