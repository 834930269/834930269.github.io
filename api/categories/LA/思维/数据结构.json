{"name":"数据结构","slug":"LA/思维/数据结构","count":1,"postlist":[{"title":"LA 3902","slug":"la-3902","date":"2017-07-10T13:21:12.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3902.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3902\" target=\"_blank\" rel=\"noopener\">Network</a></strong> <strong>【题解】</strong> <strong>可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表.</strong> <strong>最优选择放置服务器的方法是选择距离主机最远(k)的那个服务器上安装VOD即可.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203902.cpp\" target=\"_blank\" rel=\"noopener\">LA 3902.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;</p>\n<p>const int maxn=1000+10;<br>vector<int> gr[maxn],nodes[maxn];<br>int n,s,k,fa[maxn];<br>bool covered[maxn];</int></p>\n<p>///无根树转有根树,计算fa数组,根据深度把–叶子节点–插入nodes表中<br>///u当前节点下标,f,当前节点父节点下标,d深度.<br>void dfs(int u,int f,int d){<br>    fa[u]=f;<br>    int nc=gr[u].size();<br>    ///距离根节点k距离以内的叶子结点不用记录<br>    if(nc==1 &amp;&amp; d&gt;k) nodes[d].push_back(u);<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f)dfs(v,u,d+1);<br>    }<br>}</p>\n<p>void dfs2(int u,int f,int d){<br>    covered[u]=true;<br>    int nc=gr[u].size();<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f&amp;&amp;d&lt;k)dfs2(v,u,d+1);///只覆盖到新服务器不超过k的结点 ///v!=f =&gt; 如果从f访问到u,那么就不能再从u回访f.深搜嘛.一路莽到底.<br>    }<br>}</p>\n<p>int solve(){<br>    int ans=0;<br>    memset(covered,0,sizeof(covered));<br>    for(int d=n-1;d&gt;k;–d){<br>        for(int i=0;i&lt;nodes[d].size();++i){<br>            int u=nodes[d][i];<br>            if(covered[u])continue;///不考虑已经覆盖的点</p>\n<pre><code>        int v=u;\n        for(int j=0;j&lt;k;++j)v=fa\\[v\\];///找到相邻k级祖先,不可能有-1，因为之前已经把离根k的节点忽略了\n        dfs2(v,-1,0);///在结点v设置服务器,然后通过对该服务器深搜\n                     ///找到所有的叶子结点\n        ans++;\n    }\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d%d”,&amp;n,&amp;s,&amp;k);///节点数,初始VOD服务器的编号和k<br>        for(int i=1;i&lt;=n;++i){gr[i].clear();nodes[i].clear();}<br>        for(int i=0;i&lt;n-1;++i){<br>            int a,b;<br>            scanf(“%d%d”,&amp;a,&amp;b);<br>            gr[a].push_back(b);<br>            gr[b].push_back(a);<br>        }<br>        dfs(s,-1,0);<br>        printf(“%d\\n”,solve());<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【Link】 Network 【题解】 可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"数据结构","slug":"LA/思维/数据结构","count":1,"path":"api/categories/LA/思维/数据结构.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]}]}