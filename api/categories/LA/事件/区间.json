{"name":"区间","slug":"LA/事件/区间","count":1,"postlist":[{"title":"LA 3905","slug":"la-3905","date":"2017-04-05T09:18:51.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3905.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>区间扫描,  抽象成事件来做的区间扫描</strong> <strong>【题解】</strong> <strong>蓝书P45</strong> <strong><a href=\"http://blog.csdn.net/xl2015190026/article/details/52937814\" target=\"_blank\" rel=\"noopener\">另一个更详细的blog</a></strong> <strong>代码中难懂的部分都已经注释了.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>//0&lt;x+a*t&lt;w</strong> <strong>//0&lt;x+a*t&lt;w,0&lt;y+b*t&lt;h,  t&gt;0</strong> <strong>//起始坐标:(x,y) 速度:(a,b)</strong> <strong>//x横坐标运动范围(0-w) y纵坐标运动范围(0-h)</strong> <strong>//题目给的公式 在时刻t坐标:p+tv=(x,y)+(t*a,t*b)</strong> <strong>//然后根据这个范围求出出现在镜框的范围内的时间区间,开区间</strong> <strong>//因为出现在镜框上不算进入射程.</strong> <strong>void update(int x,int a,int w,double &amp;L,double &amp;R){</strong> **    if(a==0){** **        if(x&lt;=0 || x&gt;=w) R=L-1;//无解,无法出现在镜框范围内** **    }else if(a&gt;0){** **        L=max(L,-(double)x/a);** **        R=min(R,(double)(w-x)/a);** **    }else{** **        L=max(L,(double)(w-x)/a);** **        R=min(R,-(double)x/a);** **    }** <strong>}</strong> <strong>const int maxn=100000+10;</strong> <strong>struct Event{</strong> **    double x;** **    int type;//状态,0为右端点,1为左端点** **    bool operator&lt;(const Event &amp;a)const{** **        return x&lt;a.x || (x==a.x &amp;&amp; type&gt;a.type);//先处理右端点** **    }** <strong>}events[maxn*2];</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int w,h,n,e=0;** **        scanf(“%d%d%d”,&amp;w,&amp;h,&amp;n);** **        for(int i=0;i&lt;n;++i){** **            int x,y,a,b;** **            scanf(“%d%d%d%d”,&amp;x,&amp;y,&amp;a,&amp;b);** **            //0&lt;x+a*t&lt;w,0&lt;y+b*t&lt;h,  t&gt;0** **            double L=0,R=1e9;//先开一个无穷大的区间** **            update(x,a,w,L,R);** **            update(y,b,h,L,R);** **            if(R&gt;L){//只把有效可进入镜框的点加入区间** **                events[e++]=(Event){L,0};** **                events[e++]=(Event){R,1};** **            }** **        }** **        //排序区间,可以画图看下.** **        sort(events,events+e);** **        int cnt=0,ans=0;** **        for(int i=0;i&lt;e;++i){** **            if(events[i].type==0)** **                cnt++,ans=max(ans,cnt);** **            else cnt–;** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 区间扫描,  抽象成事件来做的区间扫描 【题解】 蓝书P45 另一个更详细的blog 代码中难懂的部分都已经注释了. 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; //0&lt;x+a*t&lt;w /","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"事件","slug":"LA/事件","count":1,"path":"api/categories/LA/事件.json"},{"name":"区间","slug":"LA/事件/区间","count":1,"path":"api/categories/LA/事件/区间.json"}],"tags":[{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"事件","slug":"事件","count":1,"path":"api/tags/事件.json"},{"name":"区间","slug":"区间","count":1,"path":"api/tags/区间.json"}]}]}