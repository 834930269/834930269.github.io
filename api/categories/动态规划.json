{"name":"动态规划","slug":"动态规划","count":6,"postlist":[{"title":"动态规划模板","slug":"dynamic-muban","date":"2017-04-16T04:00:16.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dynamic-muban.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【多重部分和问题】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=100000+10;</strong> <strong>int A[maxn],M[maxn],N,K;</strong> <strong>int dp[maxn];//滚动数组,当前第i个数在第j权下剩余的数量</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;N) &amp;&amp; N){** **        for(int i=0;i&lt;N;++i)** **            scanf(“%d%d”,&amp;A[i],&amp;M[i]);** **        cin&gt;&gt;K;** **        fill(dp,dp+maxn,-1);** **        dp[0]=0;** **        for(int i=0;i&lt;N;++i)** **            for(int j=0;j&lt;=K;++j){** **                if(dp[j]&gt;=0){** **                    dp[j]=M[i];** **                }else if(j&lt;A[i] || dp[j-A[i]]&lt;=0){** **                    dp[j]=-1;** **                }else{** **                    dp[j]=dp[j-A[i]]-1;** **                }** **            }** **        if(dp[K]&gt;=0) printf(“YES\\n”);** **        else puts(“NO”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【不等概率掷硬币】</strong></p>\n<blockquote>\n<p><strong>小Hi有一枚神奇的硬币。已知第i次投掷这枚硬币时，正面向上的概率是Pi。  ** **现在小Hi想知道如果总共投掷N次，其中恰好M次正面向上的概率是多少。</strong> <strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>double dp[1005][1005];</strong> <strong>int main(){</strong> <em>*    int n,m;** **    scanf(“%d%d”,&amp;n,&amp;m);** **    dp[0][0]=1.0;** **    for(int i=0;i&lt;n;++i){** **        double x;** **        scanf(“%lf”,&amp;x);** **        for(int j=0;j&lt;=i;++j){** **            dp[i+1][j]+=dp[i][j]</em>(1.0-x);** **            dp[i+1][j+1]+=dp[i][j]<em>x;*</em> **        }** **    }** **    printf(“%.6lf\\n”,dp[n][m]);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【LIS最长上升子序列】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>int A[30]={1,2,12,4,7,6,32,54,2,8784,23,212,54,59,85,2,6,542,35},N=19;</strong> <strong>int dp[20],maxmum=-INF;</strong> <strong>int main(){</strong> **    rep(i,N){** **        dp[i]=1;** **        rep(j,i){** **            if(A[j]&lt;A[i])** **                dp[i]=max(dp[i],dp[j]+1);** **        }** **        maxmum=max(maxmum,dp[i]);** **    }** **    rep(i,N){** **        printf(“%d “,dp[i]);** **    }** **    printf(“\\n%d\\n”,maxmum);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【排除62和4-数位dp】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【多重部分和问题】#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=100000+10; int A[maxn],M[maxn],N,K; int dp[maxn];//滚动数组,当前第i个数在第j","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"模板","slug":"动态规划/模板","count":1,"path":"api/categories/动态规划/模板.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"动态规划","slug":"dynamic-program","date":"2018-03-13T13:24:32.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/dynamic-program.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>痛并不快乐着..</p>\n</blockquote>\n<h1 id=\"数位dp\"><a href=\"#数位dp\" class=\"headerlink\" title=\"数位dp\"></a>数位dp</h1><blockquote>\n<p>HDU 3555</p>\n<blockquote>\n<p>不要49</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n\nLL dp[20][3];\nint digit[20];\n\nLL dfs(int pos,int pre,int state,bool jud){\n    //cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;state&lt;&lt;endl;\n    ///数位递归到0则返回\n    if(pos==0)\n        return 1;\n    ///如果有数据就返回数据\n    if(!jud&amp;&amp;dp[pos][state]!=-1)\n        return dp[pos][state];\n\n    LL ans=0;\n    int ed=jud?digit[pos]:9;\n    //cout&lt;&lt;ed&lt;&lt;endl;\n    for(int i=0;i&lt;=ed;++i){\n        if(pre==4&amp;&amp;i==9)continue;\n        ans+=dfs(pos-1,i,i==4,jud&amp;&amp;i==ed);\n    }\n    if(!jud){///不取上界时,可以取满\n        dp[pos][state]=ans;\n    }\n    return ans;\n}\n\n///数字处理函数\nLL cal(LL x){\n    int pos=0;\n    while(x){\n        digit[++pos]=x%10;\n        x/=10;\n    }\n    return dfs(pos,0,0,true);\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    int T;\n    for(scanf(&quot;%d&quot;,&amp;T);T;T--){\n        LL n;\n        scanf(&quot;%lld&quot;,&amp;n);\n        printf(&quot;%lld\\n&quot;,n-cal(n)+1);\n    }\n    return 0;\n}</code></pre><blockquote>\n<p>HDU 2089</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000000+7;\nLL dp[20][3];\nint digit[20];\n\nLL dfs(int pos,int pre,int state,bool jud){\n    //cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;state&lt;&lt;endl;\n    ///数位递归到0则返回\n    if(pos==0)\n        return 1;\n    ///如果有数据就返回数据\n    if(!jud&amp;&amp;dp[pos][state]!=-1)\n        return dp[pos][state];\n\n    LL ans=0;\n    int ed=jud?digit[pos]:9;//这句是判断他的上界\n    //cout&lt;&lt;ed&lt;&lt;endl;\n    for(int i=0;i&lt;=ed;++i){\n        if(pre==6&amp;&amp;i==2)continue;\n        if(i==4)continue;\n        ans+=dfs(pos-1,i,i==6,jud&amp;&amp;i==ed);\n    }\n    if(!jud){///不取上界时,可以取满\n        dp[pos][state]=ans;\n    }\n    return ans;\n}\n\n///数字处理函数\nLL cal(LL x){\n    int pos=0;\n    //cout&lt;&lt;&quot;tx: &quot;;\n    while(x){\n        digit[++pos]=x%10;\n        //cout&lt;&lt;x%10&lt;&lt;endl;\n        x/=10;\n    }\n    return dfs(pos,0,0,true);\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    LL n,m;\n    while(~scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m) &amp;&amp; n+m){\n        printf(&quot;%lld\\n&quot;,cal(m)-cal(n-1));\n    }\n    return 0;\n}</code></pre>","text":"痛并不快乐着..数位dpHDU 3555不要49#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL dp[20][3];int digit[20];LL dfs(int pos,int ","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"数位DP","slug":"动态规划/数位DP","count":1,"path":"api/categories/动态规划/数位DP.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"}]},{"title":"玲珑杯 R7 D-Pick Up Coin","slug":"linglong-r7-d-pick-up-coin","date":"2016-12-24T13:51:29.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/linglong-r7-d-pick-up-coin.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:</p>\n<p>dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }</p>\n<p>  【Code】(不会,代码搁置,回头看)</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int Q[1010];<br>int dp[1005][1005];<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int n;<br>    cin&gt;&gt;n;<br>    while(n–){<br>        int M;<br>        cin&gt;&gt;M;<br>        for(int i=1;i&lt;=M;++i)<br>            cin&gt;&gt;Q[i];<br>        Q[0]=Q[M+1]=1;<br>        for(int i=0;i&lt;=M+1;++i)<br>            for(int j=0;j&lt;=M+1;++j)<br>                dp[i][j]=0;<br>        for(int len=1;len&lt;=M;++len)<br>                for(int i=1,j=i+len-1;j&lt;=M;++i,++j)<br>                    for(int k=i;k&lt;=j;++k)<br>                        dp[i][j]=max(dp[i][j],dp[i][k-1]+dp[k+1][j]+Q[k]*Q[i-1]*Q[j+1]);</algorithm></p>\n<pre><code>        cout&lt;&lt;dp\\[1\\]\\[M\\]&lt;&lt;endl;\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }  【Code】(不会,代码搁置,回头看)#incl","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"OpenJudge \t程序设计与算法（二）第五周作业(2017春季)","slug":"openjudge-two","date":"2017-03-03T05:38:27.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/openjudge-two.json","excerpt":"","keywords":null,"cover":null,"content":"<p>–动态规划 【1:拦截导弹】 【Code】</p>\n<blockquote>\n<p><strong><em>#include&lt;bits/stdc++.h&gt;</em></strong> <strong><em>using namespace std;</em></strong> <strong><em>const int maxn=70;</em></strong> <strong><em>int a[maxn],N;</em></strong> <strong><em>int maxlen[maxn],m=-1;</em></strong> <strong><em>int main(){</em></strong> <strong>_    cin&gt;&gt;N;_</strong> <strong>_    for(int i=1;i&lt;=N;++i){_</strong> <strong>_        cin&gt;&gt;a[i]; maxlen[i]=1;_</strong> <strong>_    }_</strong> <strong>_    for(int i=2;i&lt;=N;++i)_</strong> <strong>_        for(int j=1;j&lt;i;++j)_</strong> <strong>_            if(a[i]&lt;=a[j]){_</strong> <strong>_                maxlen[i]=max(maxlen[i],maxlen[j]+1);_</strong> <strong>_                if(maxlen[i]&gt;m) m=maxlen[i];_</strong> <strong>_            }_</strong> <strong>_    cout&lt;&lt;m&lt;&lt;endl;_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>最长上升序列问题,目前对动规的理解走到了明白1.动规是逆着的递归.2.动规是通过从尾开始动态的更改所有的最忧解,从而找到所需要的最优解.</p>\n","text":"–动态规划 【1:拦截导弹】 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=70; int a[maxn],N; int maxlen[maxn],m=-1; int main(){","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"POJ 3356 AGTC","slug":"poj-3356-agtc","date":"2017-01-07T09:16:52.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-3356-agtc.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 动态规划:编辑距离 【题目来源】 <a href=\"http://poj.org/problem?id=3356\" target=\"_blank\" rel=\"noopener\">POJ-3356-AGTC</a> 【思路来源】 <a href=\"http://www.cnblogs.com/dongsheng/archive/2013/05/27/3102498.html\" target=\"_blank\" rel=\"noopener\">可笑痴狂</a> 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==A[i]，这样做的话， 至少需要 dp[i - 1][j] + 1步操作，即 dp[i][j] = dp[i - 1][j] + 1。 ②、我们可以删除 B[j]，这样的话，B[1…j] 变为A[1…i] 需要 dp[i][j - 1]步， 即 dp[i][j] = dp[i][j - 1] + 1。 ③、我们也可以考虑修改 B[j]，使它变为A[j]，但是如果 B[j]本来就等于 A[i]的话， 那修改其实相当于用了 0步，如果 B[j] != A[i] 的话，那修改相当于用了 1步。 所以 dp[i][j] = dp[i - 1][j - 1] + （A[i] == B[j] ? 0, 1）。 决策： 决策就很简单了，从上面三种状态转移中选择一个最小值就可以了。 处理边界： 处理好边界非常重要，这里需要注意的是对dp[0][0….m],dp[0…..n][0]的初始化， 可以这样看，dp[0][i],就是说A[1…n]是一个空串，而B[1…m]十个长度为i的串， 很显然B串变为A串就是删除i个核苷酸。 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<string></string></p>\n<p>#include<cstring><br>using namespace std;<br>char s1[1005],s2[1005];<br>int dp[1005][1005];<br>int s1l,s2l;</cstring></p>\n<p>int DP(){<br>        for(int i=0;i&lt;s1l;++i){<br>            for(int j=0;j&lt;s2l;++j){<br>                if(s1[i]==s2[j])<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]);<br>                else<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]+1);<br>            }<br>        }<br>    return dp[s1l][s2l];<br>}</p>\n<p>void init(){<br>    memset(dp,0,sizeof(dp));<br>    int tmp=max(s1l,s2l);<br>    for(int i=1;i&lt;=tmp;++i)<br>        dp[i][0]=dp[0][i]=i;<br>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;s1l&gt;&gt;s1){<br>        cin&gt;&gt;s2l&gt;&gt;s2;<br>        init();<br>        cout&lt;&lt;DP()&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 动态规划:编辑距离 【题目来源】 POJ-3356-AGTC 【思路来源】 可笑痴狂 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"编辑距离","slug":"动态规划/编辑距离","count":1,"path":"api/categories/动态规划/编辑距离.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"编辑距离","slug":"编辑距离","count":1,"path":"api/tags/编辑距离.json"}]},{"title":"玲珑杯 Round#18 C","slug":"round18-c","date":"2017-07-15T10:45:01.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/round18-c.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1146\" target=\"_blank\" rel=\"noopener\">1146 - 图论你先敲完模板</a></strong> <strong>【题解】</strong> <strong>首先我们可以想到一个简单的dp方程</strong> <strong>dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a</strong> <strong>1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算.</strong> <strong>所以我们可以从i-1往回(1)递推,如果某一点距离差大于30.则直接退出循环即可.</strong> <strong>最终结果为dp[n].且结果需要用long long存.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20C.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 C.cpp</a></strong></p>\n<hr>\n<p> **#include&lt;bits/stdc++.h&gt;</p>\n<p>#define fill(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f</p>\n<p>#pragma comment(linker, “/STACK:102400000,102400000”)<br>using namespace std;<br>const int maxn=100000+10;<br>int n;<br>long long dp[maxn],a,dt[100000+10];<br>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%lld”,&amp;n,&amp;a);<br>        for(int i=1;i&lt;=n;++i){<br>            dp[i]=1000000000000000000;<br>            scanf(“%lld”,&amp;dt[i]);<br>            for(int j=i-1;j&gt;=1;–j){<br>                long long t;<br>                if(dt[i]-dt[j]&gt;30)break;<br>                if(dp[j]!=1000000000000000000) t=dp[j];<br>                else t=0;<br>                dp[i]=min(dp[i],t+(1&lt;&lt;(dt[i]-dt[j]))+a);<br>            }<br>        }<br>        printf(“%lld\\n”,dp[n]);<br>    }<br>    return 0;<br>}**</p>\n","text":"【Topic Link】 1146 - 图论你先敲完模板 【题解】 首先我们可以想到一个简单的dp方程 dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a 1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算. 所","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]}]}