{"name":"动态规划","slug":"UVa/动态规划","count":4,"postlist":[{"title":"UVa 1025","slug":"uva-1025","date":"2016-12-25T13:49:54.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/uva-1025.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策 2:搭乘往右开的车(如果有)。 决策 3:搭乘往左开的车(如果有)。 【Code】 P268 A Spy in the Metro  </p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;<br>const int inf=0x3f3f3f3f;<br>int N,T,LN,RN,kase=0;<br>bool has_train[205][55][2];<br>int dp[205][55],ti[55];</cstring></p>\n<p>void solve(){</p>\n<pre><code>for(int i=1;i&lt;N;++i) dp\\[T\\]\\[i\\]=inf;\ndp\\[T\\]\\[N\\]=0;\n\nfor(int i=T-1;i&gt;=0;i--)\n    for(int j=1;j&lt;=N;++j){\n        dp\\[i\\]\\[j\\]=dp\\[i+1\\]\\[j\\]+1;//等待一个单位\n        if(j&lt;N&amp;&amp;has_train\\[i\\]\\[j\\]\\[0\\]&amp;&amp;i+ti\\[j\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j\\]\\]\\[j+1\\]);//右\n        if(j&gt;1&amp;&amp;has_train\\[i\\]\\[j\\]\\[1\\]&amp;&amp;i+ti\\[j-1\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j-1\\]\\]\\[j-1\\]);//左\n    }\n\n    cout&lt;&lt;&quot;Case Number &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;;\n    if(dp\\[0\\]\\[1\\]&gt;=inf) cout&lt;&lt;&quot;impossible\\\\n&quot;;\n    else cout&lt;&lt;dp\\[0\\]\\[1\\]&lt;&lt;&quot;\\\\n&quot;;</code></pre><p>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;N&amp;&amp;N){<br>        cin&gt;&gt;T;</p>\n<pre><code>    memset(has\\_train,0,sizeof(has\\_train));\n\n    for(int i=1;i&lt;=N-1;++i)\n        cin&gt;&gt;ti\\[i\\];\n    cin&gt;&gt;LN;//左端点向右开的车\n    for(int i=1;i&lt;=LN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=1;j&lt;=N-1;++j){\n            if(start&lt;=T)has_train\\[start\\]\\[j\\]\\[0\\]=true;//第t秒第j个站点有车\n            start+=ti\\[j\\];\n        }\n    }\n\n    cin&gt;&gt;RN;//右端点向左开的车\n    for(int i=1;i&lt;=RN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=N-1;j&gt;=1;--j){\n               if(start&lt;=T) has_train\\[start\\]\\[j+1\\]\\[1\\]=true;//第t秒第j个站点有车总共N个站台,往回走\n                start+=ti\\[j\\];\n        }\n    }\n    solve();\n\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"},{"name":"算法学习","slug":"UVa/动态规划/算法学习","count":1,"path":"api/categories/UVa/动态规划/算法学习.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10755","slug":"uva-10755","date":"2017-04-08T08:04:53.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-10755.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>最大子长方体和,降维.</strong> <strong>【题解】</strong> <strong>蓝书P56</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i)</strong> <strong>using namespace std;</strong> <strong>typedef long long LL;</strong> <strong>const int maxn=30;</strong> <strong>const LL INF=1LL&lt;&lt;60;</strong> <strong>LL S[maxn][maxn][maxn];</strong> <strong>void expand(int i,int&amp; b0,int&amp; b1,int&amp; b2){</strong> **    b0=i&1; i&gt;&gt;=1;** **    b1=i&1; i&gt;&gt;=1;** **    b2=i&1;** <strong>}</strong> <strong>int sign(int b0,int b1,int b2){</strong> **    return (b0+b1+b2)%2==1?1:-1;** <strong>}</strong> <strong>LL sum(int x1,int x2,int y1,int y2,int z1,int z2){</strong> **    int dx=x2-x1+1,dy=y2-y1+1,dz=z2-z1+1;** **    LL s=0;** **    for(int i=0;i&lt;8;++i){** **        int b0,b1,b2;** **        expand(i,b0,b1,b2);** **        s-=S[x2-b0*dx][y2-b1*dy][z2-b2*dz]*sign(b0,b1,b2);** **    }** **    return s;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int a,b,c,b0,b1,b2;** **        scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **        memset(S,0,sizeof(S));** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    scanf(“%lld”,&amp;S[x][y][z]);** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    for(int i=1;i&lt;=7;++i){** **                        //001 010 011 100 101 110 111三种位移** **                        expand(i,b0,b1,b2);** **                        //递推求和,sign()-&gt;加 or 减; expand()-&gt;状态** **                        S[x][y][z]+=S[x-b0][y-b1][z-b2]<em>sign(b0,b1,b2);*</em> **                    }** **        LL ans=-INF;** **        for(int x1=1;x1&lt;=a;++x1)** **            for(int x2=x1;x2&lt;=a;++x2)** **                for(int y1=1;y1&lt;=b;++y1)** **                    for(int y2=y1;y2&lt;=b;++y2){** **                        LL M=0;** **                        //对于每次求某个x1,x2,y1,y2区间上的最大子长方体和** **                        //M等价于寻找z区间上(1-z)中最小的子矩阵** **                        for(int z=1;z&lt;=c;++z){** **                            LL s=sum(x1,x2,y1,y2,1,z);** **                            ans=max(ans,s-M);** **                            M=min(M,s);** **                        }** **                    }** **                    printf(“%lld\\n”,ans);** **                    if(T) printf(“\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 最大子长方体和,降维. 【题解】 蓝书P56 【Code】#include #include #include #include #define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i) using namespace std; t","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10891","slug":"uva-10891","date":"2017-07-13T16:42:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10891.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10891\" target=\"_blank\" rel=\"noopener\">Game of Sum</a></strong> <strong>【题意】</strong> <strong>给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B).</strong> <strong>【题解】</strong> <strong>因为任意时刻游戏的状态都是连续子序列.</strong> <strong>用d(i,j)表示原序列的第i~j个元素组成的子序列.在双方都采取最优策略的情况下,先手得分的最大值.</strong> <strong>状态转移时,我们考虑从左取和从右取多少个.等价于枚举给对方剩下怎样的子序列.是(k,end)(begin&lt;k&lt;=end),还是(begin,k)(begin&lt;=k&lt;end).</strong> <strong>状态转移方程:d(begin,end)=sum(begin,end)-min{d(begin+1,end),d(begin+2,end),…,d(end,end), d(begin,end-1),d(begin,end-2),…,d(begin,begin),0}</strong> <strong>0代表全取完,所以不需要边界处理.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVa%2010891.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10891.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=100+20;<br>int A[maxn],vis[maxn][maxn],S[maxn],d[maxn][maxn];</p>\n<p>int dp(int b,int e){<br>    if(vis[b][e]) return d[b][e];///记忆化搜索<br>    vis[b][e]=1;<br>    int m=0;<br>    ///从b-&gt;e选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b+1;k&lt;=e;++k) m=min(m,dp(k,e)); ///从e-&gt;b选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b;k&lt;e;++k) m=min(m,dp(b,k));<br>    d[b][e]=S[e]-S[b-1]-m;<br>    return d[b][e];<br>}</p>\n<p>int main(){<br>    int n;S[0]=0;<br>    while(~scanf(“%d”,&amp;n) &amp;&amp; n){<br>        for(int i=1;i&lt;=n;++i){**<br> <strong>scanf(“%d”,&amp;A[i]);</strong><br> <strong>S[i]=S[i-1]+A[i];</strong><br> <strong>}</strong><br> <strong>memset(vis,0,sizeof(vis));</strong><br> <strong>printf(“%d\\n”,2*dp(1,n)-S[n]);///=&gt;dp(1,n)-(S[n]-dp(1,n))<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Game of Sum 【题意】 给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B). 【题解】 因为任意时刻游戏的状态都是连续子序列. 用d(i,j)","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 437","slug":"uva-437","date":"2017-04-16T14:34:35.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-437.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>DAG上的DP</strong> <strong>下面的代码一是转换成最长单增子序列LIS做的</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=300;</strong> <strong>struct star{</strong> **    int a,b,c;** **    bool operator&lt;(const star &amp;A)const{** **        return a==A.a?b&lt;A.b:a&lt;A.a;** **    }** <strong>};</strong> <strong>star S[maxn];</strong> <strong>int N,kase=1;</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        int x,y,z,k=0;** **        rep(i,N){** **            SIII(x,y,z);** **            S[k].a=x;S[k].b=y;S[k++].c=z;** **            S[k].a=x;S[k].c=y;S[k++].b=z;** **            S[k].b=x;S[k].a=y;S[k++].c=z;** **            S[k].b=x;S[k].c=y;S[k++].a=z;** **            S[k].c=x;S[k].b=y;S[k++].a=z;** **            S[k].c=x;S[k].a=y;S[k++].b=z;** **        }** **        sort(S,S+k);** **        int ans=-INF,dp[maxn];** **        rep(i,k){** **            dp[i]=S[i].c;** **            rep(j,i){** **                if(S[j].a&lt;S[i].a &amp;&amp; S[j].b&lt;S[i].b){** **                    dp[i]=max(dp[i],dp[j]+S[i].c);** **                }** **            }** **            ans=max(ans,dp[i]);** **        }** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>代码二</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=30+5;</strong> <strong>int N,kase=1,blocks[maxn][3],d[maxn][3];</strong> <strong>void get_dimensions(int* v,int b,int dim){</strong> **    int idx=0;** **    rep(i,3) if(i!=dim) v[idx++]=blocks[b][i];** <strong>}</strong> <strong>int dp(int i,int j){</strong> **    int&amp; ans=d[i][j];** **    if(ans&gt;0) return ans;** **    ans=0;** **    int v[2],v2[2];** **    get_dimensions(v,i,j);** **    rep(a,N) rep(b,3){** **        get_dimensions(v2,a,b);** **        if(v2[0]&lt;v[0] &amp;&amp; v2[1]&lt;v[1]) ans=max(ans,dp(a,b));** **    }** **    ans+=blocks[i][j];** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        rep(i,N){** **            rep(j,3) SI(blocks[i][j]);** **            sort(blocks[i],blocks[i]+3);** **        }** **        cle(d,0);** **        int ans=0;** **        rep(i,N) rep(j,3) ans=max(ans,dp(i,j));** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 DAG上的DP 下面的代码一是转换成最长单增子序列LIS做的 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}