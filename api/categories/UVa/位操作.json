{"name":"位操作","slug":"UVa/位操作","count":2,"postlist":[{"title":"UVa  11464","slug":"uva-11464","date":"2017-03-31T12:59:56.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-11464.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>gird 网格,格子</strong> <strong>so taht 以便</strong> <strong>The parity 奇偶校验</strong> <strong>even 有偶数意</strong> <strong>transformation 转化</strong> <strong>achieve 取得,获得,实现,成功</strong> <strong>requirement 要求</strong> <strong>indicates 表明</strong> <strong>character 性格,品质</strong> <strong>separated 分开,隔开</strong> <strong>instead 代替,反而,相反</strong> <strong>【题解】</strong> <strong>蓝书 P16</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<algorithm></algorithm></strong> <strong>using namespace std;</strong> <strong>const int INF=0x3f3f3f3f;</strong> <strong>const int maxn=20;</strong> <strong>int A[maxn][maxn],B[maxn][maxn],n,T,ca=1;</strong> <strong>int check(int s){</strong> **    memset(B,0,sizeof(B));** <strong>//先初始化第一行</strong> **    for(int i=0;i&lt;n;++i){** **        if(s &amp; (1&lt;&lt;i)) B[0][i]=1;//这句意思是判断每一位上是否是1** <strong>//即(1&lt;&lt;n)只有第n位是1,其他位都是0 为真即为1</strong> <strong>else if(A[0][i]==1) return INF;//1不能变成0</strong> **    }** **    for(int i=1;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            int sum=0;//元素B[i-1][0]的上,左,右元素之和** **            if(i&gt;1)sum+=B[i-2][j];** **            if(j&gt;0)sum+=B[i-1][j-1];** <strong>if(j&lt;n-1)sum+=B[i-1][j+1];</strong> **            B[i][j]=sum%2;//sum是偶数,=0,奇数,=1** **            if(A[i][j]==1 &amp;&amp; B[i][j]==0) return INF;** <strong>//不存在1-&gt;0的操作.</strong> <strong>}</strong> **    }** **    int cnt=0;** **    for(int i=0;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            if(A[i][j]!=B[i][j])** <strong>cnt++;</strong> <strong>}</strong> <strong>}</strong> <strong>return cnt;</strong> <strong>}</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        printf(“Case %d: “,ca++);** **        scanf(“%d”,&amp;n);** **        for(int i=0;i&lt;n;++i)** **            for(int j=0;j&lt;n;++j)** **                scanf(“%d”,&amp;A[i][j]);** <strong>int ans=INF;</strong> **        for(int i=0;i&lt;(1&lt;&lt;n);++i)** <strong>ans=min(ans,check(i));</strong> **        if(ans==INF) ans=-1;** <strong>printf(“%d\\n”,ans);</strong> <strong>}</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 gird 网格,格子 so taht 以便 The parity 奇偶校验 even 有偶数意 transformation 转化 achieve 取得,获得,实现,成功 requirement 要求 indicates 表明 character 性格,品质 separ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"枚举","slug":"UVa/位操作/枚举","count":1,"path":"api/categories/UVa/位操作/枚举.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"}]},{"title":"UVa 11825","slug":"uva-11825","date":"2017-07-14T16:41:09.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-11825.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-11825\" target=\"_blank\" rel=\"noopener\">Hackers’ Crackdown</a></strong> <strong>【题意】</strong> <strong>有N台机器，每台机器上有N个服务</strong> <strong>你可以对每台机器选择关闭他以及和他相邻的机器的一种服务</strong> <strong>当所有机器不能运行一个服务时，就是摧毁了一种服务</strong> <strong>问你最多能摧毁多少个服务</strong> <strong>【题解】</strong> <strong>就是把n台电脑看成n个集合,每个集合的成员就是这台电脑,以及和这台电脑相邻的电脑;</strong> <strong>我们就是要求把这些集合合并成尽量多的大集合,使每个集合都等于全集;也就是因为最开始的小集合,我们可以让它里面全部电脑的某一项服务全部失误,那如果合并成一个大集合,则这个大集合的某一项服务可以全部失效;所以能合并成几个等于全集的大集合,就可以让几项服务失效;</strong> <strong>【Tip】</strong> <strong>状态压缩,异或操作是相同得0,不同得1.LRJ这道题的位运算用的好…</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2011825.cpp\" target=\"_blank\" rel=\"noopener\">Uva 11825.cpp</a></strong></p>\n<hr>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int N,T,P[1&lt;&lt;17],f[1&lt;&lt;17],cover[1&lt;&lt;17],ca=1;<br>int main(){<br>    while(~scanf(“%d”,&amp;N),N){<br>        ///初始化第i台计算机的相邻集合<br>        for(int i=0;i&lt;N;++i){<br>            int n,m;<br>            scanf(“%d”,&amp;n);<br>            P[i]=1&lt;&lt;i;<br>            for(int j=0;j&lt;n;++j){<br>                scanf(“%d”,&amp;m);<br>                P[i] |= 1&lt;&lt;m;<br>            }<br>        }<br>        ///S是N个计算机的所有组合的集合,二进制表示,cover[S]是集合的并<br>        for(int S=0;S&lt;(1&lt;&lt;N);++S){<br>            cover[S]=0;<br>            for(int i=0;i&lt;N;++i){<br>                if(S &amp; (1&lt;&lt;i)) cover[S] |= P[i];///第i台机器选/不选<br>            }<br>        }<br>        f[0]=0;<br>        int ALL=(1&lt;&lt;N)-1;///全集二进制表示<br>        for(int S=1;S&lt;(1&lt;&lt;N);++S){<br>            f[S]=0;<br>            ///筛出S的子集进行动态规划<br>            for(int S0=S;S0;S0=(S0-1)&amp;S){<br>                if(cover[S0]==ALL)///如果子集S的子集的并是全集<br>                    f[S]=max(f[S],f[S^S0]+1);<br>            }<br>        }<br>        printf(“Case %d: %d\\n”,ca++,f[ALL]);<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Hackers’ Crackdown 【题意】 有N台机器，每台机器上有N个服务 你可以对每台机器选择关闭他以及和他相邻的机器的一种服务 当所有机器不能运行一个服务时，就是摧毁了一种服务 问你最多能摧毁多少个服务 【题解】 就是把n台电脑看成n个集合,每","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"动态规划","slug":"UVa/位操作/动态规划","count":1,"path":"api/categories/UVa/位操作/动态规划.json"},{"name":"状态压缩","slug":"UVa/位操作/动态规划/状态压缩","count":1,"path":"api/categories/UVa/位操作/动态规划/状态压缩.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}]}]}