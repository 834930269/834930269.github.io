{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"postlist":[{"title":"UVa 11401","slug":"uva-11401","date":"2018-02-04T10:10:32.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11401.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVA-11401\" title=\"https://vjudge.net/problem/UVA-11401\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11401</a></p>\n<h1><span id=\"type\">type</span></h1><p>组合数学,加法原理,三角形三边定理</p>\n<h1><span id=\"题意\">题意</span></h1><p>给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>考虑三角形三边定理.</p>\n<blockquote>\n<p>设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条边. 则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边) 考虑y的取值,确定z的取值.</p>\n<blockquote>\n<p>y∈[1,x-1] 当y取1时,z无值.当y取2时,z有唯一值x-1 当y取3时,z可以取(x-1),(x-2). 故y取x-1时,z可以取的种数为x-2种.</p>\n<blockquote>\n<p>根据等差数列求和公式: 总种类数Sn = 0+1+2+…+(x-2)</p>\n</blockquote>\n<p>Sn = (x-2)(x-1)/2(种) 但这个值并不等于c(x) 因为:</p>\n<blockquote>\n<p>1.对于每个三角形都计数了两遍 =&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2 2.以上的计算方式存在y=z的情况 (这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z) =&gt; 比如x=7 y=4时,z就可以取到4</p>\n<blockquote>\n<p>对于第二种问题的解决很简单. 对于每个x考虑y==z的情况: 设t为c(x)中y=z时的情况总数: 则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.</p>\n</blockquote>\n<p>故t=(x-1)-(x/2+1)+1=x-1-(int)x/2</p>\n</blockquote>\n</blockquote>\n<p>故c(x)=(Sn-t)/2</p>\n<blockquote>\n<p>又因为c(x)是最长边为x时的种类数.</p>\n</blockquote>\n<p>故设f(n)为最长边不超过n时的种类数 根据加法原理,因为互无交集 故 f(n)=c(1)+c(2)+c(3)+…+c(n)</p>\n</blockquote>\n<p>化成递推: f(n)=f(n-1)+c(n)</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11401\ntype: 组合数学,加法原理,三角形三边定理\n题意: 给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形\n\n题解:\n考虑三角形三边定理.\n设c(x)为以x为最长边的可拼成三角形的数目.\n设y,z为另外两条边.\n则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边)\n考虑y的取值,确定z的取值.\ny∈[1,x-1]\n当y取1时,z无值.当y取2时,z有唯一值x-1\n当y取3时,z可以取(x-1),(x-2).\n故y取x-1时,z可以取的种数为x-2种.\n根据等差数列求和公式:\n总种类数Sn\n= 0+1+2+...+(x-2)\n= (x-2)(x-1)/2(种)\n但这个值并不等于c(x)\n因为:\n1.对于每个三角形都计数了两遍\n=&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2\n2.以上的计算方式存在y=z的情况\n(这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z)\n=&gt; 比如x=7 y=4时,z就可以取到4\n对于第二种问题的解决很简单.\n对于每个x考虑y==z的情况:\n设t为c(x)中y=z时的情况总数:\n则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.\n故t=(x-1)-(x/2+1)+1=x-1-(int)x/2\n故c(x)=(Sn-t)/2\n又因为c(x)是最长边为x时的种类数.\n故设f(n)为最长边不超过n时的种类数\n根据加法原理,因为互无交集\n故 f(n)=c(1)+c(2)+c(3)+...+c(n)\n化成递推: f(n)=f(n-1)+c(n)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nlong long sum[maxn];\nint n;\ninline void init(){\n    long long Sn,Cn,t;\n    memset(sum,0,sizeof(sum));\n    for(long long i=4;i&lt;=1000000;++i){\n        Sn=(i-2)*(i-1)/2;\n        t=i-1-i/2;\n        Cn=(Sn-t)&gt;&gt;1;\n        int id=(int)i;\n        sum[id]=sum[id-1]+Cn;\n    }\n}\nint main(){\n    init();\n    while(cin&gt;&gt;n){\n        if(n&lt;3)break;\n        cout&lt;&lt;sum[n]&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11401type组合数学,加法原理,三角形三边定理题意给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形题解考虑三角形三边定理.设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11538","slug":"uva-11538","date":"2018-02-04T04:55:35.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11538.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"题目连接\">题目连接：</span></h1><p><a href=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" title=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" target=\"_blank\" rel=\"noopener\">https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087</a> PS: 蓝书P105，书上有一个错误的地方,Sigma(1<del>n-1) i(i-1)那里书上得到的结果是2*Sigma(1</del>n-1) i(i-1)的结果.我在代码中标注了.</p>\n<h1><span id=\"link\">Link:</span></h1><p><a href=\"https://vjudge.net/problem/UVA-11538\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11538</a> type: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6</p>\n<h1><span id=\"题意\">题意:</span></h1><p>有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.</p>\n<h1><span id=\"题解\">题解:</span></h1><blockquote>\n<p>分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线</p>\n<blockquote>\n<p>同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1) 同一列: 合同一行类似,结果是nm(n-1) 同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)</p>\n<blockquote>\n<p>可以观测到所有’/‘方向的斜线长度为: 1,2,3,…,n,n,n,n-1,n-2…,2,1 其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可) 其中每条斜线上的取法种数 = i<em>(i-1) diagonal=Sigma(1~n-1) i(i-1) =&gt; i==1时确实是0种可能,因为皇后是放在块内而不是点上的. 则 All_diagonal = 2(2*diagonal+(m-n+1)*n</em>(n-1)) =&gt; 这里的乘2是因为有两种斜线’/‘和’\\‘的可能 其中</p>\n<blockquote>\n<p>diagonal =Sigma(1<del>n-1) i^2 - Sigma(1</del>n-1) i =n(n-1)(2n-1)/6 - n(n-1)/2 =n(n-1)(2n-4)/6 All_diagonal = 2(2<em>(n(n-1)(2n-4)/6)+(m-n+1)*n\\</em>(n-1)) = 2n(n-1)(3m-n-1)/3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>这三种情况互不相交,最终答案就等于三者和.</p>\n</blockquote>\n<p>Code:</p>\n<pre><code>/*\nLink: https://vjudge.net/problem/UVA-11538\ntype: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6\n\n题意: 有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.\n\n题解: 分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线\n\n同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1)\n同一列: 合同一行类似,结果是nm(n-1)\n同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)\n    可以观测到所有&apos;/&apos;方向的斜线长度为: 1,2,3,...,n,n,n,n-1,n-2...,2,1\n    其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可)\n    其中每条斜线上的取法种数 = i*(i-1)\n    diagonal=Sigma(1~n-1) i(i-1)   =&gt;   i==1时确实是0种可能,因为皇后是放在块内而不是点上的.\n    则   All_diagonal = 2(2*diagonal+(m-n+1)*n*(n-1))  =&gt; 这里的乘2是因为有两种斜线&apos;/&apos;和&apos;\\&apos;的可能\n    其中diagonal=Sigma(1~n-1) i^2 - Sigma(1~n-1) i  =&gt;n方和展开公式,等差数列求和\n                =n(n-1)(2n-1)/6 - n(n-1)/2\n                =n(n-1)(2n-4)/6\n\n        All_diagonal = 2(2*(n(n-1)(2n-4)/6)+(m-n+1)*n*(n-1))\n                     = 2n(n-1)(3m-n-1)/3\n\n这三种情况互不相交,最终答案就等于三者和.\n*/\n\n//Code\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nunsigned long long N,M;\nint main(){\n    while(cin&gt;&gt;N&gt;&gt;M){\n        if(N==0&amp;&amp;M==0)break;\n        unsigned long long row=N*M*(M-1);\n        unsigned long long column=N*M*(N-1);\n\n        if(N&gt;M) swap(N,M);\n        cout&lt;&lt;row+column+2*N*(N-1)*(3*M-N-1)/3&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"题目连接：https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087 PS: 蓝书P105，书上有一个错误的地方,Sigma(1n-1) i(i-1)那里书上得到的结果是2*Sigma(1n-","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1262","slug":"uva-1262","date":"2017-01-13T15:45:11.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1262.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 组合数学 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-1262\" target=\"_blank\" rel=\"noopener\">UVa-1262-Password</a> 【思路】 见紫书P323例10-8 【WA Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;</cstring></p>\n<p>char m[8][8];<br>char a[8][8];<br>int reg[8][8]={0},n;</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=reg[i][0];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=reg[i][0];<br>        j=n/tot;<br>        printf(“%c”,reg[i][j+1]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        memset(reg,0,sizeof(reg));<br>        int flag=1;<br>        cin&gt;&gt;n;<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>for(int i=1;i&lt;=6;++i)\n        scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\nfor(int j=1;j&lt;=5;++j)\n    for(int t=1;t&lt;=6;++t)\n        for(int i=1;i&lt;=6;++i)\n            if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\]){\n                reg\\[j\\]\\[++reg\\[j\\]\\[0\\]\\]=a\\[t\\]\\[j\\];\n                break;\n            }\n\nfor(int t=1;t&lt;=5;++t){\n    if(reg\\[t\\]\\[0\\]==0) flag=0;\n    sort(&amp;reg\\[t\\]\\[1\\],&amp;reg\\[t\\]\\[reg\\[t\\]\\[0\\]+1\\]);\n}</code></pre><p> /*<br>        for(int t=1;t&lt;=5;++t){<br>            for(int q=1;q&lt;=reg[t][0];++q)<br>                printf(“%c “,reg[t][q]);<br>            printf(“\\n”);<br>        }<br>        */</p>\n<pre><code>    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n<p>【AC Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>char m[10][10];<br>char a[10][10];<br>int n,k[10];<br>vector<char> v[10];</char></p>\n<p>bool init(){</p>\n<p>}</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=k[i];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=k[i];<br>        j=n/tot;<br>        printf(“%c”,v[i][j]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    scanf(“%d”,&amp;N);<br>    while(N–){<br>        for(int i=1;i&lt;=5;++i) v[i].clear();<br>        int flag=1;<br>        scanf(“%d”,&amp;n);<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>    for(int i=1;i&lt;=6;++i)\n            scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\n    for(int j=1;j&lt;=5;++j)\n        for(int t=1;t&lt;=6;++t)\n            for(int i=1;i&lt;=6;++i)\n                if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\])\n                    v\\[j\\].push_back(a\\[t\\]\\[j\\]);\n\n    for(int i=1;i&lt;=5;++i){\n        if(v\\[i\\].empty()){\n            flag=0;\n            break;\n        }\n        sort(v\\[i\\].begin(),v\\[i\\].end());\n        unique(v\\[i\\].begin(),v\\[i\\].end());\n        k\\[i\\]=0;\n        while(k\\[i\\]&lt;v\\[i\\].size()-1 &amp;&amp; v\\[i\\]\\[k\\[i\\]+1\\]&gt;v\\[i\\]\\[k\\[i\\]\\]) k\\[i\\]++;\n        k\\[i\\]++;\n    }\n\n    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n","text":"【类型】 组合数学 【题目来源】 UVa-1262-Password 【思路】 见紫书P323例10-8 【WA Code】#include#include#include#include<br>using namespace std;char m[8][8];<br>char ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}