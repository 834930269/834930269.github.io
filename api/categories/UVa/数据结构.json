{"name":"数据结构","slug":"UVa/数据结构","count":3,"postlist":[{"title":"UVa 210","slug":"uva-210","date":"2017-01-24T06:09:29.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-210.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构&lt;双端队列&gt;,STL 【Tip】 deque容器的介绍.这里我看的是C++标准程序库P160.队头操作用 <strong>front();队尾</strong>back(); 【题意】 紫书P139 给定n个程序，每种程序有五种操作，分别为 var = constant(赋值)，print var (打印)， lock, unlock，end 变量用小写字母表示，初始化为0，为程序所公有（一个程序里对某个变量修改可以会影响其他程序里的这个变量）， 常数小于100（也就是说最多两位数）。 每个时刻都只能有一个程序处于运行状态，其他的都在等待，上述五种操作用时分别是t1, t2, t3, t4, t5。运行中的程序， 每次最多能运行q个时间，当q个时间被用完后，它会被放在等待队列的尾部，然后再从首部取出一个程序运行，初始等待队列按输入顺序， 但是lock和unlock会改变顺序，它们总是成对出现，不会出现嵌套。如果某个程序已经执行了lock，后面还有程序执行lock， 那么这个程序就会马上被放到一个阻止队列的尾部（当然如果运行时间还没用完也就浪费了）。当unlock结束后，阻止队列中的第一个程序进入等待队列的首部。 (敲一遍就知道什么意思了.) 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<queue></queue></em> <em>#include<cstring></cstring></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>const int maxn=1000;</em> <em>deque<int> readyQ;</int></em> <em>queue<int> blockQ;</int></em> <em>int n,quantum,c[5],var[26],ip[maxn];//ip为指令的位置</em> <em>bool locked;</em> <em>char prog[maxn][10];//指令</em> <em>void run(int pid){</em> _    int q=quantum;_ _    while(q&gt;0){_ _        char* p=prog[ip[pid]];_ _        switch(p[2]){_ _            case ‘=’://var=constant_ _                var[p[0]-‘a’]=isdigit(p[5])?(p[4]-‘0’)*10+p[5]-‘0’ : p[4]-‘0’;_ _                q-=c[0];_ _                break;_ _            case ‘i’://print_ _                printf(“%d: %d\\n”,pid+1,var[p[6]-‘a’]);_ _                q-=c[1];_ _                break;_ _            case ‘c’://lock_ _                if(locked) { blockQ.push(pid); return; }_ _                locked=true;_ _                q-=c[2];_ _                break;_ _            case ‘l’://unlock_ _                locked=false;_ _                if(!blockQ.empty()){_ _                    int pid2=blockQ.front(); blockQ.pop();_ _                    readyQ.push_front(pid2);_ _                }_ _                q-=c[3];_ _                break;_ _            case ‘d’://end_ _                return;_ _        }_ _        ip[pid]++;_ _    }_ _    readyQ.push_back(pid);_ <em>}</em> <em>int main(){</em> _    int T;_ _    scanf(“%d”,&amp;T);_ _    while(T–){_ _            scanf(“%d %d %d %d %d %d %d\\n”,&amp;n,&amp;c[0],&amp;c[1],&amp;c[2],&amp;c[3],&amp;c[4],&amp;quantum);_ _            memset(var, 0, sizeof(var));_ _            int line=0;_ _            for(int i=0;i&lt;n;++i){_ _                fgets(prog[line++],maxn,stdin);_ _                ip[i]=line-1;_ _                while(prog[line-1][2]!=’d’)_ _                    fgets(prog[line++],maxn,stdin);_ _                readyQ.push_back(i);_ _            }_ _            locked=false;_ _            while(!readyQ.empty()){_ _                int pid=readyQ.front(); readyQ.pop_front();_ _                run(pid);_ _            }_ _          if(T) printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>Save</p>\n","text":"【类型】 数据结构&lt;双端队列&gt;,STL 【Tip】 deque容器的介绍.这里我看的是C++标准程序库P160.队头操作用 front();队尾back(); 【题意】 紫书P139 给定n个程序，每种程序有五种操作，分别为 var = constant(赋值)，pr","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 442","slug":"uva-442","date":"2017-01-24T15:17:02.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-442.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构,栈,STL 【Tip】 这道题和四则运算入栈规则一样,是数字入栈,凡遇到 ‘)’ 则操作前两个字符(这里是矩阵). 矩阵链乘,A(m,n),B(n,d).A(n)==B(n)才成立. 注意.入栈顺序与出栈顺序是相反的,而矩阵链乘不满足乘法交换律.所以(AB)!=(BA)也存在(AB)有值(BA)无值. (这道题没在每条语句执行结束时清空栈,意在.in数据全部有效?)(大雾 【Code】</p>\n<blockquote>\n<p><strong><em>#include<iostream></iostream></em></strong> <strong><em>#include<algorithm></algorithm></em></strong> <strong><em>#include<cstdio></cstdio></em></strong> <strong><em>#include<cstring></cstring></em></strong> <strong><em>#include<stack></stack></em></strong> <strong><em>#include<string></string></em></strong> <strong><em>using namespace std;</em></strong> <strong><em>struct Matrix{</em></strong> <strong>_    int m,n;_</strong> <strong>_    Matrix(int a=0,int b=0):m(a),n(b) {}_</strong> <strong><em>}m[27];</em></strong> <strong><em>stack<matrix> s;</matrix></em></strong> <strong><em>int main(){</em></strong> <strong>_    int n;_</strong> <strong>_    scanf(“%d”,&amp;n);_</strong> <strong>_    for(int i=0;i&lt;n;++i){_</strong> <strong>_        string name;_</strong> <strong>_        cin&gt;&gt;name;_</strong> <strong>_        int k=name[0]-‘A’;_</strong> <strong>_        scanf(“%d%d”,&amp;m[k].m,&amp;m[k].n);_</strong> <strong>_    }_</strong> <strong>_    string expt;_</strong> <strong>_    while(cin&gt;&gt;expt){_</strong> <strong>_        int len=expt.length();_</strong> <strong>_        bool error=false;_</strong> <strong>_        int ans=0;_</strong> <strong>_        for(int i=0;i&lt;len;++i){_</strong> <strong>_            if(isalpha(expt[i])) s.push(m[expt[i]-‘A’]);_</strong> <strong>_            else if(expt[i]==’)’){_</strong> <strong>_                Matrix m2=s.top();s.pop();//这两句注意顺序.比如(AB)肯定是A先入栈,所以第一个出栈的肯定是B_</strong> <strong>_                Matrix m1=s.top();s.pop();_</strong> <strong>_                if(m1.n!=m2.m){_</strong> <strong>_                    error=true;_</strong> <strong>_                    break;_</strong> <strong>_                }else{_</strong> <strong>_                    ans+=m1.n*m1.m*m2.n;_</strong> <strong>_                    s.push(Matrix(m1.m,m2.n));_</strong> <strong>_                }_</strong> <strong>_            }_</strong> <strong>_        }_</strong> <strong>_        if(error) printf(“error\\n”);_</strong> <strong>_        else printf(“%d\\n”,ans);_</strong> <strong>_    }_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>Save</p>\n","text":"【类型】 数据结构,栈,STL 【Tip】 这道题和四则运算入栈规则一样,是数字入栈,凡遇到 ‘)’ 则操作前两个字符(这里是矩阵). 矩阵链乘,A(m,n),B(n,d).A(n)==B(n)才成立. 注意.入栈顺序与出栈顺序是相反的,而矩阵链乘不满足乘法交换律.所以(AB)!","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 514","slug":"uva-514","date":"2017-01-24T13:11:51.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-514.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构,栈,STL 【Tip】 印象中好像可以不模拟栈的操作,根据定义来判断？(雾 水题. 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>#include<cstring></cstring></em> <em>#include<stack></stack></em> <em>#define maxn 2000</em> <em>using namespace std;</em> <em>int N,target[maxn],B;</em> <em>bool locked;</em> <em>int main(){</em> _    while(scanf(“%d”,&amp;N),N){_ _        while(scanf(“%d”,&amp;target[0]),target[0]){_ _            stack<int> s;_ _            locked=false;_ _            B=target[0]+1;//B用来记录入栈后最大的那个元素,之后入栈以它为下限._ _            for(int i=1;i&lt;target[0];++i)_ _                s.push(i);_ _            for(int i=1;i&lt;N;++i){_ _                scanf(“%d”,&amp;target[i]);_ _                if(!s.empty() &amp;&amp; !locked){_ _                    if(s.top()==target[i]) s.pop();_ _                    else if(target[i]&lt;s.top()) locked=true;_ _                    else if(target[i]&gt;s.top() &amp;&amp; B){_ _                        for(int j=B;j&lt;target[i];++j)_ _                            s.push(j);_ _                        B=target[i]+1;_ _                    }_ _                }else if(!locked){_ _                    for(int j=B;j&lt;target[i];++j)_ _                            s.push(j);_ _                    B=target[i]+1;_ _                }_ _            }_ _            printf(“%s\\n”,locked?”No”:”Yes”);_ _        }_ _        printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></int></p>\n</blockquote>\n","text":"【类型】 数据结构,栈,STL 【Tip】 印象中好像可以不模拟栈的操作,根据定义来判断？(雾 水题. 【Code】#include #include #include #include #include #define maxn 2000 using namespace std","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}