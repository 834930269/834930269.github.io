{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"postlist":[{"title":"UVa 10375","slug":"uva-10375","date":"2017-01-08T14:19:03.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10375.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,素数筛法 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10375\" target=\"_blank\" rel=\"noopener\">UVa-10375-Choose and divide</a> 【唯一分解定理】 任何一个大于1的自然数<em>N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N</em>=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为素数，其中指数ai是正整数。这样的分解称为<em>N</em>的标准分解式. 【思路】 根据题意得: 给定p q r s 求 ①.(p!<em>s!</em>(r-s)!)/(r!<em>q!</em>(p-q)!) 暴力会炸,至于为啥.</p>\n<p>10000! 总位数：35660位,要不要试试？</p>\n<p>1.先筛10000以内的素数. 2.数组e表示当前结果的唯一分解式中各个素数的指数,prime数组第i位的指数是多少.如:e={1，0，2，0，0，0 …}表示pow(2,1)*pow(5,2)=50 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath></cmath></p>\n<p>#define MAXN 10000<br>using namespace std;</p>\n<p>int prime[MAXN];<br>bool is_prime[MAXN];<br>int primesize=0,p,q,r,s;</p>\n<p>int e[MAXN];</p>\n<p>void sieve(){<br>    memset(is_prime,1,sizeof(is_prime));<br>    is_prime[1]=is_prime[0]=false;<br>    for(int i=0;i&lt;MAXN;++i){<br>        if(is_prime[i]){<br>            prime[primesize++]=i;<br>            for(int j=i*2;j&lt;MAXN;j+=i)<br>                is_prime[j]=false;<br>        }<br>    }<br>}</p>\n<p>//乘以或除以n,d=1表示乘,d=-1表示除<br>void add_integer(int n,int d){<br>    for(int i=0;i&lt;primesize;++i){<br>        while(n%prime[i]==0){//必须是while<br>            n/=prime[i];<br>            e[i]+=d;<br>        }<br>        if(n==1)break;//提前终止循环,节约时间<br>    }<br>}</p>\n<p>void add_factorial(int n,int d){<br>    for(int i=1;i&lt;=n;++i)<br>        add_integer(i,d);<br>}</p>\n<p>int main(){<br>    sieve();<br>    while(cin&gt;&gt;p&gt;&gt;q&gt;&gt;r&gt;&gt;s){<br>        memset(e,0,sizeof(e));<br>        //以下一串表示上面的公式①的分子和分母.<br>        add_factorial(p,1);<br>        add_factorial(s,1);<br>        add_factorial(r-s,1);<br>        add_factorial(q,-1);<br>        add_factorial(r,-1);<br>        add_factorial(p-q,-1);<br>        double ans=1;<br>        for(int i=0;i&lt;primesize;++i)<br>            ans*=pow(prime[i],e[i]);<br>        printf(“%.5lf\\n”,ans);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,素数筛法 【题目来源】 UVa-10375-Choose and divide 【唯一分解定理】 任何一个大于1的自然数N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10791","slug":"uva-10791","date":"2017-01-09T05:11:28.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10791.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10791\" target=\"_blank\" rel=\"noopener\">UVa-10791-Minimum Sum LCM</a> 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因子(一定是素数)加到最后的结果中. 其过程等同于素数筛法,先筛2^a1,再筛3^a2 …其筛出的ai不为0的因子的底数一定是素数.因为  *唯一分解定理:一个数可以分解为若干素数的幂相乘的形式. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath><br>using namespace std;<br>typedef long long LL;</cmath></p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    LL N;<br>    int lam=1;<br>    while(cin&gt;&gt;N){<br>        if(N&lt;=0)break;<br>        LL sum=0,cnt=0;<br>        for(int i=2;i&lt;=sqrt(N);++i){<br>            if(N%i==0){<br>                LL mut=1;<br>                cnt++;<br>                while(N%i==0){<br>                    N/=i;<br>                    mut*=i;<br>                }<br>                sum+=mut;<br>            }<br>        }<br>        if(N&gt;1 || cnt==0){<br>            //这里的N是计算以后偶剩下的N,这个N一定是一个素数,直接加即可<br>            sum+=N;<br>            cnt++;<br>        }<br>        if(cnt==1) sum++;<br>       printf(“Case %d: %lld\\n”,lam++,sum);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 UVa-10791-Minimum Sum LCM 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}