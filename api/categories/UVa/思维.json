{"name":"思维","slug":"UVa/思维","count":4,"postlist":[{"title":"UVa 10795","slug":"uva-10795","date":"2017-07-09T13:06:29.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10795.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10795\" target=\"_blank\" rel=\"noopener\">A Different Task</a></strong> <strong>汉诺塔问题总结:</strong> <a href=\"http://blog.csdn.net/xueerfei008/article/details/9904681\" target=\"_blank\" rel=\"noopener\"><strong>杭电 汉诺塔问题总结</strong></a> <strong>【题解】</strong> <strong>大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标.</strong> <strong>f(P,i,final):已知各盘子的初始柱子编号数组为P,把盘子1,2,3,4…i全部移到柱子final所需的步数.</strong> <strong>参考局面等于中转态.即中转柱子下标为6-P[i]-finish[i].将前i-1个盘子移动到中转柱上.然后把盘子i移动到final柱子上,最后将i-1个盘子从中转态移动到final.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2010795.cpp\" target=\"_blank\" rel=\"noopener\">UVA 10795.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long LL;</p>\n<p>LL f(int* P,int i,int finaln){<br>    if(i==0) return 0;<br>    ///如果当前最大的这个号的起始盘子等于最终落脚盘子<br>    ///不用移动.所以f(P,i,final)=f(P,i-1,final)<br>    if(P[i]==finaln) return f(P,i-1,finaln);<br>    ///经典汉诺塔的结论,将前i-1个盘子从一个柱子移动到另一个柱子<br>    ///这个步骤需要2^(i-1)-1步.加上移动盘子i到最终盘子<br>    ///的那一步,一共需要2^(i-1)步.<br>    return f(P,i-1,1+2+3-P[i]-finaln)+(1LL&lt;&lt;(i-1));<br>}</p>\n<p>const int maxn=60+10;<br>int n,start[maxn],finish[maxn];</p>\n<p>int main(){<br>    int kase=0;<br>    while(scanf(“%d”,&amp;n)==1&amp;&amp;n){<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;start[i]);<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;finish[i]); ///结论:如果最大的盘子一开始就在最终的柱子上 ///则不用移动. ///找到号码最大的那几个不需要移动的盘子. int k=n; while(k&gt;=1&amp;&amp;start[k]==finish[k])k–;</p>\n<pre><code>    ///结论:由于移动的步数是对称的,即往回移动的步伐\n    ///和步数等于往前移动.\n    LL ans=0;\n    if(k&gt;=1){\n        int other=6-start\\[k\\]-finish\\[k\\];\n        ans=f(start,k-1,other)+f(finish,k-1,other)+1;\n    }\n    printf(&quot;Case %d: %lld\\\\n&quot;,++kase,ans);\n}\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n","text":"【Link】 A Different Task 汉诺塔问题总结: 杭电 汉诺塔问题总结 【题解】 大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标. ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"模拟","slug":"UVa/思维/模拟","count":1,"path":"api/categories/UVa/思维/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11078","slug":"uva-11078","date":"2017-04-04T11:57:26.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11078.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Credit 信誉,信用,相信,信任</strong> <strong>senior 上司,高级的</strong> <strong>as if 犹如,好似</strong> <strong>attend 出席,致力于,照料</strong> <strong>requisite 必需品,必需的</strong> <strong>advance 发展,前行,增长</strong> <strong>assess 评定,估价</strong> <strong>amount 数量,总数,总计</strong> <strong>figure out 计算出,估计</strong> <strong>【题解】</strong> <strong>记录输入时队列前面的最大值,然后用最大值依次减去后面比他小的数,维护ans.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int ans,T,N,Max,c;</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        scanf(“%d”,&amp;N);** **        ans=-INF;Max=-INF;** **        for(int i=0;i&lt;N;++i){** **                scanf(“%d”,&amp;c);** **                ans=max(ans,Max-c);** **                Max=max(Max,c);** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Credit 信誉,信用,相信,信任 senior 上司,高级的 as if 犹如,好似 attend 出席,致力于,照料 requisite 必需品,必需的 advance 发展,前行,增长 assess 评定,估价 amount 数量,总数,总计 figure ou","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11384","slug":"uva-11384","date":"2017-04-04T09:45:31.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11384.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>screen 屏幕</strong> <strong>subtract 减去,扣掉</strong> <strong>objective 目标,目的</strong> <strong>Her objective will be to make all the numbers 0.  他的目标是将所有的数字变成0.</strong> <strong>as 作为</strong> <strong>twist 扭曲,拧,拧伤,使苦恼</strong> <strong>for each 为每一个</strong> <strong>determine 下决心,决定,确定</strong> <strong>terminated 终止于</strong> <strong>separate 单独的</strong> <strong>【题解】</strong> <strong>蓝书P26</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>int N,cnt;</strong> <strong>//可以发现..其实右边界并没有用到= =Orz</strong> <strong>int solve(int l,int r,int num){</strong> **    if(l==1 &amp;&amp; r==1){** **        printf(“%d\\n”,num);** **        return num;** **    }** **    solve((l-1)/2+1,l-1,num+1);** <strong>}</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;N)){** **        cnt=0;** **        cnt=solve(N/2+1,N,1);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 screen 屏幕 subtract 减去,扣掉 objective 目标,目的 Her objective will be to make all the numbers 0.  他的目标是将所有的数字变成0. as 作为 twist 扭曲,拧,拧伤,使苦恼 for ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11426","slug":"uva-11426","date":"2018-02-12T08:37:59.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11426.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVA-11426\" title=\"https://vjudge.net/problem/UVA-11426\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11426</a></p>\n<h1><span id=\"type-数论欧拉函数递推思维\">Type: 数论,欧拉函数,递推,思维</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n∈[1,4000000]</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>首先我们应该清楚</p>\n<blockquote>\n<p>4000000的数据,用暴力 - 对每个gcd求值相加复杂度是i*j*O(gcd) 你懂就行,这么大的复杂度肯定爆炸.</p>\n</blockquote>\n<p>所以我们第一想法肯定是预处理.</p>\n<blockquote>\n<p>我们设 f(n) 为 (1,n)+(2,n)+(3,n)+…+(n-1,n) 则 S(n)=f(1)+f(2)+…+f(n)</p>\n<blockquote>\n<p>通过这个公式我们就可以递推出所有的 S(n)</p>\n<blockquote>\n<p>S(n)=S(n-1)+f(n)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>然后我们的问题就转化成了求f(n)</p>\n<blockquote>\n<p>首先我们会自然地想到,与n互素的答案是1.即(k,n)的结果都是n的约数</p>\n<blockquote>\n<p>我们可以按照这个约数来进行分类, 用 g(n,i)表示满足gcd(x,n)=i 且 x\\&lt;n 的正整数x的个数 则: f(n)=Sum(i*g(n,i) | i是n的约数,g(n,i)是1~n中gcd(k,n)=i的k的个数)</p>\n<blockquote>\n<p>然后我们注意到: -gcd(x,n)=i -则gcd(x/i,n/i)=1 -即x/i与n/i互质</p>\n</blockquote>\n<p>然后我们就可以将 g(n,i) 看做1~n中与 n/i 互质的数的个数,即</p>\n</blockquote>\n<p>g(n,i) = phi(n/i) 然后我们预处理phi[maxn],预处理完以后处理f(n),这里如果用二重循环依然是接受不了的 所以我们沿用筛法的思想对f[maxn]数组进行预处理,遇到i 是 k 的约数时,直接f[k]+=(i*phi[n/i])</p>\n</blockquote>\n<p>最后预处理S[maxn]即可</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>/*\n我们要求:\nG=Sigma(i=1~N) Sigma(j=i+1~N) GCD(i,j)\nN&lt;=4000000，这样的范围二次循环+GCD肯定是不行的\n所以我们考虑\nf(n)=Sigma(i=1~n-1) gcd(i,n)\n则\nG(n)=Sigma(i=1~n) f(i)\n=G(n-1)+f(n)\n所以我们的问题转换为如何求f(n)\n\n即k都是n的约数\n可以按照约数进行分类,用g(n,i)表示满足 (x,n)=i且x&lt;n的正整数x的个数\n则 f(n)=sum(i\\*g(n,i)|i是n的约数)\n\n再重提: g(n,i)代表满足(x,n)=i,且x&lt;n的正整数x的个数\n\n我们知道,如果 (a,n)=k\n则 (a/k,n/k)=1\n\n所以我们可以理解为g(n,i)代表的是x/i与n/i互质的数的个数\n即满足条件的x/i 有 phi(n/i)个\ng(n,i)=phi(n/i)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=4000000+10;\nLL phi[maxn];\n\nLL f[maxn];\n\nLL g[maxn];\nvoid phi_table(){\n    for(int i=2;i&lt;maxn;++i) phi[i]=0;\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nvoid init(){\n    phi_table();\n    memset(f,0,sizeof(f));\n    for(int i=1;i&lt;maxn;++i){\n        for(int j=i*2;j&lt;maxn;j+=i){\n            f[j]+=(i*phi[j/i]);\n        }\n    }\n    memset(g,0,sizeof(g));\n    for(int i=1;i&lt;maxn;++i) g[i]=g[i-1]+f[i];\n}\n\nint main(){\n    init();\n    int k;\n    while(~scanf(&quot;%d&quot;,&amp;k) &amp;&amp; k){\n        printf(&quot;%lld\\n&quot;,g[k]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11426Type: 数论,欧拉函数,递推,思维题意输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"数论","slug":"UVa/思维/数论","count":1,"path":"api/categories/UVa/思维/数论.json"},{"name":"欧拉函数","slug":"UVa/思维/数论/欧拉函数","count":1,"path":"api/categories/UVa/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}