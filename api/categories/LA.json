{"name":"LA","slug":"LA","count":7,"postlist":[{"title":"LA 3029","slug":"la-3029","date":"2017-04-05T13:07:21.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3029.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>扫描线,悬线法</strong> <strong>【题解】</strong> <strong>蓝书P50</strong> <strong><a href=\"http://blog.csdn.net/qq415200973/article/details/11377199\" target=\"_blank\" rel=\"noopener\">扫描方程的解释</a></strong> <strong>我对代码的理解放在代码里了.</strong> <strong>如果为满：left[i][j]=0,right[i][j]=n,up[i][j]=0,这里是为了下一行的比较做准备。可以模拟试一试。</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>using namespace std;</strong> <strong>const int maxn=1000;</strong> <strong>int mat[maxn][maxn],up[maxn][maxn],left[maxn][maxn],right[maxn][maxn];</strong> <strong>int readchar(){</strong> <em>*    int a=getchar();** **    while(a!=’F’ &amp;&amp; a!=’R’) a=getchar();** **    return a;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int m,n;** **        scanf(“%d%d”,&amp;m,&amp;n);** **        for(int i=0;i&lt;m;++i)** **            for(int j=0;j&lt;n;++j){** **                int ch=getchar();** **                while(ch!=’F’ &amp;&amp; ch!=’R’) ch=getchar();** **                mat[i][j]=ch==’F’?0:1;** **            }** **        int ans=0;** **        for(int i=0;i&lt;m;++i){//从上到下逐行处理** **            int lo=-1,ro=n;** **            for(int j=0;j&lt;n;++j)//从左向右处理** **                if(mat[i][j]==1){left[i][j]=up[i][j]=0;lo=j;}** **                else{** **                    up[i][j]=i==0?1:up[i-1][j]+1;** **                    //lo存的是左边界的下标,而不是到左边将诶有多少空地** **                    //这里,每次遇到障碍(1)时,lo就等于j(重新开始计算左边界)** **                    //然后,left[i][j]存的是当前矩阵的右边界** **                    //这里是lo+1,而不是lo++,所以lo的值在碰到障碍前一直不变** **                    //因为受到上一行的影响,所以需要在上一行和本行中选取一个最大** **                    //下标的左边界.** **                    left[i][j]=i==0?lo+1:max(left[i-1][j],lo+1);** **                }** **            for(int j=n-1;j&gt;=0;–j)//从右往左扫描,维护right并更新答案** **                if(mat[i][j]==1){right[i][j]=n;ro=j;}** **                //为啥等于n捏？？？** **                //为了使其下一行若是空格,作比较的时候,会发现上一行的下标一定是最大的** **                //从而不影响下一行右边界的计算** **                else{** **                    right[i][j]=i==0?ro-1:min(right[i-1][j],ro-1);** **                    ans=max(ans,up[i][j]</em>(right[i][j]-left[i][j]+1));** **                }** **        }** **        printf(“%d\\n”,ans<em>3);*</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 扫描线,悬线法 【题解】 蓝书P50 扫描方程的解释 我对代码的理解放在代码里了. 如果为满：left[i][j]=0,right[i][j]=n,up[i][j]=0,这里是为了下一行的比较做准备。可以模拟试一试。 【Code】#include #include us","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"悬线法","slug":"LA/思维/悬线法","count":1,"path":"api/categories/LA/思维/悬线法.json"}],"tags":[{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"}]},{"title":"LA 3401","slug":"la-3401","date":"2017-04-04T08:44:39.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3401.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【生词】 identical 完全相同的事物,同一的,完全的 suitable 适当的,相配的 rotations 旋转 mirror 镜子,反射 Figure 3 图3 repainting 重新检测,重涂,重画 fewer 较少的,较少数 separate 分开,单独的</p>\n","text":"【生词】 identical 完全相同的事物,同一的,完全的 suitable 适当的,相配的 rotations 旋转 mirror 镜子,反射 Figure 3 图3 repainting 重新检测,重涂,重画 fewer 较少的,较少数 separate 分开,单独的","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"模拟","slug":"LA/模拟","count":1,"path":"api/categories/LA/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3708","slug":"la-3708","date":"2017-03-31T15:25:38.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/la-3708.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题解】</strong> <strong>蓝书P8</strong> <strong>题意是原本n个墓碑均匀分布在一个周长为10000的圆周上，现在加入m个，如果要使得n+m个墓碑都均匀分布的话，那么原来的墓碑最少的移动总距离是多少。</strong> <strong>因为加入m个之后m+n个墓碑的位置是固定的，要是移动距离最少必定会有一个墓碑不动，将圆周分成m+n段，分别标上0,1,2,3,4。。然后需要移动的墓碑坐标就是数轴上面的非整数点，两边的值靠近哪个就选哪个，之后再等比例扩大即可。</strong> <strong>放大倍数:10000/(M+N)</strong> <strong>原先N的坐标在放入M后的位置:</strong> <strong>//设距离L</strong> <strong>//i_(10000/N)=L_</strong> <em><strong>//L/(10000/(M+N))=pos</strong> <strong>//pos=i</strong></em><strong>(10000/N)/(10000/(M+N))</strong> <strong>//pos=i*(M+N)/N</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>int N,M;</strong> <strong>int main(){</strong> <em>*    while(scanf(“%d%d”,&amp;N,&amp;M)!=EOF) {** **        double ans=0.0;** **        for(int i=1;i&lt;N;++i){** **            double pos=(double)i/N</em>(N+M);<em>* **            //原先N的坐标在原来的位置是哪里** <strong>//设距离L</strong> **            //i</em>(10000/N)=L<em>* **            //L/(10000/(M+N))=pos** **//pos=i</em>(10000/N)/(10000/(M+N))<em>* **//pos=i</em>(M+N)/N** **            ans+=fabs(pos-floor(pos+0.5))/(N+M);** **            //floor()向下取整,这里等价于找两边距离最近** <strong>//的那个点.</strong> <strong>}</strong> **        printf(“%.4lf\\n”,ans<em>10000);  *</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>与上面题解同理(没那么奇葩的写法的Code)</strong></p>\n<blockquote>\n<p>**#include <cstdio></cstdio></p>\n<p>#include <cstring></cstring></p>\n<p>#include <algorithm></algorithm></p>\n<p>using namespace std;</p>\n<p>int main() {<br>    int n,m;<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)) {<br>        double ans = 0;<br>        for(int i = 1;i &lt; n;i++) {<br>            double pos = (double)i * (m + n) / n;<br>            ans += min(pos - (int)pos,(int)(pos + 1) - pos);<br>                        //取离两边距离最近的那个点<br>        }<br>        printf(“%.4lf\\n”,ans * 10000 / (m + n));<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【题解】 蓝书P8 题意是原本n个墓碑均匀分布在一个周长为10000的圆周上，现在加入m个，如果要使得n+m个墓碑都均匀分布的话，那么原来的墓碑最少的移动总距离是多少。 因为加入m个之后m+n个墓碑的位置是固定的，要是移动距离最少必定会有一个墓碑不动，将圆周分成m+n段，分别标上","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"}],"tags":[{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3882","slug":"la-3882","date":"2017-07-11T07:02:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3882.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3882\" target=\"_blank\" rel=\"noopener\">And Then There Was One</a></strong> <strong>【题解】</strong> <strong>假设问题是从n个人编号分别为0…n-1，取第k个，</strong> <strong>则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2…</strong> <strong>此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号</strong> <strong>把k号设置为0,则</strong> <strong>k 0</strong> <strong>k+1 1</strong> <strong>…</strong> <strong>0 n-k</strong> <strong>1 n-k+1</strong> <strong>假设已经求得了n-1个人情况下的最终胜利者保存在f[n-1]中，则毫无疑问，该胜利者还原到原来的真正编号即为 (f[n-1]+k)%n （因为第二轮重新编号的时候，相当于把每个人的编号都减了k，因此重新+k即可恢复到原来编号）。由此，我们可以想象，当最终只剩下一个人的时候，该人即为胜利者，此时重新编号，因为只有一个人，所以此时f[1]=0</strong> <strong>这样f[2]=(f[1]+k)%2,这样就可以求出最终胜利者在2个人的时候的情况下的编号，由递推公式f[n]=(f[n-1]+k)%n,可递推到最初编号序列中该胜利者的编号。</strong> <strong>因此用这个方法，只需一遍On的扫描，即可求出最终答案</strong> <strong>不过该题要求编号从1开始，只要把f[n]+1即可，同时，该题指定了第一个要删除的人必须为编号为m的人，其实也不难，求出f[n]之后，把原本编号为0的位置移到跟m只相距k的位置即可实现第一次删除的编号为m。所以最终 ans=(f[n]+1+m-k);</strong> <strong>当然因为m-k可能为负数，导致整个ans为负，这样其实最后+n即可解决。</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203882.cpp\" target=\"_blank\" rel=\"noopener\">LA 3882.cpp</a></strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=10000+10;<br>int f[maxn];<br>int main(){<br>    int n,k,m;<br>    while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n){<br>        ///最后一次变换只有一个点,所以最终点设为0<br>        ///每次去掉一个点以后重新编号,所以%i<br>        ///从底向上的方法<br>        f[1]=0;<br>        for(int i=2;i&lt;=n;++i)f[i]=(f[i-1]+k)%i;<br>        ///因为是从0编号,而题目要求从1编号,所以+1<br>        ///因为从0开始,而题目要求从m开始删除第k个<br>        ///所以第一次删除的下标应该是f[n]-k=第一次的起始下标<br>        ///0-k+m+1=真正的起始坐标,因为第一次需要将m设为0,从m开始重新编号<br>        int ans=(m-k+1+f[n])%n;<br>        ///因为m-k+1可能小于0,所以m-k+1+f[n]也可能小于0<br>        if(ans&lt;=0) ans+=n;<br>        printf(“%d\\n”,ans);<br>    }<br>    return 0;<br>}</strong></p>\n</blockquote>\n","text":"【Link】 And Then There Was One 【题解】 假设问题是从n个人编号分别为0…n-1，取第k个， 则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2… 此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号 把k号设置为","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"动态规划","slug":"LA/动态规划","count":1,"path":"api/categories/LA/动态规划.json"},{"name":"思维","slug":"LA/动态规划/思维","count":1,"path":"api/categories/LA/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3902","slug":"la-3902","date":"2017-07-10T13:21:12.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3902.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3902\" target=\"_blank\" rel=\"noopener\">Network</a></strong> <strong>【题解】</strong> <strong>可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表.</strong> <strong>最优选择放置服务器的方法是选择距离主机最远(k)的那个服务器上安装VOD即可.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203902.cpp\" target=\"_blank\" rel=\"noopener\">LA 3902.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;</p>\n<p>const int maxn=1000+10;<br>vector<int> gr[maxn],nodes[maxn];<br>int n,s,k,fa[maxn];<br>bool covered[maxn];</int></p>\n<p>///无根树转有根树,计算fa数组,根据深度把–叶子节点–插入nodes表中<br>///u当前节点下标,f,当前节点父节点下标,d深度.<br>void dfs(int u,int f,int d){<br>    fa[u]=f;<br>    int nc=gr[u].size();<br>    ///距离根节点k距离以内的叶子结点不用记录<br>    if(nc==1 &amp;&amp; d&gt;k) nodes[d].push_back(u);<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f)dfs(v,u,d+1);<br>    }<br>}</p>\n<p>void dfs2(int u,int f,int d){<br>    covered[u]=true;<br>    int nc=gr[u].size();<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f&amp;&amp;d&lt;k)dfs2(v,u,d+1);///只覆盖到新服务器不超过k的结点 ///v!=f =&gt; 如果从f访问到u,那么就不能再从u回访f.深搜嘛.一路莽到底.<br>    }<br>}</p>\n<p>int solve(){<br>    int ans=0;<br>    memset(covered,0,sizeof(covered));<br>    for(int d=n-1;d&gt;k;–d){<br>        for(int i=0;i&lt;nodes[d].size();++i){<br>            int u=nodes[d][i];<br>            if(covered[u])continue;///不考虑已经覆盖的点</p>\n<pre><code>        int v=u;\n        for(int j=0;j&lt;k;++j)v=fa\\[v\\];///找到相邻k级祖先,不可能有-1，因为之前已经把离根k的节点忽略了\n        dfs2(v,-1,0);///在结点v设置服务器,然后通过对该服务器深搜\n                     ///找到所有的叶子结点\n        ans++;\n    }\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d%d”,&amp;n,&amp;s,&amp;k);///节点数,初始VOD服务器的编号和k<br>        for(int i=1;i&lt;=n;++i){gr[i].clear();nodes[i].clear();}<br>        for(int i=0;i&lt;n-1;++i){<br>            int a,b;<br>            scanf(“%d%d”,&amp;a,&amp;b);<br>            gr[a].push_back(b);<br>            gr[b].push_back(a);<br>        }<br>        dfs(s,-1,0);<br>        printf(“%d\\n”,solve());<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【Link】 Network 【题解】 可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"数据结构","slug":"LA/思维/数据结构","count":1,"path":"api/categories/LA/思维/数据结构.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]},{"title":"LA 3905","slug":"la-3905","date":"2017-04-05T09:18:51.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3905.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>区间扫描,  抽象成事件来做的区间扫描</strong> <strong>【题解】</strong> <strong>蓝书P45</strong> <strong><a href=\"http://blog.csdn.net/xl2015190026/article/details/52937814\" target=\"_blank\" rel=\"noopener\">另一个更详细的blog</a></strong> <strong>代码中难懂的部分都已经注释了.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>//0&lt;x+a*t&lt;w</strong> <strong>//0&lt;x+a*t&lt;w,0&lt;y+b*t&lt;h,  t&gt;0</strong> <strong>//起始坐标:(x,y) 速度:(a,b)</strong> <strong>//x横坐标运动范围(0-w) y纵坐标运动范围(0-h)</strong> <strong>//题目给的公式 在时刻t坐标:p+tv=(x,y)+(t*a,t*b)</strong> <strong>//然后根据这个范围求出出现在镜框的范围内的时间区间,开区间</strong> <strong>//因为出现在镜框上不算进入射程.</strong> <strong>void update(int x,int a,int w,double &amp;L,double &amp;R){</strong> **    if(a==0){** **        if(x&lt;=0 || x&gt;=w) R=L-1;//无解,无法出现在镜框范围内** **    }else if(a&gt;0){** **        L=max(L,-(double)x/a);** **        R=min(R,(double)(w-x)/a);** **    }else{** **        L=max(L,(double)(w-x)/a);** **        R=min(R,-(double)x/a);** **    }** <strong>}</strong> <strong>const int maxn=100000+10;</strong> <strong>struct Event{</strong> **    double x;** **    int type;//状态,0为右端点,1为左端点** **    bool operator&lt;(const Event &amp;a)const{** **        return x&lt;a.x || (x==a.x &amp;&amp; type&gt;a.type);//先处理右端点** **    }** <strong>}events[maxn*2];</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int w,h,n,e=0;** **        scanf(“%d%d%d”,&amp;w,&amp;h,&amp;n);** **        for(int i=0;i&lt;n;++i){** **            int x,y,a,b;** **            scanf(“%d%d%d%d”,&amp;x,&amp;y,&amp;a,&amp;b);** **            //0&lt;x+a*t&lt;w,0&lt;y+b*t&lt;h,  t&gt;0** **            double L=0,R=1e9;//先开一个无穷大的区间** **            update(x,a,w,L,R);** **            update(y,b,h,L,R);** **            if(R&gt;L){//只把有效可进入镜框的点加入区间** **                events[e++]=(Event){L,0};** **                events[e++]=(Event){R,1};** **            }** **        }** **        //排序区间,可以画图看下.** **        sort(events,events+e);** **        int cnt=0,ans=0;** **        for(int i=0;i&lt;e;++i){** **            if(events[i].type==0)** **                cnt++,ans=max(ans,cnt);** **            else cnt–;** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 区间扫描,  抽象成事件来做的区间扫描 【题解】 蓝书P45 另一个更详细的blog 代码中难懂的部分都已经注释了. 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; //0&lt;x+a*t&lt;w /","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"事件","slug":"LA/事件","count":1,"path":"api/categories/LA/事件.json"},{"name":"区间","slug":"LA/事件/区间","count":1,"path":"api/categories/LA/事件/区间.json"}],"tags":[{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"事件","slug":"事件","count":1,"path":"api/tags/事件.json"},{"name":"区间","slug":"区间","count":1,"path":"api/tags/区间.json"}]},{"title":"LA 4329","slug":"la-4329","date":"2017-06-21T04:08:50.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-4329.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-4329\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-4329</a></strong> <strong>【thought】</strong> <strong>考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的.</strong> <strong>那么1 ~ (i-1)中有  (i-sm[i]-1)  个比A[i]能力大的,(i+1) ~ N 中有  (N-i-sl[i])  个比A[i]能力大的.</strong> <strong>根据乘法原理 对于第i个人做裁判有 sl[i]<em>(i-sm[i]-1)+sm[i]</em>(N-i-sl[i]) 中比赛可能,因为每个人做裁判,所以最后结果为每个人做裁判的情况和.</strong> <strong>考虑 T=1_19998+2_19997+3_19996+…+19998_1 爆int,故用long long 存.</strong> <strong>【Type】</strong> <strong>树状数组,lowbit()</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong> <strong>【溢出int测试】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329test.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong></p>\n","text":"【Link】 https://vjudge.net/problem/UVALive-4329 【thought】 考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的. 那么1 ~ (i-1)中有 ","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"树状数组","slug":"LA/树状数组","count":1,"path":"api/categories/LA/树状数组.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]}]}