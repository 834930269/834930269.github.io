{"name":"KMP","slug":"KMP","count":2,"postlist":[{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） C KMP-Next数组","slug":"5-c-kmp","date":"2018-02-27T12:23:59.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/5-c-kmp.json","excerpt":"","keywords":null,"cover":null,"content":"<p>[toc]</p>\n<blockquote>\n<p>Next数组</p>\n</blockquote>\n<h1><span id=\"自己写的卡在9500的代码\">自己写的卡在%95.00的代码</span></h1><p>我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nmap&lt;int,int&gt; ex;\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=1;i&lt;=len;++i){\n        printf(&quot;%d &quot;,Next[i]);\n    }\n}\n\nvoid solve(){\n    ex.clear();\n    getNext();\n    //print();\n    int bef=Next[len],now,max_len=0;\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    while(bef!=0){\n        now=bef;\n        bef=Next[bef];\n    }\n\n    for(int i=1;i&lt;=len;++i){\n        if(Next[i] &amp;&amp; Next[i]%now==0){\n            int k=Next[i]/now;\n            for(int j=1;j&lt;=k;++j){\n                ex[j*now]++;\n            }\n        }\n    }\n    map&lt;int,int&gt;::iterator it;\n    for(it=ex.begin();it!=ex.end();it++){\n        if(it-&gt;second&gt;1) max_len=max(max_len,it-&gt;first);\n    }\n    if(max_len){\n        max_len=min(max_len,Next[len]);\n        for(int i=0;i&lt;max_len;++i){\n            printf(&quot;%c&quot;,str[i]);\n        }\n    }else printf(&quot;Just a legend&quot;);\n    printf(&quot;\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1><span id=\"ac代码\">AC代码</span></h1><blockquote>\n<p>AC代码</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nint exist[maxn];\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid solve(){\n    memset(exist,0,sizeof(exist));\n    getNext();\n    int bef=Next[len];\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    //忽略第一个和最后一个\n    for(int i=2;i&lt;len;++i){\n        exist[Next[i]]++;\n    }\n\n    while(bef&gt;0){\n        if(exist[bef]){\n            for(int i=0;i&lt;bef;++i){\n                printf(&quot;%c&quot;,str[i]);\n            }\n            printf(&quot;\\n&quot;);\n            return;\n        }\n        bef=Next[bef];\n    }\n    printf(&quot;Just a legend\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1><span id=\"当然还有一种方法是比较特别的比较直观把每个可能子串kmp一下如果匹配成功了就直接输出就好了\">当然,还有一种方法是比较特别的(比较直观),把每个可能子串KMP一下,如果匹配成功了,就直接输出就好了</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nchar a[1000005],b[1000005];\nint next[1000006];\nvoid getnext(char *c)\n{\n    next[0]=next[1]=0;\n    int i,j,len=strlen(c);\n    for(i=1,j=0;i&lt;len;i++)\n    {\n        while(c[i]!=c[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(c[i]==c[j])j++;\n        next[i+1]=j;\n    }\n}\nint kmp(char *o,char *f)\n{\n    int cont=0;\n    int i,j,len1=strlen(o),len2=strlen(f);\n    for(i=0,j=0;i&lt;len1;i++)\n    {\n        while(o[i]!=f[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(o[i]==f[j])j++;\n        if(j==len2)\n        {\n            cont++;\n            j=next[j];\n        }\n    }\n    return cont;\n}\nint main()\n{\n    int i;\n    scanf(&quot;%s&quot;,a);\n    getnext(a);\n    int len=next[strlen(a)];\n    if(len==0)\n    {\n        printf(&quot;Just a legend\\n&quot;);\n        return 0;\n    }\n    for(i=0;i&lt;len;i++)\n        b[i]=a[i];\n    b[i]=&apos;\\0&apos;;\n    int cont=kmp(a,b);\n    while(cont&lt;3)\n    {\n        len=next[len];\n        if(len==0)break;\n        for(i=0;i&lt;len;i++)\n            b[i]=a[i];\n        b[i]=&apos;\\0&apos;;\n        cont=kmp(a,b);\n    }\n    if(cont&gt;=3&amp;&amp;len)printf(&quot;%s\\n&quot;,b);\n    else printf(&quot;Just a legend\\n&quot;);\n    return 0;\n}</code></pre><p>1<br>=</p>\n<p>2<br>=</p>\n","text":"[toc]Next数组自己写的卡在%95.00的代码我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1001000;int Next[max","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"字符串处理","slug":"KMP/字符串处理","count":1,"path":"api/categories/KMP/字符串处理.json"},{"name":"牛客练习赛","slug":"KMP/字符串处理/牛客练习赛","count":1,"path":"api/categories/KMP/字符串处理/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"}]},{"title":"POJ 1961","slug":"poj-1961","date":"2018-02-25T05:26:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-1961.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVALive-3026\" title=\"https://vjudge.net/problem/UVALive-3026\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-3026</a></p>\n<h1><span id=\"type-kmp-next数组\">Type: KMP-Next数组</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><h2><span id=\"前置\">前置</span></h2><h3><span id=\"关于next数组\">关于Next数组</span></h3><blockquote>\n<p>(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符进行再次匹配. (2) j=Next[k]表示第 j 个字符和第 k 个字符一样. (3) j=Next[k]表示前 j 个字符和后 j 个字符一样</p>\n<blockquote>\n<p>即 1<del>j-1 和 k-j+1</del>k 这两个子串相等</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"正文\">正文</span></h2><blockquote>\n<p>即我们求出该字符串的Next数组后我们可以判断当前 (i-Next[i]) 是否能被 i 整除.</p>\n<blockquote>\n<p>即 i%(i-Next[i]) 是否等于0.</p>\n<blockquote>\n<p>i-Next[i]为该子串的长度,如果可以整除则证明该子串为循环节,循环节长度为 i-Next[i] ,循环次数为 i/(i-Next[i]).</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nchar ts[maxn];\nint n,kase=1;\nint Next[maxn];\nvoid getNext(){\n    int j=0,k=-1;\n    Next[0]=-1;\n    while(j&lt;n){\n        if(k==-1 || ts[j]==ts[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\nvoid print(){\n    for(int i=1;i&lt;=n;++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(!n)break;\n        scanf(&quot;%s&quot;,ts);\n        getNext();\n        //print();\n        printf(&quot;Test case #%d\\n&quot;,kase++);\n        for(int i=2;i&lt;=n;++i){\n            if(Next[i]&lt;=0) continue;\n            if(i%(i-Next[i])==0){\n                printf(&quot;%d %d\\n&quot;,i,i/(i-Next[i]));\n            }\n        }\n        printf(&quot;\\n&quot;);\n        getchar();\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVALive-3026Type: KMP-Next数组题意给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度题解前置关于Next数组(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"LA","slug":"KMP/LA","count":1,"path":"api/categories/KMP/LA.json"},{"name":"POJ","slug":"KMP/LA/POJ","count":1,"path":"api/categories/KMP/LA/POJ.json"},{"name":"字符串处理","slug":"KMP/LA/POJ/字符串处理","count":1,"path":"api/categories/KMP/LA/POJ/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]}]}