{"name":"并查集","slug":"ccf/kruskal/并查集","count":1,"postlist":[{"title":"ccf 2017前四题","slug":"ccf-2017-pre-f","date":"2017-08-19T05:25:33.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2017-pre-f.json","excerpt":"","keywords":null,"cover":null,"content":"<p>第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *<em>要登录和会员 *</em> <a href=\"http://118.190.20.162/home.page\" target=\"_blank\" rel=\"noopener\">http://118.190.20.162/home.page</a> github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/tree/master/CCSP/2017-3\" title=\"CCF 2017-3 前四题\" target=\"_blank\" rel=\"noopener\">CCF 2017-3 前四题</a> 第一题:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    int N,K;\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;K)){\n        int ans=0,d,n=0;\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;d);\n            n+=d;\n            if(n&gt;=K){\n                n=0;\n                ans++;\n            }\n        }\n        if(n)ans++;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>第二题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint N,M;\nint I,J;\n\nlist&lt;int&gt; li;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        li.clear();\n        for(int i=1;i&lt;=N;++i){\n            li.push_back(i);\n        }\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%d%d&quot;,&amp;I,&amp;J);\n            if(J==0)continue;\n            list&lt;int&gt;::iterator it,it2;\n            for(it=li.begin();*it!=I;it++){}\n            it2=it;\n            int flag=J&gt;0?1:-1;\n            J=abs(J)+(flag&gt;0?1:0);\n            while(J){\n                J--;\n                flag&gt;0?it++:it--;\n            }\n            li.insert(it,I);\n            li.erase(it2);\n        }\n        list&lt;int&gt;::iterator it;\n        it=li.begin();\n        printf(&quot;%d&quot;,*it);\n        it++;\n        for(;it!=li.end();it++){\n            printf(&quot; %d&quot;,*it);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>第三题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define BUF_SS 101\n\nusing namespace std;\n\nchar buf[101];\nint pre=-1;\n\nint check_hl(int st){\n    char hr[100];\n    string tip;\n    int ind=st+1,cs=0,hs=0;\n    while(buf[ind]!=&apos;]&apos;){\n        if(buf[ind]==&apos;_&apos;){\n            tip+=&quot;&lt;em&gt;&quot;;\n            ind++;\n            while(buf[ind]!=&apos;_&apos;){\n                tip+=buf[ind];\n                ind++;\n            }\n            tip+=&quot;&lt;/em&gt;&quot;;\n            ind++;\n        }else{\n            tip+=buf[ind];\n            ind++;\n        }\n    }\n    ind+=2;\n    while(buf[ind]!=&apos;)&apos;){\n        hr[hs++]=buf[ind];\n        ind++;\n    }\n    hr[hs]=&apos;\\0&apos;;\n    printf(&quot;&lt;a href=\\&quot;%s\\&quot;&gt;&quot;,hr);\n    cout&lt;&lt;tip&lt;&lt;&quot;&lt;/a&gt;&quot;;\n    return ind-st;\n}\n\nint check_em(int st){\n    int ind=st+1;\n    printf(&quot;&lt;em&gt;&quot;);\n    while(buf[ind]!=&apos;_&apos;){\n        if(buf[ind]==&apos;[&apos;){\n            int ed=check_hl(ind);\n            ind+=(ed+1);\n        }else{\n            putchar(buf[ind]);\n            ind++;\n        }\n    }\n    printf(&quot;&lt;/em&gt;&quot;);\n    return ind-st;\n}\n\nvoid check_h(int sz){\n    int n,r=0;\n    char sts[20],ste[20];\n    while(buf[r]==&apos;#&apos;){\n        r++;\n    }\n    int s=r,e=sz-1;\n    sprintf(sts,&quot;&lt;h%d&gt;&quot;,r);\n    sprintf(ste,&quot;&lt;/h%d&gt;&quot;,r);\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;%s&quot;,sts);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;%s\\n&quot;,ste);\n}\n\nvoid check_u(int sz){\n    if(pre!=2)printf(&quot;&lt;ul&gt;\\n&quot;);\n    int s=1,e=sz-1;\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;&lt;li&gt;&quot;);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;&lt;/li&gt;\\n&quot;);\n}\n\nvoid check_p(int sz){\n    if(pre!=3)printf(&quot;&lt;p&gt;&quot;);\n    if(pre==3)putchar(&apos;\\n&apos;);\n    for(int i=0;buf[i]!=&apos;\\n&apos; &amp;&amp; i&lt;sz;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n}\n\nint main(){\n    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n    while(fgets(buf,BUF_SS,stdin)){\n        if(buf[0]==&apos;\\n&apos;){\n            if(pre==3){\n                printf(&quot;&lt;/p&gt;\\n&quot;);\n                pre=0;continue;\n            }else if(pre==2){\n                printf(&quot;&lt;/ul&gt;\\n&quot;);\n                pre=0;continue;\n            }\n            continue;\n        }\n        int sz=strlen(buf);\n        if(buf[0]==&apos;#&apos;) check_h(sz),pre=1;\n        else if(buf[0]==&apos;*&apos;) check_u(sz),pre=2;\n        else check_p(sz),pre=3;\n    }\n    if(pre==3)printf(&quot;&lt;/p&gt;\\n&quot;);\n    if(pre==2)printf(&quot;&lt;/ul&gt;\\n&quot;);\n    return 0;\n}</code></pre><p>写题的时候写了一组测试数据: In[1]:</p>\n<pre><code># Heading\n\n## Sub-heading\n\nParagraphs are separated\nby a blank line.\n\nText attributes _italic_.\n\nBullet list:\n\n*      apples\n* oranges\n* pears\n\nA _[NLJ6link616lins1](http://example.com)_.\n\n[NLJ6_link_616_lins_1](http://example.com)</code></pre><p>out[1]:</p>\n<pre><code>&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;h2&gt;Sub-heading&lt;/h2&gt;\n&lt;p&gt;Paragraphs are separated\nby a blank line.&lt;/p&gt;\n&lt;p&gt;Text attributes &lt;em&gt;italic&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Bullet list:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;apples&lt;/li&gt;\n&lt;li&gt;oranges&lt;/li&gt;\n&lt;li&gt;pears&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A &lt;em&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6link616lins1&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6&lt;em&gt;link&lt;/em&gt;616&lt;em&gt;lins&lt;/em&gt;1&lt;/a&gt;&lt;/p&gt;</code></pre><p>第四题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAX_M=200000+10;\nconst int maxn=200000+10;\nint N,M;\nint A,B,C;\n\nstruct Edge{\n    int from,to,dist;\n};\nstruct HeapNode{\n    int d,from,to;\n    bool operator&lt;(const HeapNode&amp; rhs)const{\n        return d&gt;rhs.d;\n    }\n};\n\nstruct Kruskal{\n    int n,m;///点数和边数\n    vector&lt;Edge&gt; edges;///边表\n    vector&lt;int&gt; G[maxn];///每个节点出发的边编号\n    priority_queue&lt;HeapNode&gt; Q;\n\n    ///并查集\n    int fa[maxn];///父亲\n    int ra[maxn];///高度\n    ///init:初始化(点数)\n    ///find_Root:查找树的根\n    ///unite:合并x和y所属集合\n    ///same:判断x和y是否是同一个集合\n    void init(int n){\n        this-&gt;n=n;\n        for(int i=0;i&lt;n;++i){\n            fa[i]=i;\n            ra[i]=0;\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    int find_Root(int x){\n        if(fa[x]==x){\n            return x;\n        }else{\n            return fa[x]=find_Root(fa[x]);\n        }\n    }\n    void unite(int x,int y){\n        x=find_Root(x);\n        y=find_Root(y);\n        if(x==y) return;\n\n        if(ra[x]&lt;ra[y]){\n            fa[x]=y;\n        }else{\n            fa[y]=x;\n        }\n    }\n    bool same(int x,int y){\n        return find_Root(x)==find_Root(y);\n    }\n\n    void AddEdge(int from,int to,int dist){\n        edges.push_back((Edge){from,to,dist});\n        m=edges.size()-1;\n        G[from].push_back(m-1);\n        Q.push((HeapNode){dist,from,to});\n    }\n\n    int kruskal(){\n        HeapNode h;\n        while(!Q.empty()){\n            if(find_Root(N)==find_Root(1))break;\n            h=Q.top();Q.pop();\n            if(find_Root(h.from)==find_Root(h.to))continue;\n            unite(h.from,h.to);\n        }\n        printf(&quot;%d\\n&quot;,h. d);\n    }\n}K;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        K.init(N);\n        for(int i=0;i&lt;M;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);\n            K.AddEdge(A,B,C);\n        }\n        K.kruskal();\n    }\n    return 0;\n}</code></pre>","text":"第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *要登录和会员 * http://118.190.20.162/home.page git","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"kruskal","slug":"ccf/kruskal","count":1,"path":"api/categories/ccf/kruskal.json"},{"name":"并查集","slug":"ccf/kruskal/并查集","count":1,"path":"api/categories/ccf/kruskal/并查集.json"},{"name":"模拟","slug":"ccf/kruskal/并查集/模拟","count":1,"path":"api/categories/ccf/kruskal/并查集/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"},{"name":"CCF","slug":"CCF","count":1,"path":"api/tags/CCF.json"}]}]}