{"name":"算法学习","slug":"博弈论/算法学习","count":1,"postlist":[{"title":"博弈论","slug":"game","date":"2018-01-24T03:05:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/game.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg","content":"<p>[toc]</p>\n<h1><span id=\"博弈论\">博弈论</span></h1><h2><span id=\"博弈树\">博弈树</span></h2><p>重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。</p>\n<h2><span id=\"sg函数\">SG函数</span></h2><h3><span id=\"基本概念\">基本概念</span></h3><p>在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个状态,则两点间有一条有向边,这样就得到了一个状态图.</p>\n<h3><span id=\"巴什博奕\">巴什博奕</span></h3><p>以巴什博奕为例,一共有n个物品,两人轮流取,一次最少取走1个最多去走m个，最后取光的人获胜。下图展示了n=6,m=3的时候的状态图,节点内的数字表示当前状态剩下的物品的个数. <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" alt></a> 假设游戏不会出现平局,即状态图是无环图的话,所有的状态可以分为两种,P态和N态。P态表示该状态对于前一个玩家来说是必胜态,而N态表示该状态对于下一个玩家来说是必胜态。例如对于n=6,m=3的巴什博奕来说,0个物品显然是P态,而还剩1、2或3个物品的状态都是N态。 一个状态被称为终止状态,如果当前状态下游戏不能再继续进行,譬如巴什博奕种物品都已经被取光了,在大部分游戏规则中,终止状态都是P态,所以如果不加特殊说明,一下都假设P态为终止状态. 从定义可知,任意一个P态,他要么是终止状态,要么他所有可以转移到的状态都是N态,而对于任意一个N态,他至少有一个后继状态是P态.</p>\n<h3><span id=\"sg函数\">SG函数</span></h3><p>SG函数是这样定义的:对于任意状态x,他的SG函数值g(x)=mex{g(y)|y是x的后续状态},其中mex是一个对于非负整数集合S的运算, mex(S)为S中没有出现的最小负整数 。对于一个终止状态,因为他没有后继状态,所以他的SG函数值是0. 还是以上面的巴什博奕为例: n=6,m=3.用Si表示还剩i个物品的状态。S0是终止状态,所以g(S0)=0。S1的唯一后继状态是S0,所以g(S1)=1,S2可以转移到S1和S0，所以g(S2)是2.因为S3可以转移到S0,S1,S2,所以g(S3)=3.对于S4来说,它可以转移到S1，S2，S3(1，2，3),所以g(S4)=0.以此类推可以知道g(S5)=1，g(S6)=2. 如果知道一个状态SG函数值,则可以快速的判断当前状态时P态还是N态.对于一个函数,如果状态值是0则是P态,否则就是N态. g(S4),P态,先手必败(后继都是N态);g(S5)，N态(后继有P态),先手必胜.</p>\n<h1><span id=\"kuangbin介绍博弈\">KuangBin介绍博弈</span></h1><h2><span id=\"一巴什博奕bash-game\">（一）巴什博奕（Bash Game）：</span></h2><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个， 后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果 n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的 取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十 个，谁能报到100者胜。</p>\n<h2><span id=\"二威佐夫博奕wythoff-game\">（二）威佐夫博奕（Wythoff Game）：</span></h2><p>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示 两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6， 10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有 如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1 ，而 bk= ak + k &gt; ak -1 + k-1 = bk-1 &gt; ak-1 。所以性质1。成立。 2。任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其 他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由 于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了 奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局 势；如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab + ak个物体,变为奇异局 势（ ab – ak , ab – ak+ b – ak）；如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余 的数量a – ak 即可；如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k） ,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – a j 即可。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜 ；反之，则后拿者取胜。 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 奇妙的是其中出现了黄金分割数（1+√5）/2 = 1。618…,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。</p>\n<h3><span id=\"威佐夫博弈的几点判断\">威佐夫博弈的几点判断:</span></h3><h4><span id=\"非奇异局势时先手一方只需要将当前局势变成奇异局势即可必胜\">非奇异局势时,先手一方只需要将当前局势变成奇异局势即可必胜</span></h4><h4><span id=\"奇异局势时后手一方只需要将非奇异局势变成奇异局势必胜\">奇异局势时,后手一方只需要将非奇异局势变成奇异局势必胜</span></h4><h2><span id=\"三尼姆博奕nimm-game\">（三）尼姆博奕（Nimm Game）：</span></h2><p>有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首 先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是 （0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一 下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情 形。 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示 这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结 果： 1 =二进制01 2 =二进制10 3 =二进制11 （+） ——————— 0 =二进制00 （注意不进位） 对于奇异局势（0，n，n）也一样，结果也是0。 任何奇异局势（a，b，c）都有a（+）b（+）c =0。 <strong>如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b &lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果: a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（a（+）b）即可。</strong> 例1。（14，21，39），14（+）21=27，39-27=12，所以从39中拿走12个物体即可达 到奇异局势（14，21，27）。 例2。（55，81，121），55（+）81=102，121-102=19，所以从121中拿走19个物品 就形成了奇异局势（55，81，102）。 例3。（29，45，58），29（+）45=48，58-48=10，从58中拿走10个，变为（29，4 5，48）。</p>\n<pre><code>例4。我们来实际进行一盘比赛看看：\n    甲:(7,8,9)-&gt;(1,8,9)奇异局势\n    乙:(1,8,9)-&gt;(1,8,4)\n    甲:(1,8,4)-&gt;(1,5,4)奇异局势\n    乙:(1,5,4)-&gt;(1,4,4)\n    甲:(1,4,4)-&gt;(0,4,4)奇异局势\n    乙:(0,4,4)-&gt;(0,4,2)\n    甲:(0.4,2)-&gt;(0,2,2)奇异局势\n    乙:(0,2,2)-&gt;(0,2,1)\n    甲:(0,2,1)-&gt;(0,1,1)奇异局势\n    乙:(0,1,1)-&gt;(0,1,0)\n    甲:(0,1,0)-&gt;(0,0,0)奇异局势\n    甲胜。</code></pre><h2><span id=\"拓展\">拓展</span></h2><h3><span id=\"斐波那契博弈\">斐波那契博弈</span></h3><p>1、问题模型： 有一堆个数为n的石子，游戏双方轮流取石子，满足： （1）先手不能在第一次把所有的石子取完； （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。 2、解决思路： 当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 证明：根据“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。如n=83 = 55+21+5+2，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，那么一定是先手取走这5颗石子中的最后一颗，同理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。 反证：如果n是Fibonacci数，如n=89：记先手一开始所取的石子数为y （1）若y&gt;=34颗（也就是89的向前两项），那么一定后手赢，因为89-34=55=34+21&lt;2*34。 （2）y&lt;34时剩下的石子数x介于55到89之间，它一定不是一个Fibonacci数，把x分解成Fibonacci数：x=55+f[i]+…+f[j]，若，如果f[j]&lt;=2y，那么对B就是面临x局面的先手，所以根据之前的分析，后手只要先取f[j]个即可，以后再按之前的分析就可保证必胜。</p>\n<h3><span id=\"公平组合博弈impartial-combinatori-games\">公平组合博弈（Impartial Combinatori Games）</span></h3><p>1、定义： （1）两人参与。 （2）游戏局面的状态集合是有限。 （3）对于同一个局面，两个游戏者的可操作集合完全相同 （4）游戏者轮流进行游戏。 （5）当无法进行操作时游戏结束，此时不能进行操作的一方算输。 （6）无论游戏如何进行，总可以在有限步数之内结束。 2、模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有公平组合游戏（Impartial Combinatori Games）的抽象模型。其实，任何一个ICG都可以通过把每个局势看成一个顶点，对每个局势和它的子局势连一条有向边来抽象成这个“有向图游戏”。 3、解决思路： 现在，假定我们给出两个游戏G1 和 G2。如果我们只知道单个游戏的P-状态和N-状态我们能够正确地玩好游戏和G1 + G2吗？答案是否定的。不难看出两个P-状态的和总是P-状态，P-状态和N-状态的和总是N-状态。但是两个N-状态的和既可能是P-状态也可能是N-状态。因此，只知道单个游戏的P-状态和N-状态是不够的。 为了正确地玩好游戏和我们需要推广P-状态和N-状态，它就是Sprague-Grudy函数（或者简称为g函数） 4、Sprague-Grudy定理： 令N = {0, 1, 2, 3, …} 为自然数的集合。Sprague-Grundy 函数给游戏中的每个状态分配了一个自然数。结点v的Grundy值等于没有在v的后继的Grundy值中出现的最小自然数. 形式上：给定一个有限子集 S ⊂ N,令mex S(最小排斥值)为没有出现在S中的最小自然数。定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。 5、性质： （1）所有的终结点所对应的顶点，其SG值为0，因为它的后继集合是空集——所有终结点是必败点（P点）。 （2）对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0——无论如何操作，从必败点（P点）都只能进入必胜点（N点）//对手走完又只能把N留给我们。 （3）对于一个g(x)!=0的顶点，必定存在一个后继点y满足g(y)=0——从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）//就是那种我们要走的方法。 6、应用： （1）可选步数为1-m的连续整数，直接取模即可，SG(x) = x % (m+1); （2）可选步数为任意步，SG(x) = x; （3）可选步数为一系列不连续的数，用mex(计算每个节点的值)</p>\n","text":"[toc]博弈论博弈树重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。SG函数基本概念在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个","link":"","raw":null,"photos":[],"categories":[{"name":"博弈论","slug":"博弈论","count":3,"path":"api/categories/博弈论.json"},{"name":"算法学习","slug":"博弈论/算法学习","count":1,"path":"api/categories/博弈论/算法学习.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]}]}