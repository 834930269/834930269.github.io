{"name":"模拟","slug":"2017多校/模拟","count":2,"postlist":[{"title":"2017多校训练1 HDU 6034 Balala Power!","slug":"2017-hdu-6034-balala-power","date":"2017-07-27T15:41:01.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6034-balala-power.json","excerpt":"","keywords":null,"cover":"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg","content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6034\" title=\"Balala Power!\" target=\"_blank\" rel=\"noopener\">Balala Power!</a> <a href=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" title=\"Balala\" target=\"_blank\" rel=\"noopener\"><img src=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" alt=\"Balala\" title=\"Balala\"></a> 题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可以有前导0,规则是为0的字符不能位于len&gt;1的字符串的开头. 题解: 统计每个字符的总结果,排序,最大的字符赋值25,然后依次往下赋值.然后判断前导0,找到第一个可以为0的存在的字符,将它赋值为0,之后其他的左移一位.(出现前导0的情况表示26个字符都已经出现了). github: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/1/1002.cpp\" title=\"1002.cpp\" target=\"_blank\" rel=\"noopener\">1002.cpp</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1e5+5;\nconst int mod=1e9+7;\nstruct star{\n    int reg[100005];\n    bool vi;\n    int c;\n    bool operator &lt; (const star &amp;A)const{\n        for(int i=maxn-1;i&gt;=0;--i){\n            if(reg[i]&gt;A.reg[i]) return 1;\n            else if(reg[i]&lt;A.reg[i]) return 0;\n            else continue;\n        }\n    }\n}ch[30];\nchar str[100005];\nint Hash[30];///字符-权值映射\nlong long ans,fac[100005];\ninline void init(){\n    for(int i=0;i&lt;27;++i){\n        memset(ch[i].reg,0,sizeof(ch[i].reg));\n        ch[i].vi=true;\n        ch[i].c=0;\n    }\n    ans=0;\n}\nint main(){\n    int n,len,p,kase=0;\n    fac[0]=1;///预先处理26^i;\n    for(int i=1;i&lt;maxn;++i)\n        fac[i]=fac[i-1]*26%mod;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        init();\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            len=strlen(str);\n            for(int j=0;j&lt;len;++j){\n                p=str[j]-&apos;a&apos;;\n                ch[p].reg[len-j-1]++;\n            }\n            if(len&gt;1)\n                ch[str[0]-&apos;a&apos;].vi=false;\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                if(ch[i].reg[j]&gt;=26){\n                    ch[i].reg[j+1]+=ch[i].reg[j]/26;\n                    ch[i].reg[j]%=26;\n                }\n            }\n            ch[i].c=i;\n        }\n        sort(ch,ch+26);\n        for(int i=0;i&lt;26;++i)\n            Hash[ch[i].c]=26-i-1;\n        for(int i=25;i&gt;=0;--i){///从最小的开始判断是否可以为0\n            if(ch[i].vi){\n                for(int j=25;j&gt;i;--j)\n                    Hash[ch[j].c]=Hash[ch[j-1].c];\n                Hash[ch[i].c]=0;\n                break;\n            }\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                ans=(ans+fac[j]*ch[i].reg[j]*Hash[ch[i].c]%mod)%mod;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:Balala Power!  [Figure]  题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]},{"title":"2017 Multi-University Training Contest - Team 9  1008","slug":"2017-multi-university-training-contest-team-9-1008","date":"2017-08-22T11:37:20.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/2017-multi-university-training-contest-team-9-1008.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6168\" title=\"HDU-6168 Numbers\" target=\"_blank\" rel=\"noopener\">HDU-6168 Numbers</a> github Code Link: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008.cpp\" title=\"1008.cpp\" target=\"_blank\" rel=\"noopener\">1008.cpp</a> Test Code: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008test.cpp\" title=\"1008test.cpp\" target=\"_blank\" rel=\"noopener\">1008test.cpp</a> 题解: 用map记录下每个数字出现的次数.然后对b进行排序,首先可以知道,排序后的数组,前两个数一定是a序列的前两个数.然后从这两个数开始拓展,a1+a2必在b中,所以在map中找到a1+a2的数量然后-1,之后把接下来的第一个数Push到a数组中,并且删除一个a1+a3和a2+a3,依次递推.知道a.size()到达sqrt(m/2)或者i&gt;=m为止,结束循环. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=200000;\n\nint c[maxn];\nint m,n;\nmap&lt;int,int&gt; d;\nvector&lt;int&gt; a;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;m)){\n        d.clear();a.clear();\n        n=sqrt(m&lt;&lt;1);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            d[c[i]]++;\n        }\n        sort(c,c+m);\n        a.push_back(c[0]);a.push_back(c[1]);\n        d[c[1]]--;d[c[0]]--;\n        for(int i=1;i&lt;m &amp;&amp; a.size()&lt;n;++i){\n            int si=a.size()-1;\n            for(int j=0;j&lt;si;++j){\n                if(d.find(a[si]+a[j])!=d.end() &amp;&amp; d[a[si]+a[j]]&gt;0){\n                    d[a[si]+a[j]]--;\n         //           printf(&quot;IDone %d\\n&quot;,a[si-1]+a[j]);\n                }\n            }\n            while(d[c[i]]==0){\n                int no=c[i];\n                while(c[i]==no){\n                    ++i;\n                    if(i&gt;=m)break;\n                }\n                if(i&gt;=m)break;\n    //            printf(&quot;Done %d\\n&quot;,c[i]);\n            }\n            if(i&lt;m){\n                a.push_back(c[i]);\n         //       printf(&quot;Push %d\\n&quot;,c[i]);\n                d[c[i]]--;\n            }\n            --i;\n        }\n        printf(&quot;%d\\n&quot;,a.size());\n        printf(&quot;%d&quot;,a[0]);\n        for(int i=1;i&lt;a.size();++i){\n            printf(&quot; %d&quot;,a[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>Test Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint t[5]={3,7,6,9,10};\nvector&lt;int&gt; ans;\nint main(){\n     freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n     freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n     for(int i=0;i&lt;5;++i) ans.push_back(t[i]);\n     for(int i=0;i&lt;5;++i){\n        for(int j=i+1;j&lt;5;++j){\n            ans.push_back(t[i]+t[j]);\n        }\n     }\n     printf(&quot;%d\\n&quot;,ans.size());\n     for(int i=0;i&lt;ans.size();++i) printf(&quot;%d &quot;,ans[i]);\n    return 0;\n}</code></pre>","text":"类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:HDU-6168 Numbers github Code Link: :earth_asia:1008.cpp Test Code: :earth_asia:1008","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]}]}