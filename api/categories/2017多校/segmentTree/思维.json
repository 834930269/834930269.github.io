{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"postlist":[{"title":"2017多校训练2 HDU 6047 Maximum Sequence","slug":"2017-hdu-6047-maximum-sequence","date":"2017-07-29T04:51:07.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6047-maximum-sequence.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6047\" title=\"Maximum Sequence\" target=\"_blank\" rel=\"noopener\">Maximum Sequence</a> 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,记录每个i到maxindex(A)的最大值,然后动态更新. github: 1.线段树法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003_Range_Tree.cpp\" title=\"1003_Range_Tree.cpp\" target=\"_blank\" rel=\"noopener\">1003_Range_Tree.cpp</a> 2.暴力动态更新法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003.cpp\" title=\"1003.cpp\" target=\"_blank\" rel=\"noopener\">1003.cpp</a></p>\n<pre><code>///线段树法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst int maxnode=2000050;\n\nint b[maxnode],N;\nint maxv[maxnode];\n\nvoid build(int o,int l,int r){\n    if(l==r){\n        if(l&gt;N) return;///预先分配2*N个结点\n        scanf(&quot;%d&quot;,&amp;maxv[o]);maxv[o]-=l;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(o&lt;&lt;1,l,mid);\n    build(o&lt;&lt;1|1,mid+1,r);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint query(int o,int l,int r,int ll,int rr){\n    if(l&gt;=ll&amp;&amp;r&lt;=rr) return maxv[o];\n    int ma=-1,mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=ll) ma=max(ma,query(o&lt;&lt;1,l,mid,ll,rr));\n    if(rr&gt;mid) ma=max(ma,query(o&lt;&lt;1|1,mid+1,r,ll,rr));\n    return ma;\n}\n\nvoid update(int o,int l,int r,int p,int val){\n    if(l==r){\n        maxv[o]=val;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    if(p&lt;=mid)update(o&lt;&lt;1,l,mid,p,val);\n    else update(o&lt;&lt;1|1,mid+1,r,p,val);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        build(1,1,2*N);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        LL ans=0;\n        for(int i=N+1;i&lt;=2*N;++i){\n            int k=query(1,1,2*N,b[i-N],i-1);\n            update(1,1,2*N,i,k-i);\n            ans=(ans+k)%mod;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n\n///HDU 6047 暴力动态更新法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=500000+50;\nconst int mod=1e9+7;\nint N;\nint a[maxn],b[maxn],maxa[maxn];\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=1;i&lt;=N;++i){\n            int aa;\n            scanf(&quot;%d&quot;,&amp;aa);\n            a[i]=aa-i;\n        }\n        maxa[N]=a[N];\n        for(int i=N-1;i&gt;=1;--i) maxa[i]=max(maxa[i+1],a[i]);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        long long ans=0;\n        ans=(ans+maxa[b[1]])%mod;\n        int t=maxa[b[1]]-N-1;\n        for(int i=2;i&lt;=N;++i){\n            maxa[b[i]]=max(maxa[b[i]],t);\n            ans=(ans+maxa[b[i]])%mod;\n            t=max(t,maxa[b[i]]-N-1);\n        }\n        printf(&quot;%lld\\n&quot;,ans%mod);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: :point_right:Maximum Sequence 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"segmentTree","slug":"2017多校/segmentTree","count":1,"path":"api/categories/2017多校/segmentTree.json"},{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"path":"api/categories/2017多校/segmentTree/思维.json"},{"name":"线段树","slug":"2017多校/segmentTree/思维/线段树","count":1,"path":"api/categories/2017多校/segmentTree/思维/线段树.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]}]}