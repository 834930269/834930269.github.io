{"name":"dfs","slug":"2017多校/dfs","count":1,"postlist":[{"title":"2017 杭电多校训练赛 补题","slug":"2017-hdu-up","date":"2018-01-14T04:25:53.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/2017-hdu-up.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif","content":"<p>[toc]</p>\n<h1><span id=\"第一场\"><strong>第一场</strong></span></h1><h2><span id=\"1003-colorful-tree-hdoj6035\"><strong>1003 Colorful Tree hdoj6035</strong></span></h2><p>题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n<em>(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) *</em> //思路<strong>：Answer = 所有颜色种类 * 所有路径数量 - 每一种颜色有多少路径没有经过 . 一开始假设每条路径都经过了所有颜色，再把每种颜色没经过的路径数减去就行，这个应该很好理解。问题是怎么算没经过的路径数？操作是这样的，如果算颜色1没经过的路径数，我们先把图里所有颜色是1的节点遮起来（假设这个点不存在，图在这个点是断路），图就被分成了很多块，</strong>每块的值= 那一块里的顶点数<em>（那一块里的顶点数-1）/2*</em>。 所有块的值加起来就是不经过颜色1的所有路径数。 到这里是不是还是很好理解，那么问题来了，怎么实现？…题解里说用虚树什么的… 用一个DFS即可，复杂度O（n） 用Size数组储存以每个节点为根节点的子树大小（即子树里节点的个数），Sum数组…很难解释，大概是表示以每种颜色为根节点的子树的大小和，但不是非常准确，如果以颜色2为根节点的子树里还含有颜色为2的节点，那只要算根节点这个颜色为2的子树大小即可，若在以这个颜色为2的点为根节点的子树之外还有颜色为2的点，那还要加上这个点的值…不知道能不能理解…解释不清楚，大概就这个意思… 以下图颜色2为例，代码里最后的for里(即以根<strong>第一个节点</strong>计算中)减去的（n-sum[2]）*（n-sum[2]-1）/2的那部分减去的是下图橙色圈里的那块，dfs里<code>减去pp那部分</code>是下图里蓝色圈的那块。其他具体的按照自己的理解再思考思考。 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" alt></a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 200005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\n//c[]数组是每个节点的颜色\nint c[maxn],head[maxn],len,sum[maxn],size[maxn],vis[maxn];\nLL d;\n//边表\n//邻接表\nstruct node{\n    int v,next;\n}p[maxn&lt;&lt;1];\n\nvoid addedge(int u,int v){\n    //有向边指向点的编号\n    p[len].v=v;\n    //每条边的下一条边是上一次纪录的边的号码\n    p[len].next=head[u];\n    //邻接表的方法\n    //len为当前边的编号\n\n    //只记录当前节点的最后一个边的位置\n    head[u]=len++;\n}\n//对树进行dfs\nvoid dfs(int x,int fa){\n    //非这个点为根的所有该颜色的点\n    LL pre=sum[c[x]];\n    //size数组是当前节点的子节点总数目\n    size[x]=1;\n    int add=0;\n    //通过邻接表对当前节点x进行dfs\n    //等于0则退出\n    for(int i=head[x];~i;i=p[i].next){\n        //如果遇到反向边了,跳过,继续往其他边走\n        if(p[i].v==fa)\n            continue;\n        dfs(p[i].v,x);\n        size[x] += size[p[i].v];\n        //计算当前节点子树所有和当前节点颜色不同的点的个数\n        LL count = size[p[i].v] - sum[c[x]] + pre;\n        pre = sum[c[x]];\n        //当前子树的不同颜色点的个数\n        add += count;\n        //假设其他颜色都是白色,d即等于不同颜色所组成的边的总个数\n        d += count*(count-1)&gt;&gt;1;\n    }\n    //计算以x为根节点子树的所有与x不同颜色的点的个数\n    sum[c[x]] += add + 1;\n}\n\nint main(){\n    int n,tcase=1;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        memset(head,-1,sizeof(head));\n        memset(sum,0,sizeof(sum));\n        memset(vis,0,sizeof(vis));\n        d=len=0;\n        LL number = 0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            //记录颜色,颜色范围是[1,n]\n            if(!vis[c[i]]){\n                vis[c[i]]=1;\n                number++;\n            }\n        }\n        for(int i=1;i&lt;n;++i){\n            int u,v;\n            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);\n            addedge(u,v);\n            addedge(v,u);\n        }\n        dfs(1,0);\n        //ans初始等于(颜色个数)*(所有边的个数)-d(d为每个颜色在每个子树上被减去的不会经过那个颜色的路径的个数)\n        LL ans=(number*(n-1)*n&gt;&gt;1)-d;\n        for(int i=1;i&lt;=n;++i){\n            //不存在的颜色不需要计算,把已存在的颜色计算一下\n            if(vis[i]&amp;&amp;i!=c[1]){\n                //在根节点中与颜色i不同的颜色的个数\n                LL count=n-sum[i];\n                //每个颜色的路径数=(n*(n-1)&gt;&gt;1)-(count*(count-1)&gt;&gt;1)\n                //以根节点为中心减去不同于当前颜色的路径的个数\n                //最终得到的ans即为 每个颜色路径个数 的和\n                ans-=count*(count-1)&gt;&gt;1;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,tcase++,ans);\n    }\n    return 0;\n}</code></pre><h2><span id=\"1006-function-hdoj6038\"><strong>1006 Function hdoj6038</strong></span></h2><p>这道题似懂非懂的写了出来… 大体是寻找循环节. 我写的代码有点乱… 原式为: f[i]=b[f[a[i]]] A:{1,0,2} B{0,1} 可组成f: 000 111 110 001 A:{2,0,1} b{0,2,3,1} 可组成f: 000 231 312 123 以i -&gt; a[i] i -&gt; b[i] 为图的边进行Tarjan. 用Tarjan判断a和b各自有几个环(强连通分量),并且记录下每个环的大小. 然后AC代码如下(以后思路清楚了再重新看看…):</p>\n<pre><code>//HDU 6038\n#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\nconst int maxn=100000+100;\nconst int mod=1e9+7;\ntypedef long long int lli;\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint a[maxn],b[maxn];\n\nstack&lt;int&gt; S;\nmap&lt;int,int&gt; A,B;\n\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\ninline lli qp(lli aa,lli x){\n    if(aa == 0) return 0;\n    lli ans = 1;\n    for(;x;x&gt;&gt;=1){\n        if(x&amp;1) ans = ans*aa % mod;\n        aa = aa*aa % mod;\n    }\n    return ans % mod;\n}\n\nvoid dfs(int u,map&lt;int,int&gt;&amp; T){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v,T);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            //未回溯时计算low数组需要通过pre数组\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        int cnt=0;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            cnt++;\n            if(x==u)break;\n        }\n        T[cnt]++;\n    }\n}\n\nvoid Tarjan(int n,map&lt;int,int&gt;&amp; T){\n    while(!S.empty()){\n        S.pop();\n    }\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i,T);\n    }\n}\n\nint main(){\n    int n,m,kase=0;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;a[i]);\n        }\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;b[i]);\n        }\n        //对aTarjan\n        for(int i=0;i&lt;n;++i){\n            addAdge(i,a[i]);\n        }\n        Tarjan(n,A);\n        for(int i=0;i&lt;n;++i){\n            G[i].clear();\n        }\n        //对bTarjan\n        for(int i=0;i&lt;m;++i){\n            addAdge(i,b[i]);\n        }\n        Tarjan(m,B);\n        for(int i=0;i&lt;m;++i){\n            G[i].clear();\n        }\n\n        long long ans=1;\n        map&lt;int,int&gt;::iterator it1;\n        map&lt;int,int&gt;::iterator it2;\n        for(it1=A.begin();it1!=A.end();it1++){\n            long long tmp=0;\n            for(it2=B.begin();it2!=B.end();it2++){\n                if(it1-&gt;first%it2-&gt;first==0){\n                    tmp=tmp+it2-&gt;second*it2-&gt;first;\n                }\n                //printf(&quot;%d %d : %d %d\\n&quot;,it1-&gt;first,it2-&gt;first,it1-&gt;second,it2-&gt;second);\n            }\n            ans=ans*qp(tmp,it1-&gt;second)%mod;\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n        A.clear();\n        B.clear();\n    }\n    return 0;\n}</code></pre><h2><span id=\"1008-hints-of-sd0061-hdoj6040\"><strong>1008 Hints of sd0061 hdoj6040</strong></span></h2><h1><span id=\"第二场\"><strong>第二场</strong></span></h1><h1><span id=\"第三场\"><strong>第三场</strong></span></h1>","text":"[toc]第一场1003 Colorful Tree hdoj6035题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) * //思路：Answer = 所有颜色种类 * 所有路径数量","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"dfs","slug":"2017多校/dfs","count":1,"path":"api/categories/2017多校/dfs.json"},{"name":"图论","slug":"2017多校/dfs/图论","count":1,"path":"api/categories/2017多校/dfs/图论.json"},{"name":"思维","slug":"2017多校/dfs/图论/思维","count":1,"path":"api/categories/2017多校/dfs/图论/思维.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]}]}