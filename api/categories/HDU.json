{"name":"HDU","slug":"HDU","count":12,"postlist":[{"title":"数据结构补充","slug":"datastruct-add","date":"2018-02-13T13:12:07.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/datastruct-add.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…</p>\n<blockquote>\n<p>注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"并查集\">并查集</span></h1><h2><span id=\"要领\">要领</span></h2><blockquote>\n<p>以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.</p>\n<blockquote>\n<p>并查集是不可能分割的,即只能合并,不可分割.</p>\n<blockquote>\n<p>在牛客上听大佬讲课貌似存在可分割并查集,带权并查集.</p>\n</blockquote>\n</blockquote>\n<p>现在拓宽下,并查集常用于判断加入一个点后是否会在原图上形成环. 或者判断有几个连通分量(通常是无向图),然后问你这些节点全部关联起来至少需要添加几条边.</p>\n</blockquote>\n<h2><span id=\"实现前奏\">实现前奏</span></h2><blockquote>\n<p>首先是逻辑,并查集实现规则是一个点一个点入图时进行合并,即join,然后在合并时进行find,查找根节点是否相同,不同则将浅的树合并到深的树上,判断深浅通过每次合并时对rank进行操作,然后在一个优化是路径压缩,即如果a节点的最高根节点是c,则直接将a记录为c即可.</p>\n<blockquote>\n<p>以上实现的前提是我们只需要逻辑上正确即可.</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"以题为马\">以题为马</span></h2><blockquote>\n<p>HDU 1232 判断有多少个连通块,然后答案就是ans-1</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nstruct DisjointSet{\n    vector&lt;int&gt; father,rank;\n    int Num;\n    DisjointSet(int n):father(n),rank(n),Num(n){\n        for(int i=1;i&lt;n;++i){\n            father[i]=i;\n        }\n    }\n\n    int find(int v){\n        return father[v]=father[v]==v?v:find(father[v]);\n    }\n\n    void merge(int x,int y){\n        int a=find(x),b=find(y);\n        if(rank[a]&lt;rank[b]){\n            father[a]=b;\n        }else{\n            father[b]=a;\n            if(rank[a]==rank[b]){\n                ++rank[a];\n            }\n        }\n    }\n\n    int getCnum(){\n        int ans=0;\n        for(int i=1;i&lt;Num;++i){\n            if(father[i]==i) ans++;\n        }\n        return ans-1;\n    }\n};\n\nint main(){\n    int m,n;\n\n    while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        DisjointSet ds(n+1);\n        int s,t;\n        scanf(&quot;%d&quot;,&amp;m);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d %d&quot;,&amp;s,&amp;t);\n            ds.merge(s,t);\n        }\n        printf(&quot;%d\\n&quot;,ds.getCnum());\n    }\n    return 0;\n}</code></pre><h1><span id=\"单调栈\">单调栈</span></h1><h1><span id=\"线段树区间更新和查询\">线段树区间更新和查询</span></h1><p>POJ 3468</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q;\nLL lazy[maxn];\nLL sum[maxn];\nLL tree[maxn];\nLL a[maxn];\n\nvoid build(int p,int l,int r){\n    if(l==r){tree[p]=a[l];return;}\n    int mid=(l+r)&gt;&gt;1;\n    build(p&lt;&lt;1,l,mid);\n    build(p&lt;&lt;1|1,mid+1,r);\n    tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];\n}\n\nvoid PushDown(int p,int m){\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nLL find(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return tree[p];\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=find(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=find(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n    for(int i=1;i&lt;=N;++i) scanf(&quot;%lld&quot;,&amp;a[i]);\n    build(1,1,N);\n    char op;\n    int l,r,c;\n    while(Q--){\n        cin&gt;&gt;op;\n        if(op==&apos;Q&apos;){\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            printf(&quot;%lld\\n&quot;,Query(1,1,N,l,r)+find(1,1,N,l,r));\n        }else if(op==&apos;C&apos;){\n            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);\n            update(1,1,N,c,l,r);\n        }\n    }\n    return 0;\n}</code></pre>","text":"2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.并查集要领以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.并查集是不可能分割的,即只能合并,不可分割.在牛客上听大","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"并查集","slug":"HDU/并查集","count":1,"path":"api/categories/HDU/并查集.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"}]},{"title":"HDU 1431","slug":"hdu-1431","date":"2018-02-06T14:37:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1431.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1431\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>\n<h1><span id=\"type-二分线性素数筛\">type: 二分,线性素数筛</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>先用线筛打1000W的表,然后二分查找a的下标,暴力a到b内素数是否是回文数即可.</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000000+10;\nint a,b,tot=0;\n\nbool valid[maxn];\nint prime[maxn];\nvoid init(int n,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint query(int len,int key){\n    int left=1;\n    int right=len;\n    int mid;\n    while(left&lt;=right){\n        mid=(left+right)&gt;&gt;1;\n        if(key&lt;prime[mid]){\n            right=mid-1;\n        }else if(key&gt;prime[mid]){\n            left=mid+1;\n        }else return mid;\n    }\n    return -1;\n}\n\nbool check(int n){\n    if((n/10)==0) return true;\n    int str[20];\n    int len=0,l=n;\n    for(;l&gt;0;){\n        ++len;\n        str[len]=l%10;\n        l/=10;\n    }\n    for(int i=1;i&lt;=len;++i){\n        if(str[i]!=str[len-i+1]) return false;\n    }\n    return true;\n}\n\nint main(){\n    init(10000000,prime);\n    while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b)){\n        int id=query(tot,a);\n        for(int i=id;prime[i]&lt;=b &amp;&amp; prime[i];++i){\n            if(check(prime[i])){\n                printf(&quot;%d\\n&quot;,prime[i]);\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttp://acm.hdu.edu.cn/showproblem.php?pid=1431type: 二分,线性素数筛题意题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.题解先用线筛打1000W的表,然后二分","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"二分搜索","slug":"HDU/二分搜索","count":1,"path":"api/categories/HDU/二分搜索.json"},{"name":"数论","slug":"HDU/二分搜索/数论","count":1,"path":"api/categories/HDU/二分搜索/数论.json"},{"name":"线性素数筛法","slug":"HDU/二分搜索/数论/线性素数筛法","count":1,"path":"api/categories/HDU/二分搜索/数论/线性素数筛法.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 1021","slug":"hdu-1021","date":"2018-02-09T12:25:13.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1021.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/HDU-1021\" title=\"https://vjudge.net/problem/HDU-1021\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-1021</a></p>\n<h1><span id=\"type-数论同余定理和余数性质找规律也可以\">Type: 数论,同余定理和余数性质,找规律也可以</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11</p>\n<blockquote>\n<p>问:</p>\n<blockquote>\n<p>给你一个数n,如果f(n)整除3,则输出yes,否则no.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>(1) 暴力输出一波会发现如果 n%4==2,则输出yes (2) 正解:</p>\n<blockquote>\n<p>问题可以转换成 f(n)%3 是否等于0 那么我们只需要记录下每个 f(n)%3 的值即可 f(n)≡(f(n-1)+f(n-2))(mod 3) n&gt;=2 f(n)=((f(n-1)%3)+(f(n-2)%3))%3</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><h2><span id=\"1-找规律\">1-找规律</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(n%4==2){\n            printf(&quot;yes\\n&quot;);\n        }else{\n            printf(&quot;no\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre><h2><span id=\"2-正解\">2-正解</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nint m[maxn];\n\nvoid init(){\n    m[0]=7,m[1]=11;\n    for(int i=2;i&lt;=1000000;++i){\n        m[i]=((m[i-1]%3)+(m[i-2]%3))%3;\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        printf(&quot;%s\\n&quot;,(!m[n])?&quot;yes&quot;:&quot;no&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-1021Type: 数论,同余定理和余数性质,找规律也可以题意f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11问:给你一个数n,如果f(n)整除3,则输出yes,否则no.题解(1) 暴力输出","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 1846","slug":"hdu-1846","date":"2018-01-24T08:33:41.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1846.json","excerpt":"","keywords":null,"cover":null,"content":"<p>裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        if((n)%(m+1)==0) printf(&quot;second\\n&quot;);\n        else printf(&quot;first\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ ","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"巴什博奕","slug":"巴什博奕","count":1,"path":"api/tags/巴什博奕.json"}]},{"title":"HDU 1847","slug":"hdu-1847","date":"2018-01-24T09:54:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1847.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"博弈论-sg函数\">【博弈论 - SG函数】</span></h1><h2><span id=\"题目\">题目:</span></h2><h3><span id=\"good-luck-in-cet-4-everybody\">Good Luck in CET-4 Everybody!</span></h3><p>Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 11483 Accepted Submission(s): 7446 大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。 “升级”？“双扣”？“红五”？还是“斗地主”？ 当然都不是！那多俗啊~ 作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的： 1、 总共n张牌; 2、 双方轮流抓牌； 3、 每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…） 4、 抓完牌，胜负结果也出来了：最后抓完牌的人为胜者； 假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？ 当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。 Good luck in CET-4 everybody!</p>\n<h2><span id=\"input\">Input</span></h2><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p>\n<h2><span id=\"output\">Output</span></h2><p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p>\n<h2><span id=\"sampleinput\">SampleInput</span></h2><p>1 3</p>\n<h2><span id=\"sampleoutput\">SampleOutput</span></h2><p>Kiki Cici</p>\n<h2><span id=\"题解\">题解</span></h2><p>首先我们要知道SG函数代表的是当前状态的数值.如果是0,则为先手必败(SG函数值为可到达状态中未出现的最小的整数).然后我们从SG函数延伸一下– 1.我们假设当n=0时,先手必败. 2.当n=1时,因为S(0)=0，所以当前状态是非奇异局势.先手必胜,即,你可以通过拿走一定的牌使下一个拿牌的人的局势变成奇异局势(必败态). 即转移给下一个抽牌者状态为S(0). 3.当n=2是,因为S(0)=0，S(1)=1.所以当前状态是非奇异局势,先手必胜. 即你可以把下一个抽牌者状态转换成S(0). 4.当n=3时,可到达状态为S(3-1)=S(2)=1.S(3-2)=S(1)=1.因为无论往那个状态走,都会使对方先手必胜,所以该局势为奇异局势.先手必败. 故我们可以根据以上推理过程将全部的1000个状态是否必胜预处理处来.其预处理过程为<strong>检查可以到达的状态是否存在奇异局势,如果存在,则该局势为非奇异局势,即先手必胜态</strong>. 因为可拿牌数都是2^n.所以预处理复杂度为O(nlg(n)). PS…:其实预处理完以后你会发现.每当n%3==0时,为奇异局势. Code:</p>\n<pre><code>//SG函数\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nbool game[1001];\n\nvoid init(){\n    memset(game,false,sizeof(game));\n    for(int i=1;i&lt;=1000;++i){\n        int t=1;\n        while(i-t&gt;=0){\n            //如果i-t是奇异局势,则先手必胜\n            if(!game[i-t]){\n                game[i]=true;\n                break;\n            }\n            t&lt;&lt;=1;\n        }\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(game[n]){\n            printf(&quot;Kiki\\n&quot;);\n        }else{\n            printf(&quot;Cici\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【博弈论 - SG函数】题目:Good Luck in CET-4 Everybody!Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submissio","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 1849","slug":"hdu-1849","date":"2018-01-24T10:35:08.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1849.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg","content":"<p>【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" alt></a> 原题说我们需要将每个格子内的棋子进行移动,当所有棋子都位于最左边编号为0的格子时,游戏结束. 首先我们将棋盘竖起来(自己画的,所以会少一点,但大体意思一样). <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124182908.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124182908.png\" alt></a> 然后我们将其中的棋子分开来: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124183152.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124183152.png\" alt></a> 这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时,即代表石子已取空. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int K;\n    while(~scanf(&quot;%d&quot;,&amp;K)){\n        if(K==0) break;\n        int ans=0;\n        while(K--){\n            int a;\n            scanf(&quot;%d&quot;,&amp;a);\n            ans^=a;\n        }\n        if(ans==0)puts(&quot;Grass Win!&quot;);\n        else puts(&quot;Rabbit Win!&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图:  [Figure]  这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2035","slug":"hdu-2035","date":"2018-02-11T08:47:36.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2035.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/HDU-2035\" title=\"https://vjudge.net/problem/HDU-2035\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2035</a></p>\n<h1><span id=\"type-同余定理\">Type: 同余定理</span></h1><h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>可以将提议理解为 ans%1000</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1000;\nint main(){\n    int A,B;\n    while(cin&gt;&gt;A&gt;&gt;B&amp;&amp;A+B){\n        int ans=1;\n        for(int i=1;i&lt;=B;++i){\n            ans=((ans%mod)*(A%mod))%mod;\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-2035Type: 同余定理题解可以将提议理解为 ans%1000Code#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=1000;","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2098","slug":"hdu-2098","date":"2017-04-18T04:25:02.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/hdu-2098.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>数位dp入门</strong> <strong>【Tip】</strong> <strong><a href=\"http://www.cnblogs.com/wenruo/p/4725005.html\" target=\"_blank\" rel=\"noopener\">一个blog</a></strong> <strong><a href=\"https://wenku.baidu.com/view/9de41d51168884868662d623.html\" target=\"_blank\" rel=\"noopener\">一个ppt</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 数位dp入门 【Tip】 一个blog 一个ppt 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"动态规划","slug":"HDU/动态规划","count":1,"path":"api/categories/HDU/动态规划.json"},{"name":"数位DP","slug":"HDU/动态规划/数位DP","count":1,"path":"api/categories/HDU/动态规划/数位DP.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"}]},{"title":"HDU 2099","slug":"hdu-2099","date":"2016-12-26T09:54:51.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/hdu-2099.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【暴力水+整除】 因为数据量不大. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int main(){<br>    int a,b;<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>        if(a==0&amp;&amp;b==0)<br>            break;<br>        int flag=0;<br>        for(int i=0;i&lt;=99;++i)<br>        {<br>            if((i+a*100)%b==0)<br>                if(i&lt;10)<br>                    flag==0?flag=1,cout&lt;&lt;”0”&lt;&lt;i:cout&lt;&lt;” 0”&lt;&lt;i;<br>                else<br>                    flag==0?flag=1,cout&lt;&lt;i:cout&lt;&lt;” “&lt;&lt;i;<br>        }<br>        cout&lt;&lt;endl;<br>    }<br>    return 0;<br>}</algorithm></p>\n","text":"【暴力水+整除】 因为数据量不大. 【Code】#include#include<br>using namespace std;<br>int main(){<br>    int a,b;<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>    ","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"算法学习","slug":"HDU/算法学习","count":1,"path":"api/categories/HDU/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2149","slug":"hdu-2149","date":"2018-01-24T08:16:55.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2149.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"巴什博奕\">【巴什博奕】</span></h1><h2><span id=\"题目\">题目:</span></h2><p>虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。 后来发现，整个拍卖会只有Lele和他的死对头Yueyue。 通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。 Lele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。 由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候， Lele要出多少才能保证自己买得到这块地呢？</p>\n<h2><span id=\"input\">Input:</span></h2><p>本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。 每组测试包含两个整数M和N(含义见题目描述，0&lt;N，M&lt;1100)</p>\n<h2><span id=\"output\">Output:</span></h2><p>对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。 如果Lele在第一次无论如何出价都无法买到这块土地，就输出”none”。</p>\n<h2><span id=\"sample-input\">Sample Input:</span></h2><p>4 2 3 2 3 5</p>\n<h2><span id=\"sample-output\">Sample Output:</span></h2><p>1 none 3 4 5</p>\n<h2><span id=\"题解\">题解</span></h2><p>我们知道,在巴士博弈中,n=0为先手必输态,之后n=m+1为下一个先手必输态. 而当Lele在竞拍的时候,如果他所在的初始状态是如上所述的这样一个奇异局势(即先手必输局势),那他一定输(none). 当Lele在竞拍处于非奇异局势时,在选择最优的情况下,他一定可以赢得竞拍.即他只需要通过增价将对手置于奇异状态即可. 所以当我们想要找出Lele第一次出家的可能性时,只需要先找出Lele的第一个置对方为奇异局势的 价格 .然后在寻找下一个的时候只需要依次++,直到下一次加价会给对方一个 非奇异局势前 结束循环. 当然,存在一种可能性就是,初次加价可能会溢出n的价格范围.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n,m;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        if(n%(m+1)==0) printf(&quot;none\\n&quot;);\n        else{\n            int next=0;\n            while(1){\n                next++;\n                if((n-next)%(m+1)==0){\n                    printf(&quot;%d&quot;,next);\n                    break;\n                }\n            }\n            while(next&lt;m){\n                next++;\n                if((n-next)%(m+1)==0 || next&gt;=n){\n                    printf(&quot; %d&quot;,next);\n                }else{\n                    break;\n                }\n            }\n            printf(&quot;\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】题目:虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2188","slug":"hdu-2188","date":"2018-01-24T07:49:43.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-2188.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"巴什博奕\">【巴什博奕】</span></h1><p>可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    while(~scanf(&quot;%d&quot;,&amp;T)){\n        while(T--){\n            scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n            if((n)%(m+1)==0) printf(&quot;Rabbit\\n&quot;);\n            else printf(&quot;Grass\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int T,n,m;    while(~s","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2588 GCD","slug":"hdu-2588-gcd","date":"2017-11-25T11:45:09.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/hdu-2588-gcd.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 数论-欧拉函数-折半枚举 原题连接: <a href=\"https://vjudge.net/problem/HDU-2588\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2588</a></p>\n<blockquote>\n<p>题意</p>\n<blockquote>\n<p>输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.</p>\n</blockquote>\n<p>题解</p>\n<blockquote>\n<p>首先无法枚举X求GCD(X,N) 我们考虑 (X,N) = (q*d,b*d) 其中d是X,N的最大公约数. 可以知道 b&gt;=q 且 b与q互质①. 所以就转换成了对每个这样的d求 euler(b)(见①) 且 d&gt;=M 的个数. 也就转换成了枚举d求euler(b)之和.但是这仍是O(TNlgN)复杂度的. 所以我们采用折半枚举的做法,因为要枚举的是d,而d*b在sqrt(N)之后就变成了b*d了.所以我们可以只需要枚举sqrt(N)个数,将b,d都看做b即可.</p>\n</blockquote>\n</blockquote>\n<p>Code:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    for(int i=0;i&lt;T;++i){\n        int ans=0;\n        int N,M;\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;M);\n        for(int i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                if(i&gt;=M)\n                    ans+=euler(N/i);\n                if((N/i)!=i &amp;&amp; (N/i)&gt;=M)\n                ///如果==i且&gt;=M的话证明i&gt;=M,而不需要计算两次,所以排除掉\n                    ans+=euler(i);\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"类型: 数论-欧拉函数-折半枚举 原题连接: https://vjudge.net/problem/HDU-2588题意输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.题解首先无法枚举X求GCD(X,N) 我们考","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"数论","slug":"HDU/数论","count":1,"path":"api/categories/HDU/数论.json"},{"name":"欧拉函数","slug":"HDU/数论/欧拉函数","count":1,"path":"api/categories/HDU/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]}]}