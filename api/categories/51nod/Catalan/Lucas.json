{"name":"Lucas","slug":"51nod/Catalan/Lucas","count":1,"postlist":[{"title":"51nod 1120 机器人走方格 V3","slug":"51nod-1120-rm-v3","date":"2018-03-07T12:59:38.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1120-rm-v3.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png","content":"<h1><span id=\"typelucascatalan序列逆元\">Type:Lucas+Catalan序列+逆元</span></h1><h1><span id=\"题目\">题目</span></h1><p>N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。</p>\n<h1><span id=\"input\">Input</span></h1><p>输入一个数N(2 &lt;= N &lt;= 10^9)。</p>\n<h1><span id=\"output\">Output</span></h1><p>输出走法的数量 Mod 10007。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>4</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>10</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>画图会发现就是一个Catalan序列, 但我一开始没理解题意,原来只是不能跨过斜线,但可以在斜线上走…</p>\n<blockquote>\n<p>在Excel中画了一下,因为两边是对称的,所以我们只需要求一边,将最终的答案*2即可.</p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png\" alt></p>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=10007;\n\nLL Pow(LL a,LL b,LL p){\n    LL ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%p;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%p;\n    }\n    return ans;\n}\n\nLL Comb(LL a,LL b,LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Pow(cb, p-2,p))%p;\n    return ans;\n}\nLL Lucas(LL n, LL m, LL p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inv(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nint main(){\n    LL N;\n    while(cin&gt;&gt;N){\n        N=N-1;\n        LL d1,d2;\n        LL x=Lucas(2*N,N,mod);\n        LL d=inv(N+1,mod);\n        //cout&lt;&lt;&quot;Lucas: &quot;&lt;&lt;x&lt;&lt;endl;\n        //cout&lt;&lt;&quot;Inv: &quot;&lt;&lt;d&lt;&lt;endl;\n        cout&lt;&lt;2*x*d%mod&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:Lucas+Catalan序列+逆元题目N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。Input输入一个","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"Catalan","slug":"51nod/Catalan","count":1,"path":"api/categories/51nod/Catalan.json"},{"name":"Lucas","slug":"51nod/Catalan/Lucas","count":1,"path":"api/categories/51nod/Catalan/Lucas.json"},{"name":"数论","slug":"51nod/Catalan/Lucas/数论","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论.json"},{"name":"组合数学","slug":"51nod/Catalan/Lucas/数论/组合数学","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学.json"},{"name":"逆元","slug":"51nod/Catalan/Lucas/数论/组合数学/逆元","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"Catalan","slug":"Catalan","count":1,"path":"api/tags/Catalan.json"},{"name":"Lucas","slug":"Lucas","count":1,"path":"api/tags/Lucas.json"}]}]}