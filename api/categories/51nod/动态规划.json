{"name":"动态规划","slug":"51nod/动态规划","count":3,"postlist":[{"title":"51nod 1201 整数划分","slug":"51nod-1201-int-pagi","date":"2018-03-06T01:33:53.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1201-int-pagi.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"typedp思维\">Type:DP,思维</span></h1><h1><span id=\"题意\">题意</span></h1><p>将N分为若干个不同整数的和，有多少种不同的划分方式，例如：n = 6，{6} {1,5} {2,4} {1,2,3}，共4种。由于数据较大，输出Mod 10^9 + 7的结果即可。</p>\n<h1><span id=\"input\">Input</span></h1><p>输入1个数N(1 &lt;= N &lt;= 50000)。</p>\n<h1><span id=\"output\">Output</span></h1><p>输出划分的数量Mod 10^9 + 7。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>6</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>4</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>首先我们可以由</p>\n<blockquote>\n<p>1+2+3+…+m=n 估算出 大概只有sqrt(2*n)个数字左右</p>\n</blockquote>\n<p>我们设当前状态为 dp[i][j]</p>\n<blockquote>\n<p>dp[i][j] 代表当前数字为 j ,被划分成了 i 部分. 状态转移推倒:</p>\n<blockquote>\n<p>我们假设已知所有 dp 的划分数序列. (1) 我们将 dp[i][j-i] 每个 划分数每个数字 +1 ,我们将得到 不存在1 的划分数. (2) 我们将 dp[i-1][j-i] 每个 划分数每个数字(共 i-1 个) +1 ,我们将得到 不存在1 的且长度为 i-1 ,和为 j-1 的划分数,然后我们将 1 放到划分数中,即得到全部 有1 的划分数.</p>\n</blockquote>\n<p>即 dp[i][j]=(dp[i][j-i]+dp[i-1][j-i])%mod</p>\n</blockquote>\n<p>正确性证明:</p>\n<blockquote>\n<p>假设已知 dp[i][j] 的全部序列. 我们只需要一直对每个数字 -1 就可以将所有序列置为 全0.</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"给一个例子自己倒着推一下也成立\">给一个例子自己倒着推一下也成立</span></h1><pre><code>组成1的 有 {1} \n\n组成2的 有 {2} \n\n组成3的 有 {1,2} {3}\n\n组成4的 有 {1,3} {4}\n\n组成5的 有 {1,4} {2,3} {5}\n\n组成6的 有 {1,5} {2,4} {1,2,3} {6}\n\n组成7的 有 {1,6} {2,5} {3,4} {1,2,4} {7}</code></pre><h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=50010;\nconst LL mod=1e9+7;\nint N;\nLL dp[330][maxn];\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;N);\n    dp[1][1]=1ll;\n    for(int i=2;i&lt;=N;++i){\n        for(int j=1;j&lt;=(int)sqrt(2*i);++j){\n            dp[j][i]=(dp[j][i-j]+dp[j-1][i-j])%mod;\n        }\n    }\n    LL ans=0;\n    for(int i=1;i&lt;=(int)sqrt(2*N);++i) ans=(ans+dp[i][N])%mod;\n    printf(&quot;%lld\\n&quot;,ans);\n    return 0;\n}</code></pre>","text":"Type:DP,思维题意将N分为若干个不同整数的和，有多少种不同的划分方式，例如：n = 6，{6} {1,5} {2,4} {1,2,3}，共4种。由于数据较大，输出Mod 10^9 + 7的结果即可。Input输入1个数N(1 &lt;= N &lt;= 50000)。Out","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51NOD 1241 特殊的排序","slug":"51nod-1241-tsds","date":"2018-03-08T10:57:18.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1241-tsds.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type动态规划思维最长等差数列简化\">Type:动态规划,思维,最长等差数列(简化)</span></h1><h1><span id=\"题目\">题目</span></h1><p>一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾部 =&gt; 1 2 3 4 5 这样就排好了，移动了2个元素。 给出一个1-N的排列，输出完成排序所需的最少移动次数。</p>\n<h1><span id=\"input\">Input</span></h1><p>第1行：1个数N(2 &lt;= N &lt;= 50000)。 第2 - N + 1行：每行1个数，对应排列中的元素。</p>\n<h1><span id=\"output\">Output</span></h1><p>输出1个数，对应所需的最少移动次数。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>5 2 5 3 4 1</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>2</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>一开始会想到和逆序数有关,排序就是减少逆序数,所以会想到其中非逆序序列中最长的那个不用变化. 然后可以容易地证明剩余的数只需要移动一次即可到达正确的位置上</p>\n<blockquote>\n<p>比如 12346587 可以发现最长等差整数序列是 12345 而我们需要 12345678 第一次: 1234587 6 第二次: 1234586 7 第三次: 1234567 8 OK,往数列前面放的也一样</p>\n</blockquote>\n<p>那么我们的问题就是如何求最长等差数列(等差为1)了,</p>\n<blockquote>\n<p>因为等差为1,所以我们不难想到: dp[i] 为数字 i 的最长等差数列. 遍历Num[]数组的时候计算 dp 即可 dp[i]=dp[i-1]+1</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=50000+10;\n\nint dp[maxn],N,Num[maxn],max_;\n\nint main(){\n    while(cin&gt;&gt;N){\n        memset(dp,0,sizeof(dp));\n        dp[0]=0;\n        max_=1;\n        for(int i=1;i&lt;=N;++i){\n            cin&gt;&gt;Num[i];\n        }\n        for(int i=1;i&lt;=N;++i){\n            dp[Num[i]]=dp[Num[i]-1]+1;\n            max_=max(dp[Num[i]],max_);\n            //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;dp[Num[i]]&lt;&lt;endl;\n        }\n        cout&lt;&lt;N-max_&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:动态规划,思维,最长等差数列(简化)题目一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"思维","slug":"51nod/动态规划/思维","count":1,"path":"api/categories/51nod/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51nod DP-矩阵取数问题","slug":"51nod-dp-study","date":"2016-12-24T14:22:05.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/51nod-dp-study.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x – 1, y) , f(x, y – 1) ) + A[x][y] 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<vector><br>using namespace std;<br>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    vector&lt;vector<int> &gt; ve(N+1,vector<int>(N+1,0)),dp(N+1,vector<int>(N+1,0));</int></int></int></vector></p>\n<pre><code>for(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        cin&gt;&gt;ve\\[i\\]\\[j\\];\n\nfor(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        dp\\[i\\]\\[j\\]=max(dp\\[i-1\\]\\[j\\],dp\\[i\\]\\[j-1\\])+ve\\[i\\]\\[j\\];\n\ncout&lt;&lt;dp\\[N\\]\\[N\\]&lt;&lt;endl;\n\nreturn 0;</code></pre><p>}</p>\n","text":"【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"算法学习","slug":"51nod/动态规划/算法学习","count":1,"path":"api/categories/51nod/动态规划/算法学习.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}]}