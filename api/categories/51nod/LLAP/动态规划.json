{"name":"动态规划","slug":"51nod/LLAP/动态规划","count":1,"postlist":[{"title":"51nod 1055 最长等差数列","slug":"51nod-1055-llap","date":"2018-03-08T11:18:14.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1055-llap.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type-动态规划双向dp思维技巧\">Type: 动态规划,双向DP,思维,技巧</span></h1><h1><span id=\"题目\">题目</span></h1><p>N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10 12 14 其中6 8 10 12 14最长，长度为5。</p>\n<h1><span id=\"input\">Input</span></h1><p>第1行：N，N为正整数的数量(3 &lt;= N &lt;= 10000)。 第2 - N+1行：N个正整数。(2&lt;= A[i] &lt;= 10^9)</p>\n<h1><span id=\"output\">Output</span></h1><p>最长等差数列的长度。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>10 1 3 5 6 8 9 10 12 13 14</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>5</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>数据范围可判是O(N^2) 一开始我一直在想如何把数字,即两个数之间的差用哈希存起来,来方便dp. 然后搜了题解发现是论文题. 被叫做LLAP问题 Length of the Longest Arithmetic Progressio</p>\n</blockquote>\n<h2><span id=\"论文link\">论文Link:</span></h2><p><a href=\"https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/\" target=\"_blank\" rel=\"noopener\">https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/</a></p>\n<h2><span id=\"论文解释\">论文解释</span></h2><blockquote>\n<p>这道题可以转化为:</p>\n<blockquote>\n<p>给与一个 排过序 的集合set,我们要求这个集合中的最长等差数列的长度.</p>\n</blockquote>\n<p>标重点: 序列是已排好序的 我们设 dp[i][j] 为以下标 i 和 j 两个元素开头的等差序列最长长度. 我们可以创建一个浮标 j 作为等差数列的中间值</p>\n<blockquote>\n<p>初始化一个 i=j-1,k=j+1.</p>\n<blockquote>\n<p>1.如果 set[i]+set[k] &lt; set[j]*2</p>\n<blockquote>\n<p>k++</p>\n</blockquote>\n<p>2.如果 set[i]+set[k] &gt; set[j]*2</p>\n<blockquote>\n<p>i–</p>\n</blockquote>\n<p>如果 set[i]+set[k]=set[j]*2</p>\n<blockquote>\n<p>则构成等差数列,我们只需要让</p>\n<blockquote>\n<p>dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1</p>\n</blockquote>\n<p>如果dp[j][k]=0的话,dp[i][j]直接=3就可以了,因为 i,j,k 三个刚好构成等差数列.否则等于 dp[j][k]+1</p>\n</blockquote>\n<p>计算完以后 i–,k++ 继续计算其他以 j 为第二个点的等差数列</p>\n</blockquote>\n<p>倒序计算,正序反过来即可</p>\n</blockquote>\n<p>另外: 还可以 直接将 dp 数组初始化为 2(因为每个数的等差数列至少为2). dp[i][j]=dp[j][k]+1 另外有一个小技巧: 如果int的取值范围不大,但是数组要开很大的时候,可以用 short int,比如这道题.</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxn=10000;\n\nshort int dp[maxn][maxn];\nint Num[maxn],ans,N;\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;Num[i]);\n        }\n        sort(Num,Num+N);\n        ans=0;\n        for(int j=N-2;j&gt;=1;--j){\n            int i=j-1,k=j+1;\n            while(k&lt;N&amp;&amp;i&gt;=0){\n                if(Num[i]+Num[k]&gt;2*Num[j]){\n                    --i;\n                }else if(Num[i]+Num[k]&lt;2*Num[j]){\n                    ++k;\n                }else{\n                    dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1;\n                    ans=max(ans,(int)dp[i][j]);\n                    --i;++k;\n                }\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type: 动态规划,双向DP,思维,技巧题目N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"LLAP","slug":"51nod/LLAP","count":1,"path":"api/categories/51nod/LLAP.json"},{"name":"动态规划","slug":"51nod/LLAP/动态规划","count":1,"path":"api/categories/51nod/LLAP/动态规划.json"},{"name":"双向dp","slug":"51nod/LLAP/动态规划/双向dp","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp.json"},{"name":"思维","slug":"51nod/LLAP/动态规划/双向dp/思维","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LLAP","slug":"LLAP","count":1,"path":"api/tags/LLAP.json"},{"name":"双向dp","slug":"双向dp","count":1,"path":"api/tags/双向dp.json"}]}]}