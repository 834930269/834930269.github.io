{"name":"逆元","slug":"51nod/同余定理/数论/逆元","count":1,"postlist":[{"title":"51nod 1225 余数之和","slug":"51nod-1225-yszh","date":"2018-03-12T10:04:08.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1225-yszh.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type逆元数论思维同余定理\">Type:逆元,数论,思维,同余定理</span></h1><h1><span id=\"直接上代码题解在代码中这道题有点耗时间但挺有趣的\">直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nLL N;\n/*打表\nvoid Table(int NN){\n    for(int i=1;i&lt;=NN;++i){\n        printf(&quot;%04d-%04d &quot;,i,NN%i);\n    }\n}\n*/\nLL fast_mod(LL a,LL n,LL Mod){\n    LL ans=1;\n    while(n){\n        if(n&amp;1){\n            ans=(ans*a)%Mod;\n        }\n        a=(a*a)%Mod;\n        n&gt;&gt;=1;\n    }\n    return ans;\n}\n\nLL inv2=fast_mod(2,mod-2,mod);\n///对照算法\nLL hh(){\n    LL n=N;\n    LL ans;\n    ans=n%mod*(n%mod)%mod;\n    for(LL t,r,i=1;i&lt;=n;++i) {\n        t=n/i;\n        r=n/t;\n        ans=ans-((r-i+1)%mod*((r+i)%mod))%mod*inv2%mod*t%mod;\n        while(ans&lt;0) ans+=mod;\n        i=r;\n    }\n    return ans;\n}\n\n///本来想的是计算当前N/i相同的数量--结果为:\n///(N-tmp*i)/i 即计算在 N-当前数字*(N/i)后还有多少个数字可以\n///整分给(N/i),由于这个方法利用了除法,所以处理除法溢出有点麻烦\n///1e9左右就炸掉了\n///乘法溢出也很麻烦\n\n///最好的方法就是 N/tmp 理解为最后一个除以 N 等于 tmp 的数字是几\n\n///式子: F[N]=N*N-Sigma(N/i*i | i∈[1,N])\n///其中 括号内的式子的 N/i 有sqrt(n)个不同的值\n///证: 设 tmp=100/i 则 tmp*i=100 故 Count(tmp)&lt;=sqrt(100)\n///并且可以看出 相同的 N/i 对应的 i 是连续的.\n///即我们可以用等差数列求和公式来求 当 tmp=N/i 时 i 的和\n///用等差数列求和时/2用 2的逆元来做\\\n\n///自己坐着坐着就莫名其妙和他一样了= =\nLL solve(){\n    LL ans=N%mod*(N%mod)%mod;\n    for(LL i=1;i&lt;=N;){\n        LL tmp=N/i;\n        LL t=N/tmp;\n        tmp=((i+t)%mod*((t-i+1)%mod))%mod*inv2%mod*tmp%mod;\n        ans=(ans%mod-tmp%mod+mod)%mod;\n        i=t+1;\n    }\n    return ans;\n}\n\nvoid dui_pai(){\n    for(LL i=1;i&lt;=1000000;++i){\n        N=i;\n        if(hh()!=solve()) printf(&quot;%lld Faild\\n&quot;,N);\n    }\n    puts(&quot;Done&quot;);\n}\n\nint main(){\n    //dui_pai();\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        printf(&quot;%lld\\n&quot;,solve());\n    }\n    return 0;\n}</code></pre>","text":"Type:逆元,数论,思维,同余定理直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL mod=1e9+7;LL N;/","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"同余定理","slug":"51nod/同余定理","count":1,"path":"api/categories/51nod/同余定理.json"},{"name":"数论","slug":"51nod/同余定理/数论","count":1,"path":"api/categories/51nod/同余定理/数论.json"},{"name":"逆元","slug":"51nod/同余定理/数论/逆元","count":1,"path":"api/categories/51nod/同余定理/数论/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"}]}]}