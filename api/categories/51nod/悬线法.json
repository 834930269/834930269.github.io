{"name":"悬线法","slug":"51nod/悬线法","count":1,"postlist":[{"title":"51nod 1158","slug":"51nod-1158","date":"2018-03-18T10:32:44.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1158.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-悬线法-单调栈-未学-用悬线法做的\"><a href=\"#Type-悬线法-单调栈-未学-用悬线法做的\" class=\"headerlink\" title=\"Type:悬线法,单调栈(未学,用悬线法做的)\"></a>Type:悬线法,单调栈(未学,用悬线法做的)</h1><h1 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h1><blockquote>\n<p>蓝书P51，最大子矩阵 O(mn)</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=510;\nint m,n;\nint mat[maxn][maxn],up[maxn][maxn],left[maxn][maxn],right[maxn][maxn];\n\nvoid print(){\n    printf(&quot;Up:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,up[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n    printf(&quot;Left:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,left[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n    printf(&quot;Right:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,right[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)){\n        for(int i=1;i&lt;=m;++i){\n            for(int j=1;j&lt;=n;++j){\n                scanf(&quot;%d&quot;,&amp;mat[i][j]);\n            }\n        }\n        int ans=0;\n        for(int i=1;i&lt;=m;++i){\n            int lo=0,ro=n;\n            for(int j=1;j&lt;=n;++j){///从右往左扫描,维护up和left\n                if(!mat[i][j]){\n                    up[i][j]=left[i][j]=0;lo=j;\n                }else{\n                    up[i][j]=up[i-1][j]+1;\n                    left[i][j]=max(left[i-1][j],lo+1);\n                }\n            }\n            for(int j=n;j&gt;=1;--j){///维护right\n                if(!mat[i][j]){\n                    right[i][j]=n+1;ro=j-1;\n                }else{\n                    right[i][j]=i==1?ro:min(right[i-1][j],ro);\n                    ans=max(ans,up[i][j]*(right[i][j]-left[i][j]+1));\n                }\n            }\n        }\n        //print();\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type:悬线法,单调栈(未学,用悬线法做的)提示蓝书P51，最大子矩阵 O(mn)Code#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=510;int m,n;","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"悬线法","slug":"51nod/悬线法","count":1,"path":"api/categories/51nod/悬线法.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"}]}]}