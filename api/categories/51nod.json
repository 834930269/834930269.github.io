{"name":"51nod","slug":"51nod","count":12,"postlist":[{"title":"51nod 1020 逆序排列","slug":"51nod-1020-reverse","date":"2018-03-05T04:50:19.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1020-reverse.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"typedp逆序数\">Type:DP,逆序数</span></h1><h1><span id=\"题目\">题目</span></h1><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。 如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。 1-n的全排列中，逆序数最小为0（正序），最大为n*(n-1) / 2（倒序） 给出2个数n和k，求1-n的全排列中，逆序数为k的排列有多少种？ 例如：n = 4 k = 3。 1 2 3 4的排列中逆序为3的共有6个，分别是： 1 4 3 2 2 3 4 1 2 4 1 3 3 1 4 2 3 2 1 4 4 1 2 3 由于逆序排列的数量非常大，因此只需计算并输出该数 Mod 10^9 + 7的结果就可以了。</p>\n<h1><span id=\"input\">Input</span></h1><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000) 第2 - T + 1行：每行2个数n，k。中间用空格分隔。（2 &lt;= n &lt;= 1000, 0 &lt;= k &lt;= 20000)</p>\n<h1><span id=\"output\">Output</span></h1><p>共T行，对应逆序排列的数量 Mod (10^9 + 7)</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>1 4 3</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>6</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>考虑 dp[i][j] 表示 元素个数为 i 个时 逆序数为 j 的全排列个数为 dp[i][j] 个.</p>\n<blockquote>\n<p>设当前元素为 N ,则 N 可以放在原来 N-1 个元素的任意全排列的 N-i(i∈[0,N)) 上的位置.</p>\n<blockquote>\n<p>当 N 放在位置 N-i 上时,该排列的逆序数会增长 i (因为N最大,所以后面i个为逆序,前面为顺序),所以当我们想要找长度为 N ,逆序数为 k 的个数时,只需要找长度为 N-1 ,逆序数为 k-i 的全排列的个数即可.</p>\n<blockquote>\n<p>所以 dp[N][k] = lambda(dp[N-1][k-i] | i∈[0,N))</p>\n</blockquote>\n<p>复杂度为 O(k(N^2)) 会炸.</p>\n</blockquote>\n<p>考虑优化:</p>\n<blockquote>\n<p>① dp[N][k] = lambda(dp[N-1][k-i] | i∈[0,N)) ② dp[N][k-1] = lambda(dp[N-1][k-1-i] | i∈[0,N)) ①-②: dp[N][k]-dp[N][k-1] = dp[N-1][k]-dp[N-1][k-N] dp[N][k]=dp[N-1][k]-dp[N-1][k-N]+dp[N][k-1]</p>\n</blockquote>\n</blockquote>\n<p>得出递推公式:</p>\n<blockquote>\n<p>① dp[i][j]=1 j=0 ② dp[i][j]=dp[i-1][j]-dp[i-1][j-i]+dp[i][j-1]</p>\n</blockquote>\n<p>由题目的约束条件:</p>\n<blockquote>\n<p>逆序数最小为0（正序），最大为n*(n-1) / 2（倒序）</p>\n</blockquote>\n<p>故枚举逆序数只需要枚举到 i*(i-1)/2&amp;&amp;j\\&lt;20000即可 注意j-i不能&lt;0</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e9+7;\nint dp[1010][20010];\n\nvoid init(){\n    for(int i=1;i&lt;=1000;++i) dp[i][0]=1;\n    for(int i=2;i&lt;=1000;++i){\n        for(int j=1;j&lt;=i*(i-1)/2&amp;&amp;j&lt;=20000;++j){\n            dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n            if(j-i&gt;=0)dp[i][j]=(((dp[i][j]-dp[i-1][j-i])%mod)+mod)%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int n,k;\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n        printf(&quot;%d\\n&quot;,dp[n][k]);\n    }\n    return 0;\n}</code></pre>","text":"Type:DP,逆序数题目在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。 如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。 1-n的全排列中，逆序数最小为0（正序","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"全排列","slug":"51nod/全排列","count":1,"path":"api/categories/51nod/全排列.json"},{"name":"动态规划","slug":"51nod/全排列/动态规划","count":1,"path":"api/categories/51nod/全排列/动态规划.json"},{"name":"逆序数","slug":"51nod/全排列/动态规划/逆序数","count":1,"path":"api/categories/51nod/全排列/动态规划/逆序数.json"}],"tags":[{"name":"逆序数","slug":"逆序数","count":2,"path":"api/tags/逆序数.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"全排列","slug":"全排列","count":1,"path":"api/tags/全排列.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51nod 1040 最大公约数之和","slug":"51nod-1040-max-gcd-sum","date":"2018-03-04T14:51:10.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1040-max-gcd-sum.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type欧拉函数gcd性质思维\">Type:欧拉函数,gcd性质,思维</span></h1><h1><span id=\"题目\">题目</span></h1><p>给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15</p>\n<h2><span id=\"input\">Input</span></h2><p>1个数N(N &lt;= 10^9)</p>\n<h2><span id=\"output\">Output</span></h2><p>公约数之和</p>\n<h2><span id=\"input示例\">Input示例</span></h2><p>6</p>\n<h2><span id=\"output示例\">Output示例</span></h2><p>15</p>\n<h2><span id=\"题解\">题解</span></h2><blockquote>\n<p>N&lt;=10^9,所以肯定无法暴力枚举 考虑我们要求 lambda(gcd(i,N) | i∈[1,N])</p>\n<blockquote>\n<p>我们可以知道: 对于每个数N,他的约数范围在[1<del>N]之间,即我们可以将问题转化为(设约数为Ni,1</del>N中约数为Ni个数为Mi):</p>\n<blockquote>\n<p>lambda(Ni*Mi)</p>\n</blockquote>\n<p>假设我们已经得到了Ni,问题就在于我们如何求出Mi 设i为1~N中任意数:</p>\n<blockquote>\n<p>(1) Mi=count(gcd(i,N)=Ni | i∈[1<del>N]) =count(gcd(i/Ni,N/Ni)=1 | i∈[1</del>N])</p>\n<blockquote>\n<p>即我们只需要求出1~N中与N/Ni互素的数的个数即可</p>\n<blockquote>\n<p>即 euler(N/Ni)</p>\n</blockquote>\n</blockquote>\n<p>(2) Mi=euler(N/Ni)</p>\n</blockquote>\n<p>ans=lambda(Ni*euler(N/Ni))</p>\n</blockquote>\n<p>然后有一个小性质,即 i*i&lt;=N时,我们枚举到sqrt(i)同时求出 N/i ,枚举完所有的 i 即枚举完所有 1~N 内 N 的约数.</p>\n</blockquote>\n<h2><span id=\"code\">Code</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nLL N;\n\nLL euler(LL n){\n    LL res=n,a=n;\n    for(LL i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            res=res/i*(i-1);\n            while(a%i==0)a/=i;\n        }\n    }\n    if(a&gt;1)res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        LL ans=0;\n        for(LL i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                ans+=(i*euler(N/i));\n                if(i*i!=N){\n                    ans+=((N/i)*euler(i));\n                }\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type:欧拉函数,gcd性质,思维题目给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15Input1个数N(N &lt;= 10^9)Output公约数之和Input示例","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"思维","slug":"51nod/思维","count":1,"path":"api/categories/51nod/思维.json"},{"name":"数论","slug":"51nod/思维/数论","count":1,"path":"api/categories/51nod/思维/数论.json"},{"name":"欧拉函数","slug":"51nod/思维/数论/欧拉函数","count":1,"path":"api/categories/51nod/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"51nod 1055 最长等差数列","slug":"51nod-1055-llap","date":"2018-03-08T11:18:14.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1055-llap.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type-动态规划双向dp思维技巧\">Type: 动态规划,双向DP,思维,技巧</span></h1><h1><span id=\"题目\">题目</span></h1><p>N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10 12 14 其中6 8 10 12 14最长，长度为5。</p>\n<h1><span id=\"input\">Input</span></h1><p>第1行：N，N为正整数的数量(3 &lt;= N &lt;= 10000)。 第2 - N+1行：N个正整数。(2&lt;= A[i] &lt;= 10^9)</p>\n<h1><span id=\"output\">Output</span></h1><p>最长等差数列的长度。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>10 1 3 5 6 8 9 10 12 13 14</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>5</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>数据范围可判是O(N^2) 一开始我一直在想如何把数字,即两个数之间的差用哈希存起来,来方便dp. 然后搜了题解发现是论文题. 被叫做LLAP问题 Length of the Longest Arithmetic Progressio</p>\n</blockquote>\n<h2><span id=\"论文link\">论文Link:</span></h2><p><a href=\"https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/\" target=\"_blank\" rel=\"noopener\">https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/</a></p>\n<h2><span id=\"论文解释\">论文解释</span></h2><blockquote>\n<p>这道题可以转化为:</p>\n<blockquote>\n<p>给与一个 排过序 的集合set,我们要求这个集合中的最长等差数列的长度.</p>\n</blockquote>\n<p>标重点: 序列是已排好序的 我们设 dp[i][j] 为以下标 i 和 j 两个元素开头的等差序列最长长度. 我们可以创建一个浮标 j 作为等差数列的中间值</p>\n<blockquote>\n<p>初始化一个 i=j-1,k=j+1.</p>\n<blockquote>\n<p>1.如果 set[i]+set[k] &lt; set[j]*2</p>\n<blockquote>\n<p>k++</p>\n</blockquote>\n<p>2.如果 set[i]+set[k] &gt; set[j]*2</p>\n<blockquote>\n<p>i–</p>\n</blockquote>\n<p>如果 set[i]+set[k]=set[j]*2</p>\n<blockquote>\n<p>则构成等差数列,我们只需要让</p>\n<blockquote>\n<p>dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1</p>\n</blockquote>\n<p>如果dp[j][k]=0的话,dp[i][j]直接=3就可以了,因为 i,j,k 三个刚好构成等差数列.否则等于 dp[j][k]+1</p>\n</blockquote>\n<p>计算完以后 i–,k++ 继续计算其他以 j 为第二个点的等差数列</p>\n</blockquote>\n<p>倒序计算,正序反过来即可</p>\n</blockquote>\n<p>另外: 还可以 直接将 dp 数组初始化为 2(因为每个数的等差数列至少为2). dp[i][j]=dp[j][k]+1 另外有一个小技巧: 如果int的取值范围不大,但是数组要开很大的时候,可以用 short int,比如这道题.</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxn=10000;\n\nshort int dp[maxn][maxn];\nint Num[maxn],ans,N;\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;Num[i]);\n        }\n        sort(Num,Num+N);\n        ans=0;\n        for(int j=N-2;j&gt;=1;--j){\n            int i=j-1,k=j+1;\n            while(k&lt;N&amp;&amp;i&gt;=0){\n                if(Num[i]+Num[k]&gt;2*Num[j]){\n                    --i;\n                }else if(Num[i]+Num[k]&lt;2*Num[j]){\n                    ++k;\n                }else{\n                    dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1;\n                    ans=max(ans,(int)dp[i][j]);\n                    --i;++k;\n                }\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type: 动态规划,双向DP,思维,技巧题目N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"LLAP","slug":"51nod/LLAP","count":1,"path":"api/categories/51nod/LLAP.json"},{"name":"动态规划","slug":"51nod/LLAP/动态规划","count":1,"path":"api/categories/51nod/LLAP/动态规划.json"},{"name":"双向dp","slug":"51nod/LLAP/动态规划/双向dp","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp.json"},{"name":"思维","slug":"51nod/LLAP/动态规划/双向dp/思维","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LLAP","slug":"LLAP","count":1,"path":"api/tags/LLAP.json"},{"name":"双向dp","slug":"双向dp","count":1,"path":"api/tags/双向dp.json"}]},{"title":"51nod 1084 矩阵取数问题 V2","slug":"51nod-1084-jzqs-v2","date":"2018-03-05T15:06:34.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1084-jzqs-v2.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"typedp多路进程dp\">Type:DP,多路(进程)DP</span></h1><h1><span id=\"题目\">题目</span></h1><p>一个M*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，先从左上走到右下，再从右下走到左上。第1遍时只能向下和向右走，第2遍时只能向上和向左走。两次如果经过同一个格子，则该格子的奖励只计算一次，求能够获得的最大价值。 例如：3 * 3的方格。 1 3 3 2 1 3 2 2 1 能够获得的最大价值为：17。1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 2 -&gt; 1。其中起点和终点的奖励只计算1次。</p>\n<h1><span id=\"input\">Input</span></h1><p>第1行：2个数M N，中间用空格分隔，为矩阵的大小。(2 &lt;= M, N &lt;= 200) 第2 - N + 1行：每行M个数，中间用空格隔开，对应格子中奖励的价值。(1 &lt;= A[i,j] &lt;= 10000)</p>\n<h1><span id=\"output\">Output</span></h1><p>输出能够获得的最大价值。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>3 3 1 3 3 2 1 3 2 2 1</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>17</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>一开始的想法是先走一遍取最大值,然后回溯到起点,把走过的地方置为 0,然后WA= =,发现是行不通的,因为两次都是最有没办法保证全局最优.</p>\n<blockquote>\n<p>然后搜了题解</p>\n</blockquote>\n<p>这里用到多进程dp,即我们用 dp[step][j][k] 代表当前走了 step 步,第一个走的人在第 j行,第二个走的人在第 k行时最大的经过路径之和. 如果 j==k 时,即两个人当前路径点重合了.我们只需要随便选取一个加到记忆化数组中即可. 而当我们多路dp时,两个人来到当前状态的方向可能是</p>\n<blockquote>\n<p>(1) 第一个人往下走,第二个人往下走 (2) 第一个人往下走,第二个人往右走 (3) 第一个人往右走,第二个人往下走 (4) 第一个人往右走,第二个人往右走</p>\n</blockquote>\n<p>我们只需要在遍历到每个状态时,对以上四个状态找最大值加上两个人当前地点的数字即可 答案是dp[M+N][N][N]</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=210;\nint N,M,A;\nint mp[maxn][maxn],dp[2*maxn][maxn][maxn];\n\nint main(){\n    ///读题bug,N是行,第二个读入\n    scanf(&quot;%d%d&quot;,&amp;M,&amp;N);\n    for(int i=1;i&lt;=N;++i){\n        for(int j=1;j&lt;=M;++j){\n            scanf(&quot;%d&quot;,&amp;mp[i][j]);\n        }\n    }\n    ///枚举步数\n    for(int i=2;i&lt;=N+M;++i){\n        ///枚举位于行数 i-j or k即为当前所处列(因为总步数为i(行数加列数和))\n        for(int j=1;j&lt;=N&amp;&amp;i-j&gt;=0;++j){\n            for(int k=1;k&lt;=N&amp;&amp;i-k&gt;=0;++k){\n                ///分为四种情况,下下,下右,右下,右右\n                if(k==j){\n                    //下下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+mp[j][i-j]);\n                    //下右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+mp[j][i-j]);\n                    //右下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+mp[j][i-j]);\n                    //右右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]+mp[j][i-j]);\n                }else{\n                    //下下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+mp[j][i-j]+mp[k][i-k]);\n                    //下右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+mp[j][i-j]+mp[k][i-k]);\n                    //右下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+mp[j][i-j]+mp[k][i-k]);\n                    //右右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]+mp[j][i-j]+mp[k][i-k]);\n                }\n            }\n        }\n    }\n    printf(&quot;%d\\n&quot;,dp[N+M][N][N]);\n    return 0;\n}</code></pre>","text":"Type:DP,多路(进程)DP题目一个M*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，先从左上走到右下，再从右下走到左上。第1遍时只能向下和向右走，第2遍时只能向上和向左走。两次如果经过同一个格子，则该格子的奖励只计算一次，求能够获得的最大价值。 例如：3 *","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"多进程dp","slug":"51nod/多进程dp","count":1,"path":"api/categories/51nod/多进程dp.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"多进程dp","slug":"多进程dp","count":1,"path":"api/tags/多进程dp.json"}]},{"title":"51nod 1119 机器人走方格V2","slug":"51nod-1119-reboot-in-v2","date":"2018-03-07T07:42:36.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1119-reboot-in-v2.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type-组合数学二项式定理逆元\">Type: 组合数学,二项式定理,逆元</span></h1><h1><span id=\"题目\">题目</span></h1><p>M * N的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。</p>\n<h1><span id=\"input\">Input</span></h1><p>第1行，2个数M,N，中间用空格隔开。（2 &lt;= m,n &lt;= 1000000)</p>\n<h1><span id=\"output\">Output</span></h1><p>输出走法的数量 Mod 10^9 + 7。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>2 3</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>3</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>画一下图会发现这就是杨辉三角,而我们需要求的是C(N+M-2,N-1) 用逆元和递推公式算一下就可以了</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int maxn=1000000+10;\nint m,n;\n\nLL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}\n\nLL solve(int N,int M){\n    ///ans=C(N,M)\n    //cout&lt;&lt;N&lt;&lt;&quot; &quot;&lt;&lt;M&lt;&lt;endl;\n    LL ans=1;\n    for(int i=1;i&lt;=M;++i){\n        ans=ans*(N-i+1)*1ll%mod*inv[i]%mod;\n    }\n    return ans;\n}\n\nint main(){\n    init();\n    while(cin&gt;&gt;m&gt;&gt;n){\n        cout&lt;&lt;solve(n+m-2,n-1)&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type: 组合数学,二项式定理,逆元题目M * N的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。Input第1行，2个数M,N，中间用空格隔开。（2 &lt;= m,n &lt;= 100","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"二项式定理","slug":"51nod/二项式定理","count":1,"path":"api/categories/51nod/二项式定理.json"},{"name":"组合数学","slug":"51nod/二项式定理/组合数学","count":1,"path":"api/categories/51nod/二项式定理/组合数学.json"},{"name":"逆元","slug":"51nod/二项式定理/组合数学/逆元","count":1,"path":"api/categories/51nod/二项式定理/组合数学/逆元.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"二项式定理","slug":"二项式定理","count":1,"path":"api/tags/二项式定理.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"}]},{"title":"51nod 1120 机器人走方格 V3","slug":"51nod-1120-rm-v3","date":"2018-03-07T12:59:38.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1120-rm-v3.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png","content":"<h1><span id=\"typelucascatalan序列逆元\">Type:Lucas+Catalan序列+逆元</span></h1><h1><span id=\"题目\">题目</span></h1><p>N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。</p>\n<h1><span id=\"input\">Input</span></h1><p>输入一个数N(2 &lt;= N &lt;= 10^9)。</p>\n<h1><span id=\"output\">Output</span></h1><p>输出走法的数量 Mod 10007。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>4</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>10</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>画图会发现就是一个Catalan序列, 但我一开始没理解题意,原来只是不能跨过斜线,但可以在斜线上走…</p>\n<blockquote>\n<p>在Excel中画了一下,因为两边是对称的,所以我们只需要求一边,将最终的答案*2即可.</p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png\" alt></p>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=10007;\n\nLL Pow(LL a,LL b,LL p){\n    LL ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%p;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%p;\n    }\n    return ans;\n}\n\nLL Comb(LL a,LL b,LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Pow(cb, p-2,p))%p;\n    return ans;\n}\nLL Lucas(LL n, LL m, LL p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inv(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nint main(){\n    LL N;\n    while(cin&gt;&gt;N){\n        N=N-1;\n        LL d1,d2;\n        LL x=Lucas(2*N,N,mod);\n        LL d=inv(N+1,mod);\n        //cout&lt;&lt;&quot;Lucas: &quot;&lt;&lt;x&lt;&lt;endl;\n        //cout&lt;&lt;&quot;Inv: &quot;&lt;&lt;d&lt;&lt;endl;\n        cout&lt;&lt;2*x*d%mod&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:Lucas+Catalan序列+逆元题目N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。Input输入一个","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"Catalan","slug":"51nod/Catalan","count":1,"path":"api/categories/51nod/Catalan.json"},{"name":"Lucas","slug":"51nod/Catalan/Lucas","count":1,"path":"api/categories/51nod/Catalan/Lucas.json"},{"name":"数论","slug":"51nod/Catalan/Lucas/数论","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论.json"},{"name":"组合数学","slug":"51nod/Catalan/Lucas/数论/组合数学","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学.json"},{"name":"逆元","slug":"51nod/Catalan/Lucas/数论/组合数学/逆元","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"Catalan","slug":"Catalan","count":1,"path":"api/tags/Catalan.json"},{"name":"Lucas","slug":"Lucas","count":1,"path":"api/tags/Lucas.json"}]},{"title":"51nod 1158","slug":"51nod-1158","date":"2018-03-18T10:32:44.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1158.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type悬线法单调栈未学用悬线法做的\">Type:悬线法,单调栈(未学,用悬线法做的)</span></h1><h1><span id=\"提示\">提示</span></h1><blockquote>\n<p>蓝书P51，最大子矩阵 O(mn)</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=510;\nint m,n;\nint mat[maxn][maxn],up[maxn][maxn],left[maxn][maxn],right[maxn][maxn];\n\nvoid print(){\n    printf(&quot;Up:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,up[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n    printf(&quot;Left:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,left[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n    printf(&quot;Right:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,right[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)){\n        for(int i=1;i&lt;=m;++i){\n            for(int j=1;j&lt;=n;++j){\n                scanf(&quot;%d&quot;,&amp;mat[i][j]);\n            }\n        }\n        int ans=0;\n        for(int i=1;i&lt;=m;++i){\n            int lo=0,ro=n;\n            for(int j=1;j&lt;=n;++j){///从右往左扫描,维护up和left\n                if(!mat[i][j]){\n                    up[i][j]=left[i][j]=0;lo=j;\n                }else{\n                    up[i][j]=up[i-1][j]+1;\n                    left[i][j]=max(left[i-1][j],lo+1);\n                }\n            }\n            for(int j=n;j&gt;=1;--j){///维护right\n                if(!mat[i][j]){\n                    right[i][j]=n+1;ro=j-1;\n                }else{\n                    right[i][j]=i==1?ro:min(right[i-1][j],ro);\n                    ans=max(ans,up[i][j]*(right[i][j]-left[i][j]+1));\n                }\n            }\n        }\n        //print();\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type:悬线法,单调栈(未学,用悬线法做的)提示蓝书P51，最大子矩阵 O(mn)Code#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=510;int m,n;","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"悬线法","slug":"51nod/悬线法","count":1,"path":"api/categories/51nod/悬线法.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"}]},{"title":"51nod 1201 整数划分","slug":"51nod-1201-int-pagi","date":"2018-03-06T01:33:53.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1201-int-pagi.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"typedp思维\">Type:DP,思维</span></h1><h1><span id=\"题意\">题意</span></h1><p>将N分为若干个不同整数的和，有多少种不同的划分方式，例如：n = 6，{6} {1,5} {2,4} {1,2,3}，共4种。由于数据较大，输出Mod 10^9 + 7的结果即可。</p>\n<h1><span id=\"input\">Input</span></h1><p>输入1个数N(1 &lt;= N &lt;= 50000)。</p>\n<h1><span id=\"output\">Output</span></h1><p>输出划分的数量Mod 10^9 + 7。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>6</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>4</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>首先我们可以由</p>\n<blockquote>\n<p>1+2+3+…+m=n 估算出 大概只有sqrt(2*n)个数字左右</p>\n</blockquote>\n<p>我们设当前状态为 dp[i][j]</p>\n<blockquote>\n<p>dp[i][j] 代表当前数字为 j ,被划分成了 i 部分. 状态转移推倒:</p>\n<blockquote>\n<p>我们假设已知所有 dp 的划分数序列. (1) 我们将 dp[i][j-i] 每个 划分数每个数字 +1 ,我们将得到 不存在1 的划分数. (2) 我们将 dp[i-1][j-i] 每个 划分数每个数字(共 i-1 个) +1 ,我们将得到 不存在1 的且长度为 i-1 ,和为 j-1 的划分数,然后我们将 1 放到划分数中,即得到全部 有1 的划分数.</p>\n</blockquote>\n<p>即 dp[i][j]=(dp[i][j-i]+dp[i-1][j-i])%mod</p>\n</blockquote>\n<p>正确性证明:</p>\n<blockquote>\n<p>假设已知 dp[i][j] 的全部序列. 我们只需要一直对每个数字 -1 就可以将所有序列置为 全0.</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"给一个例子自己倒着推一下也成立\">给一个例子自己倒着推一下也成立</span></h1><pre><code>组成1的 有 {1} \n\n组成2的 有 {2} \n\n组成3的 有 {1,2} {3}\n\n组成4的 有 {1,3} {4}\n\n组成5的 有 {1,4} {2,3} {5}\n\n组成6的 有 {1,5} {2,4} {1,2,3} {6}\n\n组成7的 有 {1,6} {2,5} {3,4} {1,2,4} {7}</code></pre><h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=50010;\nconst LL mod=1e9+7;\nint N;\nLL dp[330][maxn];\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;N);\n    dp[1][1]=1ll;\n    for(int i=2;i&lt;=N;++i){\n        for(int j=1;j&lt;=(int)sqrt(2*i);++j){\n            dp[j][i]=(dp[j][i-j]+dp[j-1][i-j])%mod;\n        }\n    }\n    LL ans=0;\n    for(int i=1;i&lt;=(int)sqrt(2*N);++i) ans=(ans+dp[i][N])%mod;\n    printf(&quot;%lld\\n&quot;,ans);\n    return 0;\n}</code></pre>","text":"Type:DP,思维题意将N分为若干个不同整数的和，有多少种不同的划分方式，例如：n = 6，{6} {1,5} {2,4} {1,2,3}，共4种。由于数据较大，输出Mod 10^9 + 7的结果即可。Input输入1个数N(1 &lt;= N &lt;= 50000)。Out","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51nod 1225 余数之和","slug":"51nod-1225-yszh","date":"2018-03-12T10:04:08.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1225-yszh.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type逆元数论思维同余定理\">Type:逆元,数论,思维,同余定理</span></h1><h1><span id=\"直接上代码题解在代码中这道题有点耗时间但挺有趣的\">直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nLL N;\n/*打表\nvoid Table(int NN){\n    for(int i=1;i&lt;=NN;++i){\n        printf(&quot;%04d-%04d &quot;,i,NN%i);\n    }\n}\n*/\nLL fast_mod(LL a,LL n,LL Mod){\n    LL ans=1;\n    while(n){\n        if(n&amp;1){\n            ans=(ans*a)%Mod;\n        }\n        a=(a*a)%Mod;\n        n&gt;&gt;=1;\n    }\n    return ans;\n}\n\nLL inv2=fast_mod(2,mod-2,mod);\n///对照算法\nLL hh(){\n    LL n=N;\n    LL ans;\n    ans=n%mod*(n%mod)%mod;\n    for(LL t,r,i=1;i&lt;=n;++i) {\n        t=n/i;\n        r=n/t;\n        ans=ans-((r-i+1)%mod*((r+i)%mod))%mod*inv2%mod*t%mod;\n        while(ans&lt;0) ans+=mod;\n        i=r;\n    }\n    return ans;\n}\n\n///本来想的是计算当前N/i相同的数量--结果为:\n///(N-tmp*i)/i 即计算在 N-当前数字*(N/i)后还有多少个数字可以\n///整分给(N/i),由于这个方法利用了除法,所以处理除法溢出有点麻烦\n///1e9左右就炸掉了\n///乘法溢出也很麻烦\n\n///最好的方法就是 N/tmp 理解为最后一个除以 N 等于 tmp 的数字是几\n\n///式子: F[N]=N*N-Sigma(N/i*i | i∈[1,N])\n///其中 括号内的式子的 N/i 有sqrt(n)个不同的值\n///证: 设 tmp=100/i 则 tmp*i=100 故 Count(tmp)&lt;=sqrt(100)\n///并且可以看出 相同的 N/i 对应的 i 是连续的.\n///即我们可以用等差数列求和公式来求 当 tmp=N/i 时 i 的和\n///用等差数列求和时/2用 2的逆元来做\\\n\n///自己坐着坐着就莫名其妙和他一样了= =\nLL solve(){\n    LL ans=N%mod*(N%mod)%mod;\n    for(LL i=1;i&lt;=N;){\n        LL tmp=N/i;\n        LL t=N/tmp;\n        tmp=((i+t)%mod*((t-i+1)%mod))%mod*inv2%mod*tmp%mod;\n        ans=(ans%mod-tmp%mod+mod)%mod;\n        i=t+1;\n    }\n    return ans;\n}\n\nvoid dui_pai(){\n    for(LL i=1;i&lt;=1000000;++i){\n        N=i;\n        if(hh()!=solve()) printf(&quot;%lld Faild\\n&quot;,N);\n    }\n    puts(&quot;Done&quot;);\n}\n\nint main(){\n    //dui_pai();\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        printf(&quot;%lld\\n&quot;,solve());\n    }\n    return 0;\n}</code></pre>","text":"Type:逆元,数论,思维,同余定理直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL mod=1e9+7;LL N;/","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"同余定理","slug":"51nod/同余定理","count":1,"path":"api/categories/51nod/同余定理.json"},{"name":"数论","slug":"51nod/同余定理/数论","count":1,"path":"api/categories/51nod/同余定理/数论.json"},{"name":"逆元","slug":"51nod/同余定理/数论/逆元","count":1,"path":"api/categories/51nod/同余定理/数论/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"}]},{"title":"51NOD 1241 特殊的排序","slug":"51nod-1241-tsds","date":"2018-03-08T10:57:18.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1241-tsds.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type动态规划思维最长等差数列简化\">Type:动态规划,思维,最长等差数列(简化)</span></h1><h1><span id=\"题目\">题目</span></h1><p>一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾部 =&gt; 1 2 3 4 5 这样就排好了，移动了2个元素。 给出一个1-N的排列，输出完成排序所需的最少移动次数。</p>\n<h1><span id=\"input\">Input</span></h1><p>第1行：1个数N(2 &lt;= N &lt;= 50000)。 第2 - N + 1行：每行1个数，对应排列中的元素。</p>\n<h1><span id=\"output\">Output</span></h1><p>输出1个数，对应所需的最少移动次数。</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>5 2 5 3 4 1</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>2</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>一开始会想到和逆序数有关,排序就是减少逆序数,所以会想到其中非逆序序列中最长的那个不用变化. 然后可以容易地证明剩余的数只需要移动一次即可到达正确的位置上</p>\n<blockquote>\n<p>比如 12346587 可以发现最长等差整数序列是 12345 而我们需要 12345678 第一次: 1234587 6 第二次: 1234586 7 第三次: 1234567 8 OK,往数列前面放的也一样</p>\n</blockquote>\n<p>那么我们的问题就是如何求最长等差数列(等差为1)了,</p>\n<blockquote>\n<p>因为等差为1,所以我们不难想到: dp[i] 为数字 i 的最长等差数列. 遍历Num[]数组的时候计算 dp 即可 dp[i]=dp[i-1]+1</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=50000+10;\n\nint dp[maxn],N,Num[maxn],max_;\n\nint main(){\n    while(cin&gt;&gt;N){\n        memset(dp,0,sizeof(dp));\n        dp[0]=0;\n        max_=1;\n        for(int i=1;i&lt;=N;++i){\n            cin&gt;&gt;Num[i];\n        }\n        for(int i=1;i&lt;=N;++i){\n            dp[Num[i]]=dp[Num[i]-1]+1;\n            max_=max(dp[Num[i]],max_);\n            //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;dp[Num[i]]&lt;&lt;endl;\n        }\n        cout&lt;&lt;N-max_&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:动态规划,思维,最长等差数列(简化)题目一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"思维","slug":"51nod/动态规划/思维","count":1,"path":"api/categories/51nod/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51nod 1383 整数分解为2的幂","slug":"51nod-1383-2-mo","date":"2018-03-07T04:50:34.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1383-2-mo.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type-组合数学母函数\">Type: 组合数学,母函数</span></h1><h1><span id=\"题目\">题目</span></h1><p>任何正整数都能分解成2的幂，给定整数N，求N的此类划分方法的数量！由于方案数量较大，输出Mod 1000000007的结果。 比如N = 7时，共有6种划分方法。 7=1+1+1+1+1+1+1 =1+1+1+1+1+2 =1+1+1+2+2 =1+2+2+2 =1+1+1+4 =1+2+4</p>\n<h1><span id=\"input\">Input</span></h1><p>输入一个数N（1 &lt;= N &lt;= 10^6)</p>\n<h1><span id=\"output\">Output</span></h1><p>输出划分方法的数量Mod 1000000007</p>\n<h1><span id=\"input示例\">Input示例</span></h1><p>7</p>\n<h1><span id=\"output示例\">Output示例</span></h1><p>6</p>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>生成函数</p>\n<blockquote>\n<p>我们可以将题意理解为:</p>\n<blockquote>\n<p>有1,2,4,…,2^N&lt;=1000000 种物品可以选择,每种物品可以选择数量为无限,问你当背包重量为 M 时有多少种选择.</p>\n</blockquote>\n</blockquote>\n<p>列出生成函数为:</p>\n<blockquote>\n<p>g(m)=(1+x+x^2+x^3+…)(1+x^2+x^4+x^6+…) (1+x^4+x^8+x^12+…)(1+x^8+x^16+x^24+…) …(1+x^19) | (因为x^20&gt;1e6)</p>\n</blockquote>\n<p>只需要求出展开式中每项的序数即可,输入 N 输出 K[N] 我们给定一个数组 c1 作为储存系数用.</p>\n<blockquote>\n<p>只需要将每个括号内的式子乘入数组 c1 即可.</p>\n<blockquote>\n<p>限制条件为 i=2^t &lt;= 1000000 j+i &lt;= 1000000</p>\n</blockquote>\n</blockquote>\n<p>所有的计算都向第一个括号 (1+x+x^2+…+x^1000000) 为基准进行合并，合并到 j+i&gt;1000000 为止. 其他部分解释放在代码中</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=1000100;\nint c1[maxn]={1};\n\ninline void init(int n){\n    for(int i=1;i&lt;=n;i&lt;&lt;=1){\n        for(int j=0;(j+i)&lt;=n;++j){\n            ///j+i是 当前值为j,加上第log2(i)括号内的等差幂次i\n            ///后计算出目标待加值为 (j+i)\n            ///即幂次为(j+i)的母函数系数计算过程为:\n            /// (k)x^(i+j)=(k1)x^j*x^i*(k2)x^(i+j)\n            /// 即 k=k1+k2\n            /// 即 c1[j+i]=c[j]+c[j+i]\n            ///x^i系数为1因为生成函数第log2(i)个括\n            ///号中所有x^i的系数为1\n            c1[j+i]=(c1[j+i]+c1[j])%mod;\n        }\n    }\n}\n\n\nint main(){\n    init(1000000);\n    int N;\n\n    while(cin&gt;&gt;N){\n        cout&lt;&lt;c1[N]&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type: 组合数学,母函数题目任何正整数都能分解成2的幂，给定整数N，求N的此类划分方法的数量！由于方案数量较大，输出Mod 1000000007的结果。 比如N = 7时，共有6种划分方法。 7=1+1+1+1+1+1+1 =1+1+1+1+1+2 =1+1+1+2+2 =1","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"母函数","slug":"51nod/母函数","count":1,"path":"api/categories/51nod/母函数.json"},{"name":"组合数学","slug":"51nod/母函数/组合数学","count":1,"path":"api/categories/51nod/母函数/组合数学.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"母函数","slug":"母函数","count":1,"path":"api/tags/母函数.json"}]},{"title":"51nod DP-矩阵取数问题","slug":"51nod-dp-study","date":"2016-12-24T14:22:05.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/51nod-dp-study.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x – 1, y) , f(x, y – 1) ) + A[x][y] 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<vector><br>using namespace std;<br>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    vector&lt;vector<int> &gt; ve(N+1,vector<int>(N+1,0)),dp(N+1,vector<int>(N+1,0));</int></int></int></vector></p>\n<pre><code>for(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        cin&gt;&gt;ve\\[i\\]\\[j\\];\n\nfor(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        dp\\[i\\]\\[j\\]=max(dp\\[i-1\\]\\[j\\],dp\\[i\\]\\[j-1\\])+ve\\[i\\]\\[j\\];\n\ncout&lt;&lt;dp\\[N\\]\\[N\\]&lt;&lt;endl;\n\nreturn 0;</code></pre><p>}</p>\n","text":"【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"算法学习","slug":"51nod/动态规划/算法学习","count":1,"path":"api/categories/51nod/动态规划/算法学习.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}]}