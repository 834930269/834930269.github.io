{"name":"LintCode","slug":"LintCode","count":2,"postlist":[{"title":"LintCode(12-22)","slug":"lintcode12-22","date":"2019-02-10T06:42:21.000Z","updated":"2019-07-03T16:05:51.666Z","comments":true,"path":"api/articles/lintcode12-22.json","excerpt":"<h1 id=\"12-Min-Stack\"><a href=\"#12-Min-Stack\" class=\"headerlink\" title=\"(12) - Min Stack\"></a>(12) - Min Stack</h1><blockquote>\n<p>一个栈维护最小值,另一个栈存数据</p>\n<blockquote>\n<p>为什么最小值同步插入可行,因为栈的pop只能从栈顶开始，所以:</p>\n<blockquote>\n<p>1.栈顶元素最小,minValue栈顶也是该元素 2.栈顶元素不是最小,minValue中没有该元素</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class MinStack &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Stack</span>&lt;<span class=\"built_in\">Integer</span>&gt; <span class=\"built_in\">data</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Stack</span>&lt;<span class=\"built_in\">Integer</span>&gt; minValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MinStack() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do intialization if necessary</span></span><br><span class=\"line\">        <span class=\"built_in\">data</span>=<span class=\"literal\">new</span> <span class=\"built_in\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        minValue=<span class=\"literal\">new</span> <span class=\"built_in\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        minValue.push(<span class=\"number\">0x3f3f3f3f</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * @param number: An integer</span></span><br><span class=\"line\"><span class=\"comment\">     * @return: nothing</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"literal\">void</span> push(int number) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// write your code here</span></span><br><span class=\"line\">        <span class=\"built_in\">data</span>.push(number);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;=minValue.peek()) minValue.push(number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * @return: An integer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int pop() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">data</span>.peek().<span class=\"keyword\">equals</span>(minValue.peek())) minValue.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">data</span>.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * @return: An integer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int <span class=\"keyword\">min</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> minValue.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"(12) - Min Stack一个栈维护最小值,另一个栈存数据为什么最小值同步插入可行,因为栈的pop只能从栈顶开始，所以:1.栈顶元素最小,minValue栈顶也是该元素 2.栈顶元素不是最小,minValue中没有该元素1<br>2<br>3<br>4<br>5<br>6<","link":"","raw":null,"photos":[],"categories":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/categories/LintCode.json"}],"tags":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/tags/LintCode.json"}]},{"title":"LintCode(1-11+114)","slug":"pl2-lintcode","date":"2018-06-17T09:46:21.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/pl2-lintcode.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"2-尾部的零easy\">（2） 尾部的零(Easy)</span></h1><blockquote>\n<p>因为2的数量远大于5,统计5的数量即可</p>\n</blockquote>\n<pre><code>public class Solution {\n    /*\n     * @param n: An integer\n     * @return: An integer, denote the number of trailing zeros in n!\n     */\n\n    public long trailingZeros(long n) {\n        // write your code here, try to do it without arithmetic operators.\n        long cnt=0,k=n;\n\n        while(k&gt;0){\n            cnt+=k/5;\n            k/=5;\n        }\n        return cnt;\n    }\n}</code></pre><h1><span id=\"3-统计数字中等\">（3） 统计数字(中等)</span></h1><blockquote>\n<p>伪数位DP</p>\n</blockquote>\n<pre><code>public class Solution {\n    /*\n     * @param : An integer\n     * @param : An integer\n     * @return: An integer denote the count of digit k in 1..n\n     */\n\n    public int digitCounts(int k, int n) {\n        // write your code here\n        int cnt=0,mt=1,tmp=0;\n        int a=n;\n        if(k==0)tmp=1;\n        while(a&gt;0){\n            int digit=a%10;\n            a/=10;\n            if(digit&gt;k)cnt+=(a+1-tmp)*mt;\n            else if(digit==k) cnt+=(a-tmp)*mt+n%mt+1;\n            else cnt+=a*mt;\n            mt*=10;\n        }\n        cnt+=tmp;\n        return cnt;\n    }\n};</code></pre><h1><span id=\"4-丑数二中等\">（4） 丑数二(中等)</span></h1><h2><span id=\"筛法只能过94\">筛法只能过94%</span></h2><blockquote>\n<p>因为他后面的数据超过10亿!….</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n        int[] ans=new int[767];\n        boolean[] is=new boolean[10000000];  \n        int tot=0;\n\n        void init(int n){\n            for(int i=0;i&lt;10000000;++i) is[i]=false;\n            is[1]=true;\n            ans[tot++]=1;\n            for(int i=1;i&lt;10000000;++i){\n                if(is[i]){\n                    for(int j=i*2;j&lt;10000000;j*=2){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                    for(int j=i*3;j&lt;10000000;j*=3){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                    for(int j=i*5;j&lt;10000000;j*=5){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                }\n            }\n        }\n\n    public int nthUglyNumber(int n) {\n        // write your code here\n            init(n);\n            //ans=IntStream.of(ans).boxed().sorted().mapToInt(Integer::intValue).toArray();\n            Arrays.sort(ans);\n            return ans[n-1];\n    }\n}</code></pre><h2><span id=\"用hashsetdfs-ac\">用HashSet+Dfs AC</span></h2><blockquote>\n<p>因为他给数据了,所以在已知数据是INT_MAX的前提下就好做多了</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n    HashSet&lt;Integer&gt; tSet=new HashSet&lt;&gt;();\n    int[] ans=new int[1665];\n    int tot=0;\n    void dfs(long num){\n        if(num&gt;(long)1898437500)return;\n        if(tSet.size()&gt;=1665) return;\n        if(tSet.contains((int)num)) return;\n        else{\n            tSet.add((int)num);\n            if(tot==1665)return;\n            ans[tot++]=(int)num;\n            dfs(num*2);\n            dfs(num*3);\n            dfs(num*5);\n        }\n    }\n\n    public int nthUglyNumber(int n) {\n        // write your code here\n        dfs(1);\n        Arrays.sort(ans);\n        return ans[n-1];\n    }\n}</code></pre><h2><span id=\"找规律的解法\">找规律的解法</span></h2><blockquote>\n<p>可以发现只需要三个指针指向P1P2P3,同步前移,第n个就是这三个中最小的一个</p>\n</blockquote>\n<pre><code>class Solution {\npublic:\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n    #define min(a,b) ((a)&lt;(b)?(a):(b))\n    #define min3(a,b,c) (min(min(a,b),min(a,c)))\n    int nthUglyNumber(int n) {\n        int i = 1;\n        int p2 = 0;\n        int p3 = 0;\n        int p5 = 0;\n        int uglyNum[6048] = {0};\n        uglyNum[0] = 1;\n        while ( i &lt; n ) {\n            uglyNum[i] = min3(uglyNum[p2] * 2, uglyNum[p3] * 3, uglyNum[p5] * 5);\n            if (uglyNum[i] == uglyNum[p2] * 2) {\n                p2++;\n            }\n            if (uglyNum[i] == uglyNum[p3] * 3) {\n                p3++;\n            }\n            if (uglyNum[i] == uglyNum[p5] * 5) {\n                p5++;\n            }\n            i++;\n        }\n        return uglyNum[n-1];\n    }\n};</code></pre><h1><span id=\"5-第k大中等\">（5） - 第K大(中等)</span></h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>利用快速排序的分块算法(Partition)+二分查找的思想解决即可.</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Topic_5 {\n    public static void main(String[] args){\n        int[] nums=new int[]{9,3,2,4,8};\n        System.out.println(kthLargestElement(3,nums));\n    }\n\n    //用首元素做pivot\n    private static int partition(int l,int r,int[] nums){\n        int pivot=nums[l];\n        int temp=nums[l],low=l,high=r;\n        while(low&lt;high){\n            while(low&lt;high &amp;&amp; nums[high]&lt;=temp){\n                high--;\n            }\n            nums[low]=nums[high];\n            while(low&lt;high &amp;&amp; nums[low]&gt;=temp){\n                low++;\n            }\n            nums[high]=nums[low];\n        }\n        nums[low]=temp;\n        return low;\n    }\n\n    public static int kthLargestElement(int n, int[] nums) {\n        // write your code here\n        int l=0,r=nums.length - 1;\n        while(l&lt;r){\n            int k=partition(l,r,nums);\n            if(k==n-1) break;\n            if(k&lt;n-1) l=k+1;\n            else if(k&gt;n-1) r=k-1;\n        }\n        return nums[n-1];\n    }\n}</code></pre><h1><span id=\"6-合并有序数组简单\">（6） - 合并有序数组(简单)</span></h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>常规合并</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param A: sorted integer array A\n     * @param B: sorted integer array B\n     * @return: A new sorted integer array\n     */\n\n    private int[] solve(int A[],int B[]){\n        int[] res=new int[A.length+B.length];\n        int tagA=0,tagB=0,tot=0;\n        while(tagA&lt;A.length &amp;&amp; tagB&lt;B.length){\n            if(A[tagA]&lt;B[tagB])res[tot++]=A[tagA++];\n            else res[tot++]=B[tagB++];\n        }\n        while(tagA&lt;A.length){\n            res[tot++]=A[tagA++];\n        }\n        while(tagB&lt;B.length){\n            res[tot++]=B[tagB++];\n        }\n        return res;\n    }\n\n    public int[] mergeSortedArray(int[] A, int[] B) {\n        // write your code here\n        return solve(A,B);\n    }\n}</code></pre><h1><span id=\"7-序列化二叉树与反序列化\">（7） - 序列化二叉树与反序列化</span></h1><blockquote>\n<p>注意bfs序列化后最简单的反序列化是for循环. dfs序列化后最简单的反序列是递归. 当然也可以用两序遍历</p>\n</blockquote>\n<pre><code>import sun.reflect.generics.tree.Tree;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class TOPIC_6 {\n    public static class TreeNode {\n        public int val;\n        public TreeNode left, right;\n        public TreeNode(int val) {\n            this.val = val;\n            this.left = this.right = null;\n        }\n    }\n\n    public static void main(String[] args){\n        TreeNode nt=Solution.deserialize(&quot;1,2,3,#,#,#,#,&quot;);\n        System.out.println(Solution.serialize(nt));\n    }\n\n    public static class Solution {\n        /**\n         * This method will be invoked first, you should design your own algorithm\n         * to serialize a binary tree which denote by a root node to a string which\n         * can be easily deserialized by your own &quot;deserialize&quot; method later.\n         */\n\n        public static void dfs(TreeNode root,StringBuilder data){\n            if(root==null){\n                data.append(&quot;#,&quot;);\n            }else{\n                data.append(String.valueOf(root.val)+&quot;,&quot;);\n                dfs(root.left,data);\n                dfs(root.right,data);\n            }\n        }\n\n        public static String serialize(TreeNode root) {\n            // write your code here\n            StringBuilder data=new StringBuilder();\n            dfs(root,data);\n            return data.toString();\n        }\n\n        // Decodes your encoded data to tree.\n        public static TreeNode deserialize(String data) {\n            LinkedList&lt;String&gt; que = new LinkedList&lt;String&gt;();\n            que.addAll(Arrays.asList(data.split(&quot;,&quot;)));\n            return deserial(que);\n        }\n\n        private static TreeNode deserial(LinkedList&lt;String&gt; que){\n            String str = que.pollFirst();\n            if(str.equals(&quot;#&quot;)){\n                return null;\n            }\n            TreeNode root = new TreeNode(Integer.valueOf(str));\n            if(que.size()!=0) {\n                root.left = deserial(que);\n                root.right = deserial(que);\n            }\n            return root;\n        }\n    }\n}</code></pre><h1><span id=\"8-旋转字符串\">（8） 旋转字符串</span></h1><blockquote>\n<p>剑指Offer上的一道题</p>\n<blockquote>\n<p>先整体旋转,然后把offset前后各旋转一次即可</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param str: An array of char\n     * @param offset: An integer\n     * @return: nothing\n     */\n\n    void Reverse(char[] str,int start,int end){\n        while(start&lt;end){\n            if(end-1&lt;=start)break;\n            str[start]^=str[end-1];\n            str[end-1]^=str[start];\n            str[start]^=str[end-1];\n            start++;end--;\n        }\n    } \n\n    public void rotateString(char[] str, int offset) {\n        // write your code here\n        int len=str.length;\n        if(len&lt;=0)return;\n        int fnos=offset%len;\n        Reverse(str,0,len);\n        Reverse(str,0,fnos);\n        Reverse(str,fnos,len);\n    }\n}</code></pre><h1><span id=\"9-嘶嘶\">（9） - 嘶嘶</span></h1><pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: A list of strings.\n     */\n    public List&lt;String&gt; fizzBuzz(int n) {\n        // write your code here\n        List&lt;String&gt; ans=new LinkedList&lt;String&gt;();\n        for(int i=1;i&lt;=n;++i){\n            if(i%3==0 &amp;&amp; i%5==0) ans.add(&quot;fizz buzz&quot;);\n            else if(i%3==0) ans.add(&quot;fizz&quot;);\n            else if(i%5==0) ans.add(&quot;buzz&quot;);\n            else ans.add(String.valueOf(i));\n        }\n        return ans;\n    }\n}</code></pre><h1><span id=\"11-search-range-in-binary-search-tree\">（11） - Search Range in Binary Search Tree</span></h1><blockquote>\n<p>常规dfs,可以剪枝</p>\n</blockquote>\n<pre><code>/**\n * Definition of TreeNode:\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left, right;\n *     public TreeNode(int val) {\n *         this.val = val;\n *         this.left = this.right = null;\n *     }\n * }\n */\n\npublic class Solution {\n\n    private int l;\n    private int r;\n\n    public void dfs(List&lt;Integer&gt; data,TreeNode root){\n        int value=root.val;\n        if(value&gt;=l &amp;&amp; value&lt;= r){\n            data.add(value);\n            if(root.left!=null)\n                dfs(data,root.left);\n            if(root.right!=null)\n                dfs(data,root.right);\n        }else{\n            if(value &gt;= r &amp;&amp; root.left!=null){\n                dfs(data,root.left);\n            }\n            if(value &lt;= l &amp;&amp; root.right!=null){\n                dfs(data,root.right);\n            }\n        }\n    }\n\n\n\n    /**\n     * @param root: param root: The root of the binary search tree\n     * @param k1: An integer\n     * @param k2: An integer\n     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order\n     */\n    public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) {\n        List&lt;Integer&gt; data=new LinkedList&lt;&gt;();\n        if(root==null)return data;\n        this.l=k1;\n        this.r=k2;\n        dfs(data,root);\n        return data;\n    }\n}</code></pre><h1><span id=\"114-不同的路径中等\">（114） 不同的路径(中等)</span></h1><blockquote>\n<p>很明显是杨辉三角,求C(n,m) 当然,也可以用动态规划,dp[i][j]=dp[i-1][j]+dp[i][j-1]</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param m: positive integer (1 &lt;= m &lt;= 100)\n     * @param n: positive integer (1 &lt;= n &lt;= 100)\n     * @return: An integer\n     */\n    public int[][] res=new int[204][204];\n    public void init(){\n        res[0][0]=1;\n        for(int i=1;i&lt;=200;++i){\n            res[i][0]=1;\n            for(int j=1;j&lt;=i;++j){\n                res[i][j]=res[i-1][j-1]+res[i-1][j];\n            }\n        }\n    }\n\n    public int uniquePaths(int m, int n) {\n        // write your code here\n        init();\n        return res[m+n-2][m-1];\n    }\n}</code></pre>","text":"（2） 尾部的零(Easy)因为2的数量远大于5,统计5的数量即可public class Solution {    /*     * @param n: An integer     * @return: An integer, denote the number of tr","link":"","raw":null,"photos":[],"categories":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/categories/LintCode.json"}],"tags":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/tags/LintCode.json"}]}]}