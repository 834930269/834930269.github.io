{"name":"字符串处理","slug":"AC自动机/KMP/字符串处理","count":1,"postlist":[{"title":"字符串算法","slug":"charset-algorithm","date":"2018-02-24T10:32:39.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/charset-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png","content":"<h1 id=\"Trie\"><a href=\"#Trie\" class=\"headerlink\" title=\"Trie\"></a>Trie</h1><blockquote>\n<p>这个…不想写了</p>\n</blockquote>\n<h1 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h1><blockquote>\n<p>朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)</p>\n</blockquote>\n<h2 id=\"Next数组\"><a href=\"#Next数组\" class=\"headerlink\" title=\"Next数组\"></a>Next数组</h2><blockquote>\n<p>对于KMP而言最重要的莫过于这个Next数组了.</p>\n<blockquote>\n<p>Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.</p>\n</blockquote>\n<p>构造方法:</p>\n<blockquote>\n<p>Next[i]=max{j | j\\&lt;i 且N[1..j]=N[i-j+1..i]}</p>\n<blockquote>\n<p>即Next[i]球的试串P[1..i]的一个最长的前缀P[1..j],这个前缀同时也是他的后缀。当这个前缀找不到的时候,Next[i]=0</p>\n</blockquote>\n</blockquote>\n<p>例如:</p>\n<blockquote>\n<p>模式串 P = ababc</p>\n<blockquote>\n<p>则Next[4]=2,因为ab不仅是abab的前缀,也是他的后缀. 而Next[5]=0，因为无法找到ababc(P[1..5])的一个前缀同时又是他的后缀.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"附上一张图\"><a href=\"#附上一张图\" class=\"headerlink\" title=\"附上一张图\"></a>附上一张图</h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" alt></a></p>\n<h2 id=\"匹配时逻辑\"><a href=\"#匹配时逻辑\" class=\"headerlink\" title=\"匹配时逻辑\"></a>匹配时逻辑</h2><blockquote>\n<p>KMP 在匹配时同时维护两个下标 i 和 j ,表示当前模式串 P 的前 j 个字符与主串 T 在位置 i 前的 j 个字符匹配,即 P[1..j]=T[i-j..i-1]。 当算法尝试对 T[i] 和 P[j+1] 匹配中遇到不相同的字符,就会通过Next数组进行跳跃。</p>\n</blockquote>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><h3 id=\"Next数组-1\"><a href=\"#Next数组-1\" class=\"headerlink\" title=\"Next数组\"></a>Next数组</h3><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(cin&gt;&gt;T){\n        getNext();\n        print();\n    }\n    return 0;\n}</code></pre><h4 id=\"几组数据\"><a href=\"#几组数据\" class=\"headerlink\" title=\"几组数据\"></a>几组数据</h4><pre><code>ababc\nNext: -1 0 0 1 2\n\nabcdef\nNext: -1 0 0 0 0 0\n\nabcdabce\nNext: -1 0 0 0 0 1 2 3\n\nabcabcabc\nNext: -1 0 0 0 1 2 3 4 5\n\nabcdabcabcd\nNext: -1 0 0 0 0 1 2 3 1 2 3</code></pre><h3 id=\"KMP-返回第一个匹配的下标\"><a href=\"#KMP-返回第一个匹配的下标\" class=\"headerlink\" title=\"KMP - 返回第一个匹配的下标\"></a>KMP - 返回第一个匹配的下标</h3><h4 id=\"主程\"><a href=\"#主程\" class=\"headerlink\" title=\"主程\"></a>主程</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint KMP_index(){\n    int i=0,j=0,slen=S.length(),tlen=T.length();\n    getNext();\n    while(i&lt;slen &amp;&amp; j&lt;tlen){\n        if(j==-1 || S[i]==T[j]){\n            i++;\n            j++;\n        }else j=Next[j];\n    }\n    if(j==tlen) return i-tlen;\n    else return -1;\n}\n\nint main(){\n    while(cin&gt;&gt;S&gt;&gt;T){\n        int ans=KMP_index();\n        if(ans==-1) cout&lt;&lt;&quot;Failed!&quot;&lt;&lt;endl;\n        else cout&lt;&lt;&quot;Succesed!String T was matched in index &quot;&lt;&lt;ans&lt;&lt;&quot;.&quot;&lt;&lt;endl;\n        print();\n    }\n    return 0;\n}</code></pre><h4 id=\"两组数据\"><a href=\"#两组数据\" class=\"headerlink\" title=\"两组数据\"></a>两组数据</h4><pre><code>IN[0]: jashdjashdjabababcabcsdas\nIN[1]: abcabc\nOUT[0]: Succesed!String T was matched in index 15.\nOUT[1]: -1 0 0 0 1 2\nIN[2]: jashdjashdjabababcabcsdas\nIN[3]: abcabcd\nOUT[2]: Failed!\nOUT[3]: -1 0 0 0 1 2 3</code></pre><h1 id=\"AC-Corasick-自动机\"><a href=\"#AC-Corasick-自动机\" class=\"headerlink\" title=\"AC-Corasick 自动机\"></a>AC-Corasick 自动机</h1><blockquote>\n<p>思想是KMP+Trie,在Trie上建立失配指针.</p>\n<blockquote>\n<p>常用于主串匹配多个字符串</p>\n</blockquote>\n</blockquote>\n<h2 id=\"尾节点记录字符串下标的AC自动机\"><a href=\"#尾节点记录字符串下标的AC自动机\" class=\"headerlink\" title=\"尾节点记录字符串下标的AC自动机\"></a>尾节点记录字符串下标的AC自动机</h2><blockquote>\n<p>优点是可以直接输出字符串.</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2 id=\"尾节点记录可重复子串在总串中出现次数\"><a href=\"#尾节点记录可重复子串在总串中出现次数\" class=\"headerlink\" title=\"尾节点记录可重复子串在总串中出现次数\"></a>尾节点记录可重复子串在总串中出现次数</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    int ch[maxn][sigma_size];\n    int f[maxn],last[maxn];\n    int cnt[maxn],val[maxn];\n    int siz;\n\n    int ans;\n\n    void init(){\n        siz=ans=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///表示以第u棵节点为字符串最后一个字符节点的个数\n       ///如果想存储该节点代表的是哪个字符串.即存储该字符串的下标\n       ///val[u]=v;(v是下标)\n       ///但是这样存储就会出现无法统计之前有多少个重复字符串\n       ///比如这道题如果输入\n       ///3\n       ///sha\n       ///sha\n       ///sha\n       ///shashasha\n       ///则用第一种方法最后结果是3\n       ///但用第二种方法只能匹配一次sha\n       val[u]++;\n    }\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        if(u){\n            if(!cnt[u]) ans+=val[u],cnt[u]=1;\n            add(last[u]);\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i]);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2 id=\"失配函数优化\"><a href=\"#失配函数优化\" class=\"headerlink\" title=\"失配函数优化\"></a>失配函数优化</h2><blockquote>\n<p>接下来都基于第一个代码进行优化,可以复刻到第二个代码上</p>\n<blockquote>\n<p>即将失配记录转变成 一条确定的边连到Trie中(这样应该就不能被称之为树了)</p>\n</blockquote>\n<p>if(!u) continue; =&gt;</p>\n<blockquote>\n<p>if(!u) {ch[k][c]=ch[f[k]][c];continue;} 删掉适配函数BFS中的 while()</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) {ch[k][c]=ch[f[k]][c];continue;}\n                Q.push(u);\n                int v=f[k];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2 id=\"MLE和TLE优化–内存优化\"><a href=\"#MLE和TLE优化–内存优化\" class=\"headerlink\" title=\"MLE和TLE优化–内存优化\"></a>MLE和TLE优化–内存优化</h2><blockquote>\n<p>听说之前网络赛的时候就有道AC自动机的题,然后普通的模板总是MLE. 少了一半的时间,一半的内存</p>\n<blockquote>\n<p>意在每次不全初始化,每多一个节点初始化一次</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组fail,last\n    int f[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数,根节点编号\n    int siz,root;\n\n    int ans;\n\n    int newNode(){\n        memset(ch[siz],0,sizeof(ch[siz]));\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        ans=0;siz=0;root=newNode();\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    //Fail树,build\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2 id=\"但是以上自动机识别形如a-ab-abc-abcd这类子串会出问题-在刷题时发现的-下面重新用新的方法来解决这个问题-建议用下面的AC自动机\"><a href=\"#但是以上自动机识别形如a-ab-abc-abcd这类子串会出问题-在刷题时发现的-下面重新用新的方法来解决这个问题-建议用下面的AC自动机\" class=\"headerlink\" title=\"但是以上自动机识别形如a,ab,abc,abcd这类子串会出问题,在刷题时发现的,下面重新用新的方法来解决这个问题,建议用下面的AC自动机\"></a>但是以上自动机识别形如a,ab,abc,abcd这类子串会出问题,在刷题时发现的,下面重新用新的方法来解决这个问题,建议用下面的AC自动机</h2><h3 id=\"HDU-2222，上面的那些题-修改\"><a href=\"#HDU-2222，上面的那些题-修改\" class=\"headerlink\" title=\"HDU 2222，上面的那些题,修改\"></a>HDU 2222，上面的那些题,修改</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root,ans;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n        ans=0;\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        gets(str);\n        tot_len=strlen(str);\n        aho.Find(str);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h3 id=\"HDU-5880-青岛区域赛网赛\"><a href=\"#HDU-5880-青岛区域赛网赛\" class=\"headerlink\" title=\"HDU 5880,青岛区域赛网赛\"></a>HDU 5880,青岛区域赛网赛</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            if(!isalpha(s[i])){\n                u=0;\n                continue;\n            }\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            /*\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                p=f[p];\n            }\n            */\n            add(u,i);\n        }\n    }\n\n    void print(){\n        for(int i=0;i&lt;tot_len;++i){\n            if(cle[i]) putchar(&apos;*&apos;);\n            else putchar(str[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str,i+1);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(str);\n        tot_len=strlen(str);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(str);\n        aho.print();\n    }\n    return 0;\n}</code></pre><h1 id=\"后缀数组\"><a href=\"#后缀数组\" class=\"headerlink\" title=\"后缀数组\"></a>后缀数组</h1><h1 id=\"后缀自动机\"><a href=\"#后缀自动机\" class=\"headerlink\" title=\"后缀自动机\"></a>后缀自动机</h1>","text":"Trie这个…不想写了KMP朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)Next数组对于KMP而言最重要的莫过于这个Next数组了.Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.构","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"KMP","slug":"AC自动机/KMP","count":1,"path":"api/categories/AC自动机/KMP.json"},{"name":"字符串处理","slug":"AC自动机/KMP/字符串处理","count":1,"path":"api/categories/AC自动机/KMP/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]}]}