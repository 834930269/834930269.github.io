{"name":"STL","slug":"LibreOJ/STL","count":1,"postlist":[{"title":"LibreOJ  516","slug":"libreoj-516","date":"2017-07-12T10:51:48.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/libreoj-516.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Problem Link】</strong> <strong><a href=\"https://loj.ac/problem/516\" target=\"_blank\" rel=\"noopener\">#516. 「LibreOJ β Round #2」DP 一般看规律</a></strong> <strong>【题意】</strong> <strong>输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT.</strong> <strong>【题解】</strong> <strong>每个数字只与他的前驱和后继产生贡献。构建n个set，每次将较小的暴力合并到大的上面，通过lower_bound来找到他的前驱和后继。懒得离散化可以用map来存set。</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LibreOJ/%23516%20DP%E4%B8%80%E8%88%AC%E7%9C%8B%E8%A7%84%E5%BE%8B.cpp\" target=\"_blank\" rel=\"noopener\">#516 DP一般看规律.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int ans,n,m,num,x,y;<br>map&lt;int,set<int> &gt; mp;///数字-&gt;数字下标集映射</int></p>\n<p>void insert_update(int q,int index){<br>    set<int> &amp;r=mp[q];<br>    set<int>::iterator it=r.lower_bound(index);<br>    if(it!=r.end()) ans=min(ans,<em>it-index);///右边相邻第一个<br>    if(it!=r.begin()) it–,ans=min(ans,index-</em>it);///左边相邻第一个<br>    r.insert(index);<br>}</int></int></p>\n<p>int main(){<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)){<br>        ans=2147483647;mp.clear();<br>        for(int i=0;i&lt;n;++i){<br>            scanf(“%d”,&amp;num);<br>            insert_update(num,i);<br>        }<br>        for(int i=0;i&lt;m;++i){<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            if(x==y){printf(“%d\\n”,ans);continue;}<br>            set &amp;r=mp[x],&amp;t=mp[y];<br>            if(r.size()&gt;t.size())swap(r,t);<br>            for(set<int>::iterator si=r.begin();si!=r.end();si++)<br>                insert_update(y,<em>si);<br>            r.clear();<br>            printf(“%d\\n”,ans);<br>        }<br>    }<br>    return 0;<br>}*</em></int></p>\n","text":"【Problem Link】 #516. 「LibreOJ β Round #2」DP 一般看规律 【题意】 输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT. 【题解】 每个数字只与他的前驱和后继产生贡献。构建n个","link":"","raw":null,"photos":[],"categories":[{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/categories/LibreOJ.json"},{"name":"STL","slug":"LibreOJ/STL","count":1,"path":"api/categories/LibreOJ/STL.json"},{"name":"思维","slug":"LibreOJ/STL/思维","count":1,"path":"api/categories/LibreOJ/STL/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"},{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/tags/LibreOJ.json"}]}]}