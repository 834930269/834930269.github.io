{"name":"Sdut","slug":"Sdut","count":11,"postlist":[{"title":"山东省第七届省赛","slug":"acm-icpc-7","date":"2018-03-04T02:42:24.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/acm-icpc-7.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"A-水\"><a href=\"#A-水\" class=\"headerlink\" title=\"A:水\"></a>A:水</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,A,B;\n    while(~scanf(&quot;%d&quot;,&amp;T)){\n        for(int i=0;i&lt;T;++i){\n            cin&gt;&gt;A&gt;&gt;B;\n            if(A%B){\n                cout&lt;&lt;(A/B)+1&lt;&lt;endl;\n            }else{\n                cout&lt;&lt;(A/B)&lt;&lt;endl;\n            }\n        }\n    }\n    return 0;\n}</code></pre><h1 id=\"B-二分-或者可以暴力-只有45个FB-结论题-用到斐波那契博弈里的一个结论-任何数都可以被拆成不同斐波那契的和-进而猜测直接从最大的小于N的FB往下找即可\"><a href=\"#B-二分-或者可以暴力-只有45个FB-结论题-用到斐波那契博弈里的一个结论-任何数都可以被拆成不同斐波那契的和-进而猜测直接从最大的小于N的FB往下找即可\" class=\"headerlink\" title=\"B:二分(或者可以暴力,只有45个FB)结论题,用到斐波那契博弈里的一个结论:任何数都可以被拆成不同斐波那契的和,进而猜测直接从最大的小于N的FB往下找即可\"></a>B:二分(或者可以暴力,只有45个FB)结论题,用到斐波那契博弈里的一个结论:任何数都可以被拆成不同斐波那契的和,进而猜测直接从最大的小于N的FB往下找即可</h1><h2 id=\"我吐槽下SDUT的OJ…尼玛10-9能写成109-劳资找了大大大大大大半天错硬是不知道错哪里了艹\"><a href=\"#我吐槽下SDUT的OJ…尼玛10-9能写成109-劳资找了大大大大大大半天错硬是不知道错哪里了艹\" class=\"headerlink\" title=\"我吐槽下SDUT的OJ…尼玛10^9能写成109,劳资找了大大大大大大半天错硬是不知道错哪里了艹\"></a>我吐槽下SDUT的OJ…尼玛10^9能写成109,劳资找了大大大大大大半天错硬是不知道错哪里了艹</h2><h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=45;\nint Fb[maxn],M;\nint vis[maxn],has_ans;\n\nvoid init(){\n    Fb[0]=1;\n    Fb[1]=2;\n    for(int i=2;i&lt;maxn;++i){\n        Fb[i]=Fb[i-1]+Fb[i-2];\n        //printf(&quot;%d\\n&quot;,Fb[i]);\n    }\n\n}\n\nvoid solve(int N){\n    stack&lt;int&gt; ans;\n    int mx=maxn;\n    while(N!=0){\n        int ind=lower_bound(Fb,Fb+mx,N)-Fb;\n        if(Fb[ind]&gt;N)ind-=1;\n        N=N-Fb[ind];\n        ans.push(Fb[ind]);\n    }\n    printf(&quot;%d=&quot;,M);\n    int t=0;\n    while(!ans.empty()){\n        if(!t){\n            printf(&quot;%d&quot;,ans.top());t++;\n        }else printf(&quot;+%d&quot;,ans.top());\n        ans.pop();\n    }\n    printf(&quot;\\n&quot;);\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        memset(vis,0,sizeof(vis));\n        has_ans=0;\n        scanf(&quot;%d&quot;,&amp;M);\n        solve(M);\n    }\n    return 0;\n}\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 40ms\nTake Memory: 196KB\nSubmit time: 2018-03-04 13:39:50\n****************************************************/</code></pre><h1 id=\"E-简单枚举\"><a href=\"#E-简单枚举\" class=\"headerlink\" title=\"E:简单枚举\"></a>E:简单枚举</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=110;\n\nint T,N,M;\nchar mp[maxn][maxn];\nint dist[4][2]={ {1,0},{-1,0},{0,-1},{0,1}};\n\nbool check(int x,int y){\n    if(x&lt;1 || x&gt;M || y&lt;1 || y&gt;N) return false;\n    return true;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int ans=0;\n        scanf(&quot;%d%d&quot;,&amp;M,&amp;N);\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%s&quot;,mp[i]+1);\n        }\n        for(int i=1;i&lt;=M;++i){\n            for(int j=1;j&lt;=N;++j){\n                if(mp[i][j]==&apos;#&apos;){\n                    for(int k=0;k&lt;4;++k){\n                        int x=i+dist[k][0],y=j+dist[k][1];\n                        if(check(x,y)){\n                            if(mp[x][y]==&apos;#&apos;)continue;\n                            int room=0;\n                            for(int kk=0;kk&lt;4;++kk){\n                                int xx=x+dist[kk][0],yy=y+dist[kk][1];\n                                if(check(xx,yy)){\n                                    if(mp[xx][yy]==&apos;#&apos;)++room;\n                                }\n                            }\n                            if(room==1)ans++;\n                        }else ++ans;\n                    }\n                }\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 228ms\nTake Memory: 212KB\nSubmit time: 2018-03-04 14:46:06\n****************************************************/</code></pre><h1 id=\"G-找规律-不像博弈-抱歉-会打表-但是规律想不出来-对不起\"><a href=\"#G-找规律-不像博弈-抱歉-会打表-但是规律想不出来-对不起\" class=\"headerlink\" title=\"G:找规律,不像博弈,抱歉,会打表,但是规律想不出来,对不起\"></a>G:找规律,不像博弈,抱歉,会打表,但是规律想不出来,对不起</h1><h2 id=\"打表\"><a href=\"#打表\" class=\"headerlink\" title=\"打表\"></a>打表</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint solve(int N){\n    int ans=0;\n    for(int i=1;i&lt;N;++i){\n        for(int j=i;j&lt;N-i;++j){\n            int k=N-i-j;\n            if((i^j^k)==0) ans++;\n        }\n    }\n    return ans;\n}\n\nint main(){\n    for(int i=1;i&lt;=200;++i){\n        printf(&quot;%d: %d\\n&quot;,i,solve(i)/3);\n    }\n    return 0;\n}</code></pre><h2 id=\"找的规律-知道规律了-直接粘的别人代码\"><a href=\"#找的规律-知道规律了-直接粘的别人代码\" class=\"headerlink\" title=\"找的规律,知道规律了,直接粘的别人代码\"></a>找的规律,知道规律了,直接粘的别人代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    int ans,pp;\n    int i;\n    long long int f[100];\n    f[2]=1;\n    f[1]=0;\n    f[0]=0;\n    for(i=3;i&lt;30;i++)\n        f[i]=f[i-1]*3+1;\n    long long int a;\n    int T;\n    cin&gt;&gt;T;\n    while(T--)\n    {\n        cin&gt;&gt;a;\n        ans=0;\n        if(a%2)\n        {\n            cout&lt;&lt;0&lt;&lt;endl;\n            continue;\n        }\n        while(a!=0)\n        {\n            pp=a%2;\n            if(pp)\n                ans++;\n            a/=2;\n        }\n        cout&lt;&lt;f[ans]&lt;&lt;endl;\n    }\n}</code></pre><h1 id=\"J-题目翻译-http-www-bubuko-com-infodetail-1612259-html-说实话-完全理解题意了基本就是水题-但对我不是\"><a href=\"#J-题目翻译-http-www-bubuko-com-infodetail-1612259-html-说实话-完全理解题意了基本就是水题-但对我不是\" class=\"headerlink\" title=\"J:题目翻译: http://www.bubuko.com/infodetail-1612259.html 说实话,完全理解题意了基本就是水题.但对我不是.\"></a>J:题目翻译: <a href=\"http://www.bubuko.com/infodetail-1612259.html\" target=\"_blank\" rel=\"noopener\">http://www.bubuko.com/infodetail-1612259.html</a> 说实话,完全理解题意了基本就是水题.但对我不是.</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint T;\nchar str[1000];\nint main(){\n    cin&gt;&gt;T;\n    while(T--){\n        int N,M;\n        cin&gt;&gt;N&gt;&gt;M;\n        int c=0,m=0,o=0,b=0;\n        getchar();\n        for(int i=0;i&lt;N;++i){\n            gets(str);\n            if(str[0]==&apos;C&apos;){\n                c++;\n            }else if(str[0]==&apos;M&apos;){\n                m++;\n            }else if(str[0]==&apos;O&apos;){\n                o++;\n            }else if(str[0]==&apos;B&apos;){\n                b++;\n            }\n        }\n        int ans=o*(2+(N-1)+m*2)+b*(2+m*2);\n        if(ans&gt;=M){\n            puts(&quot;Mrghllghghllghg!&quot;);\n        }else puts(&quot;Tell you a joke, the execution of Paladin.&quot;);\n    }\n    return 0;\n}</code></pre><h1 id=\"K-水\"><a href=\"#K-水\" class=\"headerlink\" title=\"K:水\"></a>K:水</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10010,maxm=5010;\nint N;\nstack&lt;char&gt; st;\nint main(){\n    while(~scanf(&quot;%d\\n&quot;,&amp;N)){\n        char qb;\n        while(N--){\n            int f=0;\n            do{\n                do{\n                    qb=getchar();\n                    if(isalpha(qb)) st.push(qb);\n                }while(qb!=&apos; &apos; &amp;&amp; qb!=&apos;\\n&apos;);\n                if(f==0)f++;\n                else printf(&quot; &quot;);\n                while(!st.empty()){\n                    printf(&quot;%c&quot;,st.top());\n                    st.pop();\n                }\n            }while(qb!=&apos;\\n&apos;);\n            printf(&quot;\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"A:水#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int T,A,B;    while(~scanf(&quot;%d&quot;,&amp;T)){        for(int i=0;i&","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"二分搜索","slug":"Sdut/二分搜索","count":1,"path":"api/categories/Sdut/二分搜索.json"},{"name":"博弈论","slug":"Sdut/二分搜索/博弈论","count":1,"path":"api/categories/Sdut/二分搜索/博弈论.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/二分搜索/博弈论/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/二分搜索/博弈论/第七届ACM山东省赛.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"第八届ACM省赛 K CF","slug":"acm-k-cf","date":"2018-01-18T07:35:38.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/acm-k-cf.json","excerpt":"","keywords":null,"cover":"http://acm.sdut.edu.cn/image/3903.png","content":"<h3 id=\"CF\"><a href=\"#CF\" class=\"headerlink\" title=\"CF\"></a>CF</h3><p><strong>sdut 3903</strong> Time Limit: 1000MS Memory Limit: 65536KB</p>\n<h4 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h4><p><img src=\"http://acm.sdut.edu.cn/image/3903.png\" alt> LYD loves codeforces since there are many Russian contests. In an contest lasting for <em>T</em> minutes there are <em>n</em> problems, and for the <em>i__th</em> problem you can get <em>a__i_−_d__i_∗_t__i</em> points, where <em>a__i</em> indicates the initial points, <em>d__i</em> indicates the points decreased per minute (count from the beginning of the contest), and <em>t__i</em> stands for the passed minutes when you solved the problem (count from the begining of the contest).<br>Now you know LYD can solve the <em>i__th</em> problem in <em>c__i</em> minutes. He can’t perform as a multi-core processor, so he can think of only one problem at a moment. Can you help him get as many points as he can?</p>\n<h4 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h4><p>The first line contains two integers <em>n</em>,<em>T</em>(0≤<em>n</em>≤2000,0≤<em>T</em>≤5000).<br>The second line contains <em>n</em> integers <em>a</em>1,<em>a</em>2,..,<em>a__n</em>(0&lt;<em>a__i_≤6000).<br>The third line contains _n</em> integers <em>d</em>1,<em>d</em>2,..,<em>d__n</em>(0&lt;<em>d__i_≤50).<br>The forth line contains _n</em> integers <em>c</em>1,<em>c</em>2,..,<em>c__n</em>(0&lt;_c__i_≤400).</p>\n<h4 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h4><p>Output an integer in a single line, indicating the maximum points LYD can get.</p>\n<h4 id=\"Example-Input\"><a href=\"#Example-Input\" class=\"headerlink\" title=\"Example Input\"></a>Example Input</h4><p>3 10<br>100 200 250<br>5 6 7<br>2 4 10</p>\n<h4 id=\"Example-Output\"><a href=\"#Example-Output\" class=\"headerlink\" title=\"Example Output\"></a>Example Output</h4><p>254</p>\n<h4 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a><strong>题意</strong></h4><p>有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题的分数便会减少 di ，而我们可以在 ci 时间内做出这道题而得到分数，求在时间 T 内最多可以获得的分数。</p>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a><strong>题解</strong></h4><p>首先可以感觉出这是道0-1背包问题,然后我们需要知道,当我们做题时,会一两个角度来选择题目,其一是选择做题速度最快的,其二是选择做分值降低速度最快的.那么我们的衡量标准就可以看成先做单位时间内做题最多的那道. 然后我们根据上述规则排一下序. 在用排序后的数组进行0-1背包.在背包过程中记录最大值,即为最后的结果.</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=3000;\n\nstruct pro{\n    int a,d,c;\n    //按单位时间内减少分值排序\n    bool operator &lt;(const pro &amp;pt)const{\n        return 1.0*d/c&gt;(1.0*pt.d/pt.c);\n    }\n};\n\nint n,T;\npro p[maxn];\nint dp[5010];\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;T)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].a);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].d);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].c);\n        }\n        sort(p,p+n);\n        int mx=-1;\n        for(int i=0;i&lt;n;++i){\n            for(int j=T;j&gt;=0;--j){\n                if(j&gt;=p[i].c){\n                    dp[j]=max(dp[j],dp[j-p[i].c]+p[i].a-j*p[i].d);\n                }\n                mx=max(mx,dp[j]);\n            }\n        }\n        printf(&quot;%d\\n&quot;,mx);\n    }\n    return 0;\n}</code></pre>","text":"CFsdut 3903 Time Limit: 1000MS Memory Limit: 65536KBProblem Description [Figure] 2 4 10Example Output254题意有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"动态规划","slug":"Sdut/动态规划","count":2,"path":"api/categories/Sdut/动态规划.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/动态规划/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/动态规划/第八届ACM山东省赛.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"第八届ACM省赛 Quadrat 找规律","slug":"acm-quadrat","date":"2017-11-27T23:42:08.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/acm-quadrat.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: <a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164</a> B题 题意: 求数位为n位的所有数字(0~9..9(n个9))中,各个数位与其平方%10^n所得数的各个数位之差不超过d的数的个数. 注: 所有的数位之差是循环的,比如9和1差2. 首先打表(不过我认为这道题是数位dp,但我不会):</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\n\nconst int num[5]={1,10,100,1000,10000};\nint a[15][15];\nvoid init(){\n    memset(a, 0, sizeof(a));\n    for(int i = 0; i &lt;= 9; ++i){\n        for(int j = 0; j &lt;= 9; ++j){\n            a[i][j] = abs(i-j);\n            if(a[i][j] &gt; 5) a[i][j] = 10 - a[i][j];\n        }\n    }\n}\n\nbool judge(int i,int digit,int d){\n    int res=i*i;\n    for(int j=1;j&lt;=digit;++j){\n        int b=i%10;\n        int c=res%10;\n        i/=10;res/=10;\n        if(a[b][c]&gt;d) return false;\n    }\n    return true;\n}\n\nint check(int nb,int d){\n    int cnt=0;\n    for(int i=0;i&lt;num[nb];++i){\n        if(judge(i,nb,d))\n            cnt++;\n    }\n    return cnt;\n}\n\nint main(){\n    init();\n    for(int i=1;i&lt;=4;++i){\n        printf(&quot;%d:&quot;,i);\n        for(int j=0;j&lt;4;++j){\n            printf(&quot; %d&quot;,check(i,j));\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>发现dp[i][j]=dp[i-1][j]<em>(2</em>j+1) Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nlong long dp[19][4];\n\nvoid init(){\n    dp[1][0]=4;dp[1][1]=4;\n    dp[1][2]=8;dp[1][3]=8;\n    for(int i=2;i&lt;=18;++i){\n        for(int j=0;j&lt;4;++j){\n            dp[i][j]=dp[i-1][j]*(2*j+1);\n        }\n    }\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int n,d;\n        scanf(&quot;%d %d&quot;,&amp;n,&amp;d);\n        printf(&quot;%lld\\n&quot;,dp[n][d]);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164 B题 题意: 求数位为n位的所有数字(0~9..9(n个9))中,各个数位与其平方%10^n所得数的各个数位","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"思维","slug":"Sdut/思维","count":1,"path":"api/categories/Sdut/思维.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/思维/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/思维/第八届ACM山东省赛.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"第六届山东省ACM/ICPC J Single Round Math","slug":"dljaisdacmicpc-j-single-round-math","date":"2017-04-19T08:37:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dljaisdacmicpc-j-single-round-math.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>java大整数瞎搞,话说占用内存好高啊.</strong> <strong>【题目链接】</strong> <a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3260.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3260.html</a> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>import java.util.*;</strong> <strong>import java.math.*;</strong> <strong>public class J{</strong> **    public static void main(String args[]){** **        Scanner cin=new Scanner(System.in);** **        int T;** **        BigInteger a,b,c=new BigInteger(“11”),d=new BigInteger(“0”);** **        T=cin.nextInt();** **        while((T–)!=0){** **            a=cin.nextBigInteger();** **            b=cin.nextBigInteger();** **            if(a.compareTo(c)&lt;0 || b.compareTo(c)&lt;0) System.out.println(“NO”);** **            else if(a.compareTo(b)!=0) System.out.println(“NO”);** **            else if(d.compareTo(a.remainder(c))==0) System.out.println(“YES”);** **            else System.out.println(“NO”);** **        }** **    }** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 java大整数瞎搞,话说占用内存好高啊. 【题目链接】 http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3260.html 【Code】import java.util","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"第六届ACM山东省赛","slug":"Sdut/第六届ACM山东省赛","count":2,"path":"api/categories/Sdut/第六届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第六届ACM山东省赛","slug":"第六届ACM山东省赛","count":3,"path":"api/tags/第六届ACM山东省赛.json"}]},{"title":"第六届山东省ACM/ICPC B Lowest Unique Price","slug":"dljaisdsacmicpc-b-lowest-unique-price","date":"2017-04-18T15:31:58.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/dljaisdsacmicpc-b-lowest-unique-price.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>set,映射</strong> <strong>【Tip】</strong> <strong>题目上给的数据范围是 x∈[1,106]</strong> <strong>但是我写代码时把映射空间开到100000才A了过去.?????? WTF??</strong> <strong>另外,一开始我用map动态搜索,输出时遍历查找最少价值为一次的结果,果不其然,TLE.</strong> <strong>所以改成了set动态更新第一个节点.即最小点.实现不需要遍历直接插入瞎搞的算法.</strong> <strong>PS:真心搞不懂为啥映射数组要开10W啊？？？？？？？</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define cle(a,val) memset(a,(val),sizeof(a)) #define SI(N) scanf(“%d”,&amp;(N)) #define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M)) #define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K)) #define rep(i,b) for(int i=0;i&lt;(b);i++) #define rez(i,a,b) for(int i=(a);i&lt;=(b);i++) #define red(i,a,b) for(int i=(a);i&gt;=(b);i–) const ll LINF = 0x3f3f3f3f3f3f3f3f; #define PU(x) puts(#x); #define PI(A) cout&lt;&lt;(A)&lt;&lt;endl; #define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl; #define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl; #define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl; #define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl; #define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;} const double EPS = 1e-9 ; int reg[100000]; char readchar(){ char c=getchar(); while(c!=’b’ &amp;&amp; c!=’q’ &amp;&amp; c!=’c’) c=getchar(); return c; } int main(){ int T; scanf(“%d”,&amp;T); while(T–){ set<int> se; cle(reg,0); int N; SI(N); rep(i,N){ char a; int b; a=readchar(); if(a==’b’){ SI(b); reg[b]++; if(reg[b]==1) se.insert(b); else se.erase(b); } if(a==’c’){ SI(b); if(reg[b]&gt;0){ reg[b]–; if(reg[b]==1) se.insert(b); else se.erase(b); } } if(a==’q’){ if(se.empty()) puts(“none”); else printf(“%d\\n”,*(se.begin())); } } } return 0; }</int></strong></p>\n</blockquote>\n","text":"【类型】 set,映射 【Tip】 题目上给的数据范围是 x∈[1,106] 但是我写代码时把映射空间开到100000才A了过去.?????? WTF?? 另外,一开始我用map动态搜索,输出时遍历查找最少价值为一次的结果,果不其然,TLE. 所以改成了set动态更新第一个节点.","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"STL","slug":"Sdut/STL","count":2,"path":"api/categories/Sdut/STL.json"},{"name":"第六届ACM山东省赛","slug":"Sdut/STL/第六届ACM山东省赛","count":1,"path":"api/categories/Sdut/STL/第六届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第六届ACM山东省赛","slug":"第六届ACM山东省赛","count":3,"path":"api/tags/第六届ACM山东省赛.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"}]},{"title":"第六届山东省ACM/ICPC A Nias and Tug-of-War","slug":"dljsdssacmicpc-a-nias-and-tug-of-war","date":"2017-04-18T14:45:52.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dljsdssacmicpc-a-nias-and-tug-of-war.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>重载小于号,排序</strong> <strong>【题目链接】</strong> <strong><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3251.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3251.html</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct star{</strong> **    double height,weight;** **    bool operator&lt;(const star A)const{** **        return height&lt;A.height;** **    }** <strong>}person[200];</strong> <strong>int main(){</strong> **    int T,N;** **    double ansr=0.0,ansb=0.0;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        ansr=0.0,ansb=0.0;** **        scanf(“%d”,&amp;N);** **        rep(i,N)** **            scanf(“%lf %lf”,&amp;person[i].height,&amp;person[i].weight);** **        sort(person,person+N);** **        int con=1;** **        rep(i,N){** **            if(con==1){** **                con=0;** **                ansr+=person[i].weight;** **            }else{** **                con=1;** **                ansb+=person[i].weight;** **            }** **        }** **        if(ansb&gt;ansr)** **            printf(“blue\\n”);** **        else if(ansr&gt;ansb)** **            printf(“red\\n”);** **        else   printf(“fair\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 重载小于号,排序 【题目链接】 http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3251.html 【Code】#include &lt;bits/stdc++.h&g","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"第六届ACM山东省赛","slug":"Sdut/第六届ACM山东省赛","count":2,"path":"api/categories/Sdut/第六届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第六届ACM山东省赛","slug":"第六届ACM山东省赛","count":3,"path":"api/tags/第六届ACM山东省赛.json"}]},{"title":"山东省第八届ACM省赛 fireworks","slug":"fireworks","date":"2018-02-18T12:54:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/fireworks.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>迟来的祝福,新年快乐.</p>\n</blockquote>\n<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><blockquote>\n<p>要登录</p>\n</blockquote>\n<p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" title=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html</a></p>\n<h1 id=\"Type-杨辉三角-lt-组合数学-逆元\"><a href=\"#Type-杨辉三角-lt-组合数学-逆元\" class=\"headerlink\" title=\"Type: 杨辉三角&lt;-组合数学,逆元\"></a>Type: 杨辉三角&lt;-组合数学,逆元</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>假设x位置有一个烟花,则每秒烟花都会分裂到x+1与x-1这两个位置. 给你n个烟花的初始位置xi和个数ci,问你T秒后,位置w上的烟花个数有多少个.</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>画一下样例的图会发现很像杨辉三角,我们可以将每个初始点分开计算,最后的结果就是所有初始点分裂后落在目标点的烟花个数和. 但我们发现它们的初始值大小与杨辉三角不同,并且比杨辉三角多了许多0, 然后我们考虑如何解决这两个情况.</p>\n<blockquote>\n<p>(1) 初始值ci,因为只有一个初始点,这点和杨辉三角一样.所以答案是</p>\n<blockquote>\n<p>ans(原杨辉三角在该位置的结果)*ci</p>\n</blockquote>\n<p>(2) 中间有0,这点好想,我们只需要通过推导公式将实际坐标转换为逻辑坐标即可.</p>\n</blockquote>\n<p>然后我们分情况讨论,我们在图上可以发现</p>\n<blockquote>\n<p>(1) 当 <code>分裂次数</code> 与 <code>目标位置和原位置的距离差</code> 同奇偶时该位置结果为0. (2) 当距离大于T+1时(即杨辉三角第T行值的个数),永远不可能分裂到.</p>\n</blockquote>\n<p>因为只需要考虑最后一次分裂的结果,所以只需要计算杨辉三角第T行即可,即 C(T,0<del>T) 预处理组合公式我们用 <code>组合数学</code> 性质4那个公式. 所以我们需要预处理一下1</del>1e5的逆元,将除法转换为乘法. 最后答案就是</p>\n<blockquote>\n<p>ans=Sigma(i=1~n,c*C[实际位置] | 根据情况忽略i)</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int MOD = 1e9+7;\nconst int maxn = 1e5+7;\n\nLL C[maxn];\n///逆元\nLL inv[maxn];\nvoid init_(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(MOD-MOD/i)*1ll*inv[MOD%i]%MOD;\n    }\n}\n\n///快速幂模求逆元,调动方式quick_mod(i,MOD-2)\n//这里我们用预处理.\nLL quick_mod(LL x, int n){\n    LL ret = 1;\n    while(n){\n        if(n &amp; 1) ret = ret * x % MOD;\n        x = x * x %MOD;\n        n &gt;&gt;= 1;\n    }\n    return ret;\n}\n\nvoid init(int t){\n    C[0]=1;\n    for(int i=1;i&lt;=t;++i){\n        C[i]=C[i-1]*(t-i+1)*1ll%MOD*inv[i]%MOD;\n        //printf(&quot;Num: %d %lld, INV: %lld\\n&quot;,i,C[i],inv[i]);\n    }\n}\n//判断是否同奇同偶\nbool same(int x,int y){\n    if((x&amp;1)^(y&amp;1)) return false;\n    return true;\n}\n\nint query(int t,int d){\n    if(t&amp;1){\n        return t/2-d/2;\n    }\n    return t/2+(d-1)/2;\n}\n\nint main(){\n    init_();\n    int n,T,w;\n    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;T,&amp;w)){\n        init(T);\n        LL ans=0;\n        for(int i=1;i&lt;=n;++i){\n            int x,c;\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;c);\n            int dist=abs(x-w);\n            if(!same(T+1,dist) &amp;&amp; dist&lt;T+1){\n                ans=(ans+c*C[query(T+1,dist)]%MOD)%MOD;\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n\n    return 0;\n}</code></pre>","text":"迟来的祝福,新年快乐.Link要登录http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.htmlType: 杨辉三角&lt;-组合数学,逆元题意假设x位置有一个烟花,则每秒","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"二项式定理","slug":"Sdut/二项式定理","count":1,"path":"api/categories/Sdut/二项式定理.json"},{"name":"数论","slug":"Sdut/二项式定理/数论","count":1,"path":"api/categories/Sdut/二项式定理/数论.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛.json"},{"name":"组合数学","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"第七届山东省ACM/ICPC K Reversed Words","slug":"qjsdaikacmicpc-k-reversed-words","date":"2017-04-18T12:52:16.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/qjsdaikacmicpc-k-reversed-words.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>我太菜辣,没有1A  ……F</strong>k** <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>char str[10000];</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d\\n”,&amp;T);** **    while(T–){** **        int star=-1;** **        gets(str);** **        int len=strlen(str);** **        for(int i=0;i&lt;len+1;++i){** **            if(str[i]==’ ‘ || str[i]==’\\0’ || str[i]==’\\n’){** **                for(int j=i-1;j&gt;star;–j)** **                    putchar(str[j]);** **                star=i;** **                if(str[i]==’ ‘)putchar(str[i]);** **            }** **        }** **        putchar(‘\\n’);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 我太菜辣,没有1A  ……Fk** 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; char str[10000]; int main(){ **    int T;** **    scanf(“%d","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/第七届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"第七届山东省ACM/ICPC  F  Feed the monkey","slug":"shandongacmacmicpc-f-feed-the-monkey","date":"2017-04-18T08:49:52.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/shandongacmacmicpc-f-feed-the-monkey.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>DP</strong> <strong>【题目链接】</strong> <strong><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565</a></strong> <strong>【题解】</strong> <strong>用dp[i][j][k][t]表示剩余i个第一种物品,j个第二种物品,k个第三种物品.以第t种物品为结尾的安排饲养表的种数.</strong> <strong>递归的思想来合并所有的情况,不过是减了所有的重复枝.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>const ll mod=1000000007;</strong> <strong>const int maxn=55;</strong> <strong>ll dp[maxn][maxn][maxn][4];</strong> <strong>int N1,N2,N3,D1,D2,D3,T;</strong> <strong>int main(){</strong> **    while(~SI(T)){** **        while(T–){** **            cle(dp,0);** **            SIII(N1,N2,N3);** **            SIII(D1,D2,D3);** **            red(i,N1,0) red(j,N2,0) red(k,N3,0){** **                rez(s,1,min(i,D1)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i-s][j][k][0]=(dp[i-s][j][k][0]+1)%mod;** **                    else** **                        dp[i-s][j][k][0]=((dp[i-s][j][k][0]+dp[i][j][k][1])%mod+dp[i][j][k][2])%mod;** **                }** **                rez(s,1,min(j,D2)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i][j-s][k][1]=(dp[i][j-s][k][1]+1)%mod;** **                    else** **                        dp[i][j-s][k][1]=((dp[i][j-s][k][1]+dp[i][j][k][0])%mod+dp[i][j][k][2])%mod;** **                }** **                rez(s,1,min(k,D3)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i][j][k-s][2]=(dp[i][j][k-s][2]+1)%mod;** **                    else** **                        dp[i][j][k-s][2]=((dp[i][j][k-s][2]+dp[i][j][k][0])%mod+dp[i][j][k][1])%mod;** **                }** **            }** **            ll ans=0;** **            ans=((dp[0][0][0][0]+dp[0][0][0][1])%mod+dp[0][0][0][2])%mod;** **            printf(“%lld\\n”,ans);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 DP 【题目链接】 http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565 【题解】 用dp[i][j][k][t]表示剩余i个第一种物品,j","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"动态规划","slug":"Sdut/动态规划","count":2,"path":"api/categories/Sdut/动态规划.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/动态规划/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/动态规划/第七届ACM山东省赛.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"山东省第一届省赛","slug":"1stshandongacm","date":"2018-02-25T14:00:45.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/1stshandongacm.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"A-可水可Trie-Trie解法\"><a href=\"#A-可水可Trie-Trie解法\" class=\"headerlink\" title=\"A: 可水可Trie,Trie解法\"></a>A: 可水可Trie,Trie解法</h1><blockquote>\n<p>数据不大,因为题目没有给出字符串的大小,害怕暴力超时,所以用Trie写的.</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int CHARSET=10,BASE=&apos;0&apos;,MAX_NODE=10100;\nstruct Trie{\n    int tot,root,child[MAX_NODE][CHARSET];\n    bool flag[MAX_NODE];\n    bool has_prefix;\n    bool is_root[MAX_NODE][CHARSET];\n    Trie(){\n        //printf(&quot;New Trie\\n&quot;);\n        memset(child[1],0,sizeof(child[1]));\n        memset(is_root,false,sizeof(is_root));\n        flag[1]=false;\n        has_prefix=false;\n        root=tot=1;\n    }\n    void insert(const char *str){\n        int *cur=&amp;root;\n        char last_char;\n        for(const char *p=str;*p;++p){\n            cur=&amp;child[*cur][*p-BASE];\n            last_char=*p;\n            if(is_root[*cur][last_char])has_prefix=true;\n            if(*cur==0){\n                *cur=++tot;\n                memset(child[tot],0,sizeof(child[tot]));\n                flag[tot]=false;\n            }\n        }\n        flag[*cur]=true;\n        is_root[*cur][last_char]=true;\n    }\n\n};\nint main(){\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        Trie te;\n        char str[10000];\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            if(!te.has_prefix){\n                te.insert(str);\n            }\n        }\n        if(te.has_prefix){\n            printf(&quot;NO\\n&quot;);\n        }else{\n            printf(&quot;YES\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre><h1 id=\"B-思路比较清晰-就是写的时间长-我写了两份代码\"><a href=\"#B-思路比较清晰-就是写的时间长-我写了两份代码\" class=\"headerlink\" title=\"B:思路比较清晰,就是写的时间长,我写了两份代码\"></a>B:思路比较清晰,就是写的时间长,我写了两份代码</h1><h2 id=\"单树-map-套结构体Point重载-lt-二分-内存小-时间长\"><a href=\"#单树-map-套结构体Point重载-lt-二分-内存小-时间长\" class=\"headerlink\" title=\"单树(map)套结构体Point重载&lt;+二分: 内存小,时间长\"></a>单树(map)套结构体Point重载&lt;+二分: 内存小,时间长</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\nstruct Point{\n    int x,y;\n    bool operator &lt; (const Point&amp; a)const{\n        if(x&lt;a.x) return true;\n        else if(x==a.x &amp;&amp; y&lt;a.y) return true;\n        return false;\n    }\n    bool operator == (const Point&amp; a)const{\n        if(x==a.x &amp;&amp; y==a.y) return true;\n        return false;\n    }\n\n};\nint N,kase=1;\n\nint xx,yy;\nchar opt[10];\n\nmap&lt;Point,bool&gt; G;//x点集0,true为未删除,false为删除\nmap&lt;Point,bool&gt;::iterator it;\n\nvoid init(){\n    G.clear();\n}\n\nbool cmp(Point a,Point b){\n    if(a.x&lt;b.x &amp;&amp; a.y&lt;b.y)\n        return true;\n    return false;\n}\n\nvoid add(){\n    G[(Point){xx,yy}]=true;\n}\n\nvoid find_(int a,int b){\n    it=G.upper_bound((Point){a,b});\n    if(it==G.end()){\n        printf(&quot;-1\\n&quot;);\n        return;\n    }\n    Point nw=it-&gt;first;\n    if(it-&gt;second &amp;&amp; nw.x&gt;xx &amp;&amp; nw.y&gt;yy){\n        printf(&quot;%d %d\\n&quot;,nw.x,nw.y);\n    }else{\n        do{\n            it++;\n            if(it==G.end()){printf(&quot;-1\\n&quot;);return;}\n            if(it-&gt;second &amp;&amp; (it-&gt;first).x&gt;xx &amp;&amp; (it-&gt;first).y&gt;yy){\n                printf(&quot;%d %d\\n&quot;,(it-&gt;first).x, (it-&gt;first).y);\n                return;\n            }\n        }while(1);\n    }\n}\n\nvoid remove_(){\n    G[(Point){xx,yy}]=false;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s %d %d&quot;,opt,&amp;xx,&amp;yy);\n            if(opt[0]==&apos;a&apos;){\n                add();\n            }else if(opt[0]==&apos;f&apos;){\n                find_(xx,yy);\n            }else{\n                remove_();\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 904ms\nTake Memory: 5752KB\nSubmit time: 2018-02-27 17:08:24\n****************************************************/</code></pre><h2 id=\"树-map-二分套树-map-二分-代码少-时间短-内存大\"><a href=\"#树-map-二分套树-map-二分-代码少-时间短-内存大\" class=\"headerlink\" title=\"树(map)+二分套树(map)+二分,代码少,时间短,内存大\"></a>树(map)+二分套树(map)+二分,代码少,时间短,内存大</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\n\nint N,kase=1;\n\nint xx,yy;\nchar opt[10];\n\nmap&lt;int,map&lt;int,bool&gt; &gt; G;//x点集0,true为未删除,false为删除\nmap&lt;int,bool&gt;::iterator ity;\nmap&lt;int,map&lt;int,bool&gt; &gt;::iterator itx;\n\nvoid init(){\n    G.clear();\n}\n\nvoid add(){\n    (G[xx])[yy]=true;\n}\n\nvoid find_(){\n    itx=G.upper_bound(xx);\n    while(1){\n        if(itx!=G.end()){\n            ity=(itx-&gt;second).upper_bound(yy);\n            if(ity!=(itx-&gt;second).end() &amp;&amp; ity-&gt;second){\n                printf(&quot;%d %d\\n&quot;,itx-&gt;first,ity-&gt;first);\n                return;\n            }\n            if(ity!=(itx-&gt;second).end()){\n                for(ity++;ity!=(itx-&gt;second).end();ity++){\n                    if(ity-&gt;second){\n                        printf(&quot;%d %d\\n&quot;,itx-&gt;first,ity-&gt;first);\n                        return;\n                    }\n                }\n            }\n        }else break;\n        itx++;\n    }\n    printf(&quot;-1\\n&quot;);\n}\n\nvoid remove_(){\n    (G[xx])[yy]=false;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s %d %d&quot;,opt,&amp;xx,&amp;yy);\n            if(opt[0]==&apos;a&apos;){\n                add();\n            }else if(opt[0]==&apos;f&apos;){\n                find_();\n            }else{\n                remove_();\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 516ms\nTake Memory: 12712KB\nSubmit time: 2018-02-27 17:24:44\n****************************************************/</code></pre><h2 id=\"然后我百度一下原题-发现set直接删除就好…还是STL不太熟-内存小-用时也少-不过没第二份少\"><a href=\"#然后我百度一下原题-发现set直接删除就好…还是STL不太熟-内存小-用时也少-不过没第二份少\" class=\"headerlink\" title=\"然后我百度一下原题,发现set直接删除就好…还是STL不太熟,内存小,用时也少,不过没第二份少\"></a>然后我百度一下原题,发现set直接删除就好…还是STL不太熟,内存小,用时也少,不过没第二份少</h2><pre><code>#include &lt;iostream&gt;  \n#include &lt;stdio.h&gt;  \n#include &lt;algorithm&gt;  \n#include &lt;set&gt;  \n#include &lt;string&gt;  \nusing namespace std;  \n\nint main()  \n{  \n    pair&lt;int,int&gt;p;  \n    int n;char str[10];  \n    int c=1;  \n    while(cin&gt;&gt;n&amp;&amp;n)  \n    {  \n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;:&quot;&lt;&lt;endl;  \n        set&lt; pair&lt;int,int&gt; &gt;s;  \n        while(n--)  \n        {  \n            scanf(&quot;%s&quot;,str);  \n            scanf(&quot;%d%d&quot;,&amp;p.first,&amp;p.second);  \n            if(str[0]==&apos;a&apos;)  \n                s.insert(p);  \n            else if(str[0]==&apos;r&apos;)  \n                s.erase(p);  \n            else if(str[0]==&apos;f&apos;)  \n            {  \n                set&lt; pair&lt;int,int&gt; &gt;::iterator it;  \n                it=s.lower_bound(p);//找到set中第一个比p大的元素的位置，找不到则为s.end()  \n                for(;it!=s.end();it++)  \n                {  \n                    if(it-&gt;first&gt;p.first&amp;&amp;it-&gt;second&gt;p.second)//都大于才符合题意  \n                    {  \n                        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;  \n                        break;  \n                    }  \n                }  \n                if(it==s.end())//找不到  \n                    cout&lt;&lt;-1&lt;&lt;endl;  \n            }  \n        }  \n        cout&lt;&lt;endl;  \n    }  \n    return 0;  \n}  </code></pre><h2 id=\"貌似还可以用线段树优化\"><a href=\"#貌似还可以用线段树优化\" class=\"headerlink\" title=\"貌似还可以用线段树优化..\"></a>貌似还可以用线段树优化..</h2><h3 id=\"F-k\"><a href=\"#F-k\" class=\"headerlink\" title=\"F**k\"></a>F**k</h3><h1 id=\"C-排序水过-别问我为啥写的那么麻烦…因为我半截才想到-懒得改了\"><a href=\"#C-排序水过-别问我为啥写的那么麻烦…因为我半截才想到-懒得改了\" class=\"headerlink\" title=\"C:排序水过,别问我为啥写的那么麻烦…因为我半截才想到,懒得改了\"></a>C:排序水过,别问我为啥写的那么麻烦…因为我半截才想到,懒得改了</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\nstruct Query{\n    int s,t;\n};\nint N,kase=1;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; G[maxn];\n        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; it;\n        vector&lt;Query&gt; Q;\n        for(int i=1;i&lt;=N;++i){\n            int s,t;\n            scanf(&quot;%d%d&quot;,&amp;s,&amp;t);\n            G[s].push(t);\n            Q.push_back((Query){s,t});\n        }\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;Q.size();++i){\n            int s=Q[i].s,t=Q[i].t;\n            bool has_ans=false;\n            for(int j=s+1;j&lt;=309 &amp;&amp; !has_ans;++j){\n                it=G[j];\n                while(!it.empty()){\n                    int nw=it.top();it.pop();\n                    if(nw&gt;t){\n                        has_ans=true;\n                        printf(&quot;%d %d\\n&quot;,j,nw);\n                        break;\n                    }\n                }\n            }\n            if(!has_ans){\n                printf(&quot;-1 -1\\n&quot;);\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><h1 id=\"D-中途相遇法-负值二分\"><a href=\"#D-中途相遇法-负值二分\" class=\"headerlink\" title=\"D:中途相遇法+负值二分\"></a>D:中途相遇法+负值二分</h1><blockquote>\n<p>因为内置的lower_bound只能查找第一个大于等于的,而我们需要的是小于等于的,所以将所有的值变成负数插入到vector中即可. 这道题N^4肯定是不可行的.所以我们考虑用中途相遇法,</p>\n<blockquote>\n<p>即先处理出任意两个值的和,然后遍历和数组,在原数组中查找是否存在一个值和当前和相加&lt;=M,如果等于M,break即可.</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2000;\nint N,M,KASE=1;\nint arr[maxn];\nvector&lt;int&gt; first;\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M) &amp;&amp; N+M){\n        first.clear();\n        int ans=0;\n        for(int i=0;i&lt;N;++i) scanf(&quot;%d&quot;,&amp;arr[i]);\n        for(int i=0;i&lt;N;++i){\n            for(int j=i;j&lt;N;++j){\n                first.push_back(-(arr[i]+arr[j]));\n            }\n        }\n        sort(first.begin(),first.end());\n        for(int i=0;i&lt;first.size();++i){\n            int need=M+first[i];\n            if(need&lt;=0) continue;\n            else{\n                int id=lower_bound(first.begin(),first.end(),-need)-first.begin();\n                int nw=-(first[i]+first[id]);\n                if(nw&lt;=M) ans=max(ans,nw);\n            }\n            if(ans==M)break;\n        }\n        printf(&quot;Case %d: %d\\n\\n&quot;,KASE++,ans);\n    }\n    return 0;\n}</code></pre><h1 id=\"G-排序水过\"><a href=\"#G-排序水过\" class=\"headerlink\" title=\"G:排序水过\"></a>G:排序水过</h1><blockquote>\n<p>一开始没读懂题意时最难受的</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100100;\nint Dist[maxn],N;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;Dist[i]);\n        }\n        sort(Dist,Dist+N);\n        LL ans=0ll;\n        for(int i=1;i&lt;N;++i){\n            ans+=((Dist[i]-Dist[i-1])&lt;&lt;1);\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><h1 id=\"I-分别进行两个dfs即可-四方向和八方向\"><a href=\"#I-分别进行两个dfs即可-四方向和八方向\" class=\"headerlink\" title=\"I:分别进行两个dfs即可,四方向和八方向\"></a>I:分别进行两个dfs即可,四方向和八方向</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint move1[4][2]={ {0,-1},{0,1},{-1,0},{1,0}};\nint move2[8][2]={ {0,-1},{0,1},{-1,0},{1,0},\n                 {1,-1},{1,1},{-1,-1},{-1,1}};\nchar mp[110][110];\nint N,kase=1;\nint vis1[110][110],vis2[110][110];\n\nvoid init(){\n    memset(vis1,0,sizeof(vis1));\n    memset(vis2,0,sizeof(vis2));\n}\n\nbool check(int x,int y){\n    if(x&gt;=N || y&gt;=N || x&lt;0 || y&lt;0 || mp[x][y]==&apos;0&apos;)\n        return false;\n    return true;\n}\n\nvoid dfs4(int x,int y){\n    if(!check(x,y) || vis1[x][y]) return;\n    vis1[x][y]=1;\n    for(int i=0;i&lt;4;++i){\n        int nx=x+move1[i][0],ny=y+move1[i][1];\n        dfs4(nx,ny);\n    }\n}\n\nvoid dfs8(int x,int y){\n    if(!check(x,y) || vis2[x][y]) return;\n    vis2[x][y]=1;\n    for(int i=0;i&lt;8;++i){\n        int nx=x+move2[i][0],ny=y+move2[i][1];\n        dfs8(nx,ny);\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,mp[i]);\n        }\n        int ans4=0,ans8=0;\n        for(int i=0;i&lt;N;++i){\n            for(int j=0;j&lt;N;++j){\n                if(mp[i][j]==&apos;1&apos; &amp;&amp; !vis1[i][j]){\n                    ans4++,dfs4(i,j);\n                }\n                if(mp[i][j]==&apos;1&apos; &amp;&amp; !vis2[i][j]){\n                    ans8++,dfs8(i,j);\n                }\n            }\n        }\n        printf(&quot;Case %d: %d %d\\n\\n&quot;,kase++,ans4,ans8);\n    }\n    return 0;\n}</code></pre><h1 id=\"E-大模拟\"><a href=\"#E-大模拟\" class=\"headerlink\" title=\"E:大模拟\"></a>E:大模拟</h1><p>大模拟</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long LL;\nconst int maxn=35;\nint N,kase=1;\nchar mp[maxn][maxn];\nint vis[maxn][maxn][maxn][maxn][5];\n///EWSN东西南北\nint dis[4][2]={ {0,1},{0,-1},{1,0},{-1,0}};\n///saya更喜欢EWNS\nint nt[4][2]={ {0,1},{0,-1},{-1,0},{1,0}};\n\nbool check(int x,int y){\n    if(x&lt;0||y&lt;0||x&gt;=N||y&gt;=N)return false;\n    return true;\n}\n///返回当前的朝向在,数组为dis\nint now_dir(int x,int y,int t){\n    char str=mp[x][y];\n    int in=0;\n    if(str==&apos;E&apos;) in=0;\n    else if(str==&apos;W&apos;) in=1;\n    else if(str==&apos;S&apos;) in=2;\n    else in=3;\n    in+=t;\n    return in%4;\n}\n\nint dist(int x,int y,int tx,int ty){\n    return (x-tx)*(x-tx)+(y-ty)*(y-ty);\n}\n\nint query_dir(int x,int y,int tx,int ty){\n    int mind=INF,dir_=-1;\n    for(int i=0;i&lt;4;++i){\n        int xx=x+nt[i][0],yy=y+nt[i][1];\n        if(!check(xx,yy)) continue;\n        int d=dist(xx,yy,tx,ty);\n        if(mind&gt;d){\n            mind=d;\n            dir_=i;\n        }\n    }\n    ///返回第一个想走的方向\n    return dir_;\n}\n\nint main(){\n    while(scanf(&quot;%d&quot;,&amp;N)!=EOF &amp;&amp; N!=0){\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,&amp;mp[i]);\n        }\n        int x=0,y=0,tx=N-1,ty=N-1,step=0;\n        int xx,yy,txx,tyy;\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        while(1){\n            if(step&gt;=100){\n                printf(&quot;Not sure.\\n&quot;);\n                break;\n            }\n            if(tx==x&amp;&amp;ty==y){\n                printf(&quot;Get the treasure! At step %d.\\n&quot;,step);\n                break;\n            }\n            ///saya第一步\n            int saya=now_dir(x,y,step);\n            xx=x+dis[saya][0],yy=y+dis[saya][1];\n            if(check(xx,yy)){\n                x=xx,y=yy;\n            }\n            ///saya第二步\n            if(!(x==tx&amp;&amp;y==ty)){\n                int goal=query_dir(x,y,tx,ty);\n                xx=x+nt[goal][0],yy=y+nt[goal][1];\n                if(check(xx,yy)){\n                    x=xx,y=yy;\n                }\n            }\n            ///宝藏走\n            int tres=now_dir(tx,ty,step);\n            txx=tx+dis[tres][0],tyy=ty+dis[tres][1];\n            if(check(txx,tyy)){\n                tx=txx,ty=tyy;\n            }\n\n            if(vis[x][y][tx][ty][step%4]){\n                printf(&quot;Impossible. At step %d.\\n&quot;,step);\n                break;\n            }else{\n                vis[x][y][tx][ty][step%4]=1;\n            }\n            step+=1;\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"A: 可水可Trie,Trie解法数据不大,因为题目没有给出字符串的大小,害怕暴力超时,所以用Trie写的.#include&lt;bits/stdc++.h&gt;using namespace std;const int CHARSET=10,BASE=&apos;0&apo","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"STL","slug":"Sdut/STL","count":2,"path":"api/categories/Sdut/STL.json"},{"name":"Trie","slug":"Sdut/STL/Trie","count":1,"path":"api/categories/Sdut/STL/Trie.json"},{"name":"中途相遇法","slug":"Sdut/STL/Trie/中途相遇法","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法.json"},{"name":"二分搜索","slug":"Sdut/STL/Trie/中途相遇法/二分搜索","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索.json"},{"name":"数据结构","slug":"Sdut/STL/Trie/中途相遇法/二分搜索/数据结构","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索/数据结构.json"},{"name":"第一届ACM山东省塞","slug":"Sdut/STL/Trie/中途相遇法/二分搜索/数据结构/第一届ACM山东省塞","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索/数据结构/第一届ACM山东省塞.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"中途相遇法","slug":"中途相遇法","count":2,"path":"api/tags/中途相遇法.json"},{"name":"Trie","slug":"Trie","count":1,"path":"api/tags/Trie.json"},{"name":"第一届ACM山东省塞","slug":"第一届ACM山东省塞","count":1,"path":"api/tags/第一届ACM山东省塞.json"}]},{"title":"第七届山东省ACM/ICPC H Memory Leak","slug":"qjsdaihacmicpc-h-memory-leak","date":"2017-04-18T12:25:42.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/qjsdaihacmicpc-h-memory-leak.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>模拟,感受一下什么叫绝望吧…</strong> <strong>【Tip】</strong> <strong>F</strong>k!…..QNMD鲁棒性….QAQ** <strong>后记…发现自己的代码可以过…但是忘了关freopean..所以才WA…尴尬//= // =//</strong> <strong>【Code】</strong> <strong>鲁棒形比我好,一点的,代码.</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int T;</strong> <strong>char name[10010],stri[10010];</strong> <strong>int num;</strong> <strong>struct Star{</strong> **    char s[2000];** **    char contain[10010];** **    int ind;** **    bool has_end;** <strong>};</strong> <strong>Star S[10010];</strong> <strong>int main(){</strong> ** //   #ifndef DEF** ** //    freopen(“in.txt”,”r”,stdin);** ** //    freopen(“out.txt”,”w”,stdout);** ** //  #endif // DEF** **    scanf(“%d”,&amp;T);** **        while(T–){** **            char op[100],def[10100];** **            num=0;** **            while(scanf(“%s”,op)){** **                if(op[3]==’u’){** **                    scanf(“%<em>s”);*</em> **                    break;** **                }** **                if(op[3]==’r’){** **                    while(scanf(“%s”,def)){** **                        int flag=1,star_num=0,ind_num=0,len=strlen(def);** **                        for(int i=0;i&lt;len;++i){** **                            if(flag==1 &amp;&amp; def[i]!=’[‘){** **                                S[num].s[star_num++]=def[i];** **                            }** **                            if(def[i]==’[‘){** **                                S[num].s[star_num]=0;** **                                flag=2;** **                                continue;** **                            }** **                            if(flag==2 &amp;&amp; def[i]!=’]‘){** **                                ind_num=ind_num<em>10+(def[i]-‘0’);*</em> **                            }** **                            if(def[i]==’]‘){** **                                S[num].contain[0]=0;//初始化** **                                S[num].has_end=true;** **                                S[num].ind=ind_num;** **                                star_num=0;** **                                ind_num=0;** **                                num++;** **                                continue;** **                            }** **                        }** **                        if(def[len-1]==’;’) break;** **                    }** **                }** **                if(op[3]==’s’){** **                    scanf(“%s%<em>c”,name);*</em> **                    gets(stri);** **                    int index=num;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    int len=strlen(stri);** **                    if(len&gt;=S[index].ind){** **                        S[index].has_end=false;** **                        stri[S[index].ind]=0;//‘\\0’** **                    }else S[index].has_end=true;** **                    strcpy(S[index].contain,stri);** **                }** **                if(op[3]==’t’){** **                    scanf(“%s”,name);** **                    int index=num;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    for(int i=index;i&lt;num;++i){** **                        printf(“%s”,S[i].contain);** **                        if(S[i].has_end) break;** **                    }** **                    printf(“\\n”);** **                }** **            }** **        }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>我的代码</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int T;</strong> <strong>char name[10010],stri[10010];</strong> <strong>int num=0;</strong> <strong>struct Star{</strong> **    char s[2000];** **    char contain[10010];** **    int ind;** **    bool has_end;** <strong>};</strong> <strong>Star S[10010];</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF  //&lt;-F</strong>k U** **  //   freopen(“in.txt”,”r”,stdin);** **  //   freopen(“out.txt”,”w”,stdout);** ** //  #endif // DEF** **    scanf(“%d”,&amp;T);** **        while(T–){** **            char op[10],def[10100];** **            num=0;** **            while(scanf(“%s”,op)){** **                scanf(“ “);** **                if(op[3]==’u’){** **                    scanf(“%<em>s”);*</em> **                    break;** **                }** **                if(op[3]==’r’){** **                    int flag=1,star_num=0,ind_num=0;** **                    gets(def);** **                    for(int i=0,start=0;def[i]!=’\\0’;++i){** **                        if(def[i]==’ ‘ || def[i]==’,’) continue;** **                        if(flag==1 &amp;&amp; def[i]!=’[‘){** **                            S[num].s[star_num++]=def[i];** **                        }else if(def[i]==’[‘){** **                            S[num].s[star_num]=0;** **                            flag=2;** **                        }else if(flag==2 &amp;&amp; def[i]!=’]‘){** **                            ind_num=ind_num<em>10+(def[i]-‘0’);*</em> **                        }else if(def[i]==’]‘){** **                            S[num].contain[0]=0;//初始化** **                            S[num].has_end=true;** **                            S[num].ind=ind_num;** **                            star_num=0;** **                            ind_num=0;** **                            num++;** **                            flag=1;** **                        }else if(def[i]==’;’)** **                            break;** **                    }** **                }** **                if(op[3]==’s’){** **                    scanf(“%s%<em>c”,name);*</em> **                    gets(stri);** **                    int index;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    int len=strlen(stri);** **                    if(len&gt;=S[index].ind){** **                        S[index].has_end=false;** **                        stri[S[index].ind]=0;//‘\\0’** **                    }else S[index].has_end=true;** **                    strcpy(S[index].contain,stri);** **                }** **                if(op[3]==’t’){** **                    scanf(“ “);** **                    gets(name);** **                    int index;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    for(int i=index;i&lt;num;++i){** **                        printf(“%s”,S[i].contain);** **                        if(S[i].has_end) break;** **                    }** **                    printf(“\\n”);** **                }** **            }** **        }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 模拟,感受一下什么叫绝望吧… 【Tip】 Fk!…..QNMD鲁棒性….QAQ** 后记…发现自己的代码可以过…但是忘了关freopean..所以才WA…尴尬//= // =// 【Code】 鲁棒形比我好,一点的,代码.#include&lt;bits/stdc++.","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"模拟","slug":"Sdut/模拟","count":1,"path":"api/categories/Sdut/模拟.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/模拟/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/模拟/第七届ACM山东省赛.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]}]}