{"name":"Python","slug":"Python","count":41,"postlist":[{"title":"股票数据定向爬虫","slug":"gupiaodingxiangpachong","date":"2017-09-07T12:05:07.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/gupiaodingxiangpachong.json","excerpt":"","keywords":null,"cover":null,"content":"<p>累了…直接撩代码</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport traceback\nimport re\n\ndef getHTMLText(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef getStockList(lst,stockURL):\n    html=getHTMLText(stockURL)\n    soup=BeautifulSoup(html,&apos;html.parser&apos;)\n    a=soup.find_all(&apos;a&apos;)\n    for i in a:\n        try:\n            href=i.attrs[&apos;href&apos;]\n            lst.append(re.findall(r&apos;[s][hz]\\d{6}&apos;,href)[0])\n        except:\n            continue\n\ndef getStockInfo(lst,stockURL,fpath):\n    for stock in lst:\n        url=stockURL+stock+&quot;.html&quot;\n        html=getHTMLText(url)\n        try:\n            if html==&quot;&quot;:\n                continue\n            infoDict={}\n            soup=BeautifulSoup(html,&apos;html.parser&apos;)\n            stockInfo=soup.find(&apos;div&apos;,attrs={&apos;class&apos;:&apos;stock-bets&apos;})\n\n            name=stockInfo.find_all(attrs={&apos;class&apos;:&apos;bets-name&apos;})[0]\n            infoDict.update({&apos;股票名称&apos;:name.text.split()[0]})\n            keyList=stockInfo.find_all(&apos;dt&apos;)\n            valueList=stockInfo.find_all(&apos;dd&apos;)\n            for i in range(len(keyList)):\n                key=keyList[i].text\n                val=valueList[i].text\n                infoDict[key]=val\n\n            with open(fpath,&apos;a&apos;,encoding=&apos;utf-8&apos;) as f:\n                f.write(str(infoDict)+&apos;\\n&apos;)\n        except:\n            traceback.print_exc()\n            continue\n\nif __name__==&apos;__main__&apos;:\n    stock_list_url = &apos;http://quote.eastmoney.com/stocklist.html&apos;\n    stock_info_url = &apos;https://gupiao.baidu.com/stock/&apos;\n    output_file = &apos;E:\\学习相关\\廖雪峰\\python_study\\库\\第三章\\BaiduStockInfo.txt&apos;\n    slist=[]\n    getStockList(slist,stock_list_url)\n    getStockInfo(slist,stock_info_url,output_file)</code></pre><p>结果(超慢的得得得多多多多多多多,还没爬完…不过应该是解析全文默认编码的问题): 2017-09-07 20:08:30 星期四 :earth_asia:<a href=\"https://github.com/834930269/python_study/blob/master/%E5%BA%93/%E7%AC%AC%E4%B8%89%E7%AB%A0/BaiduStockInfo.txt\" title=\"github: 爬取结果.txt\" target=\"_blank\" rel=\"noopener\">github: 爬取结果.txt</a></p>\n","text":"累了…直接撩代码import requestsfrom bs4 import BeautifulSoupimport tracebackimport redef getHTMLText(url):    try:        r=requests.get(url)       ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"},{"name":"爬虫","slug":"Python/未分类/爬虫","count":2,"path":"api/categories/Python/未分类/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"Python 爬虫 BeautifulSoup库基本操作","slug":"python-beautifulsoup","date":"2017-08-30T03:53:22.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/python-beautifulsoup.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Code:</p>\n<pre><code>import requests\nr=requests.get(&apos;http://python123.io/ws/demo.html&apos;)\n#print(r.text)\ndemo=r.text\nfrom bs4 import BeautifulSoup#后面的是类\nsoup=BeautifulSoup(demo,&apos;html.parser&apos;)#第一个参宿是信息,解释器html.parse\n#print(soup.prettify())\n1#BeautifulSoup库是解析、遍历、维护、&quot;标签树&quot;的功能库.\n#名称 Name 属性 Attributes\n#四种解释器\n&apos;&apos;&apos;\n1.html.parse\n2.lxml\n3.xml\n4.html5lib\n&apos;&apos;&apos;\n#元素\n&apos;&apos;&apos;\n1.Tag 标签&lt;&gt;\n2.Name 标签的名字&lt;p&gt;=p\n3.Attributes 标签的属性 字典形式组织,格式 &lt;tag&gt;.Attributes\n4.NavigableString 标签内费属性字符串 &lt;p&gt;...(中间这部分)...&lt;/p&gt;格式&lt;tag&gt;.string\n5.Comment 标签内字符串注释部分 一种特殊的Commnet类型\n&apos;&apos;&apos;\nprint(soup.title)\nprint(soup.a.name)\nprint(soup.a.parent.parent.name)#父亲的父亲\nprint(soup.a.attrs)\nprint(soup.a.attrs[&apos;class&apos;],type(soup.a.attrs))\nprint(soup.a.string),print(soup.p.string)\n&apos;&apos;&apos;\n标签树的下行遍历\n.contents 子节点的列表,将&lt;tag&gt;所有儿子节点存入列表\n.children 子节点的迭代类型,与.contents类似,用于循环遍历儿子节点\n.descendants 子孙节点的迭代类型,包含所有子孙节点,用于循环遍历\n&apos;&apos;&apos;\nprint(soup.head)\nprint(soup.head.contents)\nprint(soup.body.contents,&apos;\\n&apos;),print(&apos;len: &apos;,len(soup.body.contents))\n&apos;&apos;&apos;\n上行遍历\n.parent 节点的父亲标签\n.parents 返回节点的先辈标签\n&apos;&apos;&apos;\nfor parent in soup.a.parents:\n    if parent is None:\n        print(parent)\n    else:\n        print(parent.name)\n&apos;&apos;&apos;\n平行遍历\n.next_sibling 返回按照HTML文本顺序的下一个平行节点标签\n.previous_sibling 返回按照HTML文本顺序的上一个平行节点标签\n.next_siblings 迭代类型,返回按照HTML文本顺序的后续所有平行节点标签\n.previous_siblings 迭代类型,返回按照HTML文本顺序的前序所有平行结点标签\n&apos;&apos;&apos;</code></pre>","text":"Code:import requestsr=requests.get(&apos;http://python123.io/ws/demo.html&apos;)#print(r.text)demo=r.textfrom bs4 import BeautifulSoup#后面的是类","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python 爬虫学习记录","slug":"python-buglearning","date":"2017-05-27T05:27:34.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-buglearning.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>代码均上传至github</strong> <strong>【第一节课】</strong> <strong># urllib 的基本用法</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20first/uri.py\" target=\"_blank\" rel=\"noopener\">uri.py</a></strong> <strong>【第二节课】</strong> <strong># urllib 的urlretrieve方法</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20urlretrieve/test.py\" target=\"_blank\" rel=\"noopener\">test.py</a></strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20urlretrieve/test2.py\" target=\"_blank\" rel=\"noopener\">test2.py</a></strong></p>\n","text":"代码均上传至github 【第一节课】 # urllib 的基本用法 uri.py 【第二节课】 # urllib 的urlretrieve方法 test.py test2.py","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python2 处理数据并绘制三维空间图","slug":"python-dwsg","date":"2017-06-01T05:12:37.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-dwsg.json","excerpt":"","keywords":null,"cover":"https://camo.githubusercontent.com/d4a677e900b6208428a00aab9b3d317064708124/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545352542392542332545382541372538362545352539422542452d312e6a7067","content":"<p><strong>【附件一.骑行数据】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/data1.txt\" target=\"_blank\" rel=\"noopener\">data1.txt</a></strong> <strong>【附件二.骑行数据处理】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/Deal-3D.py\" target=\"_blank\" rel=\"noopener\">Deal-3D.py</a></strong> <strong>处理结果:  <a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/in.txt\" target=\"_blank\" rel=\"noopener\">in.txt</a></strong> <strong>【附件三.数据分析,提取出时空分布信息】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/DealData.cpp\" target=\"_blank\" rel=\"noopener\">DealData.cpp</a></strong> <strong>提取结果:  <a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/out2.txt\" target=\"_blank\" rel=\"noopener\">out2.txt</a> (注:每行三个数据,第一个数据是时间区间编号,第二个数据是区域编号,第三个数据是单车数量)</strong> <strong>【将处理数据绘制成三维图】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/3D-Image.py\" target=\"_blank\" rel=\"noopener\">3D-Image.py</a></strong> <strong>【绘制结果三视图】</strong> <strong>正视图:</strong> <strong><img src=\"https://camo.githubusercontent.com/d4a677e900b6208428a00aab9b3d317064708124/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545352542392542332545382541372538362545352539422542452d312e6a7067\" alt></strong>   <strong>侧视图:</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/%E4%BE%A7%E8%A7%86%E5%9B%BE.jpg\" alt></strong>   <strong>俯视图:</strong> <img src=\"https://camo.githubusercontent.com/9427753fa996288ba471a87588531c11a5a7fdc9/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545342542462541462545382541372538362545352539422542452e6a7067\" alt></p>\n","text":"【附件一.骑行数据】 data1.txt 【附件二.骑行数据处理】 Deal-3D.py 处理结果:  in.txt 【附件三.数据分析,提取出时空分布信息】 DealData.cpp 提取结果:  out2.txt (注:每行三个数据,第一个数据是时间区间编号,第二个数据是区域","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python 爬取中国大学排名","slug":"python-chut","date":"2017-08-30T10:19:46.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/python-chut.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/08/17f778160b1fc4d8d2521e6846de2cbe.png","content":"<p>首先是爬取的目的地址: :zap:<a href=\"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html\" title=\"2016中国最好大学排名\" target=\"_blank\" rel=\"noopener\">=&gt;2016中国最好大学排名</a> 这里我们使用的是Python的request库和BeautifulSoup库,IDE用的是Anaconda的Spyder,Python version=3.6. 首先我们现在html中搜索清华大学(废话= =). 结果如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/17f778160b1fc4d8d2521e6846de2cbe.png\" alt=\"结果\"> 我们发现结果是在节点为’tbody’中,全部代码中也只有这一个地方有’tbody’.所以我们可以通过查找这个标签,然后再向下查找孩子来找到结果,但是我们知道,他的孩子可能会出现字符串类型,所以我们需要用isinstance(x,bs4.element.Tag),Tag–(标签)来过滤掉其它类型. 于是我们写出A程序:</p>\n<pre><code>#CrawUnivRankingA.py\nimport requests\nfrom bs4 import BeautifulSoup\nimport bs4\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef fillUnivList(ulist, html):\n    soup = BeautifulSoup(html, &quot;html.parser&quot;)\n    for tr in soup.find(&apos;tbody&apos;).children:\n        if isinstance(tr, bs4.element.Tag):\n            tds = tr(&apos;td&apos;)\n            ulist.append([tds[0].string, tds[1].string, tds[3].string])\n\ndef printUnivList(ulist, num):\n    print(&quot;{:^10}\\t{:^6}\\t{:^10}&quot;.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;))\n    for i in range(num):\n        u=ulist[i]\n        print(&quot;{:^10}\\t{:^6}\\t{:^10}&quot;.format(u[0],u[1],u[2]))\n\ndef main():\n    uinfo = []\n    url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos;\n    html = getHTMLText(url)\n    fillUnivList(uinfo, html)\n    printUnivList(uinfo, 20) # 20 univs\nmain()</code></pre><p>打印结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/807addc82e8f147efd10ff14afadcc03.png\" alt> 可以看出中间的学校缩进不规范,这是因为中文的问题,他是默认按照英文补充空格的. 改进一下,空格用chr(12288)补充:</p>\n<pre><code>#CrawUnivRankingB.py\nimport requests\nfrom bs4 import BeautifulSoup\nimport bs4\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef fillUnivList(ulist, html):\n    soup = BeautifulSoup(html, &quot;html.parser&quot;)\n    for tr in soup.find(&apos;tbody&apos;).children:\n        if isinstance(tr, bs4.element.Tag):\n            tds = tr(&apos;td&apos;)\n            ulist.append([tds[0].string, tds[1].string, tds[3].string])\n\ndef printUnivList(ulist, num):\n    tplt = &quot;{0:^10}\\t{1:{3}^10}\\t{2:^10}&quot;\n    print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;,chr(12288)))\n    for i in range(num):\n        u=ulist[i]\n        print(tplt.format(u[0],u[1],u[2],chr(12288)))\n\ndef main():\n    uinfo = []\n    url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos;\n    html = getHTMLText(url)\n    fillUnivList(uinfo, html)\n    printUnivList(uinfo, 20) # 20 univs\nmain()</code></pre><p>打印结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/a8ee56c437ee19d41e7e53a863779b97.png\" alt> 结束.</p>\n","text":"首先是爬取的目的地址: :zap:=&gt;2016中国最好大学排名 这里我们使用的是Python的request库和BeautifulSoup库,IDE用的是Anaconda的Spyder,Python version=3.6. 首先我们现在html中搜索清华大学(废话= =)","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"爬虫","slug":"Python/爬虫","count":2,"path":"api/categories/Python/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"python站 第一次更新","slug":"python-fb","date":"2017-08-11T06:56:11.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-fb.json","excerpt":"","keywords":null,"cover":null,"content":"<p>link: <a href=\"http://be-sunshine.cn:81/blog/0015024342574655180f051270a4a029c3c1a1ecc95fca0000\" title=\"第一次更新 - Mr.赝\" target=\"_blank\" rel=\"noopener\">第一次更新 - Mr.赝</a> 更新内容: <a href=\"http://be-sunshine.cn:81/signin\" title=\"登录界面优化\" target=\"_blank\" rel=\"noopener\">登录界面优化</a></p>\n","text":"link: 第一次更新 - Mr.赝 更新内容: 登录界面优化","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"}],"tags":[]},{"title":"python os模块+flask实现文件上传","slug":"python-os-flask-upload","date":"2017-10-08T00:28:45.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-os-flask-upload.json","excerpt":"","keywords":null,"cover":null,"content":"<p>首先是os模块选择上传目录: os.path为初始画一个path对象,他可以将路径转换为标准路径.</p>\n<pre><code>os.path.dirname()</code></pre><p>转到相应文件目录</p>\n<pre><code>os.getcwd()</code></pre><p>获取当前目录</p>\n<pre><code>os.path.join(path1,path2,path3...)</code></pre><p>将所有目录组合起来 实现代码如下:</p>\n<pre><code># -*- coding: utf-8 -*-\nimport os\nfrom flask import Flask, request, url_for, send_from_directory\nfrom werkzeug import secure_filename\nimport logging; logging.basicConfig(level=logging.INFO)\n\nALLOWED_EXTENSIONS = set([&apos;png&apos;, &apos;jpg&apos;, &apos;jpeg&apos;, &apos;gif&apos;])\n\napp = Flask(__name__)\napp.config[&apos;UPLOAD_FOLDER&apos;] = os.path.join(os.path.dirname(os.getcwd()),&apos;static&apos;,&apos;cav&apos;)\napp.config[&apos;MAX_CONTENT_LENGTH&apos;] = 16 * 1024 * 1024\n\n\nhtml = &apos;&apos;&apos;\n    &lt;!DOCTYPE html&gt;\n    &lt;title&gt;Upload File&lt;/title&gt;\n    &lt;h1&gt;图片上传&lt;/h1&gt;\n    &lt;form method=post enctype=multipart/form-data&gt;\n         &lt;input type=file name=file&gt;\n         &lt;input type=submit value=上传&gt;\n    &lt;/form&gt;\n    &apos;&apos;&apos;\n\n\ndef allowed_file(filename):\n    return &apos;.&apos; in filename and \\\n           filename.rsplit(&apos;.&apos;, 1)[1] in ALLOWED_EXTENSIONS\n\n\n@app.route(&apos;/uploads/&lt;filename&gt;&apos;)\ndef uploaded_file(filename):\n\n    return send_from_directory(app.config[&apos;UPLOAD_FOLDER&apos;],\n                               filename)\n\n\n@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])\ndef upload_file():\n    if request.method == &apos;POST&apos;:\n        file = request.files[&apos;file&apos;]\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            logging.info(&apos;Upload path with : &apos;,os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename))\n            logging.info(app.config[&apos;UPLOAD_FOLDER&apos;])\n            file.save(os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename))\n            file_url = url_for(&apos;uploaded_file&apos;, filename=filename)\n            return html + &apos;&lt;br&gt;&lt;img src=&apos; + file_url + &apos;&gt;&apos;\n    return html\n\n\nif __name__ == &apos;__main__&apos;:\n    app.run()</code></pre>","text":"首先是os模块选择上传目录: os.path为初始画一个path对象,他可以将路径转换为标准路径.os.path.dirname()转到相应文件目录os.getcwd()获取当前目录os.path.join(path1,path2,path3...)将所有目录组合起来 实现代码如","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python list 学习笔记","slug":"python-list-di","date":"2017-05-24T09:46:46.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-list-di.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong>跟随廖雪峰老师学习:</strong> <strong><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316724772904521142196b74a3f8abf93d8e97c6ee6000\" target=\"_blank\" rel=\"noopener\">廖雪峰python-使用list</a></strong> <strong>【Code】</strong> <strong>已上传至github.</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/list/list.py\" target=\"_blank\" rel=\"noopener\">list.py</a></strong> <strong>【总结】</strong> <strong>比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…</strong></p>\n","text":"【Link】 跟随廖雪峰老师学习: 廖雪峰python-使用list 【Code】 已上传至github. list.py 【总结】 比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python 机器学习 科学计算库","slug":"python-sklearn-moudle","date":"2018-01-08T08:34:43.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/python-sklearn-moudle.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Jupyter-Notebook\"><a href=\"#Jupyter-Notebook\" class=\"headerlink\" title=\"Jupyter Notebook\"></a>Jupyter Notebook</h1><p><strong>math Last Checkpoint: a few seconds ago (autosaved) [Python 3]</strong> <strong>Python 3</strong> <strong>Code:</strong></p>\n<pre><code>import numpy as np\n\nnp.arange(10)\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\na=np.arange(10)\n\n#可以直接对数组进行运算\n\na = a ** 2\n\na\n\narray([ 0,  1,  4,  9, 16, 25, 36, 49, 64, 81], dtype=int32)\n\n​\n\n#Scipy\n\n#用来做高等数学等计算的包\n\nfrom scipy import linalg\n\n#生成一个二维数组\n\nA = np.array([[1,2],[3,4]])\n\nA\n\narray([[1, 2],\n       [3, 4]])\n\n#计算行列式的值\n\n#1*4-2*3\n\nlinalg.det(A)\n\n​\n\n-2.0\n\n#Pandas\n\n#是一种构建于Numpy的高级数据结构和精巧工具,快速简单的处理数据\n\nimport pandas as pd\n\n#序列\n\ns = pd.Series([1,3,5,np.nan,6,8])\n\ns\n\n0    1.0\n1    3.0\n2    5.0\n3    NaN\n4    6.0\n5    8.0\ndtype: float64\n\n#时间数组,起始时间到六天\n\ndates = pd.date_range(&apos;20130101&apos;,periods=6)\n\ndates\n\nDatetimeIndex([&apos;2013-01-01&apos;, &apos;2013-01-02&apos;, &apos;2013-01-03&apos;, &apos;2013-01-04&apos;,\n               &apos;2013-01-05&apos;, &apos;2013-01-06&apos;],\n              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)\n\n#生成表格\n\n#index:行标识\n\n#columns:列标识\n\n#rand是0-1的均匀分布，randn是均值为0方差为1的正态分布；\n\n#rand(n)或randn(n)生成n*n的随机数矩阵。\n\n#rand(n,m)或randn(m,n)生成m*n的随机数矩阵。\n\ndf = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list(&apos;ABCD&apos;))\n\ndf\n\n    A   B   C   D\n2013-01-01  1.210884    0.616424    0.961066    0.173936\n2013-01-02  0.358245    0.506724    -0.047834   0.587061\n2013-01-03  -0.508396   0.012049    -0.114224   -1.195929\n2013-01-04  2.303441    0.536666    -1.013810   -0.574154\n2013-01-05  -1.327828   -0.003089   0.662432    0.038886\n2013-01-06  1.379826    1.554135    -0.681174   -0.816094\n\n#通过B列降序排序\n\ndf.sort_values(by=&apos;B&apos;)\n\n#从上到下多少行\n\n#df.head()\n\n#从下到上多少行\n\n#df.tail()\n\n#所有值和描述\n\n#df.describe()\n\n#转置\n\n#df.T\n\n​\n\n    A   B   C   D\n2013-01-01  1.210884    0.616424    0.961066    0.173936\n2013-01-02  0.358245    0.506724    -0.047834   0.587061\n2013-01-03  -0.508396   0.012049    -0.114224   -1.195929\n2013-01-04  2.303441    0.536666    -1.013810   -0.574154\n2013-01-05  -1.327828   -0.003089   0.662432    0.038886\n\n#绘图\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1,2,3])\n\nplt.ylabel(&apos;some numbers&apos;)\n\nplt.show()\n\n​</code></pre>","text":"Jupyter Notebookmath Last Checkpoint: a few seconds ago (autosaved) [Python 3] Python 3 Code:import numpy as npnp.arange(10)array([0, 1, 2, ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"机器学习","slug":"Python/机器学习","count":2,"path":"api/categories/Python/机器学习.json"},{"name":"相关库","slug":"Python/机器学习/相关库","count":1,"path":"api/categories/Python/机器学习/相关库.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"}]},{"title":"python3学习 Class私有成员访问限制","slug":"python3-class-vt","date":"2017-07-15T16:20:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-class-vt.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Visit_limit.py\" target=\"_blank\" rel=\"noopener\">Visit_limit.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[3]:</p>\n<p>‘’’<br>如果要让内部属性不被外部访问，可以把属性的名称前加上<br>两个下划线<strong>，在Python中，实例的变量名如果以</strong>开头，<br>就变成了一个私有变量（private），只有内部可以访问，外<br>部不能访问，<br>‘’’<br>class student(object):<br>    def __init__(self,name,score):<br>        self.<strong>name=name<br>        self.</strong>score=score<br>    def print_score(self):<br>        print(‘%s: %s’ %(self.__name,self.__score))<br>‘’’<br>改完后，对于外部代码来说，没什么变动，但是已经无法从外部<br>访问实例变量.__name和实例变量.__score了:只能通过类内的方法<br>才可以调用这些私有变量<br>‘’’<br>bart = student(‘Bart Simpson’, 98)<br>bart.print_score()<br>print(bart.__name)</p>\n<p># In[4]:</p>\n<p>‘’’<br>如果外部想要获取name和score怎么办,<br>给student类添加get_name和get_score<br>外部想要修改怎么办,set_score</p>\n<p>需要注意的是，在Python中，变量名类似__xxx__的，<br>也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，<br>特殊变量是可以直接访问的，不是private变量，所以，不能用<br>__name__、__score__这样的变量名。</p>\n<p>有些时候，你会看到以一个下划线开头的实例变量名，比如_name<br>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，<br>当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，<br>请把我视为私有变量，不要随意访问”。</p>\n<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。<br>不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，<br>所以，仍然可以通过_Student__name来访问__name变量：<br>‘’’<br>print(bart._student__name)#好神奇</p>\n<p>#但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。</p>\n<p># In[5]:</p>\n<p>#所以如果外界对实例化对象设置私有变量的值,因为上面说了</p>\n<p>#私有变量会被改名为 _student__name这样,所以如果使用</p>\n<p>#bart.__name=’New Name’,则表示在该对象内新建一个变量</p>\n<p>#不影响本来的<strong>name<br>bart.</strong>name=’New name’<br>bart.print_score()</p>\n<p>#out[]: Bart Simpson: 98</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: Visit_limit.py **# coding: utf-8# In[3]:‘’’<br>如果要让内部属性不被外部访问，可以把属性的名称前加上<br>两个下划线，在Python中，实例的变量名如果以开头，<br>就变成了一个私有变量","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 class","slug":"python3-class","date":"2017-07-15T03:52:34.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-class.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/class_.py\" target=\"_blank\" rel=\"noopener\">class_.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[13]:</p>\n<p>class student(object):<br>    #绑定实例属性<br>    #__init__方法的第一个参数永远是self,即实例本身<br>    def __init__(self,name,score):<br>        self.name = name<br>        self.score = score<br>    def print_score(self):<br>        print(“%s: %s” % (self.name,self.score))<br>    def get_grade(self):<br>        if self.score &gt;= 90:<br>            return ‘A’<br>        elif self.score &gt;= 60:<br>            return ‘B’<br>        else:<br>            return ‘C’</p>\n<p>bart=student(‘Bart Simpson’,59)<br>print(bart.name,bart.score,bart)<br>bart.print_score()<br>print(bart.get_grade())</p>\n<p># In[14]:</p>\n<p>#另一种访问方式<br>def pt_score(std):<br>    print(‘%s: %s’ % (std.name,std.score))<br>pt_score(bart)</p>\n<p># In[19]:</p>\n<p>‘’’<br>要定义一个方法，除了第一个参数是self外，其他<br>和普通函数一样。要调用一个方法，只需要在实例<br>变量上直接调用，除了self不用传递，其他参数正常传入：<br>‘’’</p>\n<p>‘’’<br>和静态语言不同，Python允许对实例变量绑定任何数据，也就<br>是说，对于两个实例变量，虽然它们都是同一个类的不同实例，<br>但拥有的变量名称都可能不同：<br>‘’’<br>bart = student(‘Bart Simpson’, 59)<br>lisa = student(‘Lisa Simpson’, 87)<br>bart.age = 8<br>print(bart.age)<br>print(lisa.age)#抛异常</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: class_.py **# coding: utf-8# In[13]:class student(object):<br>    #绑定实例属性<br>    #__init__方法的第一个参数永远是self,即实例本身<br>   ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 数据库","slug":"python3-database","date":"2017-07-29T01:32:25.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-database.json","excerpt":"","keywords":null,"cover":null,"content":"<p>文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Database\" title=\"Database仓库\" target=\"_blank\" rel=\"noopener\">Database仓库</a></p>\n","text":"文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:Database仓库","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"基于python3+mysql+nginx的个人博客","slug":"python3-end-blog-2","date":"2017-08-03T02:11:46.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/python3-end-blog-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg","content":"<p>一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而第三个博客是用nginx,所以使用了不同的端口号,以防冲突): 点击这里=&gt; :octocat:<a href=\"http://be-sunshine.cn:81\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn:81</a> 开源: (github上,暂时还未和python学习篇分开,回头分开再贴,Orz =3 )<del>~</del> 愿我永远有一颗不变的心! <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg\" alt></p>\n","text":"一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"全栈","slug":"Python/全栈","count":1,"path":"api/categories/Python/全栈.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"全栈","slug":"全栈","count":1,"path":"api/tags/全栈.json"}]},{"title":"python3学习 装饰器Decorator+log(日志输出)+functools+args","slug":"python3-decoratorlog-functoolsargs","date":"2017-07-14T03:08:37.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-decoratorlog-functoolsargs.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Record】</strong> <strong>函数是对象,也有其属性,比如 f.</strong>name** 获取f控制的函数的名字.** <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/Decorator/Decorator.py\" target=\"_blank\" rel=\"noopener\">Decorator.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#函数也是一个对象,所以可以赋值给变量<br>def now():<br>    print(‘1997-02-10’)<br>f=now<br>f()</p>\n<p># In[3]:</p>\n<p>#函数对象有一个__name__属性,可以拿到其名字<br>print(f.__name__)</p>\n<p># In[5]:</p>\n<p>‘’’<br>现在，假设我们要增强now()函数的功能，比如，<br>在函数调用前后自动打印日志，但又不希望修改<br>now()函数的定义，这种在代码运行期间动态增<br>加功能的方式，称之为“装饰器”（Decorator）。<br>‘’’</p>\n<p>#本质上，decorator就是一个返回函数的高阶函数</p>\n<p>#。所以，我们要定义一个能打印日志的decorator，可以定义如下：<br>def log(func):<br>    def wrapper(*args,**kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args,**kw)<br>    return wrapper<br>‘’’<br>观察上面的log，因为它是一个decorator，所以接受<br>一个函数作为参数，并返回一个函数。我们要借助<br>Python的@语法，把decorator置于函数的定义处：</p>\n<p>调用now()函数，不仅会运行now()函数本身，还会在<br>运行now()函数前打印一行日志：<br>‘’’<br>@log<br>def now2():<br>    print(‘1997-12-11’)<br>now2() </p>\n<p># In[16]:</p>\n<p>#把@log放到now()函数的定义处，相当于执行了语句：</p>\n<p>#now=log(now)<br>‘’’<br>1.wrapper()函数的参数定义是(*args, **kw)，因此，<br>wrapper()函数可以接受任意参数的调用。在wrapper()<br>函数内，首先打印日志，再紧接着调用原始函数。</p>\n<p>2.如果decorator本身需要传入参数，那就需要编写一个返<br>回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>\n<p>‘’’<br>def log2(text):<br>    def decorator(func):<br>        def wrapper(*args,**kw):<br>            print(‘%s %s():’ %(text,func.__name__))<br>            return func(*args,**kw)<br>        return wrapper<br>    return decorator</p>\n<p>#这个3层嵌套的decorator用法如下：<br>@log2(‘execute’)<br>def now3():<br>    print(‘2015-3-25’)<br>now3()</p>\n<p>#三层嵌套是这样的:now = log(‘execute’)(now)</p>\n<p># In[17]:</p>\n<p>‘’’<br>我们来剖析上面的语句，首先执行log(‘execute’)，<br>返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>\n<p>以上两种decorator的定义都没有问题，但还差最后一步。<br>因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数<br>，它们的__name__已经从原来的’now’变成了’wrapper’：<br>‘’’<br>print(now.__name__)</p>\n<p># In[20]:</p>\n<p>‘’’<br>因为返回的那个wrapper()函数名字就是’wrapper’，所以，<br>需要把原始函数的__name__等属性复制到wrapper()函数中，<br>否则，有些依赖函数签名的代码执行就会出错。</p>\n<p>不需要编写wrapper.__name__ = func.__name__这样的代码，<br>Python内置的functools.wraps就是干这个事的，所以，一个<br>完整的decorator的写法如下：<br>‘’’<br>import functools</p>\n<p>def log3(func):<br>    @functools.wraps(func)<br>    def wrapper(*args, **kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args, **kw)<br>    return wrapper</p>\n<p>#或者针对带参数的decorator：<br>def log4(text):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(*args, **kw):<br>            print(‘%s %s():’ % (text, func.__name__))<br>            return func(*args, **kw)<br>        return wrapper<br>    return decorator</p>\n<p># In[22]:</p>\n<p>#题目<br>‘’’<br>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。<br>OOP的装饰模式需要通过继承和组合来实现，而Python除了能支<br>持OOP的decorator外，直接从语法层次支持decorator。Python<br>的decorator可以用函数实现，也可以用类实现。</p>\n<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使<br>用起来非常灵活和方便。</p>\n<p>请编写一个decorator，能在函数调用的前后打印出’begin call’<br>和’end call’的日志。</p>\n<p>再思考一下能否写出一个@log的decorator，使它既支持：</p>\n<p>@log<br>def f():<br>    pass</p>\n<p>又支持：</p>\n<p>@log(‘execute’)<br>def f():<br>    pass<br>‘’’<br>def log5(<em>args1):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(\\</em>args,**kw):<br>            print(‘args1 num =%d’ %len(args1))<br>            print(‘begin %s():’ % func.__name__)<br>            func()<br>            print(‘end %s().\\n’ % func.__name__)<br>        return wrapper<br>    return decorator</p>\n<p>@log5(‘123’,’a’)<br>def dream():<br>    print(‘My Dream.’)</p>\n<p>@log5()<br>def future():<br>    print(‘Must..’)</p>\n<p>dream()<br>future()</p>\n<p>‘’’<br>Out:<br>args1 num =2<br>begin dream():<br>My Dream.<br>end dream().</p>\n<p>args1 num =0<br>begin future():<br>Must..<br>end future().<br>‘’’</p>\n<p># In[ ]:**</p>\n","text":"【Record】 函数是对象,也有其属性,比如 f.name** 获取f控制的函数的名字.** 【Source Code】 github: Decorator.py**# coding: utf-8# In[1]:#函数也是一个对象,所以可以赋值给变量<br>def now():","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 enumerate","slug":"python3-enumerate","date":"2017-07-16T09:01:37.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-enumerate.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/enumerate.py\" target=\"_blank\" rel=\"noopener\">enumerate.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[15]:</p>\n<p>from enum import Enum<br>Month=Enum(‘Months’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘Jun’, ‘Jul’, ‘Aug’, ‘Sep’, ‘Oct’, ‘Nov’, ‘Dec’))<br>for name,member in Month.__members__.items():<br>    print(name,’=&gt;’,member,’,’,member.value)</p>\n<p># In[17]:</p>\n<p>#如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：<br>from enum import unique<br>@unique<br>class WeekDay(Enum):<br>    Sun = 0 # Sun的value被设定为0<br>    Mon = 1<br>    Tue = 2<br>    Wed = 3<br>    Thu = 4<br>    Fri = 5<br>    Sat = 6</p>\n<p>#@unique装饰器可以帮助我们检查保证没有重复值。<br>day1=WeekDay.Mon<br>print(day1)<br>print(WeekDay[‘Tue’])<br>print(WeekDay.Tue.value)<br>print(day1 == WeekDay.Mon)<br>print(day1 == WeekDay.Tue)<br>print(WeekDay(1))</p>\n<p>for name,member in WeekDay.__members__.items():<br>    print(name,’=&gt;’,member,member.value)</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: enumerate.py **# coding: utf-8# In[15]:from enum import Enum<br>Month=Enum(‘Months’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 筛选器filter+筛回文数+艾氏筛法filter写法","slug":"python3-filter","date":"2017-07-13T08:47:07.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-filter.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/filter/filter.py\" target=\"_blank\" rel=\"noopener\">filter.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>‘’’<br>Python内建的filter()函数用于过滤序列。</p>\n<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>\n<p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：<br>‘’’<br>def is_odd(x):<br>    return x&amp;1==1<br>print(list(filter(is_odd,[1,2,4,5,6,9,10,15])))</p>\n<p># In[2]:</p>\n<p>#把一个序列中的空字符串删掉，可以这么写：<br>def not_empty(s):<br>    return s and s.strip()<br>print(list(filter(not_empty, [‘A’, ‘’, ‘B’, None, ‘C’, ‘  ‘])))</p>\n<p># In[8]:</p>\n<p>#filter实现无穷数的艾筛</p>\n<p>#暂未明白多个filter是怎么筛的<br>def _odd_iter():<br>    n = 1<br>    while True:<br>        n = n + 2<br>        yield n<br>def _not_divisible(n):<br>    return lambda x: x % n &gt; 0<br>def primes():<br>    yield 2<br>    it = _odd_iter() # 初始序列<br>    while True:<br>        n = next(it) # 返回序列的第一个数<br>        yield n<br>        it = filter(_not_divisible(n), it) # 构造新序列<br># 打印1000以内的素数:<br>for n in primes():<br>    if n &lt; 10:<br>        print(n)<br>    else:<br>        break</p>\n<p># In[9]:</p>\n<p>#去除非回文数<br>def is_palindrome(n):<br>    return str(n)==str(n)[::-1]<br># 测试:<br>output = filter(is_palindrome, range(1, 1000))<br>print(list(output))</p>\n<p># In[ ]:</p>\n<p>【前面的问题】<br>果然是嵌套<br>形同:it = filter(_not_divisible(n), it)只是给“奇数生成器”嵌套了一个过滤规则。执行了几次循环之后，这个生成器就成了：<br>(剔除能被7整除的(剔除能被5整除的(剔除能被3整除的(剔除能被2整除的(奇数生成器)))))<br>效率特别差= =**</p>\n","text":"【Source Code】 filter.py **# coding: utf-8# In[1]:‘’’<br>Python内建的filter()函数用于过滤序列。和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 GUI","slug":"python3-gui","date":"2017-07-24T15:35:45.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-gui.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 Tkinter library is this demo’s library. github: :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/GUI/GUI-tk.py\" title=\"GUI-tk.py\" target=\"_blank\" rel=\"noopener\">GUI-tk.py</a></p>\n<pre><code>from tkinter import *\nimport tkinter.messagebox as messagebox\n\nclass Application(Frame):\n    def __init__(self,master=None):\n        Frame.__init__(self,master)\n        self.pack()\n        self.createWidgets()\n\n    def createWidgets(self):\n        self.nameInput=Entry(self)\n        self.nameInput.pack()\n        self.alertButton=Button(self,text=&apos;Hello&apos;,command=self.hello)\n        self.alertButton.pack()\n        self.helloLabel=Label(self,text=&apos;Hello,world!&apos;)\n        self.helloLabel.pack()\n        self.quitButton=Button(self,text=&apos;Quit&apos;,command=self.quit)\n        self.quitButton.pack()\n    def hello(self):\n        name=self.nameInput.get() or &apos;world&apos;\n        messagebox.showinfo(&apos;Message&apos;,&apos;Hello, %s&apos; % name)\napp=Application()\n#设置窗口标题\napp.master.title(&apos;Hello World&apos;)\n#启动消息循环\napp.mainloop()</code></pre>","text":"【Source Code】 Tkinter library is this demo’s library. github: :point_right:GUI-tk.pyfrom tkinter import *import tkinter.messagebox as messag","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 多态和继承","slug":"python3-inheritance-and-polymorphisn","date":"2017-07-15T16:44:40.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/python3-inheritance-and-polymorphisn.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Inheritance_and_polymorphisn.py\" target=\"_blank\" rel=\"noopener\">Inheritance_and_polymorphisn.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[5]:</p>\n<p>‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称为子类（Subclass），而被继<br>承的class称为基类、父类或超类（Base class、Super class）。<br>‘’’</p>\n<p>#比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：<br>class Animal(object):<br>    def run(self):<br>        print(‘Animal is running…’)</p>\n<p>#当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：<br>class Dog(Animal):<br>    pass<br>class Cat(Animal):<br>    pass<br>‘’’<br>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是<br>它的子类。Cat和Dog类似。</p>\n<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由<br>于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什<br>么事也没干，就自动拥有了run()方法：<br>‘’’<br>dog=Dog()<br>dog.run()<br>cat=Cat()<br>cat.run()</p>\n<p>#当子类和父类都存在相同的run()方法时，我们说，</p>\n<p>#子类的run()覆盖了父类的run()，在代码运行的时候，</p>\n<p>#总是会调用子类的run()。这样，我们就获得了继承的</p>\n<p>#另一个好处：多态。<br>class Puppy(Animal):<br>    def run(self):<br>        print(‘Puppy is running…’)<br>class Shark(Animal):<br>    def run(self):<br>        print(‘Shark is running…’)<br>puppy=Puppy()<br>puppy.run()</p>\n<p># In[7]:</p>\n<p>#判断一个变量是否是某个类型可以用isinstance()判断：</p>\n<p>#可以发现,puppy可以使Animal也可以是Puppy.<br>print(isinstance(puppy,Animal))<br>print(isinstance(puppy,Puppy))<br>b=Animal()<br>print(isinstance(b,Puppy))</p>\n<p>#所以，在继承关系中，如果一个实例的数据类型是某个子类</p>\n<p>#，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p>\n<p># In[12]:</p>\n<p>#要理解多态的好处，我们还需要再编写一个函数，这个函数接受</p>\n<p>#一个Animal类型的变量：<br>def run_twice(animal):<br>    animal.run()<br>    animal.run()<br>run_twice(Dog())<br>run_twice(Puppy())<br>run_twice(Shark())</p>\n<p># In[ ]:</p>\n<p>‘’’<br>多态的好处在于:</p>\n<p>新增一个Animal的子类，不必对  –run_twice()–<br>做任何修改，实际上，任何依赖Animal作为参数的函<br>数或者方法都可以不加修改地正常运行，原因就在于<br>多态。</p>\n<p>著名的“开闭”原则：</p>\n<p>对扩展开放：允许新增Animal子类；</p>\n<p>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则<br>传入的对象必须是Animal类型或者它的子类，否则，将无法调用<br>run()方法。</p>\n<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。<br>我们只需要保证传入的对象有一个run()方法就可以了：</p>\n<p>class Timer(object):<br>    def run(self):<br>        print(‘Start…’)</p>\n<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一<br>个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看<br>做是鸭子。<br>‘’’**</p>\n","text":"【Source Code】 github: Inheritance_and_polymorphisn.py **# coding: utf-8# In[5]:‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 迭代+enumrate","slug":"python3-iterations-enumrate","date":"2017-07-12T01:26:17.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python3-iterations-enumrate.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/iteration/%E8%BF%AD%E4%BB%A3.py\" target=\"_blank\" rel=\"noopener\">迭代.py</a></strong></p>\n<blockquote>\n<p>**# coding: utf-8</p>\n<p># In[2]:</p>\n<p>d={‘a’:1,’b’:2,’c’:3}<br>for key in d:<br>    print(key)</p>\n<p># In[5]:</p>\n<p>for ch in ‘ABC’:<br>    print(ch)</p>\n<p># In[1]:</p>\n<p>#判断是否可迭代<br>from collections import Iterable<br>print(isinstance(‘abc’,Iterable))<br>print(isinstance([1,2,3],Iterable))<br>print(isinstance(123,Iterable))</p>\n<p># In[8]:</p>\n<p>for i,value in enumerate([‘A’,’B’,’C’]):<br>    print(i,value)<br>print(enumerate([‘A’,’B’,’C’]))</p>\n<p>#enumerate是枚举,列举的意思</p>\n<p>#如果对于一个列表,既要遍历索引又要遍历元素时,首先可以这样写<br>list1 = [“这”, “是”, “一个”, “测试”]<br>for i in range (len(list1)):<br>    print(i ,list1[i])<br>print(‘\\n’)</p>\n<p>#但这样很麻烦,所以可以用enumrate这样写<br>for i,value in enumerate(list1):<br>    print(i,value)<br>print(‘\\n’)</p>\n<p>#enumerate还可以接受第二个参数,用于指定初始索引<br>for i,value in enumerate(list1,1):<br>    print(i,value)<br>print(‘\\n’)</p>\n<p># In[9]:</p>\n<p>#在for循环里,同时引用两个变量<br>for x,y in [(1,1),(2,2),(3,3)]:<br>    print(x,y)</p>\n<p># In[ ]:</p>\n<p>#end**</p>\n</blockquote>\n","text":"【Source Code】 迭代.py**# coding: utf-8# In[2]:d={‘a’:1,’b’:2,’c’:3}<br>for key in d:<br>    print(key)# In[5]:for ch in ‘ABC’:<br>    print(ch","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 列表生成式+isinstance","slug":"python3-listcomprehension","date":"2017-07-12T05:44:56.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python3-listcomprehension.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/List_Comprehensions/%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F.py\" target=\"_blank\" rel=\"noopener\">列表生成式.py</a></strong></p>\n<blockquote>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br>li=list(range(1,11))<br>print(li)</p>\n<p># In[2]:</p>\n<p>#但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：<br>L=[]<br>for x in range(1,11):<br>    L.append(x*x)<br>print(L)</p>\n<p># In[3]:</p>\n<p>#但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：<br>R=[x*x for x in range(1,11)]<br>print(R)</p>\n<p># In[12]:</p>\n<p>#for循环后还可以加上if这样我们就可以筛出仅偶数的平方</p>\n<p>#x&amp;x-1是判断x是否是2的幂，x&amp;1为1为奇<br>R=[x*x for x in range(1,11) if not(x&amp;1)]<br>print(R)</p>\n<p># In[14]:</p>\n<p>#还可以使用两层循环，可以生成全排列：<br>T=[m+n for m in ‘ABC’ for n in ‘XYZ’]<br>print(T)</p>\n<p># In[2]:</p>\n<p>#运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：<br>import os # 导入os模块，模块的概念后面讲到<br>OS=[d for d in os.listdir(‘.’)]# os.listdir可以列出文件目录<br>print(OS)<br># Out [1]: [‘.anaconda’, ‘.android’, ‘.bash_history’, ‘.conda’, ‘.condarc’, ‘.gem’, ‘.gemrc’, ‘.gitconfig’, ‘.idlerc’, ‘.ipynb_checkpoints’, ‘.ipython’, ‘.jupyter’, ‘.oracle_jre_usage’, ‘.packettracer’, ‘.ssh’, ‘.viminfo’, ‘360驱动大师.lnk’, ‘ACDSee5.lnk’, ‘AppData’, ‘Application Data’, ‘Cisco Packet Tracer 6.2sv’, ‘Contacts’, ‘Cookies’, ‘Desktop’, ‘Documents’, ‘Downloads’, ‘fancy_deboss.png’, ‘Favorites’, ‘fontawesome-webfont.svg’, ‘IntelGraphicsProfiles’, ‘Links’, ‘Local Settings’, ‘Music’, ‘My Documents’, ‘NetHood’, ‘NTUSER.DAT’, ‘ntuser.dat.LOG1’, ‘ntuser.dat.LOG2’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TM.blf’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000001.regtrans-ms’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000002.regtrans-ms’, ‘ntuser.ini’, ‘ntuser.pol’, ‘Pictures’, ‘PrintHood’, ‘Recent’, ‘Saved Games’, ‘Searches’, ‘SendTo’, ‘Templates’, ‘Test.ipynb’, ‘Videos’, ‘wc’, ‘WebpageIcons.db’, ‘WIN7激活工具’, ‘XT.DAT.LOG1’, ‘XT.DAT.LOG2’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TM.blf’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000001.regtrans-ms’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000002.regtrans-ms’, ‘「开始」菜单’, ‘列表生成式.ipynb’, ‘宽带连接.lnk’, ‘迭代.ipynb’, ‘迭代.py’]</p>\n<p># In[3]:</p>\n<p>#for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：<br>d={‘x’:’A’,’y’:’B’,’z’:’C’}<br>for k,v in d.items():<br>    print(k,’=’,v)</p>\n<p># In[5]:</p>\n<p>#因此,列表生成式也可以用两个变量生成list:<br>dp=[k+’=’+v for k,v in d.items()]<br>print(dp)</p>\n<p># In[6]:</p>\n<p>#最后把一个list中的字母全变成小写:<br>L=[‘Hello’,’World’,’IBM’,’Apple’]<br>Lp=[s.lower() for s in L]<br>print(Lp)</p>\n<p># In[7]:</p>\n<p>#使用内建的isinstance(key,type)可以判断key是否是type</p>\n<p>#例:<br>L1 = [‘Hello’, ‘World’, 18, ‘Apple’, None]<br>L2=[k.lower() for k in L1 if isinstance(k,str)]<br>print(L2)</p>\n<p># In[ ]:**</p>\n</blockquote>\n","text":"【Source Code】 列表生成式.py **# coding: utf-8# In[1]:#举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br>li=list(range(1,11))<","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 map&reduce+浮点字符串转换浮点数+英文姓名规范+一点点lambda","slug":"python3-map-reduce","date":"2017-07-13T08:03:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-map-reduce.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/map%26reduce/map_reduce.py\" target=\"_blank\" rel=\"noopener\">map_reduce.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[2]:</p>\n<p>#我们先看map。map()函数接收两个参数，一个是函数，</p>\n<p>#一个是Iterable，map将传入的函数依次作用到序列的</p>\n<p>#每个元素，并把结果作为新的Iterator返回。</p>\n<p>#现在,我们用python代码实现1-9映射到x^2<br>def f(x):<br>    return x*x<br>r=map(f,[x for x in range(10)])<br>print(list(r))</p>\n<p>#map()传入的第一个参数是f，即函数对象本身。由于结</p>\n<p>#果r是一个Iterator，Iterator是惰性序列，因此通过</p>\n<p>#list()函数让它把整个序列都计算出来并返回一个list。</p>\n<p># In[3]:</p>\n<p>#将数字转换成字符<br>print(list(map(str,[x for x in range(1,10)])))</p>\n<p># In[4]:</p>\n<p>#reduce<br>‘’’<br>再看reduce的用法。reduce把一个函数作用在一个序列<br>[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce<br>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>\n<p>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>当然,可以直接用sum()<br>‘’’<br>from functools import reduce<br>def add(x,y):<br>    return x+y<br>print(reduce(add,[x for x in range(1,10)]))</p>\n<p># In[5]:</p>\n<p>#如果将[1，3，5，7，9]变成13579<br>def fn(x,y):<br>    return x*10+y<br>print(reduce(fn,[x for x in range(1,10,2)]))</p>\n<p># In[6]:</p>\n<p>‘’’<br>这个例子本身没多大用处，但是，如果考虑到字符串<br>str也是一个序列，对上面的例子稍加改动，配合map()，<br>我们就可以写出把str转换为int的函数：<br>‘’’<br>def char2num(s):<br>    return {‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9}[s]<br>print(reduce(fn, map(char2num, ‘13579’)))</p>\n<p># In[7]:</p>\n<p>#也可以直接返回转换结果<br>def str2int(s):<br>    return reduce(fn, map(char2num, s))<br>print(str2int(‘98661’))</p>\n<p># In[9]:</p>\n<p>#还可以用lambda函数进一步转化，事实证明Python的整数运算是大数= =</p>\n<p>#当然,可以直接用int()<br>def str2int(s):<br>    return reduce(lambda x,y:x*10+y,map(char2num,s))<br>print(str2int(‘46131346431311616131’))</p>\n<p># In[10]:</p>\n<p>#利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，</p>\n<p>#其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：</p>\n<p>#[‘Adam’, ‘Lisa’, ‘Bart’]：<br>def normalize(name):<br>    return name[0].upper()+name[1:].lower()<br># 测试:<br>L1 = [‘adam’, ‘LISA’, ‘barT’]<br>L2 = list(map(normalize, L1))<br>print(L2)</p>\n<p># In[11]:</p>\n<p>#Python提供的sum()函数可以接受一个list并求和，请编写一个prod()</p>\n<p>#函数，可以接受一个list并利用reduce()求积：<br>def prod(L):<br>    return reduce(lambda x,y:x*y,L)<br>print(‘3 * 5 * 7 * 9 =’, prod([3, 5, 7, 9]))</p>\n<p># In[20]:</p>\n<p>#利用map和reduce编写一个str2float函数，把字符串’123.456’转换成浮点数123.456：<br>def str2float(s):<br>    n,l=s.find(‘.’),len(s)<br>    if n!=-1:<br>        return reduce(lambda x,y:x<em>10+y,map(lambda x:int(x),s[:n]))+reduce(lambda x,y:x/10+y,map(lambda x:int(x)/10,s[l-1:n:-1]))<br>    else:<br>        return reduce(lambda x,y:x</em>10+y,map(lambda x:int(x),s))<br>print(‘str2float(\\‘166516516.1133165\\‘) =’, str2float(‘166516516.1133165’))</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: map_reduce.py **# coding: utf-8# In[2]:#我们先看map。map()函数接收两个参数，一个是函数，#一个是Iterable，map将传入的函数依次作用到序列的#每个元素，并把结果作为新的Iterat","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 多-线-程","slug":"python3-multilwp","date":"2017-07-19T06:40:14.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-multilwp.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:</strong></p>\n<ol>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E5%A4%9A%E7%BA%BF%E7%A8%8B.py\" target=\"_blank\" rel=\"noopener\">多线程.py</a></strong></li>\n</ol>\n<p>**import time,threading</p>\n<p>#新线程执行的代码:<br>def loop():<br>    print(‘thread %s is running…’ % threading.current_thread().name)<br>    n=0<br>    while n&lt;5: n=n+1 print(‘thread %s &gt;&gt;&gt; %s’ % (threading.current_thread().name,n))<br>        time.sleep(1)<br>    print(‘thread %s ended.’ % threading.current_thread().name)</p>\n<p>print(‘thread %s is running…’ % threading.current_thread().name)<br>t=threading.Thread(target=loop,name=’LoopThread’)<br>t.start()<br>t.join()<br>print(‘thread %s ended.’ % threading.current_thread().name)</p>\n<p>‘’’<br>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷<br>贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共<br>享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共<br>享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br>‘’’</p>\n<p>#高级语言计算顺序<br>‘’’<br>    balance = balance + n</p>\n<p>分两步：</p>\n<pre><code>计算balance + n，存入临时变量中；\n将临时变量的值赋给balance。</code></pre><p>你也不希望你的存款莫名其妙变成负数吧.<br>所以如果想要计算正确,就要给change_it()上一把锁当某个线程开始执行<br>change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时<br>执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。由<br>于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以<br>，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现：<br>‘’’</p>\n<p>#但可能因为锁阻止了多线程并发执行，包含锁的代码只能单线程模式执行</p>\n<p>#另外,由于多个所由于可以存在多个锁，不同的线程持有不同的锁，并试图</p>\n<p>#获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执</p>\n<p>#行，也无法结束，只能靠操作系统强制终止。</p>\n<p>#–示例<br>import time, threading</p>\n<p># 假定这是你的银行存款:<br>balance = 0</p>\n<p>def change_it(n):<br>    # 先存后取，结果应该为0:<br>    global balance<br>    balance = balance + n<br>    balance = balance - n</p>\n<p>lock = threading.Lock()</p>\n<p>def run_thread(n):<br>    for i in range(100000):<br>        # 先要获取锁:<br>        lock.acquire()<br>        try:<br>            # 放心地改吧:<br>            change_it(n)<br>        finally:<br>            # 改完了一定要释放锁:<br>            lock.release()</p>\n<p>t1 = threading.Thread(target=run_thread, args=(5,))<br>t2 = threading.Thread(target=run_thread, args=(8,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)</p>\n<p>#由于Python历史遗留的GIL问题,如果一个线程满CPU</p>\n<p>#基本上只能以单核来执行线程,如果想要实现彻底的多核线程</p>\n<p>#要用C扩展**</p>\n","text":"【Source Code】 github:多线程.py**import time,threading#新线程执行的代码:<br>def loop():<br>    print(‘thread %s is running…’ % threading.current_thread(","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 多进程+进程池+进程间通信+子进程","slug":"python3-multiprocess","date":"2017-07-19T06:29:28.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-multiprocess.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:</strong></p>\n<ol>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/multiprocessing_test.py\" target=\"_blank\" rel=\"noopener\">multiprocessing_test.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E5%AD%90%E8%BF%9B%E7%A8%8B.py\" target=\"_blank\" rel=\"noopener\">子进程.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E8%BF%9B%E7%A8%8B%E6%B1%A0.py\" target=\"_blank\" rel=\"noopener\">进程池.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.py\" target=\"_blank\" rel=\"noopener\">进程间通信.py</a></strong></li>\n</ol>\n<p><strong>不贴代码了..略多.点上面得超链接进github↑↑</strong></p>\n","text":"【Source Code】 github:multiprocessing_test.py子进程.py进程池.py进程间通信.py不贴代码了..略多.点上面得超链接进github↑↑","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 oop-多重继承+MixIn","slug":"python3-oop-mixin","date":"2017-07-16T05:56:37.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-oop-mixin.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/Multi%20inheritance.py\" target=\"_blank\" rel=\"noopener\">Multi inheritance.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：<br>class Animal(object):<br>    pass</p>\n<p># 大类:<br>class Mammal(Animal):<br>    pass</p>\n<p>class Bird(Animal):<br>    pass</p>\n<p># 各种动物:<br>class Dog(Mammal):<br>    pass</p>\n<p>class Bat(Mammal):<br>    pass</p>\n<p>class Parrot(Bird):<br>    pass</p>\n<p>class Ostrich(Bird):<br>    pass</p>\n<p>#现在，我们要给动物再加上Runnable和Flyable的功能，</p>\n<p>#只需要先定义好Runnable和Flyable的类：<br>class Runnable(object):<br>    def run(self):<br>        print(‘Running…’)</p>\n<p>class Flyable(object):<br>    def fly(self):<br>        print(‘Flying…’)</p>\n<p>#对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：<br>class Dog(Mammal, Runnable):<br>    pass</p>\n<p>#对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：<br>class Bat(Mammal, Flyable):<br>    pass</p>\n<p>#通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>\n<p># In[4]:</p>\n<p>‘’’<br>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<br>Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多<br>重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继<br>承Runnable。这种设计通常称之为MixIn。</p>\n<p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn<br>和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和<br>植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>\n<p>class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):<br>    pass<br>‘’’</p>\n<p>‘’’<br>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>\n<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>\n<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>\n<p>class MyTCPServer(TCPServer, ForkingMixIn):<br>    pass</p>\n<p>编写一个多线程模式的UDP服务，定义如下：</p>\n<p>class MyUDPServer(UDPServer, ThreadingMixIn):<br>    pass</p>\n<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>\n<p>class MyTCPServer(TCPServer, CoroutineMixIn):<br>    pass</p>\n<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>\n<p>‘’’</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: Multi inheritance.py **# coding: utf-8# In[1]:#采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：<br>class Animal(object):<br>    pass# 大类:<","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 PIL图像处理库","slug":"python3-pillow","date":"2017-07-24T10:42:57.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-pillow.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi.py\" title=\"pi.py\" target=\"_blank\" rel=\"noopener\">pi.py</a></p>\n<pre><code>from PIL import Image\n\n#打开一个jpg文件,是当前路径\nim=Image.open(&apos;test.jpg&apos;)\n#获得图像尺寸\nw,h=im.size\nprint(&apos;Original Image size: %sx%s&apos; % (w,h))\n#缩放到50%\nim.thumbnail((w//2,h//2))\nprint(&apos;Resize image to: %sx%s&apos; %(w//2,h//2))\n#把缩放后的图像用jpeg保存\nim.save(&apos;thumbnail.jpg&apos;,&apos;jpeg&apos;)</code></pre><p>2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi2.py\" title=\"pi2.py\" target=\"_blank\" rel=\"noopener\">pi2.py</a></p>\n<pre><code>from PIL import Image,ImageFilter\n#打开一个文件,当前路径\nim=Image.open(&apos;test.jpg&apos;)\n#应用模糊滤镜\nim2=im.filter(ImageFilter.BLUR)\nim2.save(&apos;blur.jpg&apos;,&apos;jpeg&apos;)</code></pre><p>3.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi3.py\" title=\"pi3.py\" target=\"_blank\" rel=\"noopener\">pi3.py</a></p>\n<pre><code>from PIL import Image,ImageDraw,ImageFont,ImageFilter\n\nimport random\n\n#随机字母\ndef rndChar():\n    return chr(random.randint(65,90))\n#随机颜色1;\ndef rndColor():\n    return (random.randint(64,255),random.randint(64,255),random.randint(64,255))\n#随机颜色2\ndef rndColor2():\n    return (random.randint(32,255),random.randint(32,255),random.randint(32,255))\n\n#240*60\nwidth=240\nheight=60\nimage=Image.new(&apos;RGB&apos;,(width,height),(255,255,255))\n#穿件Font对象\nfont=ImageFont.truetype(&apos;Arial.ttf&apos;,36)\n#创建Draw对象\ndraw=ImageDraw.Draw(image)\n#填充每个像素\nfor x in range(width):\n    for y in range(height):\n        draw.point((x,y),fill=rndColor())\n#输出文字\nfor t in range(4):\n    draw.text((60*t+10,10),rndChar(),font=font,fill=rndColor2())\n#模糊:\nimage=image.filter(ImageFilter.BLUR)\nimage.save(&apos;code.jpg&apos;,&apos;jpeg&apos;)</code></pre>","text":"【Source Code】 github: 1.:point_right:pi.pyfrom PIL import Image#打开一个jpg文件,是当前路径im=Image.open(&apos;test.jpg&apos;)#获得图像尺寸w,h=im.sizeprint(&a","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 偏函数Partial_function+args+kw","slug":"python3-partial-functionargskw","date":"2017-07-14T07:20:06.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-partial-functionargskw.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/Partial_function/Partial_function.py\" target=\"_blank\" rel=\"noopener\">github: Partial_Function.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[2]:</p>\n<p>#Partial function包含在functools中</p>\n<p>#int可以将字符串转换成整形<br>print(‘十进制: ‘,int(‘123456’),’\\n’)</p>\n<p># In[12]:</p>\n<p>#但int()函数还提供额外的base参数，默认值为10。</p>\n<p>#如果传入base参数，就可以做N进制的转换：<br>print(‘十六进制转十进制: ‘,int(‘E123456’,16),’\\n’)</p>\n<p># In[13]:</p>\n<p>#假设要转换大量的二进制字符串，每次都传入int(x, base=2)</p>\n<p>#非常麻烦，于是，我们想到，可以定义一个int2()的函数，默</p>\n<p>#认把base=2传进去：<br>def int2(x, base=2):<br>    return int(x, base)<br>print(‘二进制转十进制: ‘,int2(‘1000000’))<br>print(‘二进制转十进制: ‘,int2(‘1010101’))</p>\n<p># In[14]:</p>\n<p>#functools.partial就是帮助我们创建一个偏函数的，不需要我</p>\n<p>#们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：<br>import functools<br>int3=functools.partial(int,base=2)<br>print(‘二进制转十进制: ‘,int3(‘1000000’))<br>print(‘二进制转十进制: ‘,int3(‘1010101’))</p>\n<p># In[22]:</p>\n<p>‘’’<br>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：</p>\n<p>int2 = functools.partial(int, base=2)</p>\n<p>实际上固定了int()函数的关键字参数base，也就是：</p>\n<p>int2(‘10010’)</p>\n<p>相当于：</p>\n<p>kw = { ‘base’: 2 }<br>int(‘10010’, **kw)</p>\n<p>当传入：</p>\n<p>max2 = functools.partial(max, 10)</p>\n<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>\n<p>max2(5, 6, 7)</p>\n<p>相当于：</p>\n<p>args = (10, 5, 6, 7)<br>max(*args)</p>\n<p>‘’’</p>\n<p>max2 = functools.partial(max)<br>args = (10, 5, 6, 7)<br>print(max2(*args))</p>\n<p>#out:10<br>max3 = functools.partial(max,102)<br>args = (10, 5, 6, 7)<br>print(max3(*args))</p>\n<p>#OUT:102**</p>\n","text":"【Source Code】 github: Partial_Function.py **# coding: utf-8# In[2]:#Partial function包含在functools中#int可以将字符串转换成整形<br>print(‘十进制: ‘,int(‘12345","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 @property","slug":"python3-property","date":"2017-07-16T05:36:11.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-property.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/property.py\" target=\"_blank\" rel=\"noopener\">property.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[2]:</p>\n<p>‘’’<br>还记得装饰器（decorator）可以给函数动态加上功能吗？<br>对于类的方法，装饰器一样起作用。Python内置的@property<br>装饰器就是负责把一个方法变成属性调用的：<br>‘’’<br>class Student(object):<br>    @property<br>    def score(self):<br>        return self._score<br>    @score.setter<br>    def score(self,value):<br>        if not isinstance(value,int):<br>            raise ValueError(‘score must be an integer!’)<br>        if value &lt; 0 or value &gt; 100:<br>            raise ValueError(‘score must between 0 ~ 100!’)<br>        self._score = value<br>‘’’<br>@property的实现比较复杂，我们先考察如何使用。把一个getter方<br>法变成属性，只需要加上@property就可以了，此时，@property本身<br>又创建了另一个装饰器@score.setter，负责把一个setter方法变成属<br>性赋值，于是，我们就拥有一个可控的属性操作：</p>\n<p>相当于 Get Set<br>‘’’<br>a=Student()<br>a.score = 60 # OK，实际转化为a.set_score(60)<br>print(a.score)# OK，实际转化为s.get_score()</p>\n<p># In[3]:</p>\n<p>#a.score=9999  ValueError(‘score must between 0 ~ 100!’)</p>\n<p>#还可以定义只读属性，只定义getter方法，不定义setter方法</p>\n<p>#就是一个只读属性：<br>class Student(object):</p>\n<pre><code>@property\ndef birth(self):\n    return self._birth\n\n@birth.setter\ndef birth(self, value):\n    self._birth = value\n\n@property\ndef age(self):\n    return 2015 - self._birth</code></pre><p>#上面的birth是可读写属性，而age就是一个只读属性，因为age</p>\n<p>#可以根据birth和当前时间计算出来。</p>\n<p>‘’’<br>练习</p>\n<p>请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：<br>‘’’<br>class Screen(object):<br>    @property<br>    def width(self):<br>        return self._width<br>    @width.setter<br>    def width(self,value):<br>        self._width=value<br>    @property<br>    def height(self):<br>        return self._height<br>    @height.setter<br>    def height(self,value):<br>        self._height=value<br>    @property<br>    def resolution(self):<br>        return self.width*self.height<br># test:<br>s = Screen()<br>s.width = 1024<br>s.height = 768<br>print(s.resolution)<br>assert s.resolution == 786432, ‘1024 * 768 = %d ?’ % s.resolution</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: property.py**# coding: utf-8# In[2]:‘’’<br>还记得装饰器（decorator）可以给函数动态加上功能吗？<br>对于类的方法，装饰器一样起作用。Python内置的@property<br>装饰器","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 __slots__","slug":"python3-slots","date":"2017-07-16T04:40:11.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-slots.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/slots.py\" target=\"_blank\" rel=\"noopener\">slots.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[6]:</p>\n<p>class Student(object):<br>    pass<br>s=Student()<br>s.name=’Michael’<br>print(s.name)</p>\n<p>#还可以尝试给实例绑定一个方法：<br>def set_age(self,age):<br>    self.age=age<br>from types import MethodType<br>s.set_age=MethodType(set_age,s)#绑定方法<br>s.set_age(25)<br>print(s.age)</p>\n<p>#但是，给一个实例绑定的方法，对另一个实例是不起作用的：<br>s2=Student()</p>\n<p>#s2.set_age(25)</p>\n<p># In[8]:</p>\n<p>#为了给所有实例都绑定方法，可以给class绑定方法：<br>def set_score(self,score):<br>    self.score=score<br>Student.set_score=set_score</p>\n<p>#给class绑定方法后，所有实例均可调用：<br>s.set_score(20)<br>s2.set_score(30)<br>print(s.score,s2.score)</p>\n<p># In[9]:</p>\n<p>#使用__slots__</p>\n<p>#但是，如果我们想要限制实例的属性怎么办？比如，</p>\n<p>#只允许对Student实例添加name和age属性。</p>\n<p>#为了达到限制的目的，Python允许在定义class的时候，</p>\n<p>#定义一个特殊的__slots__变量，来限制该class实例能添加的属性：<br>class student(object):<br>    __slots__ = (‘name’, ‘age’) # 用tuple定义允许绑定的属性名称<br>s=student()<br>s.name=’Michael’<br>s.age=8</p>\n<p>#s.score=20#AttributeError</p>\n<p># In[10]:</p>\n<p>#使用__slots__要注意，__slots__定义的属性仅</p>\n<p>#对当前类实例起作用，对继承的子类是不起作用的：<br>class GraduateStudent(student):<br>    pass<br>g = GraduateStudent()<br>g.score=9999#没抛异常</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: slots.py **# coding: utf-8# In[6]:class Student(object):<br>    pass<br>s=Student()<br>s.name=’Michael’<br>print(s.nam","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 正则表达式","slug":"python3-regular-expression","date":"2017-07-20T12:42:52.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-regular-expression.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】</p>\n<ul>\n<li><p>:point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Regular%20Expression\" title=\"Regular Expression模块\" target=\"_blank\" rel=\"noopener\">Regular Expression模块</a></p>\n<p>s=’ABC\\-001’#对应正则表达式字符串为’ABC-001’<br>#因为python本身需要转义,但用 r 前缀的话,就可以忽略转义字符了<br>s=r’ABC-001’<br>import re<br>print(‘成功的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010-12345’))<br>print(‘失败的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010 12345’))</p>\n<p>test=’用户输入的字符串’<br>if re.match(r’正则表达式’,test):</p>\n<pre><code>print(&apos;ok&apos;)</code></pre><p>else:</p>\n<pre><code>print(&apos;failed&apos;)</code></pre><p>#切分字符串<br>#用正则表达式切分字符串比用固定的字符更灵活,<br>print(‘a b   c’.split(‘ ‘))<br>#[‘a’, ‘b’, ‘’, ‘’, ‘c’],无法识别连续的空格<br>#用正则表达式试试<br>print(re.split(r’\\s+’,’a b   c’))<br>#[‘a’, ‘b’, ‘c’]<br>print(re.split(r’[\\s,;]+’, ‘a,b;; c  d’))<br>#[‘a’, ‘b’, ‘c’, ‘d’]</p>\n<p>#分组<br>m=re.match(r’^(\\d{3})-(\\d{3,8})$’,’010-12345’)<br>print(m)<br>print(‘m.group(0): ‘,m.group(0),’\\nm.group(1): ‘,m.group(1),’\\nm.group(2): ‘,m.group(2))</p>\n<p>‘’’<br>^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从<br>匹配的字符串中提取出区号和本地号码</p>\n<p>如果正则表达式中定义了组，就可以在Match对象上用<br>group()方法提取出子串来。<br>‘’’<br>#提取时间<br>t=’19:05:30’<br>m=re.match(r’^(0[0-9]|1[0-9]|2[0-3]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$’,t)<br>print(m.groups())</p>\n<p>#这样可以直接匹配出合法时间,但有些时候,正则也无法完全验证,这时候就要配合程序了</p>\n<p>#贪婪匹配<br>#正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符<br>print(re.match(r’^(\\d+)(0<em>)$’, ‘102300’).groups())<br>#Out[]:(‘102300’, ‘’)<br>#由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0</em>只能匹配空字符串了。</p>\n<p>#必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，<br>#加个?就可以让\\d+采用非贪婪匹配：</p>\n<p>#尽可能少 匹配<br>print(re.match(r’^(\\d+?)(0*)$’, ‘102300’).groups())<br>#out[]:(‘1023’, ‘00’)</p>\n<p>#编译<br>‘’’<br>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>\n<pre><code>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；\n\n用编译后的正则表达式去匹配字符串。</code></pre><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预<br>编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br>‘’’<br>re_telephone = re.compile(r’^(\\d{3})-(\\d{3,8})$’)<br>print(re_telephone.match(‘010-12345’).groups())<br>print(re_telephone.match(‘010-8086’).groups())</p>\n</li>\n</ul>\n<pre><code>#邮箱匹配1\nimport re\nEmail=input(&apos;please enter the Email:&apos;)\nre_mode=re.compile(r&apos;&lt;([a-zA-Z]* [a-zA-Z]*)&gt; [\\w.]*@\\w+.[a-z]*&apos;)\nwe=re_mode.match(Email)\nif we:\n    print(we.groups())\nelse:\n    print(&apos;failed!&apos;)\n\n#邮箱匹配2\nimport re\n&apos;&apos;&apos;\n&gt;&gt;&gt; 834930269@qq.com\nok!\n&apos;&apos;&apos;\ntest=input(&apos;please enter:&apos;)\nre_mode=re.compile(r&apos;[0-9a-zA-Z._]*@\\w+.com&apos;)\nif re_mode.match(test):\n    print(&apos;ok!&apos;)\nelse:\n    print(&apos;failed!&apos;)</code></pre>","text":"【Source Code】:point_right:Regular Expression模块s=’ABC\\-001’#对应正则表达式字符串为’ABC-001’<br>#因为python本身需要转义,但用 r 前缀的话,就可以忽略转义字符了<br>s=r’ABC-001’<br>i","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 sorted","slug":"python3-sorted","date":"2017-07-13T09:03:34.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-sorted.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/sorted/sorted.py\" target=\"_blank\" rel=\"noopener\">sorted.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>print(sorted([36, 5, -12, 9, -21]))</p>\n<p>#此外，sorted()函数也是一个高阶函数，它还可</p>\n<p>#以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：<br>print(sorted([36, 5, -12, 9, -21], key=abs))</p>\n<p>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’]))</p>\n<p>#我们给sorted传入key–函数–，即可实现忽略大小写的排序：<br>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower))</p>\n<p>#要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：<br>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower, reverse=True))</p>\n<p># In[5]:</p>\n<p>L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]</p>\n<p>#key是排序规则函数</p>\n<p># In[6]:</p>\n<p>#按名字排序<br>def by_name(t):<br>    return t[0]<br>L2 = sorted(L, key=by_name)<br>print(L2)</p>\n<p>#按成绩从高到低排序<br>def by_score(t):<br>    return -t[1]<br>L2 = sorted(L, key=by_score)<br>print(L2)</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: sorted.py **# coding: utf-8# In[1]:print(sorted([36, 5, -12, 9, -21]))#此外，sorted()函数也是一个高阶函数，它还可#以接收一个key函数来实现自定义的排序，例","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 定制类","slug":"python3-str-getatr","date":"2017-07-16T08:33:50.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-str-getatr.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:<a href=\"https://github.com/834930269/python_study/blob/master/oop/%E5%AE%9A%E5%88%B6%E7%B1%BB.py\" target=\"_blank\" rel=\"noopener\">定制类.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[3]:</p>\n<p>#__str__<br>class student(object):<br>    def __init__(self,name):<br>        self.name=name<br>    def __str__(self):<br>        return ‘Student object (name: %s)’ % self.name<br>    __repr__=__str__<br>s=student(‘Michael’)</p>\n<p>#__str__是控制打印时输出类型,__repr__是控制台直接s输出的类型</p>\n<p>#如果不重写,那会输出&lt;__main__.Student object at 地址&gt;<br>s<br>print(s)</p>\n<p># In[10]:</p>\n<p>#__iter__<br>‘’’<br>如果一个类想被用于for … in循环，类似list或tuple那样，就必<br>须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python<br>的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个<br>值，直到遇到StopIteration错误时退出循环。</p>\n<p>斐波那契:<br>‘’’<br>class Fib(object):<br>    def __init__(self):<br>        self.a, self.b = 0, 1 # 初始化两个计数器a，b</p>\n<pre><code>def \\_\\_iter\\_\\_(self):\n    return self # 实例本身就是迭代对象，故返回自己\n\ndef \\_\\_next\\_\\_(self):\n    self.a, self.b = self.b, self.a + self.b # 计算下一个值\n    if self.a &gt; 100000: # 退出循环的条件\n        raise StopIteration()\n    return self.a # 返回下一个值\ndef \\_\\_getitem\\_\\_(self, n):\n    if isinstance(n, int): # n是索引\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n    if isinstance(n, slice): # n是切片\n        start = n.start\n        stop = n.stop\n        if start is None:\n            start = 0\n        a, b = 1, 1\n        L = \\[\\]\n        for x in range(stop):\n            if x &gt;= start:\n                L.append(a)\n            a, b = b, a + b\n        return L</code></pre><p>for i in Fib():<br>    print(i)</p>\n<p># In[14]:</p>\n<p>#__getitem__</p>\n<p>#Fib实例虽然能作用于for循环，看起来和list有点像，</p>\n<p>#但是，把它当成list来使用还是不行</p>\n<p>#要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：<br>f=Fib()<br>print(f[0],f[1],f[2],f[100])<br>‘’’<br>但是list有个神奇的切片方法：</p>\n<blockquote>\n<blockquote>\n<p>&gt; list(range(100))[5:10]<br>[5, 6, 7, 8, 9]</p>\n</blockquote>\n</blockquote>\n<p>对于Fib却报错。原因是__getitem__()传入的参数<br>可能是一个int，也可能是一个 切片对象slice ，所以要做判断：</p>\n<p>class Fib(object):<br>    def __getitem__(self, n):<br>        if isinstance(n, int): # n是索引<br>        if isinstance(n, slice): # n是切片<br>‘’’<br>print(f[:20])#但是没有判断倒序切片以及没有对step参数作处理：</p>\n<p>‘’’<br>此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以<br>作key的object，例如str。</p>\n<p>与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋<br>值。最后，还有一个__delitem__()方法，用于删除某个元素。</p>\n<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的<br>list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”<br>，不需要强制继承某个接口。<br>‘’’</p>\n<p># In[18]:</p>\n<p>#__getattr__</p>\n<p>#正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：<br>class Student(object):<br>    def __init__(self):<br>        self.name = ‘Michael’<br>    def __getattr__(self, attr):<br>        if attr==’score’:<br>            return 99<br>        if attr==’age’:<br>            return lambda: 25<br>        raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)</p>\n<p>#调用name属性，没问题，但是，调用不存在的score属性，就有问题了<br>‘’’</p>\n<blockquote>\n<blockquote>\n<p>&gt; s = Student()<br>&gt; print(s.name)<br>Michael<br>&gt; print(s.score)<br>Traceback (most recent call last):<br>  …<br>AttributeError: ‘Student’ object has no attribute ‘score’<br>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>\n</blockquote>\n</blockquote>\n<p>要避免这个错误，除了可以加上一个score属性外，Python还有另<br>一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：<br>class Student(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self):\n    self.name = &apos;Michael&apos;\n\ndef \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;score&apos;:\n        return 99</code></pre><p>返回函数也是完全可以的：<br>class Student(object):</p>\n<pre><code>def \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;age&apos;:\n        return lambda: 25</code></pre><p>只是调用方式要变为：</p>\n<blockquote>\n<blockquote>\n<p>&gt; s.age()<br>25<br>注意，只有在没有找到属性的情况下，才调用__getattr__，<br>已有的属性，比如name，不会在__getattr__中查找。</p>\n</blockquote>\n</blockquote>\n<p>此外，注意到任意调用如s.abc都会返回None，这是因为我们<br>定义的__getattr__默认返回就是None。要让class只响应特定<br>的几个属性，我们就要按照约定，抛出AttributeError的错误：<br>raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)<br>‘’’<br>s=Student()<br>print(s.name,s.score,s.age())</p>\n<p># In[19]:</p>\n<p>‘’’<br>举个例子：</p>\n<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>\n<pre><code>http://api.server/user/friends\nhttp://api.server/user/timeline/list</code></pre><p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>\n<p>利用完全动态的__getattr__，我们可以写出一个链式调用：<br>‘’’<br>class Chain(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self, path=&apos;&apos;):\n    self._path = path\n\ndef \\_\\_getattr\\_\\_(self, path):\n    return Chain(&apos;%s/%s&apos; % (self._path, path))\n\ndef \\_\\_str\\_\\_(self):\n    return self._path\n\n\\_\\_repr\\_\\_ = \\_\\_str\\_\\_</code></pre><p>#try<br>print(Chain().status.user.timeline.list)</p>\n<p>#out[]: /status/user/timeline/list</p>\n<p>#这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，</p>\n<p>#而且，不随API的增加而改变！</p>\n<p>#还有些REST API会把参数放到URL中，比如GitHub的API：</p>\n<p>#GET /users/:user/repos</p>\n<p>#调用时，需要把:user替换为实际用户名。</p>\n<p># In[21]:</p>\n<p>#__call__<br>class Student(object):<br>    def __init__(self, name):<br>        self.name = name</p>\n<pre><code>def \\_\\_call\\_\\_(self):\n    print(&apos;My name is %s.&apos; % self.name)</code></pre><p>s = Student(‘Michael’)<br>s()</p>\n<p># In[29]:</p>\n<p>print(callable(max),callable(map),callable(str),callable(‘123’))</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github:定制类.py **# coding: utf-8# In[3]:#__str__<br>class student(object):<br>    def __init__(self,name):<br>        self.name","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 ThreadLocal线程局部变量","slug":"python3-threadloca","date":"2017-07-19T07:43:31.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-threadloca.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>局部变量传递,避免使用线程锁</strong> <strong>github:</strong></p>\n<ul>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/ThreadLocal.py\" target=\"_blank\" rel=\"noopener\">ThreadLocal.py</a></strong></li>\n</ul>\n<p>**#Thread-较量级线程</p>\n<p>#建议在多线程环境下用局部变量,但传递变量传递很麻烦</p>\n<p>‘’’<br>def process_student(name):<br>    std=Student(name)<br>    #std是局部变量,但是每个函数都要用它,因此必须传过去<br>    #一层一层的传<br>    do_task_1(std)<br>    do_task_2(std)</p>\n<p>def do_task_1(std):<br>    do_subtask_1(std)<br>    do_subtask_1(std)</p>\n<p>def do_task_2(std):<br>    do_subtask_2(std)<br>    do_subtask_2(std)<br>‘’’</p>\n<p>#考虑,以每层的thread对象作为key,值为操作对象</p>\n<p>class Student:<br>    def __init__(self,name):<br>        self.name=name</p>\n<p>global_dict = {}<br>def std_thread(name):<br>    std=Student(name)<br>    #吧std放到全局变量中dict中<br>    global_dict[threading.current_thread()]=std<br>    do_task_1()<br>    do_task_2()</p>\n<p>def do_task_1():<br>    #不传入std,而是根据当前线程查找<br>    std=global_dict[threading,current_thread()]<br>    #…</p>\n<p>def do_task_2():<br>    #任何函数都可以根据当前线程查找<br>    std=global_dict[threading,current_thread()]<br>    #…</p>\n<p>#ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事<br>import threading</p>\n<p>#创建全局ThreadLocal对象:<br>local_school=threading.local()<br>def process_student():<br>    #获取当前县城关联的student<br>    std=local_school.student<br>    print(‘Hello,%s (in %s)\\n’ % (std,threading.current_thread().name))</p>\n<p>def process_thread(name):<br>    #绑定ThreadLocal的student:<br>    local_school.student=name<br>    process_student()</p>\n<p>t1=threading.Thread(target=process_thread,args=(‘Alice’,),name=’Thread_A’)<br>t2=threading.Thread(target=process_thread,args=(‘Bob’,),name=’Thread_B’)<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()</p>\n<p>#ThreadLocal解决了线程锁的问题,把所有的变量都处理成局部变量,互不影响**</p>\n","text":"【Source Code】 局部变量传递,避免使用线程锁 github:ThreadLocal.py**#Thread-较量级线程#建议在多线程环境下用局部变量,但传递变量传递很麻烦‘’’<br>def process_student(name):<br>    std=Stud","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 常用模块","slug":"python3-useful-moudle","date":"2017-07-21T16:06:17.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-useful-moudle.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: 1. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/Base64.py\" title=\"Base64.py\" target=\"_blank\" rel=\"noopener\">Base64</a> 2. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/MD5%E5%8A%A0%E5%AF%86%E5%AF%86%E7%A0%81.py\" title=\"MD5加密密码.py\" target=\"_blank\" rel=\"noopener\">MD5加密密码.py</a> 3. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/SAX%E8%A7%A3%E6%9E%90XML.py\" title=\"SAX解析XML.py\" target=\"_blank\" rel=\"noopener\">SAX解析XML.py</a> 4. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/With%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86.py\" title=\"with语法实现模块管理.py\" target=\"_blank\" rel=\"noopener\">with语法实现模块管理.py</a> 5. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/datetime_M.py\" title=\"datetime.py\" target=\"_blank\" rel=\"noopener\">datetime.py</a></p>\n","text":"【Source Code】 github: 1. :point_right:Base64 2. :point_right:MD5加密密码.py 3. :point_right:SAX解析XML.py 4. :point_right:with语法实现模块管理.py 5. :poin","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 UDP+TCP-IP编程","slug":"python3-udptcp-ip","date":"2017-07-26T14:19:14.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-udptcp-ip.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: —-TCP: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/TCP-IP/echo-server.py\" title=\"服务端: echo-server.py\" target=\"_blank\" rel=\"noopener\">服务端: echo-server.py</a> 2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/TCP-IP/echo-client.py\" title=\"客户端: echo-client.py\" target=\"_blank\" rel=\"noopener\">客户端: echo-client.py</a> —-UDP: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/UDP/echo-server.py\" title=\"服务端: echo-server.py\" target=\"_blank\" rel=\"noopener\">服务端: echo-server.py</a> 2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/UDP/echo-client.py\" title=\"客户端: echo-client.py\" target=\"_blank\" rel=\"noopener\">客户端: echo-client.py</a> 【TCP】 服务端:</p>\n<pre><code>import socket,threading,time\n\n#协议IPV4 后者是基于流的TCP\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n\n#绑定,监听端口\ns.bind((&apos;127.0.0.1&apos;,9999))\n\n#最大连接数为5\ns.listen(5)\nprint(&apos;Watting for connection...&apos;)\n\ndef tcplink(sock,addr):\n    print(&apos;Accpet new connection from %s:%s...&apos; % addr)\n    sock.send(b&apos;Welcome!&apos;)\n    while True:\n        data=sock.recv(1024)\n        time.sleep(1)\n        if not data or data.decode(&apos;utf-8&apos;)==&apos;exit&apos;:\n            break\n        sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;))\n    sock.close()\n    print(&apos;Connection from %s:%s closed.&apos; % addr)\n\nwhile True:\n    #接受一个连接\n    sock,addr=s.accept()\n    #创建新线程来处理TCP连接\n    t=threading.Thread(target=tcplink,args=(sock,addr))\n    t.start()</code></pre><p>客户端:</p>\n<pre><code>import socket\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n#建立连接\ns.connect((&apos;127.0.0.1&apos;,9999))\n#接受欢迎消息\nprint(s.recv(1024).decode(&apos;utf-8&apos;))\nfor data in [b&apos;Michael&apos;,b&apos;Tracy&apos;,b&apos;Sarah&apos;]:\n    #发送数据:\n    s.send(data)\n    print(s.recv(1024).decode(&apos;utf-8&apos;))\ns.send(b&apos;exit&apos;)\ns.close</code></pre><p>【UDP】 服务端:</p>\n<pre><code>import socket,threading,time\n\n#IPV4,UDP\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n#绑定端口\ns.bind((&apos;127.0.0.1&apos;,9999))\nprint(&apos;Bind UDP on 9999...&apos;)\n\ndef udplink(data,addr):\n    s.sendto(b&apos;Hello, %s!&apos; % data,addr)\n\nwhile True:\n    #接收数据\n    #recvfrom()方法返回数据和客户端的地址与端口\n    data,addr=s.recvfrom(1024)\n    t=threading.Thread(target=udplink,args=(data,addr))\n    time.sleep(1)\n    t.start()</code></pre><p>客户端:</p>\n<pre><code>import socket\n\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n\nfor data in [b&apos;Michael&apos;,b&apos;Tracy&apos;,b&apos;Sarah&apos;]:\n    #发送数据\n    s.sendto(data,(&apos;127.0.0.1&apos;,9999))\n    #接收数据\n    print(s.recv(1024).decode(&apos;utf-8&apos;))\ns.close()</code></pre>","text":"【Source Code】 github: —-TCP: 1.:point_right:服务端: echo-server.py 2.:point_right:客户端: echo-client.py —-UDP: 1.:point_right:服务端: echo-server.py","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 生成器+杨辉三角+yield+异常StopIteration","slug":"python3-yield-stopiteration","date":"2017-07-12T08:04:07.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-yield-stopiteration.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/generator/%E7%94%9F%E6%88%90%E5%99%A8.py\" target=\"_blank\" rel=\"noopener\">github: 生成器.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>‘’’<br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，<br>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，<br>那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元<br>素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制<br>，称为生成器：generator。<br>‘’’</p>\n<p>#要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：<br>L=[x<em>x for x in range(10)]<br>print(L)<br>g=(x</em>x for x in range(10))<br>print(g)</p>\n<p>#out[1]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</p>\n<p>#out[2]:  at 0x0000000004C2FB48&gt;</p>\n<p># In[3]:</p>\n<p>‘’’<br>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>\n<p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？</p>\n<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：<br>generator必须紧跟着输入,否则用next()只能输出一次循环</p>\n<p>‘’’<br>g=(x*x for x in range(10))<br>i=0<br>while i&lt;10:<br>    print(next(g))<br>    i+=1</p>\n<p># In[10]:</p>\n<p>#用for<br>g=(x*x for x in range(10))<br>for n in g:<br>    print(n)</p>\n<p># In[6]:</p>\n<p>#斐波那契</p>\n<p>#注意,赋值语句 a,b=b,a+b</p>\n<p>#相当于<br>‘’’<br>t = (b, a + b) # t是一个tuple<br>a = t[0]<br>b = t[1]</p>\n<p>‘’’<br>def fib(max):<br>    n,a,b=0,0,1<br>    while n</p>\n<p>#想要在循环中得到fib2的return值,必须捕获StopIteration错误返回值包括在</p>\n<p>#其中的value中<br>while True:<br>    try:<br>        x=next(f)<br>        print(‘f:’,x)<br>    except StopIteration as ev:<br>        print(‘Generator return value:’,ev.value)<br>        break</p>\n<p># In[17]:</p>\n<p>#yield举例<br>def odd():<br>    print(‘step 1’)<br>    yield 1<br>    print(‘step 2’)<br>    yield(3)<br>    print(‘step 3’)<br>    yield(5)<br>o=odd()<br>print(‘之前没输出’)<br>for n in o:<br>    print(n)</p>\n<p># In[ ]:</p>\n<p>#test<br>‘’’<br>杨辉三角定义如下：</p>\n<pre><code>      1\n    1   1\n  1   2   1\n1   3   3   1</code></pre><p>  1   4   6   4   1<br>1   5   10  10  5   1<br>‘’’<br>def triangles():<br>    L=[1]<br>    while True:<br>        yield L<br>        l=len(L)<br>        R=[1]<br>        for i in range(1,l):<br>            R.append(L[i-1]+L[i])<br>        R.append(1)<br>        L=R[:]<br>‘’’<br>第二种解法,中间为中间列表,和上面一样,只不过直接加起来了,避免了中间变量<br>def triangles():<br>l = [1]<br>while True:<br>    yield l<br>    l = [1] + [l[i]+l[i+1] for i in range(len(l)-1)] + [1]<br>‘’’<br># 期待输出:<br># [1]<br># [1, 1]<br># [1, 2, 1]<br># [1, 3, 3, 1]<br># [1, 4, 6, 4, 1]<br># [1, 5, 10, 10, 5, 1]<br># [1, 6, 15, 20, 15, 6, 1]<br># [1, 7, 21, 35, 35, 21, 7, 1]<br># [1, 8, 28, 56, 70, 56, 28, 8, 1]<br># [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]<br>n = 0<br>for t in triangles():<br>    print(t)<br>    n = n + 1<br>    if n == 10:<br>        break**</p>\n","text":"【Source Code】 github: 生成器.py**# coding: utf-8# In[1]:‘’’<br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，<br>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"聊天室内核从0开始 – 3 Seq2Seq","slug":"seq2seq","date":"2019-01-06T14:32:09.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/seq2seq.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Seq2Seq\"><a href=\"#Seq2Seq\" class=\"headerlink\" title=\"Seq2Seq\"></a>Seq2Seq</h1><p>关于Seq2Seq模型,看如下博客即可,针对的视频讲解可以去BliBli搜相关视频,基本一致. <a href=\"https://blog.csdn.net/wangyangzhizhou/article/details/77883152\" title=\"深度学习的seq2seq模型\" target=\"_blank\" rel=\"noopener\">深度学习的seq2seq模型</a></p>\n<blockquote>\n<p>注意要看下注意力机制</p>\n</blockquote>\n<h1 id=\"tensorflow-基础\"><a href=\"#tensorflow-基础\" class=\"headerlink\" title=\"tensorflow 基础\"></a>tensorflow 基础</h1><h1 id=\"项目完整代码-有空写其他的\"><a href=\"#项目完整代码-有空写其他的\" class=\"headerlink\" title=\"项目完整代码(有空写其他的)\"></a>项目完整代码(有空写其他的)</h1><blockquote>\n<p>这个项目中仅有一个训练一轮的模型(所以仅供看看).如果有需要还是要训练多点,但是前提当然是你有一个好的机器或者服务器,如果有信用卡也可以选择取Github Cloud 或者AWS上选择免费的服务器来帮你训练(时间会很长)</p>\n</blockquote>\n<p><a href=\"https://pan.baidu.com/s/1D18ZwROdqyilBuy6EU4xLA\" title=\"chatbot2\" target=\"_blank\" rel=\"noopener\">chatbot2</a></p>\n","text":"Seq2Seq关于Seq2Seq模型,看如下博客即可,针对的视频讲解可以去BliBli搜相关视频,基本一致. 深度学习的seq2seq模型注意要看下注意力机制tensorflow 基础项目完整代码(有空写其他的)这个项目中仅有一个训练一轮的模型(所以仅供看看).如果有需要还是要训","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"机器学习","slug":"Python/机器学习","count":2,"path":"api/categories/Python/机器学习.json"},{"name":"聊天机器人内核","slug":"Python/机器学习/聊天机器人内核","count":1,"path":"api/categories/Python/机器学习/聊天机器人内核.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"},{"name":"聊天机器人内核","slug":"聊天机器人内核","count":3,"path":"api/tags/聊天机器人内核.json"}]},{"title":"淘宝竞价爬虫","slug":"taobao-bug","date":"2017-09-06T23:40:58.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/taobao-bug.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/09/1-1.png","content":"<p>首先我们先观察搜索为书包的链接: 第一页: <code>https://s.taobao.com/search?q=书包&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.50862.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170906</code> 第二页: <code>https://s.taobao.com/search?q=书包imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.50862.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170906&amp;bcoffset=4&amp;ntoffset=4&amp;p4ppushleft=1%2C48&amp;s=44</code> 我们可以观察到书包的属性是q,而每页有44个商品,所以页数的属性是s. 所以我们推测当链接为: <code>http://s.taobao.com/search?q=书包&amp;s=44</code> 时,时当前搜索目录的第二页. 首先是getHTMLtext:</p>\n<pre><code>def getHTMLtext(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n        return r.text\n    except:\n        print(&quot;&quot;)</code></pre><p>然后我们分析代码,比如第一页第一件商品的价钱如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/1-1.png\" alt=\"第一件\" title=\"第一件\"> 我们在代码页搜索对应的价格89.00,发现对应的标记是’view_price’: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/2-1.png\" alt=\"89.00\" title=\"89.00\"> 然后是对应的标题,这里有一些问题,因为第一个东西的标题和显示的对不上,显示的是放在’title’标记中,而不知道什么的标题放在’raw_title’中: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/3-1.png\" alt> 然后我们开始编写parse方法:</p>\n<pre><code>def parsePage(til,text):\n    try:\n        r1=re.compile(r&apos;&quot;view_price&quot;:&quot;[\\d.]*&quot;&apos;)\n        r2=re.compile(r&apos;&quot;raw_title&quot;:&quot;.*?&quot;&apos;)\n        lip=re.findall(r1,text)\n        lit=re.findall(r2,text)\n        for i in range(len(lip)):\n            price=eval(lip[i].split(&apos;:&apos;)[1])\n            title=eval(lit[i].split(&apos;:&apos;)[1])\n            til.append([price,title])\n    except:\n        print(&apos;&apos;)</code></pre><p>其中eval可以忽略””这玩意？？？ 最终完成品:</p>\n<pre><code>#-*-coding:utf-8-*-\nimport requests\nimport re\n\ndef getHTMLtext(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n        return r.text\n    except:\n        print(&quot;&quot;)\n\n\ndef parsePage(til,text):\n    try:\n        r1=re.compile(r&apos;&quot;view_price&quot;:&quot;[\\d.]*&quot;&apos;)\n        r2=re.compile(r&apos;&quot;raw_title&quot;:&quot;.*?&quot;&apos;)\n        lip=re.findall(r1,text)\n        lit=re.findall(r2,text)\n        for i in range(len(lip)):\n            price=eval(lip[i].split(&apos;:&apos;)[1])\n            title=eval(lit[i].split(&apos;:&apos;)[1])\n            til.append([price,title])\n    except:\n        print(&apos;&apos;)\n\ndef printResult(lis):\n    tplt=&quot;{:4}\\t{:8}\\t{:16}&quot;\n    print(tplt.format(&apos;序号&apos;,&apos;价格&apos;,&apos;商品名称&apos;))\n    for i in range(len(lis)):\n        print(tplt.format(i+1,lis[i][0],lis[i][1]))\n        if lis[i][0]==&apos;89.00&apos;:\n            print(&apos;===============&apos;)\n\ndef main():\n    goods=&apos;书包&apos;\n    deepth=3\n    infolist=[]\n    start_url=&apos;https://s.taobao.com/search?q=书包&apos;\n    for i in range(deepth):\n        try:\n            url=start_url+&apos;&amp;s=&apos;+str(i*44)\n            text=getHTMLtext(url)\n            parsePage(infolist,text)\n        except:\n            continue\n    printResult(infolist)\n\nmain()</code></pre><p>结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/09/4-1.png\" alt></p>\n","text":"首先我们先观察搜索为书包的链接: 第一页: https://s.taobao.com/search?q=书包&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"},{"name":"爬虫","slug":"Python/未分类/爬虫","count":2,"path":"api/categories/Python/未分类/爬虫.json"}],"tags":[{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"Web Application","slug":"web-application","date":"2017-11-04T08:32:16.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/web-application.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Link <a href=\"http://cizixs.com/2015/09/21/what-is-a-web-framework\" target=\"_blank\" rel=\"noopener\">什么是Web框架</a> 一个简单的可以处理get和post的Web Application, 其中如果80端口不能访问就换成其他端口即可.</p>\n<pre><code>import socket\n\nHOST = &apos;&apos; #localhost\nPORT = 80 #监听80端口,如果不行就换成其他端口\nlisten_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#协议部分\nlisten_socket.bind((HOST,PORT))#只允许迭代类型么？\nlisten_socket.listen(1)\nconnection,address = listen_socket.accept()\nrequest = connection.recv(1024)\nconnection.sendall(b&quot;&quot;&quot;HTTP/1.1 200 OK\nContent-type: text/html\n\n\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;&quot;&quot;)#返回的响应以及data,但必须转一下bytes类型\nconnection.close()</code></pre><p>（如果上面的程序报端口错误，可以把 PORT 的值修改成其他值，比如 8080。） 上面的代码只会接收一个连接和一个请求，不管请求的 URL 是什么，都会返回同样的 HTTP 内容，response code 是 200。（很明显，这不算真正的 web server）。在这个例子，我们告诉客户端，返回的数据格式为 HTML，而不是其他的格式，比如 JSON。</p>\n","text":"Link 什么是Web框架 一个简单的可以处理get和post的Web Application, 其中如果80端口不能访问就换成其他端口即可.import socketHOST = &apos;&apos; #localhostPORT = 80 #监听80端口,如果不行就换成其","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"Web_Application","slug":"Python/Web-Application","count":1,"path":"api/categories/Python/Web-Application.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Web_Application","slug":"Web-Application","count":1,"path":"api/tags/Web-Application.json"}]},{"title":"词云: Python爬取国际时事","slug":"wordcloud-python","date":"2018-04-01T11:30:24.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/wordcloud-python.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190628.jpg","content":"<h1 id=\"前置工具\"><a href=\"#前置工具\" class=\"headerlink\" title=\"前置工具\"></a>前置工具</h1><blockquote>\n<p>python wordcloud jieba BeautifulSoup matplotlib scipy</p>\n</blockquote>\n<h1 id=\"第一步-爬取国际时事列表\"><a href=\"#第一步-爬取国际时事列表\" class=\"headerlink\" title=\"第一步: 爬取国际时事列表\"></a>第一步: 爬取国际时事列表</h1><h2 id=\"待爬地址-http-m-sohu-com-cr-57-page-1-amp-v-2\"><a href=\"#待爬地址-http-m-sohu-com-cr-57-page-1-amp-v-2\" class=\"headerlink\" title=\"待爬地址: http://m.sohu.com/cr/57/?page=1&amp;v=2\"></a>待爬地址: <a href=\"http://m.sohu.com/cr/57/?page=1&amp;v=2\" target=\"_blank\" rel=\"noopener\">http://m.sohu.com/cr/57/?page=1&amp;v=2</a></h2><blockquote>\n<p>首先我们可以观察到,每点击列表中的下一页时, page 会加一</p>\n<blockquote>\n<p>然后我们就可以确认,想获取多少条信息,直接替换page属性的值即可</p>\n</blockquote>\n<p>然后我们观察想要爬取的内容:</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190628.jpg\" alt></p>\n<h2 id=\"审查元素\"><a href=\"#审查元素\" class=\"headerlink\" title=\"审查元素:\"></a>审查元素:</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190805.jpg\" alt></p>\n<blockquote>\n<p>我们发现文本都是在 div(class=”bd3 pb1”) -&gt; div -&gt; p -&gt; a 标签下的:</p>\n</blockquote>\n<h2 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h2><blockquote>\n<p>爬取数据并保存在<strong>data.txt</strong>中:</p>\n</blockquote>\n<pre><code># coding: utf-8\n\nfrom wordcloud import WordCloud\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        pass\n\ndef has_p_a(tag):\n    pass\n\ndef getWannaData(stockURL,res):\n    html = getHTMLText(stockURL)\n    soup = BeautifulSoup(html,&apos;html.parser&apos;)\n    p = soup.find(&apos;div&apos;,class_=&quot;bd3 pb1&quot;).find_all(&apos;a&apos;)\n    for q in p:\n        res.append(q.text)\n\nres = []\nmaxn = 100\nfor i in range(1,maxn):\n    getWannaData(&apos;http://m.sohu.com/cr/57/?page=&apos;+str(i)+&apos;&amp;v=2&apos;,res)\n\nfile = open(&apos;data.txt&apos;,&apos;a+&apos;)\nfor q in res:\n    file.write(q+&apos;\\n&apos;)</code></pre><blockquote>\n<p>其中maxn是控制爬取多少页的</p>\n</blockquote>\n<h2 id=\"data-txt-部分内容\"><a href=\"#data-txt-部分内容\" class=\"headerlink\" title=\"data.txt 部分内容:\"></a>data.txt 部分内容:</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401191238.jpg\" alt></p>\n<h1 id=\"第二步-生成词云\"><a href=\"#第二步-生成词云\" class=\"headerlink\" title=\"第二步: 生成词云\"></a>第二步: 生成词云</h1><h2 id=\"前置\"><a href=\"#前置\" class=\"headerlink\" title=\"前置\"></a>前置</h2><blockquote>\n<p>因为要进行中文分词,所以要用jieba 注意再打开<strong>data.txt</strong>时<strong>编码</strong>问题 还有ttf不能保存在有中文的路径下</p>\n</blockquote>\n<h2 id=\"背景图片\"><a href=\"#背景图片\" class=\"headerlink\" title=\"背景图片\"></a>背景图片</h2><blockquote>\n<p>我们选择 <strong>水伊布.png</strong></p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/timg.jpg\" alt></p>\n<h2 id=\"生成词云\"><a href=\"#生成词云\" class=\"headerlink\" title=\"生成词云\"></a>生成词云</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/yb.png\" alt> <strong>容我说一句,在中国相对封闭的网络环境中,已经可以看到世界如此的乱了,全部的词条大部分是消极的…看起来大规模战争结束的时间太久了…(还是说,世界就没有安宁过)</strong></p>\n<blockquote>\n<p>这张图可以找到安倍</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/yb2.png\" alt></p>\n","text":"前置工具python wordcloud jieba BeautifulSoup matplotlib scipy第一步: 爬取国际时事列表待爬地址: http://m.sohu.com/cr/57/?page=1&amp;v=2首先我们可以观察到,每点击列表中的下一页时, pa","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"爬虫","slug":"Python/爬虫","count":2,"path":"api/categories/Python/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"Python Learnning Record","slug":"python-learnning-record","date":"2017-05-21T03:42:53.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-learnning-record.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/0.png","content":"<p><strong>【Link】</strong> <strong><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"noopener\">廖雪峰的python教程</a></strong> <strong>【直接运行py文件】</strong> <strong>有同学问，能不能像.exe文件那样直接运行<code>.py</code>文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在<code>.py</code>文件的第一行加上一个特殊的注释：</strong></p>\n<p>**`#!/usr/bin/env python3</p>\n<p>print(‘hello, world’)`** </p>\n<p><strong>然后，通过命令给<code>hello.py</code>以执行权限：</strong></p>\n<p><strong><code>$ chmod a+x hello.py</code></strong> </p>\n<p><strong>就可以直接运行<code>hello.py</code>了，比如在Mac下运行：</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/0.png\" alt></strong> <strong>【数据类型和变量】</strong> <strong>Python可以处理任意大小的整数，当然包括负整数. (惊了</strong> <strong>注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在<code>-2147483648</code>-<code>2147483647</code>。</strong> <strong>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</strong> <strong>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</strong></p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a><strong>字符串</strong></h4><p><strong>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</strong> <strong>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\\</code>来标识，比如：</strong></p>\n<p><strong><code>&#39;I\\&#39;m \\&quot;OK\\&quot;!&#39;</code></strong> </p>\n<p><strong>表示的字符串内容是：</strong></p>\n<p><strong><code>I&#39;m &quot;OK&quot;!</code></strong> </p>\n<p><strong>如果字符串里面有很多字符都需要转义，就需要加很多<code>\\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：</strong></p>\n<p>**`&gt;&gt;&gt; print(‘\\\\t\\‘)<br>\\       \\</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>print(r’\\\\t\\‘)<br>\\\\t\\`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果字符串内部有很多换行，用<code>\\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，可以自己试试：</strong></p>\n<p><strong><code>&gt;&gt;&gt; print(&#39;&#39;&#39;line1\n... line2\n... line3&#39;&#39;&#39;)\nline1\nline2\nline3</code></strong> </p>\n<p><strong>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入。如果写成程序，就是：</strong></p>\n<p><strong><code>print(&#39;&#39;&#39;line1\nline2\nline3&#39;&#39;&#39;)</code></strong> </p>\n<p><strong>多行字符串<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>还可以在前面加上<code>r</code>使用，请自行测试。</strong></p>\n<h4 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a><strong>空值</strong></h4><p><strong>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</strong> <strong>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</strong> <strong>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</strong></p>\n<p><strong><code>a = 123 # a是整数\nprint(a)\na = &#39;ABC&#39; # a变为字符串\nprint(a)</code></strong> </p>\n<p><strong>【整数的除法】</strong> <strong>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是<code>/</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 / 3\n3.3333333333333335</code></strong> </p>\n<p><strong><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 9 / 3\n3.0</code></strong> </p>\n<p><strong>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 // 3\n3</code></strong> </p>\n<p><strong>你没有看错，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</strong></p>\n<p><strong>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 % 3\n1</code></strong> </p>\n<p><strong>无论整数做<code>//</code>除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</strong> <strong>【字节】</strong> <strong>最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</strong> <strong>【编码】</strong> <strong>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</strong> <strong>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</strong> <strong>UTF-8:可变长编码.</strong> <strong>Unicode:不可变长全码.</strong> <strong>转换过程:</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/1-1.png\" alt></strong>   <strong>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/2.png\" alt></strong> <strong>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</strong> ** 【python的字符串】** ** 搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。** <strong>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</strong></p>\n<p><strong><code>&gt;&gt;&gt; print(&#39;包含中文的str&#39;)\n包含中文的str</code></strong> </p>\n<p><strong>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</strong></p>\n<p>**`&gt;&gt;&gt; ord(‘A’)<br>65</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>ord(‘中’)<br>20013<br>chr(66)<br>‘B’<br>chr(25991)<br>‘文’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;\\u4e2d\\u6587&#39;\n&#39;中文&#39;</code></strong> </p>\n<p><strong>【网络中文本的比特流传输转换】</strong> <strong>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</strong></p>\n<p><strong><code>x = b&#39;ABC&#39;</code></strong> </p>\n<p><strong>要注意区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</strong></p>\n<p><strong>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</strong></p>\n<p>**`&gt;&gt;&gt; ‘ABC’.encode(‘ascii’)<br>b’ABC’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘中文’.encode(‘utf-8’)<br>b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’<br>‘中文’.encode(‘ascii’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-1: ordinal not in range(128)`** </module></stdin></p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</strong></p>\n<p><strong>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\\x##</code>显示。</strong></p>\n<p><strong>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</strong></p>\n<p>**`&gt;&gt;&gt; b’ABC’.decode(‘ascii’)<br>‘ABC’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’.decode(‘utf-8’)<br>‘中文’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数：</strong></p>\n<p>**`&gt;&gt;&gt; len(‘ABC’)<br>3</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>len(‘中文’)<br>2`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</strong></p>\n<p>**`&gt;&gt;&gt; len(b’ABC’)<br>3</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>len(b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’)<br>6<br>len(‘中文’.encode(‘utf-8’))<br>6`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</strong></p>\n<p><strong>【格式化输入输出】</strong></p>\n<p><strong>最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似<code>&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/3.png\" alt></strong> <strong>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</strong></p>\n<p>**`&gt;&gt;&gt; ‘Hello, %s’ % ‘world’<br>‘Hello, world’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘Hi, %s, you have $%d.’ % (‘Michael’, 1000000)<br>‘Hi, Michael, you have $1000000.’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>你可能猜到了，<code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</strong> <strong>常见的占位符有：</strong></p>\n<p><strong>%d</strong></p>\n<p><strong>整数</strong></p>\n<p><strong>%f</strong></p>\n<p><strong>浮点数</strong></p>\n<p><strong>%s</strong></p>\n<p><strong>字符串</strong></p>\n<p><strong>%x</strong></p>\n<p><strong>十六进制整数</strong></p>\n<p><strong>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</strong></p>\n<p>**`&gt;&gt;&gt; ‘%2d-%02d’ % (3, 1)<br>‘ 3-01’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘%.2f’ % 3.1415926<br>‘3.14’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;Age: %s. Gender: %s&#39; % (25, True)\n&#39;Age: 25. Gender: True&#39;</code></strong> </p>\n<p><strong>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;growth rate: %d %%&#39; % 7\n&#39;growth rate: 7 %&#39;</code></strong> </p>\n<p><strong>【list】</strong> <strong>如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</strong></p>\n<blockquote>\n<p><strong><code>&gt; classmates[-1] &#39;Tracy&#39;</code></strong> <strong><code>往后分块记笔记...</code></strong></p>\n</blockquote>\n<p><strong>【python3学习 模块】</strong> <strong>python3内置模块文档: <a href=\"https://docs.python.org/3/library/functions.html\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/3/library/functions.html</a></strong> <strong>python3自己写模块及使用: <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431845183474e20ee7e7828b47f7b7607f2dc1e90dbb000\" target=\"_blank\" rel=\"noopener\">廖雪峰-使用模块</a></strong> <strong>python3安装第三方模块:</strong> <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186362353505516c5d4e38456fb225c18cc5b54ffb000#0\" target=\"_blank\" rel=\"noopener\"><strong>安装第三方模块</strong></a></p>\n","text":"【Link】 廖雪峰的python教程 【直接运行py文件】 有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：**`#!/usr/bin/env python3","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"聊天室内核从0开始 – 2 处理语料库","slug":"type-3","date":"2019-01-04T12:48:01.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/type-3.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>最后更新于2019/1/4</p>\n</blockquote>\n<h1 id=\"处理语料库\"><a href=\"#处理语料库\" class=\"headerlink\" title=\"处理语料库\"></a>处理语料库</h1><h2 id=\"简单处理提问与应答\"><a href=\"#简单处理提问与应答\" class=\"headerlink\" title=\"简单处理提问与应答\"></a>简单处理提问与应答</h2><blockquote>\n<p>这里我们本来可以用jieba或者其他的一些库来帮忙分词,但是因为网上存在已经分好词的语料库,所以可以省略这一步. 至于语料库,可以在github上直接搜索语料库即可以搜到. 一般语料库如下:</p>\n</blockquote>\n<pre><code>E\nM 呵/呵\nM 是/王/若/猫/的/。\nE\nM 不/是\nM 那/是/什/么/？\nE\nM 怎/么/了\nM 我/很/难/过/，/安/慰/我/~\nE\nM 开/心/点/哈/,/一/切/都/会/好/起/来\nM 嗯/ /会/的</code></pre><p>其中E代表是下一组应答的开始,M代表的是一句话. 可以认为是一问一答.</p>\n<h2 id=\"将一个句子编码化\"><a href=\"#将一个句子编码化\" class=\"headerlink\" title=\"将一个句子编码化\"></a>将一个句子编码化</h2><blockquote>\n<p>因为我们如果企图对一个句子进行判断和操作时,我们需要将这串句子编码化成为一组数字更为方便,且占内存更少. 当然,我们用这组句子编码成数字以后也可以重新根据数字编码回字符.</p>\n</blockquote>\n<p>举个栗子: map[3]=’a’,map[2]=’b’ 则 32 = ab,且 ba = 23</p>\n<blockquote>\n<p>Python的一个语法糖:</p>\n<blockquote>\n<p>[2]*2=[2,2]</p>\n</blockquote>\n<p>2019/1/9 日更新-完善注释</p>\n</blockquote>\n<pre><code>import numpy as np\n\n# 句子编码化\nclass WordSequence(object):\n    #标注TAG\n    PAD_TAG=&apos;&lt;pad&gt;&apos;\n    UNK_TAG=&apos;&lt;unk&gt;&apos; # 未识别\n    START_TAG=&apos;&lt;s&gt;&apos;\n    END_TAG=&apos;&lt;/s&gt;&apos;\n\n    PAD=0\n    UNK=1\n    START=2\n    END=3\n\n    # 初始化标签\n    def __init__(self):\n        self.dict = {\n            WordSequence.PAD_TAG: WordSequence.PAD,\n            WordSequence.UNK_TAG: WordSequence.UNK,\n            WordSequence.START_TAG: WordSequence.START,\n            WordSequence.END_TAG: WordSequence.END\n        }\n        # 是否训练过了\n        self.fited=False\n\n    # 将word的词性转换为下标\n    def to_index(self,word):\n        assert self.fited,&apos;WordSequence尚未进行fit操作&apos;\n        # 如果有,返回下标\n        if word in self.dict:\n            return self.dict[word]\n        # 没有,返回UNKnow\n        return WordSequence.UNK\n\n    def to_word(self,index):\n        assert self.fited,&apos;WordSequence尚未进行fit操作&apos;\n        # 遍历dict,找到就返回value\n        for k,v in self.dict.items():\n            if v==index:\n                return k\n        # 否则返回不知道\n        return WordSequence.UNK_TAG\n\n    def size(self):\n        assert self.fited, &apos;WordSequence尚未进行fit操作&apos;\n        return len(self.dict) + 1\n\n    def __len__(self):\n        return self.size()\n\n    # 对数据进行处理\n    def fit(self,sentences,min_count=5,max_count=None,max_features=None):\n        assert not self.fited, &apos;WordSequence只能进行一次fit&apos;\n\n        count={}\n        # 遍历所有句子\n        for sentence in sentences:\n            arr=list(sentence)\n            # 统计词频\n            for a in arr:\n                if a not in count:\n                    count[a]=0\n                count[a]+=1\n        # 只统计词频大于最小值的\n        if min_count is not None:\n            count={k:v for k,v in count.items() if v&gt;=min_count}\n        # 仅统计词频小于最大值的\n        if max_count is not None:\n            count={k:v for k,v in count.items() if v&lt;=max_count}\n\n        # 如果有特征值数的限制,比如[1,2,3]max_features=2,则\n        # 需要用的是[1,2]\n        if isinstance(max_features,int):\n            # list(dict)=[(key,value),...]\n            count = sorted(list(count.items()),key=lambda x:x[1])\n            if max_features is not None and len(count) &gt; max_features:\n                count = count[-int(max_features):]# 从尾部向前\n            # 这个以及下面那个类似于前向星式存图法里的\n            # 下标递增式存法,即加入一个元素,该元素下标\n            # 变成当前已存在的元素个数\n            # 就是把count中的key作为dict的key\n            # 在dict中的下标作为dict的value\n            for w,_ in count:\n                self.dict[w]=len(self.dict)\n        else:\n            for w in sorted(count.keys()):\n                self.dict[w]=len(self.dict)\n\n        # 处理完成\n        self.fited=True\n\n    # 序列成数列\n    def transform(self, sentence, max_len=None):\n        assert self.fited, &apos;WordSequence尚未进行fit操作&apos;\n        # PAD -&gt; 填充标签,先填充本来的句子长度所有元素为PAD\n        # 如: [&apos;&lt;PAD&gt;&apos;,&apos;&lt;PAD&gt;&apos;...]\n        if max_len is not None:\n            r = [self.PAD] * max_len\n        else:\n            r = [self.PAD] * len(sentence)\n\n        for index, a in enumerate(sentence):\n            if max_len is not None and index &gt;= len(r):\n                break\n            r[index] = self.to_index(a)\n\n        return np.array(r)\n\n    # 序列转回字母\n    def inverse_transform(self, indices, ignore_pad=False, ignore_unk=False, ignore_start=False, ignore_end=False):\n        ret = []\n        for i in indices:\n            word = self.to_word(i)\n            if word == WordSequence.PAD_TAG and ignore_pad:\n                continue\n            if word == WordSequence.UNK_TAG and ignore_unk:\n                continue\n            if word == WordSequence.START_TAG and ignore_start:\n                continue\n            if word == WordSequence.END_TAG and ignore_end:\n                continue\n\n            ret.append(word)\n\n        return ret\n\n\ndef test():\n    ws = WordSequence()\n    ws.fit([[&apos;你&apos;, &apos;好&apos;, &apos;啊&apos;], [&apos;你&apos;, &apos;好&apos;, &apos;哦&apos;], ])\n\n    indice = ws.transform([&apos;我&apos;, &apos;们&apos;, &apos;好&apos;])\n    print(indice)\n\n    back = ws.inverse_transform(indice)\n    print(back)\n\n\nif __name__ == &apos;__main__&apos;:\n    test()</code></pre><blockquote>\n<p>可以发现其实都是一些简单的映射.将每个字符都映射到一个整数上面去.</p>\n<blockquote>\n<p>这样做以后再将其打包成pkl会大大减少占用硬盘: 83MB-&gt;750kb 了解一下</p>\n</blockquote>\n</blockquote>\n<h2 id=\"对于语料中句子的规范化\"><a href=\"#对于语料中句子的规范化\" class=\"headerlink\" title=\"对于语料中句子的规范化\"></a>对于语料中句子的规范化</h2><blockquote>\n<p>这里我们提供三个函数(可自行编码):</p>\n</blockquote>\n<pre><code># 这个函数的作用是在有多个回答的条件下将回答合并起来\ndef make_split(line):\n    if re.match(r&apos;.*([，···?!\\.,!？])$&apos;, &apos;&apos;.join(line)):\n        return []\n\n    return [&apos;, &apos;]\n\n# 是否是一个有意义的句子(这里我们不做规则)\ndef good_line(line):\n    #if len(re.findall(r&apos;[a-zA-Z0-9]&apos;, &apos;&apos;.join(line))) &gt; 2:\n        #return False\n    return True\n\n# 规范化语料,即对于已提取出的预料中的句子进行处理\ndef regular(sen):\n    #sen = re.sub(r&apos;\\.{3,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;···{2,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;[,]{1,100}&apos;, &apos;，&apos;, sen)\n    #sen = re.sub(r&apos;[\\.]{1,100}&apos;, &apos;。&apos;, sen)\n    #sen = re.sub(r&apos;[\\?]{1,100}&apos;, &apos;？&apos;, sen)\n    #sen = re.sub(r&apos;[!]{1,100}&apos;, &apos;！&apos;, sen)\n\n    return sen</code></pre><blockquote>\n<p>可以发现我基本都注释掉了,因为小黄鸡的语料库就是标准的一问一答,不是自然地语料库(微信随便提取的那类),所以不需要过多的处理.</p>\n</blockquote>\n<h2 id=\"打包成pkl文件\"><a href=\"#打包成pkl文件\" class=\"headerlink\" title=\"打包成pkl文件\"></a>打包成pkl文件</h2><blockquote>\n<p>首先说一下pkl文件:</p>\n<blockquote>\n<p>pkl文件是Python运行时产生的数据序列化后存储下来的文件格式,类似于其他语言的序列化.方便以后的继续使用和读取.</p>\n</blockquote>\n</blockquote>\n<p>具体的处理语料库和打包(一问一答Tuple)代码如下:</p>\n<pre><code># -*- coding:utf-8 -*-\n\nimport re\nimport pickle\nimport sys\nfrom tqdm import tqdm\n\n\ndef make_split(line):\n    if re.match(r&apos;.*([，···?!\\.,!？])$&apos;, &apos;&apos;.join(line)):\n        return []\n\n    return [&apos;, &apos;]\n\n# 是否是一个有意义的句子(这里我们不做规则)\ndef good_line(line):\n    #if len(re.findall(r&apos;[a-zA-Z0-9]&apos;, &apos;&apos;.join(line))) &gt; 2:\n        #return False\n    return True\n\n# 规范化语料\ndef regular(sen):\n    #sen = re.sub(r&apos;\\.{3,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;···{2,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;[,]{1,100}&apos;, &apos;，&apos;, sen)\n    #sen = re.sub(r&apos;[\\.]{1,100}&apos;, &apos;。&apos;, sen)\n    #sen = re.sub(r&apos;[\\?]{1,100}&apos;, &apos;？&apos;, sen)\n    #sen = re.sub(r&apos;[!]{1,100}&apos;, &apos;！&apos;, sen)\n\n    return sen\n\n# 这样设置的意思是无限制\ndef main(limit=99999, x_limit=1, y_limit=1):\n    from word_sequence import WordSequence\n    print(&apos;extract lines&apos;)\n    fp=open(&quot;xiaohuangji.conv&quot;,&apos;r&apos;,errors=&apos;ignore&apos;,encoding=&apos;utf-8&apos;)\n\n    groups=[]\n    group=[]\n\n    # 提取出所有问答组\n    for line in tqdm(fp):\n        if line.startswith(&apos;M &apos;):\n            line=line.replace(&apos;\\n&apos;,&apos;&apos;)\n            if &apos;/&apos; in line:\n                line = line[2:].split(&apos;/&apos;)\n            else:\n                line=list(line[2:])\n            line=line[:-1]\n\n            group.append(list(regular(&apos;&apos;.join(line))))\n        else:\n            if group:\n                groups.append(group)\n                group = []\n    if group:\n        groups.append(group)\n        group = []\n\n    print(&apos;extract group&apos;)\n\n    x_data = []\n    y_data = []\n    # 将问与答分开\n    for group in tqdm(groups):\n        for i,line in  enumerate(group):\n            last_line=None\n            # last_line是上一句\n            if i&gt;0:\n                last_line = group[i-1]\n                if not good_line(last_line):\n                    last_line = None\n            if i&lt;len(group)-1:\n                next_line=group[i+1]\n                if not good_line(next_line):\n                    next_line=None\n            # 如果有下一句\n            if not last_line:\n                x_data.append(line)\n                y_data.append(next_line)\n\n        #print(len(x_data), len(y_data))\n\n    print(len(x_data), len(y_data))\n    # 构建问答,测试前20个\n    for ask,answer in zip(x_data[:20],y_data[:20]):\n        print(&apos;&apos;.join(ask))\n        print(&apos;&apos;.join(answer))\n        print(&apos;-&apos; * 20)\n\n    # 生成pkl文件\n    data=list(zip(x_data,y_data))\n\n    data=[\n        (x,y) for x,y in data if limit&gt;len(x) &gt;=x_limit and limit &gt; len(y) &gt;= y_limit\n    ]\n\n    # 打包成pkl\n    x_data, y_data = zip(*data)\n    ws_input = WordSequence()\n    ws_input.fit(x_data + y_data)\n    print(&apos;dump&apos;)\n    pickle.dump(\n        (x_data, y_data), open(&apos;chatbot.pkl&apos;, &apos;wb&apos;))\n    pickle.dump(ws_input, open(&apos;ws.pkl&apos;, &apos;wb&apos;))\n    print(&apos;done&apos;)\n\nif __name__ == &apos;__main__&apos;:\n    main()</code></pre><h1 id=\"聊天室内核从0开始-–-3-Seq2Seq\"><a href=\"#聊天室内核从0开始-–-3-Seq2Seq\" class=\"headerlink\" title=\"聊天室内核从0开始 – 3 Seq2Seq\"></a>聊天室内核从0开始 – 3 Seq2Seq</h1><p><a href=\"http://be-sunshine.cn/index.php/2019/01/06/seq2seq/\" title=\"聊天室内核从0开始 – 3 Seq2Seq\" target=\"_blank\" rel=\"noopener\">聊天室内核从0开始 – 3 Seq2Seq</a></p>\n","text":"最后更新于2019/1/4处理语料库简单处理提问与应答这里我们本来可以用jieba或者其他的一些库来帮忙分词,但是因为网上存在已经分好词的语料库,所以可以省略这一步. 至于语料库,可以在github上直接搜索语料库即可以搜到. 一般语料库如下:EM 呵/呵M 是/王/若/猫/的/","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"聊天机器人内核","slug":"Python/聊天机器人内核","count":1,"path":"api/categories/Python/聊天机器人内核.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"聊天机器人内核","slug":"聊天机器人内核","count":3,"path":"api/tags/聊天机器人内核.json"}]}]}