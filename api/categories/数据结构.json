{"name":"数据结构","slug":"数据结构","count":2,"postlist":[{"title":"第五届山东省ACM","slug":"five-shandong-acm","date":"2018-04-18T05:52:29.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/five-shandong-acm.json","excerpt":"","keywords":null,"cover":null,"content":"<p>D<br>=</p>\n<h2 id=\"类型-线段树-区间更新\"><a href=\"#类型-线段树-区间更新\" class=\"headerlink\" title=\"类型: 线段树 区间更新\"></a>类型: 线段树 区间更新</h2><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q,T;\n\nLL lazy[maxn];\nLL sum[maxn];\nbool flag[maxn];\n\nvoid init(){\n    memset(lazy,0,sizeof(lazy));\n    memset(sum,0,sizeof(sum));\n    memset(flag,false,sizeof(flag));\n}\n\nvoid PushDown(int p,int m){\n    if(flag[p]){\n        lazy[p&lt;&lt;1]=lazy[p&lt;&lt;1|1]=0;\n        sum[p&lt;&lt;1]=sum[p&lt;&lt;1|1]=sum[p]=0;\n        flag[p&lt;&lt;1]=flag[p&lt;&lt;1|1]=true;\n        flag[p]=false;\n    }\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nvoid setf(int p,int l,int r,int L,int R,int c){\n\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]=0;\n        sum[p]=0;\n        flag[p]=true;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) setf(p&lt;&lt;1,l,mid,L,R,c);\n    if(R&gt;mid) setf(p&lt;&lt;1|1,mid+1,r,L,R,c);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nint main(){\n    cin&gt;&gt;T;\n    while(T--){\n        init();\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n        int t,l,r,last=0;\n        LL ans=0;\n        for(int i=1;i&lt;=Q;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;t,&amp;l,&amp;r);\n            ///先更新全部区间的值\n            update(1,1,N,t-last,1,N);\n            ///然后查询所需区间内的和\n            ans+=Query(1,1,N,l,r);\n            ///最后将所需区间内的值置为0\n            setf(1,1,N,l,r,0);\n            last=t;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"D<br>=类型: 线段树 区间更新#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const in","link":"","raw":null,"photos":[],"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"线段树","slug":"数据结构/线段树","count":1,"path":"api/categories/数据结构/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"手撸算法","slug":"review-datastructure","date":"2017-05-26T02:55:08.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/review-datastructure.json","excerpt":"","keywords":null,"cover":null,"content":"<p>[toc]</p>\n<blockquote>\n<p>楼教主的男人八题: <a href=\"https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html\" title=\"https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html\" target=\"_blank\" rel=\"noopener\">https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html</a></p>\n</blockquote>\n<p>远离之前的模板代码,从原理上开始手撸数据结构. <strong>代码均上传至github仓库.</strong></p>\n<h1 id=\"【Dijsktra-2017-5-26】\"><a href=\"#【Dijsktra-2017-5-26】\" class=\"headerlink\" title=\"【Dijsktra 2017/5/26】\"></a>【Dijsktra 2017/5/26】</h1><p>前向星+优先队列优化+路径回溯 <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Dijsktra/Dijsktra.cpp\" target=\"_blank\" rel=\"noopener\">Dijsktra.cpp</a></strong></p>\n<h1 id=\"【并查集-2017-5-27】\"><a href=\"#【并查集-2017-5-27】\" class=\"headerlink\" title=\"【并查集 2017/5/27】\"></a>【并查集 2017/5/27】</h1><p><strong>路径压缩,启发式rank优化,将rank较小的并到rank大的集合.</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Union-Find-Set/Union-Find.cpp\" target=\"_blank\" rel=\"noopener\">Union-Find-Set.cpp</a></strong></p>\n<h1 id=\"【树状数组-2017-6-21】\"><a href=\"#【树状数组-2017-6-21】\" class=\"headerlink\" title=\"【树状数组 2017/6/21】\"></a>【树状数组 2017/6/21】</h1><p><strong>lowbit() x&amp;(-x),前缀和,LA 4329</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.cpp\" target=\"_blank\" rel=\"noopener\">树状数组.cpp</a></strong></p>\n<h1 id=\"【快速排序-2017-11-4】\"><a href=\"#【快速排序-2017-11-4】\" class=\"headerlink\" title=\"【快速排序 2017/11/4】\"></a>【快速排序 2017/11/4】</h1><p><code>java</code></p>\n<pre><code>import java.util.Random;\n\npublic class Quick\n{\n    private static int cnt=0;\n    public static void sort(int[] a){\n        Random rand = new Random();\n        System.out.println(&quot;快排之前:&quot;);\n        for(int i=0;i&lt;20;++i){\n            a[i]=rand.nextInt(100);\n            System.out.print(a[i]+&quot; &quot;);\n        }\n        sort(a,0,a.length - 1);\n    }\n    public static void sort(int[] a,int lo,int hi){\n        if(hi &lt;= lo) return;\n        int j = partition(a,lo,hi);//切分\n        sort(a,lo,j-1);\n        sort(a,j+1,hi);\n    }\n    public static int partition(int[] a,int lo,int hi){\n        //将数组切分为a[lo..i-1],a[i],a[i+1..hi]\n        int i=lo,j=hi+1;//左右扫描指针\n        int pt=a[lo];//切分元素\n        while(true){\n            //扫描左右,检查扫描是否结束并交换元素\n            while(a[++i]&lt;pt)if(i==hi) break;//扫描到最左边都没找到大于等于pt的\n            while(a[--j]&gt;pt)if(j==lo) break;\n            if(i&gt;=j) break;//指针重合\n            swap(a,i,j);//没有问题,交换两值\n        }\n        swap(a,lo,j);//将作为基准的数放回正确的位置,切分为两部分,大于基准,小于基准\n        return j;\n    }\n    public static void swap(int[] a,int x,int y){\n        if(x == y) return;\n        a[x]=a[x]^a[y];\n        a[y]=a[y]^a[x];\n        a[x]=a[x]^a[y];\n        cnt++;\n        System.out.println(&quot;\\n第&quot;+cnt+&quot;次变化 &quot;+x+&quot; to &quot;+y+&quot; : &quot;);\n        for(int item: a){\n            System.out.print(item+&quot; &quot;);\n        }\n    }\n    public static void main(String[] args){\n        int[] a=new int[20];\n        sort(a);\n        System.out.println(&quot;\\n快排之后:&quot;);\n        for(int item: a){\n            System.out.print(item+&quot; &quot;);\n        }\n    }\n}</code></pre><p><code>C++</code></p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\nusing namespace std;\n\nint qpartition(int *a,int lo,int hi){\n    int v=a[lo];\n    int i=lo,j=hi+1;\n    while(true){\n        while(a[++i]&lt;v)if(i==hi)break;\n        while(a[--j]&gt;v)if(j==lo)break;\n        if(i&gt;=j)break;\n        swap(a[i],a[j]);\n    }\n    swap(a[lo],a[j]);\n    return j;\n}\n\nvoid qsort(int *a,int lo,int hi){\n    if(lo&gt;=hi) return;\n    int j=qpartition(a,lo,hi);\n    qsort(a,lo,j-1);\n    qsort(a,j+1,hi);\n}\n\nint main(){\n    srand((unsigned)time(NULL));\n    int a[20];\n    for(int i=0;i&lt;20;++i){\n        a[i]=rand()%100;\n        printf(&quot;%d &quot;,a[i]);\n    }\n    printf(&quot;\\n&quot;);\n    qsort(a,0,19);\n    for(int i=0;i&lt;20;++i){\n        printf(&quot;%d &quot;,a[i]);\n    }\n    return 0;\n}</code></pre><p><strong>Output:</strong></p>\n<pre><code>快排之前:\n29 41 75 80 82 60 0 51 10 57 26 5 84 70 60 78 10 29 11 56 \n第1次变化 1 to 18 : \n29 11 75 80 82 60 0 51 10 57 26 5 84 70 60 78 10 29 41 56 \n第2次变化 2 to 17 : \n29 11 29 80 82 60 0 51 10 57 26 5 84 70 60 78 10 75 41 56 \n第3次变化 3 to 16 : \n29 11 29 10 82 60 0 51 10 57 26 5 84 70 60 78 80 75 41 56 \n第4次变化 4 to 11 : \n29 11 29 10 5 60 0 51 10 57 26 82 84 70 60 78 80 75 41 56 \n第5次变化 5 to 10 : \n29 11 29 10 5 26 0 51 10 57 60 82 84 70 60 78 80 75 41 56 \n第6次变化 7 to 8 : \n29 11 29 10 5 26 0 10 51 57 60 82 84 70 60 78 80 75 41 56 \n第7次变化 0 to 7 : \n10 11 29 10 5 26 0 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第8次变化 1 to 6 : \n10 0 29 10 5 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第9次变化 2 to 4 : \n10 0 5 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第10次变化 0 to 3 : \n10 0 5 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第11次变化 0 to 2 : \n5 0 10 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第12次变化 0 to 1 : \n0 5 10 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第13次变化 4 to 6 : \n0 5 10 10 11 26 29 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第14次变化 9 to 18 : \n0 5 10 10 11 26 29 29 51 41 60 82 84 70 60 78 80 75 57 56 \n第15次变化 8 to 9 : \n0 5 10 10 11 26 29 29 41 51 60 82 84 70 60 78 80 75 57 56 \n第16次变化 11 to 19 : \n0 5 10 10 11 26 29 29 41 51 60 56 84 70 60 78 80 75 57 82 \n第17次变化 12 to 18 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 70 60 78 80 75 84 82 \n第18次变化 13 to 14 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 60 70 78 80 75 84 82 \n第19次变化 10 to 13 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 60 70 78 80 75 84 82 \n第20次变化 10 to 12 : \n0 5 10 10 11 26 29 29 41 51 57 56 60 60 70 78 80 75 84 82 \n第21次变化 10 to 11 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 78 80 75 84 82 \n第22次变化 16 to 17 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 78 75 80 84 82 \n第23次变化 15 to 16 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 84 82 \n第24次变化 18 to 19 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 82 84 \n快排之后:\n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 82 84 </code></pre><h1 id=\"【动态规划-划分数-2017-11-16】\"><a href=\"#【动态规划-划分数-2017-11-16】\" class=\"headerlink\" title=\"【动态规划-划分数 2017/11/16】\"></a>【动态规划-划分数 2017/11/16】</h1><p><code>java</code> 动态转移方程： dp[i][j]: j的i划分数 j&gt;=i: dp[i][j]=dp[i-1][j]+dp[i][j-i] i&gt;j: dp[i][j]=dp[i-1][j] 即有一个划分数为0时的目标状态是dp[i-1][j]</p>\n<pre><code>import java.util.*;\npublic class stlin {\n    public static void main(String[] args){\n        Scanner in=new Scanner(System.in);\n        int n,m,M;\n        n=in.nextInt();\n        m=in.nextInt();\n        M=in.nextInt();\n        solve(n,m,M);\n    }\n    public static void solve(int n,int m,int M){\n        int[][] dp=new int[m+1][n+1]; \n        //递推式=&gt;dp[i][j]=dp[i-1][j](ai=0时对应的是i-1划分)+dp[i][j-i]()\n        dp[0][0]=1;\n        for(int i=1;i&lt;=m;++i){\n            for(int j=0;j&lt;=n;++j){\n                if(i&gt;j){\n                    dp[i][j]=dp[i-1][j];\n                }else{\n                    dp[i][j]=(dp[i-1][j]+dp[i][j-i])%M;\n                }\n            }\n        }\n        System.out.println(dp[m][n]);\n    }\n}</code></pre><h1 id=\"【矩阵链乘-2017-11-17】\"><a href=\"#【矩阵链乘-2017-11-17】\" class=\"headerlink\" title=\"【矩阵链乘 2017/11/17】\"></a>【矩阵链乘 2017/11/17】</h1><blockquote>\n<p>输入保证有效,例:</p>\n<blockquote>\n<p>6 30 35 35 15 15 5 5 10 10 20 20 25 结果: 15125</p>\n</blockquote>\n</blockquote>\n<p>从每隔两个开始计算,即自底向上的动态规划. 仔细想一下吧,计算三个的时候,两个已经计算完成了,计算四个的时候,两个和三个已经计算完成了. 比如求<code>((M1)(M2M3M4M5))</code>,你就不需要再去递归求解<code>M2M3M4M5</code>,直接查表就可以了.</p>\n<pre><code>import java.util.*;\n\npublic class VeDP {\n    public static final int MAXN=100;\n    public static final int INF=0x3f3f3f3f;\n    static int[] p=new int[MAXN+1];\n    static int[][] m=new int[MAXN+1][MAXN+1];\n    public static void main(String args[]){\n        Scanner cin=new Scanner(System.in);\n        int n;\n        n=cin.nextInt();\n        for(int i=1;i&lt;=n;++i){//因为中间肯定相同\n            p[i-1]=cin.nextInt();\n            p[i]=cin.nextInt();\n        }\n        for(int l=2;l&lt;=n;++l){\n            for(int i=1;i&lt;=n-l+1;++i){\n                int j=i+l-1;\n                m[i][j]=INF;\n                for(int k=i;k&lt;=j-1;++k){\n                    m[i][j]=Math.min(m[i][j],m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]);\n                }\n            }\n        }\n        System.out.println(m[1][n]);\n    }\n}</code></pre><h1 id=\"【LIS-2017-11-18】\"><a href=\"#【LIS-2017-11-18】\" class=\"headerlink\" title=\"【LIS 2017/11/18】\"></a>【LIS 2017/11/18】</h1><p>O(n^2) java: dp[j]:以c[j]为结尾的最长子序列长度.</p>\n<pre><code>//O(n^2)\nimport java.util.*;\npublic class LIS {\n    private static int[] c=new int[100000+1];\n    private static int[] dp=new int[100000+1];\n    public static void main(String[] args){\n        int n;\n        Scanner cin=new Scanner(System.in);\n        n=cin.nextInt();\n        for(int i=0;i&lt;n;++i){\n            c[i]=cin.nextInt();\n        }\n        /*\n         * dp[j]: 以c[j]为结尾从0...i的LIS \n         */\n        for(int i=1;i&lt;n;++i){\n            for(int j=0;j&lt;i;++j){\n                if(c[i]&gt;=c[j]){\n                    dp[i]=Math.max(dp[i],dp[j]+1);\n                }\n            }\n        }\n        System.out.println(dp[n-1]+1);\n    }\n}</code></pre><p>O(nlgn) c++: 二分搜索+dp 可以过51nod</p>\n<pre><code>//O(NlgN)\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=60000;\n\nint c[maxn],l[maxn];\nint n;\n\nint lis(){\n    l[0]=c[0];\n    int length=1;\n\n    for(int i=1;i&lt;n;++i){\n        if(l[length-1]&lt;c[i]){\n            l[length++]=c[i];\n        }else{\n            *lower_bound(l,l+length,c[i])=c[i];\n        }\n    }\n\n    return length;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%d&quot;,&amp;c[i]);\n    }\n\n    printf(&quot;%d&quot;,lis());\n    return 0;\n}</code></pre><h1 id=\"【2017-11-19-最大正方形】\"><a href=\"#【2017-11-19-最大正方形】\" class=\"headerlink\" title=\"【2017/11/19 最大正方形】\"></a>【2017/11/19 最大正方形】</h1><p>原题连接: <a href=\"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_A\" title=\"AOJ-Lagest Square\" target=\"_blank\" rel=\"noopener\">AOJ-Lagest Square</a> dp[i][j]为向左上方扩展最大的边长. dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1 Code C++:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=1500;\n\nint dp[maxn][maxn],G[maxn][maxn];\nint n,m;\n\nint main(){\n    int maxedge=0;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=0;i&lt;n;++i){\n        for(int j=0;j&lt;m;++j){\n            scanf(&quot;%d&quot;,&amp;G[i][j]);\n            if(G[i][j]==1)dp[i][j]=0;\n            else dp[i][j]=1,maxedge=1;\n        }\n    }\n    for(int i=1;i&lt;n;++i){\n        for(int j=1;j&lt;m;++j){\n            if(!G[i][j]){\n                dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;\n                maxedge=max(maxedge,dp[i][j]);\n            }\n        }\n    }\n    printf(&quot;%d\\n&quot;,maxedge*maxedge);\n    return 0;\n}</code></pre><h1 id=\"【2017-11-19-最大子矩阵】\"><a href=\"#【2017-11-19-最大子矩阵】\" class=\"headerlink\" title=\"【2017/11/19 最大子矩阵】\"></a>【2017/11/19 最大子矩阵】</h1><p>博客内写了题解 Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size,int buffer[]){\n    stack&lt;Rectangle&gt; S;\n    int maxv=0;\n    //通过后一位向前面的计算\n    //这里用到的DP大概是无参数getLargestRectangle里面的预处理\n    //这里用到的更多是思维吧,对每一行进行计算,最后求出最大值.\n    buffer[size]=0;\n\n    for(int i=0;i&lt;=size;++i){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height &lt; rect.height){\n                S.push(rect);\n            }else if(S.top().height &gt; rect.height){\n                int target=i;\n                while(!S.empty() &amp;&amp; S.top().height &gt;= rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    //printf(&quot;\\nmaxv: %d\\n&quot;,maxv);\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    //预处理每个点离他最近的上边未被污染地板的高度\n    for(int j=0;j&lt;W;++j){\n        for(int i=0;i&lt;H;++i){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i&gt;0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    /*\n    例:\n        0 0 1 0 0\n        1 0 0 0 0\n        0 0 0 1 0\n        0 0 0 1 0\n\n    After:\n        1 1 0 1 1\n        0 2 1 2 2\n        1 3 2 0 3\n        2 4 3 0 4\n    */\n    int maxv=0;\n    //传入两个值 W,列数,处理后T[i]第i行的首地址\n    for(int i=0;i&lt;H;++i){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(&quot;%d %d&quot;,&amp;H,&amp;W);\n    for(int i=0;i&lt;H;++i){\n        for(int j=0;j&lt;W;++j){\n            scanf(&quot;%d&quot;,&amp;buffer[i][j]);\n        }\n    }\n\n    printf(&quot;%d\\n&quot;,getLargestRectangle());\n    return 0;\n}</code></pre><h1 id=\"【2017-11-25-筛法求euler】\"><a href=\"#【2017-11-25-筛法求euler】\" class=\"headerlink\" title=\"【2017/11/25 筛法求euler】\"></a>【2017/11/25 筛法求euler】</h1><pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h1 id=\"【2018-1-8-开放式散列表】\"><a href=\"#【2018-1-8-开放式散列表】\" class=\"headerlink\" title=\"【2018/1/8 开放式散列表】\"></a>【2018/1/8 开放式散列表】</h1><pre><code>/*\n//alds1_4_c:Dictionary\n//算法:开放地址法散列表\n//Time: 2018/1/8 星期一\n*/\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nconst int M=1000003;\nconst int L=14;\n\nchar H[M][L];\n\n//对于每个字符返回的定义值\nint getChar(char ch){\n    if(ch==&apos;A&apos;) return 1;\n    if(ch==&apos;C&apos;) return 2;\n    if(ch==&apos;D&apos;) return 3;\n    if(ch==&apos;T&apos;) return 4;\n    return 0;\n}\n//对于字符串返回的初始散列值\nlong long getKey(char str[]){\n    long long len=strlen(str),sum=0,p=1;\n    for(int i=0;i&lt;len;++i){\n        sum+=p*getChar(str[i]);\n        //每次获取定义值后p*5,相当于转换成五进制,不会冲突\n        p*=5;\n    }\n    return sum;\n}\n\n//开放式散列值计算式: h(k,i)=(h1(k)+i*h2(k))%M\nint h1(int key){\n    return key%M;\n}\n//为了保证不会递归冲突(即往下算结果始终相同),必须使h2(key)与M互素\n//TLE最好的情况就是改这个函数= =\n//目前可以AC的: 1+(key%(M-1))\n//(1+key)%(M-1)\nint h2(int key){\n    return (1+key)%(M-1);\n}\n\n//查找\n//-1表示找到\n//h表示找到第一个可插入点\nint find(char str[]){\n    long long key=getKey(str),i,h;\n    for(i=0;;++i){\n        h=(h1(key)+i*h2(key))%M;\n        if(strcmp(H[h],str)==0) return -1;\n        else if(strlen(H[h])==0) return h;\n    }\n    return 0;\n}\n\n//插入\nvoid insert(char str[]){\n    int key=find(str);\n    if(key!=-1) strcpy(H[key],str);\n}\n\nint main(){\n    for(int i=0;i&lt;M;++i) H[M][0]=&apos;\\0&apos;;\n    char str[L],com[L];\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%s %s&quot;,com,str);\n\n        if(com[0]==&apos;i&apos;){\n            insert(str);\n        }else{\n            if(find(str)==-1)\n                printf(&quot;yes\\n&quot;);\n            else\n                printf(&quot;no\\n&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre><h1 id=\"【2018-1-17-强连通分量算法-Tarjan】\"><a href=\"#【2018-1-17-强连通分量算法-Tarjan】\" class=\"headerlink\" title=\"【2018/1/17 强连通分量算法 Tarjan】\"></a>【2018/1/17 强连通分量算法 Tarjan】</h1><p>详解Tarjan: <a href=\"http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/\" title=\"http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1 id=\"【2018-2-5-排列递推公式-容斥-组合数学】\"><a href=\"#【2018-2-5-排列递推公式-容斥-组合数学】\" class=\"headerlink\" title=\"【2018/2/5 排列递推公式+容斥 组合数学】\"></a>【2018/2/5 排列递推公式+容斥 组合数学】</h1><blockquote>\n<p>原题以及题解连接</p>\n<blockquote>\n<p><a href=\"http://be-sunshine.cn/index.php/2018/02/05/uva-11806/\" title=\"UVa 11806\" target=\"_blank\" rel=\"noopener\">UVa 11806</a></p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre><h1 id=\"【2018-2-6-O-n-素数筛法-线性筛法】\"><a href=\"#【2018-2-6-O-n-素数筛法-线性筛法】\" class=\"headerlink\" title=\"【2018/2/6 O(n)素数筛法 线性筛法】\"></a>【2018/2/6 O(n)素数筛法 线性筛法】</h1><blockquote>\n<p>一道例题: <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1431\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100001000\nusing namespace std;\n\nbool valid[maxn];\nint prime[maxn];\n/*素数筛法 O(n),对于每个素数只标记一次*/\nvoid getPrime(int n,int &amp;tot,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint main(){\n    clock_t t1 = clock();\n    int tot=0;\n    getPrime(100000000,tot,prime);\n    clock_t t2 = clock();\n\n    cout&lt;&lt;tot&lt;&lt;endl;\n    cout&lt;&lt;prime[5760000]&lt;&lt;endl;\n    cout&lt;&lt;&quot;总运行时间为: &quot;&lt;&lt;(double)(t2-t1)/ CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;&lt;&lt;endl;\n    return 0;\n}</code></pre><h1 id=\"【2018-3-10-逆元】\"><a href=\"#【2018-3-10-逆元】\" class=\"headerlink\" title=\"【2018/3/10 逆元】\"></a>【2018/3/10 逆元】</h1><h2 id=\"逆元递推式\"><a href=\"#逆元递推式\" class=\"headerlink\" title=\"逆元递推式\"></a>逆元递推式</h2><blockquote>\n<p>适用于较小数据的情况</p>\n</blockquote>\n<pre><code>LL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}</code></pre><h2 id=\"欧拉定理求逆元\"><a href=\"#欧拉定理求逆元\" class=\"headerlink\" title=\"欧拉定理求逆元\"></a>欧拉定理求逆元</h2><blockquote>\n<p>如果mod p 不是素数时最好用这个,比较少见</p>\n</blockquote>\n<pre><code>long long euler(int p)  \n{  \n    long long ans=p,a=p;  \n    long long i;  \n    for(i=2;i*i&lt;=a;i++)  \n    {  \n        if(a%i==0)  \n        {  \n            ans=ans/i*(i-1);  \n            while(a%i==0)  \n                a/=i;  \n        }  \n    }  \n    if(a&gt;1)  \n        ans=ans/a*(a-1);  \n    return ans;  \n}  \n\nlong long eu=euler(mod)-1;  \n\nlong long inv(long long a)  \n{  \n    return Pow(a,eu);  \n}  </code></pre><h2 id=\"费马小定理求逆元\"><a href=\"#费马小定理求逆元\" class=\"headerlink\" title=\"费马小定理求逆元\"></a>费马小定理求逆元</h2><blockquote>\n<p>a^(p-1)≡1(mod p)</p>\n<blockquote>\n<p>a^(p-2)就是 a 关于p的逆元</p>\n<blockquote>\n<p>前提 a与b互素</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<pre><code>long long fast_mod(long long a,long long n,long long Mod){\n    long long ans=1;\n    while(n){\n        if(n&amp;1){\n            ans=(ans*a)%Mod;\n        }\n        a=(a*a)%Mod;\n        n&gt;&gt;=1;\n    }\n    return ans;\n} \n\n/*但p(即MOD)是素数时,inv[a]=fast_mod(a,p-2,p)*/</code></pre><h2 id=\"扩展欧几里得求逆元\"><a href=\"#扩展欧几里得求逆元\" class=\"headerlink\" title=\"扩展欧几里得求逆元\"></a>扩展欧几里得求逆元</h2><pre><code>void extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inverse(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}</code></pre><h2 id=\"费马小预处理阶乘逆元-一般用于直接求组合数\"><a href=\"#费马小预处理阶乘逆元-一般用于直接求组合数\" class=\"headerlink\" title=\"费马小预处理阶乘逆元(一般用于直接求组合数)\"></a>费马小预处理阶乘逆元(一般用于直接求组合数)</h2><pre><code>ll inv[maxn+10],fac[maxn+10];\n///预处理N!的逆元\n//费马小定理\n/*\n *假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡1（mod p）\n *根据这个性质我们可以知道 a的逆元为a^(p-2)\n */\nll fast_pow(ll a,ll b)\n{\n    ll ans=1;\n    while(b){\n        if(b&amp;1ll)ans=a*ans%MOD;\n        a=a*a%MOD;\n        b&gt;&gt;=1ll;\n    }\n    return ans;\n}\nvoid pre()\n{\n    inv[0]=1ll;\n    fac[0]=1ll;\n    for(int i=1;i&lt;=maxn;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=fast_pow(fac[i],MOD-2ll);\n    }\n}\nll C(ll a,ll b)\n{\n    return fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}</code></pre>","text":"[toc]楼教主的男人八题: https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html远离之前的模板代码,从原理上开始手撸数据结构. 代码均上传至github仓库.【Dijsktra 2017/5/26】前向星+优先队列","link":"","raw":null,"photos":[],"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"算法学习","slug":"数据结构/算法学习","count":1,"path":"api/categories/数据结构/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]}]}