{"name":"POJ","slug":"POJ","count":21,"postlist":[{"title":"LA 2995","slug":"la-2995","date":"2017-04-04T06:41:40.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-2995.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>small lightweight object 轻量级的对象(比较轻的物体)</strong> <strong>hold 控制,保留,支持,持有,保存,这里意为举起</strong> <strong>intelligence 智力,情报工作,情报机关,理解力</strong> <strong>determine 下决心,决定</strong> <strong>cardinal 主要的,基本的</strong> <strong>inferring 推理,猜想</strong> <strong>upper limited 上限,最大值</strong> <strong>assume 借取,篡夺,假定,假想</strong> <strong>form 形式,形状,构成</strong> <strong>lattice 晶格,格子,格架</strong> <strong>cubes 立方体</strong> <strong>weighs权衡,重量为</strong> <strong>gram 克/g</strong> <strong>is not necessarily 没必要/不一定</strong> <strong>separated 分隔,分开的</strong> <strong>corresponds 符合,一致,相应</strong> <strong>similar 类似的,相似的</strong> <strong>【Tip】</strong> <strong>这个模拟…额…有点蒙..效率起见,回头看,蓝书P15</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>#define REP(i,n) for(int i=0;i&lt;(n);++i)</strong> <strong>using namespace std;</strong> <strong>const int maxn =10;</strong> <strong>int n;</strong> <strong>char pos[maxn][maxn][maxn];</strong> <strong>char view[6][maxn][maxn];</strong> <strong>char read_char(){</strong> **    char ch;** **    for(;;){** **        ch=getchar();** **        if((ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’) || ch==’.’) return ch;** **    }** <strong>}</strong> <strong>//get函数表示第k个视图中,第i行j列,深度为len的单位立方体</strong> <strong>//在原立方体中的坐标(x,y,z)</strong> <strong>void get(int k,int i,int j,int len,int &amp;x,int &amp;y,int &amp;z){</strong> **    if(k==0){x=len;y=j;z=i;}** **    if(k==1){x=n-1-j;y=len;z=i;}** **    if(k==2){x=n-1-len;y=n-1-j;z=i;}** **    if(k==3){x=j;y=n-1-len;z=i;}** **    if(k==4){x=n-1-i;y=j;z=len;}** **    if(k==5){x=i;y=j;z=n-1-len;}** <strong>}</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;n) &amp;&amp; n){** **        REP(i,n) REP(k,6) REP(j,n) view[k][i][j]=read_char();** **        REP(i,n) REP(j,n) REP(k,n) pos[i][j][k]=’#’;** **        REP(k,6) REP(i,n) REP(j,n) if(view[k][i][j]==’.’)** **            REP(p,n){** **                int x,y,z;** **                get(k,i,j,p,x,y,z);** **                pos[x][y][z]=’.’;** **            }** **        for(;;){** **            bool done=true;** **            REP(k,6) REP(i,n) REP(j,n) if(view[k][i][j]!=’.’){** **                REP(p,n){** **                    int x,y,z;** **                    get(k,i,j,p,x,y,z);** **                    if(pos[x][y][z]==’.’) continue;** **                    if(pos[x][y][z]==’#’) {** **                        pos[x][y][z]=view[k][i][j];** **                        break;** **                    }** **                    if(pos[x][y][z]==view[k][i][j]) break;** **                    pos[x][y][z]=’.’;** **                    done=false;** **                }** **            }** **            if(done) break;** **        }** **        int ans=0;** **        REP(i,n) REP(j,n) REP(k,n)** **            if(pos[i][j][k]!=’.’) ans++;** **        printf(“Maximum weight: %d gram(s)\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 small lightweight object 轻量级的对象(比较轻的物体) hold 控制,保留,支持,持有,保存,这里意为举起 intelligence 智力,情报工作,情报机关,理解力 determine 下决心,决定 cardinal 主要的,基本的 infe","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"模拟","slug":"POJ/模拟","count":1,"path":"api/categories/POJ/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 1067","slug":"poj-1067","date":"2018-01-24T09:11:04.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/poj-1067.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【威佐夫博弈】</p>\n<pre><code>//威佐夫博弈\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main(){\n    int n,m;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        int k=max(n,m)-min(n,m);\n        int ak=k*(1+sqrt(5))/2;\n        int bk=ak+k;\n        if(min(n,m)==ak&amp;&amp;max(n,m)==bk){\n            printf(&quot;0\\n&quot;);\n        }else{\n            printf(&quot;1\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【威佐夫博弈】//威佐夫博弈#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int n,m;    while(~sc","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"博弈论","slug":"POJ/博弈论","count":1,"path":"api/categories/POJ/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 1083","slug":"poj-1083","date":"2017-04-02T05:52:22.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-1083.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Advanced 先进的,高级的,晚期的,前进,增加</strong> <strong>Company 公司</strong> <strong>rented 租用,撕裂</strong> <strong>shape 形象,身材,具体化,模型</strong> <strong>following 下面的,接下来的,一批追随者,下列</strong> <strong>figure 图像,人形</strong> <strong>whose shape is in the following figure. 如下图所示.</strong> <strong>Corridor 走廊</strong> <strong>north side 北侧,北边,北区</strong> <strong>sorth side 南侧,南区,南边</strong> <strong>along the … 沿着 …</strong> <strong>【题意&amp;题解】</strong> <strong><a href=\"http://www.cnblogs.com/hrlnw/archive/2013/03/12/2955158.html\" target=\"_blank\" rel=\"noopener\">题意&amp;题解,仅参考思路</a></strong> <strong>注意,输入中的start和end可能出现start&gt;end的情况.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=300;</strong> <strong>int corridor[maxn],N,T;</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        fill(corridor);** **        int max=0;** **        scanf(“%d”,&amp;N);** **        for(int i=0;i&lt;N;++i){** **            int stay,to;** **            scanf(“%d%d”,&amp;stay,&amp;to);** **            //原地交换,需要注意的是,如果输入stay&gt;to的话** <strong>//无法处理区间,所以需要转换成标准形式.</strong> **            if(stay&gt;to){** **                stay=stay^to;** **                to=to^stay;** **                stay=stay^to;** **            }** **            for(int i=(stay-1)/2;i&lt;=(to-1)/2;++i){** **                corridor[i]+=10;** **                if(corridor[i]&gt;max) max=corridor[i];** **            }** **        }** **        printf(“%d\\n”,max);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Advanced 先进的,高级的,晚期的,前进,增加 Company 公司 rented 租用,撕裂 shape 形象,身材,具体化,模型 following 下面的,接下来的,一批追随者,下列 figure 图像,人形 whose shape is in the fo","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 1273","slug":"poj-1273","date":"2017-04-17T12:39:14.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-1273.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>最大流Dinic</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<vector></vector></strong> <strong>#include<queue></queue></strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 1e9;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=300;</strong> <strong>int N,M;</strong> <strong>//弧,从from到to的容量为cap,流量为flow的弧当cap=0时,意味此边是反向弧</strong> <strong>//当且仅当flow&lt;cap时,该弧存在于残量网络中</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int from,int to,int cap,int flow):from(from),to(to),cap(cap),flow(flow){}** **    int from,to,cap,flow;** <strong>};</strong> <strong>struct Dinic{</strong> **    int n,m,s,t; //节点数,边数(包括反向弧),源点编号,汇点编号** **    vector<edge> edges;//边表。edges[e]和edges[e^1]互为反向弧。** **    vector<int> G[maxn]; //邻接表,G[i][j]表示节点i的第j条边在e数组中的序号** **    bool vis[maxn]; //BFS使用** **    int d[maxn]; //从起点到i的距离** **    int cur[maxn]; //当前弧的下标** **    //插入弧,原图中的一条弧对应于两个Edge结构体,一个是这条弧本身,另一个是他的反向弧** **    //根据插入顺序不难看出,edges[0]和edges[1]互为反向弧,edges[2]和edges[3]** **    //一般的,edges[e]和edges[e^1]互为反向弧** **    void AddEdge(int from,int to,int cap){** **        edges.push_back((Edge){from,to,cap,0});** **        edges.push_back((Edge){to,from,0,0});** **        m=edges.size();** **        G[from].push_back(m-2);** **        G[to].push_back(m-1);** **    }** **    bool BFS(){** **        cle(vis,0);** **        queue<int> Q;** **        Q.push(s);** **        d[s]=0;** **        vis[s]=1;** **        while(!Q.empty()){** **            int x=Q.front();Q.pop();** **            for(int i=0;i&lt;G[x].size();++i){** **                Edge&amp; e=edges[G[x][i]];** **                if(!vis[e.to] &amp;&amp; e.cap&gt;e.flow){//只考虑残量网络中的狐** **                    vis[e.to]=1;** **                    d[e.to]=d[x]+1;** **                    Q.push(e.to);** **                }** **            }** **        }** **        return vis[t];** **    }** **    int DFS(int x,int a){** **        if(x==t || a==0) return a;** **        int flow=0,f;** **        for(int&amp; i=cur[x];i&lt;G[x].size();++i){//从上次考虑的弧** **            Edge&amp; e=edges[G[x][i]];** **            if(d[x]+1==d[e.to] &amp;&amp; (f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){** **                e.flow+=f;** **                edges[G[x][i]^1].flow-=f;** **                flow+=f;** **                a-=f;** **                if(a==0) break;** **            }** **        }** **        return flow;** **    }** **    int Maxflow(int s,int t){** **        this-&gt;s=s;this-&gt;t=t;** **        int flow=0;** **        while(BFS()){** **            cle(cur,0);** **            flow+=DFS(s,INF);** **        }** **        return flow;** **    }** <strong>};</strong> <strong>int main(){</strong> **    while(~SII(N,M)){** **        Dinic dinic;** **        dinic.n=M;** **        rep(i,N){** **            int a,b,c;** **            SIII(a,b,c);** **            dinic.AddEdge(a,b,c);** **        }** **        printf(“%d\\n”,dinic.Maxflow(1,M));** **    }** **    return 0;** <strong>}</strong></int></int></edge></p>\n</blockquote>\n","text":"【类型】 最大流Dinic 【Code】#include  #include #include #include #include #include #include using namespace std; typedef long long ll; const int INF","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"最大流","slug":"POJ/最大流","count":2,"path":"api/categories/POJ/最大流.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"最大流","slug":"最大流","count":2,"path":"api/tags/最大流.json"}]},{"title":"POJ 1503","slug":"poj-1503","date":"2017-04-02T10:37:07.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-1503.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【不用看单词…】</strong> <strong>java大数搞…</strong> <strong>【推荐相关博客】</strong> <strong><a href=\"http://m.blog.csdn.net/article/details?id=39718433\" target=\"_blank\" rel=\"noopener\">java中BigInteger</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>import java.util.Scanner;</strong> <strong>import java.math.*;</strong> <strong>public class Main{</strong> **    public static void main(String[] rgs){** **        //系统输出的** **        Scanner cin=new Scanner(System.in);** **        BigInteger b=BigInteger.valueOf(0);** **        while(cin.hasNext()){//等同于!=EOF** **            BigInteger c;** **            c=cin.nextBigInteger();** **            b=b.add(c);** **        }** **        System.out.println(b);** **    }** <strong>}</strong></p>\n</blockquote>\n","text":"【不用看单词…】 java大数搞… 【推荐相关博客】 java中BigInteger 【Code】import java.util.Scanner; import java.math.*; public class Main{ **    public static void m","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2186","slug":"poj-2186","date":"2018-04-22T15:05:21.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/poj-2186.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Tarjan</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;stack&gt;\nusing namespace std;\nconst int maxn=100000+10;\n/*\n　　有n只牛，牛之间存在一些关系，比如a认为b很受欢迎\n，b认为c很受欢迎，这样呢，a也会认为c很受欢迎，问根据\n给出的关系，有多少头牛被其他所有的牛都认为是受欢迎的？\n\n解:\n　　对于一个有向无环图来说，其中有且仅有一个点出度为零\n，那么这个特殊的点，可以由其他任何点到达。那么接下来我\n们直接对所给的图进行强连通分量划分，然后把每个强连通分\n量看做一个点，判定出度为零的点有几个，如果有一个就输出\n这个点对应的强连通分量含有的节点个数，否则为零。\n*/\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint vis[maxn];\n\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    ///如果点从1开始计数,这里改成-1即可\n    G[u-1].push_back(v-1);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    ///缩点,同一scc缩到同一点中\n    for(int i=0;i&lt;n;++i){\n        for(int j=0;j&lt;G[i].size();++j){\n            ///如果i到G[i][j]这条边不在强连通分量中\n            ///说明是一个连接外面的点\n            if(sccno[i]!=sccno[G[i][j]]){\n                vis[sccno[i]]++;\n            }\n        }\n    }\n\n    int sum=0,ans=0,cnt=0;\n    for(int i=1;i&lt;=scc_cnt;++i){\n        if(!vis[i]){\n            ///如果出度是0,则是一个边界点\n            sum++;\n            ans=i;\n        }\n    }\n    ///如果只有一个点的话,代表存在一个万人敬仰团体\n    if(sum==1){\n        for(int i=0;i&lt;n;++i){\n            if(sccno[i]==ans){\n                cnt++;\n            }\n        }\n        printf(&quot;%d\\n&quot;,cnt);\n    }else{\n        printf(&quot;0\\n&quot;);\n    }\n    return 0;\n}\n/*\n3 3\n1 2\n2 1\n2 3\n\n1\n*/</code></pre>","text":"Tarjan#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"Tarjan","slug":"POJ/Tarjan","count":1,"path":"api/categories/POJ/Tarjan.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]},{"title":"POJ 2195","slug":"poj-2195","date":"2017-04-17T15:49:19.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-2195.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>SPFA 最小费用最大流</strong> <strong>【Tip】</strong> <strong>注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<vector></vector></strong> <strong>#include<queue></queue></strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>//最多房子/人为100</strong> <strong>//最大节点数为100+100+2</strong> <strong>//最大边数为(100+100+100*100)*2=20400;AC!</strong> <strong>const int maxn=300,maxm=20410;</strong> <strong>int max_num,home_sum;</strong> <strong>char s[maxn];</strong> <strong>typedef struct{</strong> **    int x,y;** <strong>}point;</strong> <strong>point man[maxn+10],home[maxn+10];</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];** **    int nume;** **    int src,sink;//源点,汇点** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        queue<int> que;** **        que.push(src);** **        cle(dist,INF);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    int mincostflow(){** **        int cur=0;//原板子有一个ans=0** **        while(Spfa()){** **            cur+=augment();** **     //     cout&lt;&lt;cur&lt;&lt;endl;** **          //原板子  if(cur&gt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>}mcmf;</strong> <strong>int main(){</strong> <strong>#ifndef ONLINE_JUDGE</strong> **    freopen(“in.txt”, “r”, stdin);** **    freopen(“out.txt”, “w”, stdout);** <strong>#endif</strong> **    int N,M;** **    while(~SII(N,M) &amp;&amp; N+M){** **        getchar();** **        mcmf.init();** **        max_num=home_sum=0;** **        rez(i,1,N){** **            gets(s);** **            rep(j,M){** **                if(s[j]==’m’){** **                    man[max_num].x=i;** **                    man[max_num++].y=j+1;** **                }else if(s[j]==’H’){** **                    home[home_sum].x=i;** **                    home[home_sum++].y=j+1;** **                }** **            }** **        }** **        mcmf.src=0;** **        mcmf.sink=2<em>max_num+1;*</em> **        rep(i,max_num){** **            mcmf.Addedge(0,i+1,1,0);** **            mcmf.Addedge(max_num+i+1,mcmf.sink,1,0);** **            rep(j,home_sum)** **                mcmf.Addedge(i+1,max_num+j+1,1,abs(man[i].x-home[j].x)+abs(man[i].y-home[j].y));** **        }** **    //    rep(i,mcmf.nume){** **    //        printf(“%d %d %d %d\\n”,mcmf.e[i].v,mcmf.e[i].f,mcmf.e[i].w,mcmf.e[i].nxt);** **     //   }** **        printf(“%d\\n”,mcmf.mincostflow());** **    }** **    return 0;** <strong>}</strong></int></p>\n</blockquote>\n","text":"【类型】 SPFA 最小费用最大流 【Tip】 注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数. 【Code】#include  #include #include #include #include #include #i","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"最大流","slug":"POJ/最大流","count":2,"path":"api/categories/POJ/最大流.json"},{"name":"最小费用最大流","slug":"POJ/最大流/最小费用最大流","count":1,"path":"api/categories/POJ/最大流/最小费用最大流.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"最大流","slug":"最大流","count":2,"path":"api/tags/最大流.json"},{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"path":"api/tags/最小费用最大流.json"}]},{"title":"POJ 2255","slug":"poj-2255","date":"2017-04-03T07:07:43.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-2255.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>前序中序求后序</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream>  ** *<em>#include <cstring>  *</cstring></em> *<em>using namespace std;  *</em> *<em>char TF[27];  *</em> *<em>char TM[27];  *</em> *<em>void TL( int p1, int p2, int q1, int q2, int root )  *</em> *<em>{  *</em> **    if ( p1 &gt; p2 ) return;  ** **//q1,前序第一个,即根,root为中序中的根下标</iostream></strong> **    for ( root = q1 ; TM[root] != TF[p1] ; ++ root );** **    //root-q1=左子树节点个数,因为有前序,所以不需要root** **    //变量,这里的root做使用变量处理.** **    //第一个递归,前两个变量是前序中左子树的区间,** **    //后两个变量是中序中左子树的区间  ** **    TL( p1+1, p1+root-q1, q1, root-1, 0 );** **    //前两个是前序中** **    //右子树的区间,后两个是中序中右子树的区间  ** **    TL( p1+root-q1+1, p2, root+1, q2, 0 );  ** **    printf(“%c”,TM[root]);  ** *<em>}  *</em> *<em>int main()  *</em> *<em>{  *</em> **    while (~scanf(“%s%s”,TF,TM)) {  ** **        int L = strlen(TF)-1;  ** **        TL( 0, L, 0, L, 0 );  ** **        printf(“\\n”);  ** **    }  ** **    return 0;  ** *<em>} *</em></p>\n</blockquote>\n<p><strong>【补充】</strong> <strong>修改题意为根据后序中序求先序.</strong></p>\n<blockquote>\n<p><strong>#include <iostream>  ** *<em>#include <cstring>  *</cstring></em>  *<em>using namespace std;  *</em>  **char TA[27];  //后序</iostream></strong> <strong>char TM[27];  //中序</strong>  <strong>void TL( int p1, int p2, int q1, int q2 )  ** *<em>{  *</em> **    if ( p1 &gt; p2 ) return;  ** **    printf(“%c”,TA[p2]);</strong> **    int i;    ** <strong>for ( i =  q1; TM[i] != TA[p2] ; ++ i );</strong> **    TL( p1, p2-q2+i-1, q1, i-1);** **    TL( p2-q2+i, p2-1, i+1, q2 );  **  *<em>}  *</em>  *<em>int main()  *</em> *<em>{  *</em> **    while (~scanf(“%s%s”,TA,TM)) {  ** **        int L = strlen(TA)-1;  ** **        TL( 0, L, 0, L);  ** **        printf(“\\n”);  ** **    }  ** **    return 0;  ** *<em>} *</em></p>\n</blockquote>\n","text":"【Tip】 前序中序求后序 【Code】#include   ** *#include   * *using namespace std;  * *char TF[27];  * *char TM[27];  * *void TL( int p1, int p2, int q1,","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"Tree","slug":"POJ/Tree","count":1,"path":"api/categories/POJ/Tree.json"},{"name":"数据结构","slug":"POJ/Tree/数据结构","count":1,"path":"api/categories/POJ/Tree/数据结构.json"}],"tags":[{"name":"binary_tree","slug":"binary-tree","count":1,"path":"api/tags/binary-tree.json"}]},{"title":"POJ 2262","slug":"poj-2262","date":"2017-04-02T09:45:52.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/poj-2262.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Goldbach 哥德巴赫</strong> <strong>Conjecture 推测,猜想</strong> <strong>Christian 基督教徒</strong> <strong>amateur 爱好者,业余爱好者</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=1000010;</strong> <strong>int N;</strong> <strong>int is_prime[maxn+1];</strong> <strong>int prime[maxn+1],p;</strong> <strong>void sieve(int t){</strong> **    memset(is_prime,1,sizeof(is_prime));** **    p=0;** **    is_prime[0]=is_prime[1]=0;** **    for(int i=2;i&lt;=t;++i){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=t;j+=i)*</em> **                is_prime[j]=0;** **        }    ** **    }** <strong>}</strong> <strong>void solve(){</strong> <strong>//这个循环是 &lt;= 因为6=3+3,而不是&lt;</strong> **    for(int i=0;i&lt;p &amp;&amp; prime[i]&lt;=N/2 ;++i)** **        if(is_prime[N-prime[i]]){** **            printf(“%d = %d + %d\\n”,N,prime[i],N-prime[i]);** **            return;** **        }** **    printf(“Goldbach’s conjecture is wrong.\\n”);    ** <strong>}</strong> <strong>int main(){</strong> **    //1000000正解,而不是预处理到一半,这道题不同于上一道题** <strong>//可以出现大于N/2 的解.</strong> **    sieve(1000010);** **    while(~scanf(“%d”,&amp;N) &amp;&amp; N){** **        solve();** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Goldbach 哥德巴赫 Conjecture 推测,猜想 Christian 基督教徒 amateur 爱好者,业余爱好者 【Code】#include #include #include #include #include #define fill(x) mems","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2407","slug":"poj-2407","date":"2018-02-12T09:09:54.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2407.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/POJ-2407\" title=\"https://vjudge.net/problem/POJ-2407\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2407</a></p>\n<h1><span id=\"type-欧拉函数\">Type: 欧拉函数</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>求小于n 且与n互质的数的个数</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>简单欧拉,但因为是十亿的数据量,所以不能预处理</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint phi(int n){\n    int ans=n;\n    for(int i=2;i*i&lt;=n;++i){\n        if(n%i==0){\n            ans=ans-ans/i;\n            while(n%i==0){\n                n/=i;\n            }\n        }\n    }\n    if(n&gt;1){\n        ans=ans-ans/n;\n    }\n    return ans;\n}\n\nint main(){\n    int n;\n    while(cin&gt;&gt;n&amp;&amp;n){\n        cout&lt;&lt;phi(n)&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2407Type: 欧拉函数题意求小于n 且与n互质的数的个数题解简单欧拉,但因为是十亿的数据量,所以不能预处理Code#include&lt;cstdio&gt;#include&lt;algorithm&g","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2478","slug":"poj-2478","date":"2018-02-12T09:44:15.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2478.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/POJ-2478\" title=\"https://vjudge.net/problem/POJ-2478\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2478</a></p>\n<h1><span id=\"type-欧拉函数\">Type: 欧拉函数</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5} 其中分子与分母互质.</p>\n<blockquote>\n<p>目标是求Fn中的最简分数有多少个</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>仔细观察会发现因为所有分数分子分母都是互素的 设n为分母,相同分母n的最简分数的个数就等于与n互质的数的个数. 分母从2开始计数</p>\n<blockquote>\n<p>答案就是2~n的phi(k)的和</p>\n<blockquote>\n<p>注意和斐波那契一样,Farey序列也会超过long long</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000000+100;\nLL phi[maxn];\nLL Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(LL i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(LL j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){\n        printf(&quot;%lld\\n&quot;,Farey[n]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2478Type: 欧拉函数题意F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2769","slug":"poj-2769","date":"2018-02-09T09:12:34.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2769.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>可以暴力,不明所以的玄学复杂度 我觉得复杂度大概是 O(100000*log(300))</p>\n</blockquote>\n<pre><code>/*\n我以为这道题有公式...\n谁知道他要靠暴力???\n而且每次枚举前还memset????\n复杂度真的可以么...\n*/\n\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=1000000+100;\n\nbool exist[100010];\nint num[maxn];\nint T;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int N;\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=1;i&lt;=N;++i){\n            scanf(&quot;%d&quot;,&amp;num[i]);\n        }\n        for(int j=1;;++j){\n            bool is=true;\n            memset(exist,false,sizeof(exist));\n            for(int k=1;k&lt;=N;++k){\n                if(exist[num[k]%j]){\n                    is=false;\n                    break;\n                }\n                exist[num[k]%j]=true;\n            }\n            if(is){\n                printf(&quot;%d\\n&quot;,j);\n                break;\n            }\n        }\n    }\n    return 0;\n}</code></pre>","text":"可以暴力,不明所以的玄学复杂度 我觉得复杂度大概是 O(100000*log(300))/*我以为这道题有公式...谁知道他要靠暴力???而且每次枚举前还memset????复杂度真的可以么...*/#include&lt;cstdio&gt;#include&lt;cstrin","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2739","slug":"poj-2739","date":"2017-04-02T04:46:21.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-2739.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Consecutive 连贯的,连续不断的</strong> <strong>represented 代表,表现,描写</strong> <strong>such 这样的</strong> <strong>【Tip】</strong> <strong>不能全部预处理,一旦发现往下加就退出循环,否则会TLE.当然,可以更加优化,不过过了= =///.</strong>   <strong>12：50 搜了一下题解,好吧,是尺取法.思路和我的差不多,选定好右端点,然后通过不断扩大左端点来寻找解.一旦脱离了最大范围,就退出循环.</strong> <strong>PS:这道题尺取法也可以继续优化..只需要遍历到5000就可以了,5000以后通过判断is_prime? it[i]+1 : it[i];来搞定?</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>const int maxn=20000;</strong> <strong>bool is_prime[maxn+1];</strong> <strong>int prime[maxn],p;</strong> <strong>void sieve(int n){</strong> **    p=0;** **    for(int i=0;i&lt;=n;i++) is_prime[i]=true;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;=n;i++){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=n;j+=i)*</em> **                is_prime[j]=false;** **        }** **    }** <strong>}</strong> <strong>int it[maxn];</strong> <strong>void init(int N){</strong> **    memset(it,0,sizeof(it));** **    //&amp;&amp; prime[i]&lt;N** **    for(int i=0;i&lt;p;++i){** **        int t=i;** **        while(t&gt;=0){** **            long long ans=0;** **            for(int j=t;j&lt;=i;++j)** **                ans+=prime[j];** **            if(ans&gt;=10000)** **                break;** **            it[ans]++;** **            t–;** **        }** **    }** <strong>}</strong> <strong>int main(){</strong> **    sieve(10000);** **    init(5000);** **    int T;** **    while(~scanf(“%d”,&amp;T) &amp;&amp; T){** <strong>//        if(T&lt;5000)</strong> **            printf(“%d\\n”,it[T]);** <strong>//        else if(is_prime[T])</strong> <strong>//            printf(“%d\\n”,it[T]+1);</strong> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Consecutive 连贯的,连续不断的 represented 代表,表现,描写 such 这样的 【Tip】 不能全部预处理,一旦发现往下加就退出循环,否则会TLE.当然,可以更加优化,不过过了= =///.   12：50 搜了一下题解,好吧,是尺取法.思路和我","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2991","slug":"poj-2991","date":"2017-08-05T14:44:10.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/poj-2991.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树 题目连接: :earth_asia:<a href=\"http://poj.org/problem?id=2991\" title=\"Crane\" target=\"_blank\" rel=\"noopener\">POJ-Crane</a> 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子区间的向量+右子区间的向量。 求一个向量（x0,y0）逆时针旋转B度后的向量有一个公式： x1= x0 * cosB - y0 * sinB y1 = x0 * sinB + y0 * cosB 顺时针就把-B代入： x1= x0 * cosB + y0 * sinB y1 = -x0 * sinB + y0 * cosB github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-2991.CPP\" title=\"POJ 2991.cpp\" target=\"_blank\" rel=\"noopener\">POJ 2991.cpp</a> Code:</p>\n<pre><code>#define _USE_MATH_DEFINES///使用math库中的定义\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\nusing namespace std;\n\nconst int ST_SIZE=(1&lt;&lt;15)-1;\nconst int MAX_N=10010;\nconst int MAX_C=10010;\n\nint N,C;\nint L[MAX_N];\nint S[MAX_C],A[MAX_N];\n\ndouble vx[ST_SIZE],vy[ST_SIZE]; ///各节点的向量\ndouble ang[ST_SIZE]; ///各节点的角度\n\ndouble prv[MAX_N];\n\n///初始化线段树\nvoid init(int k,int l,int r){\n    ang[k]=vx[k]=0.0;\n    if(r-l==1){\n        ///叶子结点\n        vy[k]=L[l];\n    }else{\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        init(chl,l,(l+r)&gt;&gt;1);\n        init(chr,(l+r)&gt;&gt;1,r);\n        vy[k]=vy[chl]+vy[chr];\n    }\n}\n\n///把s和s+1的角度变为a\n///v是节点编号,l,r表示当前结点对应的是[l,r]区间\nvoid update(int s,double a,int k,int l,int r){\n    if(s&lt;=l) return;\n    else if(s&lt;r){\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        int m=(l+r)&gt;&gt;1;\n        update(s,a,chl,l,m);\n        update(s,a,chr,m,r);\n        if(s&lt;=m) ang[k]+=a;\n\n        double s=sin(ang[k]),c=cos(ang[k]);\n        vx[k]=vx[chl]+(c*vx[chr]-s*vy[chr]);\n        vy[k]=vy[chl]+(s*vx[chr]+c*vy[chr]);\n    }\n}\n\nvoid solve(){\n    init(0,0,N);\n    for(int i=0;i&lt;C;++i){\n        int s=S[i];\n        double a=A[i]/360.0*2*M_PI;///把角度换算成弧度\n        update(s,a-prv[s],0,0,N);\n        prv[s]=a;\n\n        printf(&quot;%.2f %.2f\\n&quot;,vx[0],vy[0]);\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;C)==2){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;L[i]);\n            prv[i]=M_PI;///180°的弧度值\n        }\n        for(int i=0;i&lt;C;++i)\n            scanf(&quot;%d%d&quot;,&amp;S[i],&amp;A[i]);\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树 题目连接: :earth_asia:POJ-Crane 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3006","slug":"poj-3006","date":"2017-04-03T04:06:39.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3006.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Dirichlet’s Theorem  狄利赫勒定理</strong> <strong>Arithmetic 算术,等差数列</strong> <strong>Progressions 级数,推进</strong> <strong>Arithmetic Progressions 等差数列</strong> <strong>Arithmetic Progressions of prime 质数等差数列</strong> <strong>If <em>a</em> and <em>d</em> are relatively prime… 如果a和b是互质数</strong> <strong>arithmetic sequence 等差数列</strong> <strong>increasing by 增加了</strong> <strong><a href=\"http://dict.youdao.com/search?q=increasing%20monotonically%20by%20degree&keyfrom=chrome.extensioneng\" target=\"_blank\" rel=\"noopener\">increasing monotonically by degree</a> 单调递增</strong> <strong>infinitely 无穷,无限的</strong> <strong>is known as 被称为</strong> <strong>your mission 你的使命/任务</strong> <strong>Your mission, should you decide to accept it, 你的使命使你决定去接受(证明？)它</strong> <strong>datasets 数据集</strong> <strong>separated by 用…来分隔？</strong> <strong>assume 假定</strong> <strong>composed of 由…组成</strong> <strong>extra 临时的,特别的,额外的</strong> <strong>characters 特性,字符</strong> <strong>corresponding 相应的,一致的</strong> <strong>【Tip】</strong> <strong>为啥都是素数？</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=1000010;</strong> <strong>bool is_prime[maxn];</strong> <strong>int prime[maxn],p,a,b,n;</strong> <strong>inline void sieve(){</strong> **    memset(is_prime,true,sizeof(is_prime));** **    p=0;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;maxn;++i)** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;maxn;j+=i)*</em> **                is_prime[j]=false;** **        }** <strong>}</strong> <strong>int main(){</strong> **    sieve();** **    while(~scanf(“%d%d%d”,&amp;a,&amp;b,&amp;n) &amp;&amp; a+b+n){** **        int sum=0,c;** **        for(int i=0,t=0;t&lt;n;++i){** **            c=a+i<em>b;*</em> **            if(is_prime[c]) t++;** **        }** **        printf(“%d\\n”,c);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Dirichlet’s Theorem  狄利赫勒定理 Arithmetic 算术,等差数列 Progressions 级数,推进 Arithmetic Progressions 等差数列 Arithmetic Progressions of prime 质数等差数列 ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3299","slug":"poj-3299","date":"2017-04-01T03:40:48.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-3299.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Adapted 适合,适应,改编</strong> <strong>free 自由,免费</strong> <strong>encyclopedia 百科全书</strong> <strong>dew point 露点</strong> <strong>【Tip】</strong> <strong>dewpoint的公式要推出来.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cmath></cmath></strong> <strong>#include<iostream></iostream></strong> <strong>using namespace std;</strong> <strong>double D,H,T;</strong> <strong>char get;</strong> <strong>int main(){</strong> <em>*    for(;;){** **        D=H=T=200;** **        for(int i=0;i&lt;2;++i){** **            cin&gt;&gt;get;** **            if(get==’E’) return 0;** **            if(get==’T’) cin&gt;&gt;T;** **            if(get==’H’) cin&gt;&gt;H;** **            if(get==’D’) cin&gt;&gt;D;** **        }** **        if(T==200)** **            T=H-0.5555</em>(6.11*exp(5417.7530*((1/273.16)-(1/(D+273.16))))-10.0);<em>* **        else if(H==200)** **            H=T+0.5555</em>(6.11*exp(5417.7530*((1/273.16)-(1/(D+273.16))))-10.0);** **        else if(D==200)** **            D=1/(1/273.16-log(((H-T)/0.5555+10.0)/6.11)/5417.7530)-273.16;** **        printf(“T %.1lf D %.1lf H %.1lf\\n”,T,D,H);** **    }    **  **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Adapted 适合,适应,改编 free 自由,免费 encyclopedia 百科全书 dew point 露点 【Tip】 dewpoint的公式要推出来. 【Code】#include #include #include #include #include #i","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3090","slug":"poj-3090","date":"2018-02-12T11:54:27.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-3090.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/POJ-3090\" title=\"https://vjudge.net/problem/POJ-3090\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-3090</a></p>\n<h1><span id=\"type-欧拉函数\">Type: 欧拉函数</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原题转换成该范围内有多少个点的 x与y互质</p>\n<blockquote>\n<p>这个与poj2478这道题求法一样,有一点不同的是,(x,y)存在的同时也会存在(y,x) 并且会同时存在(1,0)(0,1)(1,1)这三个点,所以答案是</p>\n</blockquote>\n<p>Farey[n]*2+3</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000+100;\nint phi[maxn];\nint Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n,kase=1,t;\n    scanf(&quot;%d&quot;,&amp;t);\n    while(t--){\n        scanf(&quot;%d&quot;,&amp;n);\n        printf(&quot;%d %d %d\\n&quot;,kase++,n,Farey[n]*2+3);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-3090Type: 欧拉函数题意第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?题解想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3094","slug":"poj-3094","date":"2017-04-03T07:28:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3094.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>字符串处理问题</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=400;</strong> <strong>int mp[255],sum;</strong> <strong>char str[maxn];</strong> <strong>inline void init(){</strong> <strong>fill(mp);</strong> **    for(int i=0;i&lt;=26;++i)** <strong>mp[i+’A’]=i+1;</strong> <strong>}</strong> <strong>int main(){</strong> **    init();** **    for(;;){** **        scanf(“\\n%[^\\n]“,str);** <strong>sum=0;</strong> **        if(str[0]==’#’) break;** **        for(int i=1;str[i-1]!=’\\0’;++i)** <strong>sum+=mp[str[i-1]]*i;</strong> <strong>printf(“%d\\n”,sum);</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 字符串处理问题 【Code】#include&lt;bits/stdc++.h&gt; #define fill(x) memset(x,0,sizeof(x)) using namespace std; const int maxn=400; int mp[255]","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"字符串处理","slug":"POJ/字符串处理","count":1,"path":"api/categories/POJ/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"poj 3370","slug":"poj-3370","date":"2018-01-26T07:47:40.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-3370.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【鸽巢原理】 题意: 给你两个整数c和n,以及n个整数,问这n个整数中是否有一些整数和为c的倍数. 同样可以证明,当c&lt;=n时,同样可以使用鸽巢原理证明有连续的序列和为c的倍数. 另外有一点是,Sigma ai最大可能100000^2.所以要用long long存. PS:这道题用G++提交就超时了…C++提交无事.WTF</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000+10;\nlong long sum[maxn];\nint num;\nint r[maxn];\nint c,n;\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;c,&amp;n)&amp;&amp;c&amp;&amp;n){\n        memset(r,0,sizeof(r));\n        int k=0,l=1;\n        sum[0]=0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;num);\n            sum[i]=sum[i-1]+num;\n\n            int remainder=sum[i]%c;\n            if(remainder==0){\n                k=0;\n                l=i;\n            }else if(r[remainder]){\n                k=r[remainder];\n                l=i;\n            }else r[remainder]=i;\n        }\n        printf(&quot;%d&quot;,k+1);\n        for(int i=k+2;i&lt;=l;++i){\n            printf(&quot; %d&quot;,i);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【鸽巢原理】 题意: 给你两个整数c和n,以及n个整数,问这n个整数中是否有一些整数和为c的倍数. 同样可以证明,当c&lt;=n时,同样可以使用鸽巢原理证明有连续的序列和为c的倍数. 另外有一点是,Sigma ai最大可能100000^2.所以要用long long存. PS:","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"组合数学","slug":"POJ/组合数学","count":1,"path":"api/categories/POJ/组合数学.json"},{"name":"鸽巢原理","slug":"POJ/组合数学/鸽巢原理","count":1,"path":"api/categories/POJ/组合数学/鸽巢原理.json"}],"tags":[{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"鸽巢原理","slug":"鸽巢原理","count":1,"path":"api/tags/鸽巢原理.json"}]},{"title":"POJ 3468","slug":"poj-3468","date":"2017-08-07T11:10:00.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/poj-3468.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:<a href=\"https://vjudge.net/problem/POJ-3468\" title=\"POJ-3468\" target=\"_blank\" rel=\"noopener\">POJ-3468</a> 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问a<del>b这段数的和，‘C a b c’是把a</del>b这段数都加上c。 题解: 区间问题,首先想到线段树,这里我们建两个线段树.data,datb. data用来维护区间所更新的值. datb则用来维护区间的和. 计算的时候只需要 每部分的区间和 + 每部分更新的值 即为最终答案.(百度说这叫Lazy思想.) github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-3468.cpp\" title=\"POJ-3468.cpp\" target=\"_blank\" rel=\"noopener\">POJ-3468.cpp</a> Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n///区间更新\ntypedef long long ll;\n\nconst int DAT_SIZE=(1&lt;&lt;18)-1;\nconst int MAX_N=100000+10;\nconst int MAX_Q=100000+10;\n\nint N,Q;\nint A[MAX_N];\nchar T[MAX_Q];\nint L[MAX_Q],R[MAX_Q],X[MAX_Q];\n\n///线段树,a维护区间应加值,b维护区间和\nll data[DAT_SIZE],datb[DAT_SIZE];\n\n///对区间[a,b]同时加x\n///k是节点编号,对应的区间是[l,r)\nvoid add(int a,int b,int x,int k,int l,int r){\n    if(a&lt;=l&amp;&amp;r&lt;=b){\n        data[k]+=x;\n    }else if(l&lt;b &amp;&amp; a&lt;r){\n        datb[k]+=(min(b,r)-max(a,l))*x;\n        add(a,b,x,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        add(a,b,x,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n    }\n}\n\n///计算[a,b)的和\nll sum(int a,int b,int k,int l,int r){\n    if(b&lt;=l || a&gt;=r){\n        return 0;\n    }else if(a&lt;=l &amp;&amp; r&lt;=b){\n        return data[k]*(r-l)+datb[k];\n    }else{\n        ll res=(min(b,r)-max(a,l))*data[k];\n        res+=sum(a,b,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        res+=sum(a,b,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n        return res;\n    }\n}\n\n///下标0开头的线段树初始化\n///开区间[a,b)\nvoid solve(){\n    for(int i=0;i&lt;N;++i){\n        add(i,i+1,A[i],0,0,N);\n//        printf(&quot;\\nadd: %d -&gt; %d\\n&quot;,i,A[i]);\n    }\n    for(int i=0;i&lt;Q;++i){\n        if(T[i]==&apos;C&apos;){\n            add(L[i],R[i]+1,X[i],0,0,N);\n        }else{\n            printf(&quot;%lld\\n&quot;,sum(L[i],R[i]+1,0,0,N));\n        }\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;Q)==2){\n        memset(data,0,sizeof(data));\n        memset(datb,0,sizeof(datb));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;A[i]);\n        }\n        ///区间是[0...N)所以要减一\n        for(int i=0;i&lt;Q;++i){\n            scanf(&quot;%*c%c&quot;,&amp;T[i]);\n            if(T[i]==&apos;C&apos;){\n                scanf(&quot;%d%d%d&quot;,&amp;L[i],&amp;R[i],&amp;X[i]);\n                L[i]-=1;R[i]-=1;\n            }else{\n                scanf(&quot;%d%d&quot;,&amp;L[i],&amp;R[i]);\n                L[i]-=1;R[i]-=1;\n            }\n        }\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:POJ-3468 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问ab这段数的和，‘C a b c’是把ab这段数都加上c。 题解: 区间问题,首先想","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"UVa 10881","slug":"uva-10881","date":"2017-04-03T09:17:46.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-10881.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【名言警句】</strong></p>\n<p><strong>“One thing is for certain: there is no stopping them;</strong></p>\n<p><strong>the ants will soon be here. And I, for one, welcome our</strong></p>\n<p><strong>new insect overlords.”</strong></p>\n<p>**                                                                                          —-H.G**</p>\n<p><strong>“有一件事是肯定的:没有什么能阻止他们,那些蚂蚁一定会到这里.而我,作为其中的一个,欢迎并迎接我们新的昆虫政权.”</strong></p>\n<p>**                                                                                          —-H.G**</p>\n<p><strong>【生词】</strong> <strong>overlords 证券</strong> <strong>insect 昆虫</strong> <strong>certain 肯定,确信无疑的</strong> <strong>pole 杆子,极点,电极</strong> <strong>facting 饰面,衣服的贴边</strong> <strong>walks at 走在</strong> <strong>constant 不变的,常量,恒定的.</strong> <strong>bump into 无意中遇到,碰到</strong> <strong>instantaneously 即时,不浪费时间</strong> <strong>opposite 对立面</strong> <strong>【题解】</strong> <strong>思维,蓝书P10</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=10000+10;</strong> <strong>struct Node{</strong> <strong>int id;//输入顺序</strong> <strong>int d;//位置</strong> <strong>int state;//朝向,-1,左,0,Turing,1,右</strong> **    bool operator&lt;(const Node &amp;q)const{** <strong>return d&lt;q.d;</strong> <strong>}</strong> <strong>};</strong> <strong>int Te,L,T,n,order[maxn];</strong> <strong>char turing,sta[][10]={“L”,”Turning”,”R”};</strong> <strong>Node after[maxn],before[maxn];</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;Te);** <strong>for(int i=1;i&lt;=Te;++i){</strong> **        printf(“Case #%d:\\n”,i);** **        scanf(“%d%d%d”,&amp;L,&amp;T,&amp;n);** **        for(int i=1;i&lt;=n;++i){** **            int place,dig;** <strong>char s;</strong> **            scanf(“%d %c”,&amp;place,&amp;s);** <strong>dig=(s==’L’?-1:1);</strong> **            before[i]=(Node){i,place,dig};** **            after[i]=(Node){0,place+T<em>dig,dig};*</em> **        }** <strong>//计算输入顺序排序后的数组,因为输出需要按照输入顺序输出</strong> <strong>sort(before+1,before+n+1);</strong> **        for(int i=1;i&lt;=n;++i)** <strong>order[before[i].id]=i;</strong>  <strong>//修改碰撞中的方向</strong> **        sort(after+1,after+n+1);** **        for(int i=1;i&lt;n;++i)** **            if(after[i].d==after[i+1].d)** <strong>after[i].state=after[i+1].state=0;</strong>  **        for(int i=1;i&lt;=n;++i){** **            if(after[order[i]].d&gt;L || after[order[i]].d&lt;0){** **                printf(“Fell off\\n”);** <strong>continue;</strong> **            }** **            printf(“%d %s\\n”,after[order[i]].d,sta[after[order[i]].state+1]);    ** <strong>}</strong> <strong>printf(“\\n”);</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【名言警句】“One thing is for certain: there is no stopping them;the ants will soon be here. And I, for one, welcome ournew insect overlords.”**  ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"思维","slug":"POJ/思维","count":1,"path":"api/categories/POJ/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]}]}