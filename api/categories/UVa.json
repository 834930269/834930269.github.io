{"name":"UVa","slug":"UVa","count":35,"postlist":[{"title":"POJ 1061","slug":"poj-1061","date":"2017-01-13T15:53:30.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-1061.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 扩展欧几里得 【思路】 根据题意得方程:设跳t次遇见 (1) (x+mt)-(y+nt)=kL(因为一定是整数解(因为是整数解,所以符合扩欧)) (2)移项得:(n-m)t+kL=x-y &lt;=&gt; at+bL=z (3)扩欧定理中:a,b互质,只有整数解. (4)尝试z mod gcd(a,b)是否为0,如果为0则有解,不为0,则无解. (5)最后解得的t可能存在t&lt;0. (6)最后留下的一个疑问.为什么要 mod L/gcd(a,b)? 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;</algorithm></p>\n<p>typedef long long LL;</p>\n<p>LL gcd(LL a,LL b){<br>    if(b==0)return a;<br>    else return gcd(b,a%b);<br>}</p>\n<p>void exgcd(LL a,LL b,LL &amp;x,LL &amp;y){<br>    if(!b) x=1,y=0;<br>    else {exgcd(b,a%b,y,x); y-=x<em>(a/b);}<br>}<br>int main(){<br>    long long x,y,m,n,L,d,K,t,a,z,b;<br>    cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;L;<br>    if(m==n){<br>        cout&lt;&lt;”Impossible\\n”;<br>        return 0;<br>    }<br>    a=n-m;<br>    z=x-y;<br>    b=L;<br>    d=gcd(a,b);<br>    if((x-y)%d){<br>        cout&lt;&lt;”Impossible\\n”;<br>        return 0;<br>    }<br>    a/=d;<br>    b/=d;<br>    z/=d;<br>    exgcd(a,b,t,K);<br>    K</em>=z;//z=(x-y)/gcd(a,b)-&gt;即扩大倍数k,这句等价于KL<br>    t*=z;//狮子等比扩大z倍;<br>    t=(t%b+b)%b;<br>    cout&lt;&lt;t&lt;&lt;”\\n”;<br>    return 0;<br>}</p>\n","text":"【类型】 扩展欧几里得 【思路】 根据题意得方程:设跳t次遇见 (1) (x+mt)-(y+nt)=kL(因为一定是整数解(因为是整数解,所以符合扩欧)) (2)移项得:(n-m)t+kL=x-y &lt;=&gt; at+bL=z (3)扩欧定理中:a,b互质,只有整数解. (","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"扩展欧几里得","slug":"UVa/扩展欧几里得","count":1,"path":"api/categories/UVa/扩展欧几里得.json"},{"name":"数论","slug":"UVa/扩展欧几里得/数论","count":1,"path":"api/categories/UVa/扩展欧几里得/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1025","slug":"uva-1025","date":"2016-12-25T13:49:54.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/uva-1025.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策 2:搭乘往右开的车(如果有)。 决策 3:搭乘往左开的车(如果有)。 【Code】 P268 A Spy in the Metro  </p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;<br>const int inf=0x3f3f3f3f;<br>int N,T,LN,RN,kase=0;<br>bool has_train[205][55][2];<br>int dp[205][55],ti[55];</cstring></p>\n<p>void solve(){</p>\n<pre><code>for(int i=1;i&lt;N;++i) dp\\[T\\]\\[i\\]=inf;\ndp\\[T\\]\\[N\\]=0;\n\nfor(int i=T-1;i&gt;=0;i--)\n    for(int j=1;j&lt;=N;++j){\n        dp\\[i\\]\\[j\\]=dp\\[i+1\\]\\[j\\]+1;//等待一个单位\n        if(j&lt;N&amp;&amp;has_train\\[i\\]\\[j\\]\\[0\\]&amp;&amp;i+ti\\[j\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j\\]\\]\\[j+1\\]);//右\n        if(j&gt;1&amp;&amp;has_train\\[i\\]\\[j\\]\\[1\\]&amp;&amp;i+ti\\[j-1\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j-1\\]\\]\\[j-1\\]);//左\n    }\n\n    cout&lt;&lt;&quot;Case Number &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;;\n    if(dp\\[0\\]\\[1\\]&gt;=inf) cout&lt;&lt;&quot;impossible\\\\n&quot;;\n    else cout&lt;&lt;dp\\[0\\]\\[1\\]&lt;&lt;&quot;\\\\n&quot;;</code></pre><p>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;N&amp;&amp;N){<br>        cin&gt;&gt;T;</p>\n<pre><code>    memset(has\\_train,0,sizeof(has\\_train));\n\n    for(int i=1;i&lt;=N-1;++i)\n        cin&gt;&gt;ti\\[i\\];\n    cin&gt;&gt;LN;//左端点向右开的车\n    for(int i=1;i&lt;=LN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=1;j&lt;=N-1;++j){\n            if(start&lt;=T)has_train\\[start\\]\\[j\\]\\[0\\]=true;//第t秒第j个站点有车\n            start+=ti\\[j\\];\n        }\n    }\n\n    cin&gt;&gt;RN;//右端点向左开的车\n    for(int i=1;i&lt;=RN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=N-1;j&gt;=1;--j){\n               if(start&lt;=T) has_train\\[start\\]\\[j+1\\]\\[1\\]=true;//第t秒第j个站点有车总共N个站台,往回走\n                start+=ti\\[j\\];\n        }\n    }\n    solve();\n\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"},{"name":"算法学习","slug":"UVa/动态规划/算法学习","count":1,"path":"api/categories/UVa/动态规划/算法学习.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10375","slug":"uva-10375","date":"2017-01-08T14:19:03.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10375.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,素数筛法 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10375\" target=\"_blank\" rel=\"noopener\">UVa-10375-Choose and divide</a> 【唯一分解定理】 任何一个大于1的自然数<em>N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N</em>=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为素数，其中指数ai是正整数。这样的分解称为<em>N</em>的标准分解式. 【思路】 根据题意得: 给定p q r s 求 ①.(p!<em>s!</em>(r-s)!)/(r!<em>q!</em>(p-q)!) 暴力会炸,至于为啥.</p>\n<p>10000! 总位数：35660位,要不要试试？</p>\n<p>1.先筛10000以内的素数. 2.数组e表示当前结果的唯一分解式中各个素数的指数,prime数组第i位的指数是多少.如:e={1，0，2，0，0，0 …}表示pow(2,1)*pow(5,2)=50 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath></cmath></p>\n<p>#define MAXN 10000<br>using namespace std;</p>\n<p>int prime[MAXN];<br>bool is_prime[MAXN];<br>int primesize=0,p,q,r,s;</p>\n<p>int e[MAXN];</p>\n<p>void sieve(){<br>    memset(is_prime,1,sizeof(is_prime));<br>    is_prime[1]=is_prime[0]=false;<br>    for(int i=0;i&lt;MAXN;++i){<br>        if(is_prime[i]){<br>            prime[primesize++]=i;<br>            for(int j=i*2;j&lt;MAXN;j+=i)<br>                is_prime[j]=false;<br>        }<br>    }<br>}</p>\n<p>//乘以或除以n,d=1表示乘,d=-1表示除<br>void add_integer(int n,int d){<br>    for(int i=0;i&lt;primesize;++i){<br>        while(n%prime[i]==0){//必须是while<br>            n/=prime[i];<br>            e[i]+=d;<br>        }<br>        if(n==1)break;//提前终止循环,节约时间<br>    }<br>}</p>\n<p>void add_factorial(int n,int d){<br>    for(int i=1;i&lt;=n;++i)<br>        add_integer(i,d);<br>}</p>\n<p>int main(){<br>    sieve();<br>    while(cin&gt;&gt;p&gt;&gt;q&gt;&gt;r&gt;&gt;s){<br>        memset(e,0,sizeof(e));<br>        //以下一串表示上面的公式①的分子和分母.<br>        add_factorial(p,1);<br>        add_factorial(s,1);<br>        add_factorial(r-s,1);<br>        add_factorial(q,-1);<br>        add_factorial(r,-1);<br>        add_factorial(p-q,-1);<br>        double ans=1;<br>        for(int i=0;i&lt;primesize;++i)<br>            ans*=pow(prime[i],e[i]);<br>        printf(“%.5lf\\n”,ans);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,素数筛法 【题目来源】 UVa-10375-Choose and divide 【唯一分解定理】 任何一个大于1的自然数N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10755","slug":"uva-10755","date":"2017-04-08T08:04:53.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-10755.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>最大子长方体和,降维.</strong> <strong>【题解】</strong> <strong>蓝书P56</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i)</strong> <strong>using namespace std;</strong> <strong>typedef long long LL;</strong> <strong>const int maxn=30;</strong> <strong>const LL INF=1LL&lt;&lt;60;</strong> <strong>LL S[maxn][maxn][maxn];</strong> <strong>void expand(int i,int&amp; b0,int&amp; b1,int&amp; b2){</strong> **    b0=i&1; i&gt;&gt;=1;** **    b1=i&1; i&gt;&gt;=1;** **    b2=i&1;** <strong>}</strong> <strong>int sign(int b0,int b1,int b2){</strong> **    return (b0+b1+b2)%2==1?1:-1;** <strong>}</strong> <strong>LL sum(int x1,int x2,int y1,int y2,int z1,int z2){</strong> **    int dx=x2-x1+1,dy=y2-y1+1,dz=z2-z1+1;** **    LL s=0;** **    for(int i=0;i&lt;8;++i){** **        int b0,b1,b2;** **        expand(i,b0,b1,b2);** **        s-=S[x2-b0*dx][y2-b1*dy][z2-b2*dz]*sign(b0,b1,b2);** **    }** **    return s;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int a,b,c,b0,b1,b2;** **        scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **        memset(S,0,sizeof(S));** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    scanf(“%lld”,&amp;S[x][y][z]);** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    for(int i=1;i&lt;=7;++i){** **                        //001 010 011 100 101 110 111三种位移** **                        expand(i,b0,b1,b2);** **                        //递推求和,sign()-&gt;加 or 减; expand()-&gt;状态** **                        S[x][y][z]+=S[x-b0][y-b1][z-b2]<em>sign(b0,b1,b2);*</em> **                    }** **        LL ans=-INF;** **        for(int x1=1;x1&lt;=a;++x1)** **            for(int x2=x1;x2&lt;=a;++x2)** **                for(int y1=1;y1&lt;=b;++y1)** **                    for(int y2=y1;y2&lt;=b;++y2){** **                        LL M=0;** **                        //对于每次求某个x1,x2,y1,y2区间上的最大子长方体和** **                        //M等价于寻找z区间上(1-z)中最小的子矩阵** **                        for(int z=1;z&lt;=c;++z){** **                            LL s=sum(x1,x2,y1,y2,1,z);** **                            ans=max(ans,s-M);** **                            M=min(M,s);** **                        }** **                    }** **                    printf(“%lld\\n”,ans);** **                    if(T) printf(“\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 最大子长方体和,降维. 【题解】 蓝书P56 【Code】#include #include #include #include #define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i) using namespace std; t","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10791","slug":"uva-10791","date":"2017-01-09T05:11:28.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10791.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10791\" target=\"_blank\" rel=\"noopener\">UVa-10791-Minimum Sum LCM</a> 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因子(一定是素数)加到最后的结果中. 其过程等同于素数筛法,先筛2^a1,再筛3^a2 …其筛出的ai不为0的因子的底数一定是素数.因为  *唯一分解定理:一个数可以分解为若干素数的幂相乘的形式. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath><br>using namespace std;<br>typedef long long LL;</cmath></p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    LL N;<br>    int lam=1;<br>    while(cin&gt;&gt;N){<br>        if(N&lt;=0)break;<br>        LL sum=0,cnt=0;<br>        for(int i=2;i&lt;=sqrt(N);++i){<br>            if(N%i==0){<br>                LL mut=1;<br>                cnt++;<br>                while(N%i==0){<br>                    N/=i;<br>                    mut*=i;<br>                }<br>                sum+=mut;<br>            }<br>        }<br>        if(N&gt;1 || cnt==0){<br>            //这里的N是计算以后偶剩下的N,这个N一定是一个素数,直接加即可<br>            sum+=N;<br>            cnt++;<br>        }<br>        if(cnt==1) sum++;<br>       printf(“Case %d: %lld\\n”,lam++,sum);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 UVa-10791-Minimum Sum LCM 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10795","slug":"uva-10795","date":"2017-07-09T13:06:29.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10795.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10795\" target=\"_blank\" rel=\"noopener\">A Different Task</a></strong> <strong>汉诺塔问题总结:</strong> <a href=\"http://blog.csdn.net/xueerfei008/article/details/9904681\" target=\"_blank\" rel=\"noopener\"><strong>杭电 汉诺塔问题总结</strong></a> <strong>【题解】</strong> <strong>大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标.</strong> <strong>f(P,i,final):已知各盘子的初始柱子编号数组为P,把盘子1,2,3,4…i全部移到柱子final所需的步数.</strong> <strong>参考局面等于中转态.即中转柱子下标为6-P[i]-finish[i].将前i-1个盘子移动到中转柱上.然后把盘子i移动到final柱子上,最后将i-1个盘子从中转态移动到final.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2010795.cpp\" target=\"_blank\" rel=\"noopener\">UVA 10795.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long LL;</p>\n<p>LL f(int* P,int i,int finaln){<br>    if(i==0) return 0;<br>    ///如果当前最大的这个号的起始盘子等于最终落脚盘子<br>    ///不用移动.所以f(P,i,final)=f(P,i-1,final)<br>    if(P[i]==finaln) return f(P,i-1,finaln);<br>    ///经典汉诺塔的结论,将前i-1个盘子从一个柱子移动到另一个柱子<br>    ///这个步骤需要2^(i-1)-1步.加上移动盘子i到最终盘子<br>    ///的那一步,一共需要2^(i-1)步.<br>    return f(P,i-1,1+2+3-P[i]-finaln)+(1LL&lt;&lt;(i-1));<br>}</p>\n<p>const int maxn=60+10;<br>int n,start[maxn],finish[maxn];</p>\n<p>int main(){<br>    int kase=0;<br>    while(scanf(“%d”,&amp;n)==1&amp;&amp;n){<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;start[i]);<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;finish[i]); ///结论:如果最大的盘子一开始就在最终的柱子上 ///则不用移动. ///找到号码最大的那几个不需要移动的盘子. int k=n; while(k&gt;=1&amp;&amp;start[k]==finish[k])k–;</p>\n<pre><code>    ///结论:由于移动的步数是对称的,即往回移动的步伐\n    ///和步数等于往前移动.\n    LL ans=0;\n    if(k&gt;=1){\n        int other=6-start\\[k\\]-finish\\[k\\];\n        ans=f(start,k-1,other)+f(finish,k-1,other)+1;\n    }\n    printf(&quot;Case %d: %lld\\\\n&quot;,++kase,ans);\n}\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n","text":"【Link】 A Different Task 汉诺塔问题总结: 杭电 汉诺塔问题总结 【题解】 大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标. ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"模拟","slug":"UVa/思维/模拟","count":1,"path":"api/categories/UVa/思维/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10820","slug":"uva-10820","date":"2017-01-11T15:47:56.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10820.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 欧拉函数值,素数筛法,打表 【题目来源】 算法竞赛入门 P322 例题10-7 <a href=\"https://vjudge.net/problem/UVA-10820\" target=\"_blank\" rel=\"noopener\">UVa-10820-Send a Table</a> 【思路】 运用素数筛法的思想对1~50000内的数打表得到每个数的欧拉phi函数值. 然后处理表,使得从3开始往后每个phi[i]都等于前面的phi[i]的和加上phi[i]. 题目说可以通过f(x,y)计算f(x_k,y_k)即其意思就是要求的表内x,y必须互素. 其答案是2*f(n)+1,特判n=1. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cmath><br>using namespace std;<br>int phi[50010]={0};</cmath></p>\n<p>void init(){<br>    int n=50003;<br>    for(int i=2;i&lt;=n;++i) phi[i]=0;<br>    phi[1]=1;<br>    for(int i=2;i&lt;=n;++i)<br>        if(!phi[i])<br>            for(int j=i;j&lt;=n;j+=i){<br>                if(!phi[j])<br>                    phi[j]=j;<br>                phi[j]=phi[j]/i*(i-1);<br>            }<br>    for(int i=3;i&lt;=n;++i)<br>        phi[i]+=phi[i-1];<br>}</p>\n<p>int main(){<br>    init();<br>    int M;<br>    while(scanf(“%d”,&amp;M),M){<br>        M==1?printf(“1\\n”):printf(“%d\\n”,2*phi[M]+1);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 欧拉函数值,素数筛法,打表 【题目来源】 算法竞赛入门 P322 例题10-7 UVa-10820-Send a Table 【思路】 运用素数筛法的思想对1~50000内的数打表得到每个数的欧拉phi函数值. 然后处理表,使得从3开始往后每个phi[i]都等于前面的p","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"欧拉函数","slug":"UVa/数论/欧拉函数","count":1,"path":"api/categories/UVa/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10859","slug":"uva-10859","date":"2017-07-18T07:52:02.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/uva-10859.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10859\" target=\"_blank\" rel=\"noopener\">Placing Lampposts</a></strong> <strong>【题意】</strong> <strong>给你一个ｎ个点ｍ条边的无向无环图，在尽量少的节点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。</strong> <strong>在灯的总数最小的前提下，被两盏灯同时被照亮的边数应该尽量大。</strong> <strong>【题解】</strong> <strong>树形dp,Lrj P70。</strong> <strong>这题教会了我一个很有用的技巧：有两个所求的值要优化，比如让a尽量小，ｂ也尽量小</strong> <strong>那么可以转化为让 M*a+b尽量小，其中Ｍ应该是一个比“a的最大值和b的最小值之差”还要大的数</strong> <strong>最终的答案为ans/M, ans%M</strong> <strong>回到这题，要求放的灯总数最小，被两盏灯同时照亮的边数尽量大。</strong> <strong>因为每条边要么被一盏灯照亮，要么被两盏灯照亮，所以可以转换为：</strong> <strong>求：放的灯总数量最少，被一盏灯照亮的边数尽量少。</strong> <strong>就可以变成球 M*a+b 的最小值，ａ为放置的灯数量，ｂ为被一盏灯照的边数</strong> <strong>f[u][1]表示u点放灯时的整个子树最小值</strong> <strong>f[u][0]表示u点不放灯时的整个子树最小值</strong> <strong>如果u放，那么u个子结点可以选择放，也可以不放，选择其中较小的值。如果选的是不照，就要增加一条只有一个灯照的边</strong> <strong>如果u不放，那么其子结点就必须选择要放，而且每条边都只有一个灯照</strong> <strong>【Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVA%2010859.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10859.cpp</a></strong></p>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int T,n,m,vis[2000][2],d[2000][2];<br>vector Graph[1010];</p>\n<p>int dp(int i,int j,int f){<br>    if(vis[i][j]) return d[i][j];<br>    vis[i][j]=1;<br>    int&amp; ans=d[i][j];</p>\n<pre><code>ans=2000;\nfor(int k=0;k&lt;Graph\\[i\\].size();++k)** \n    if(Graph\\[i\\]\\[k\\]!=f) \n       ans+=dp(Graph\\[i\\]\\[k\\],1,i); \nif(!j &amp;&amp; f&gt;=0)  ans++;\n\nif(j || f&lt;0){\n    int sum=0;\n    for(int k=0;k&lt;Graph\\[i\\].size();++k) \n       if(Graph\\[i\\]\\[k\\]!=f) \n          sum+=dp(Graph\\[i\\]\\[k\\],0,i); \n    if(f&gt;=0) sum++;\n    ans=min(ans,sum);\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d”,&amp;n,&amp;m);<br>        for(int i=0;i&lt;n;++i) Graph[i].clear();<br>        for(int i=0;i&lt;m;++i){<br>            int x,y;<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            Graph[x].push_back(y);<br>            Graph[y].push_back(x);<br>        }<br>        memset(vis,0,sizeof(vis));<br>        int ans=0;<br>        for(int i=0;i&lt;n;++i){<br>            if(!vis[i][0])///新的一棵树<br>                ans+=dp(i,0,-1);<br>        }<br>        printf(“%d %d %d\\n”,ans/2000,m-ans%2000,ans%2000);<br>    }<br>    return 0;<br>}</p>\n","text":"【Topic Link】 Placing Lampposts 【题意】 给你一个ｎ个点ｍ条边的无向无环图，在尽量少的节点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。 在灯的总数最小的前提下，被两盏灯同时被照亮的边数应该尽量大。 【题解】 树形dp,Lrj P7","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"树形dp","slug":"UVa/树形dp","count":1,"path":"api/categories/UVa/树形dp.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"树形dp","slug":"树形dp","count":1,"path":"api/tags/树形dp.json"}]},{"title":"UVa 10891","slug":"uva-10891","date":"2017-07-13T16:42:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10891.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10891\" target=\"_blank\" rel=\"noopener\">Game of Sum</a></strong> <strong>【题意】</strong> <strong>给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B).</strong> <strong>【题解】</strong> <strong>因为任意时刻游戏的状态都是连续子序列.</strong> <strong>用d(i,j)表示原序列的第i~j个元素组成的子序列.在双方都采取最优策略的情况下,先手得分的最大值.</strong> <strong>状态转移时,我们考虑从左取和从右取多少个.等价于枚举给对方剩下怎样的子序列.是(k,end)(begin&lt;k&lt;=end),还是(begin,k)(begin&lt;=k&lt;end).</strong> <strong>状态转移方程:d(begin,end)=sum(begin,end)-min{d(begin+1,end),d(begin+2,end),…,d(end,end), d(begin,end-1),d(begin,end-2),…,d(begin,begin),0}</strong> <strong>0代表全取完,所以不需要边界处理.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVa%2010891.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10891.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=100+20;<br>int A[maxn],vis[maxn][maxn],S[maxn],d[maxn][maxn];</p>\n<p>int dp(int b,int e){<br>    if(vis[b][e]) return d[b][e];///记忆化搜索<br>    vis[b][e]=1;<br>    int m=0;<br>    ///从b-&gt;e选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b+1;k&lt;=e;++k) m=min(m,dp(k,e)); ///从e-&gt;b选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b;k&lt;e;++k) m=min(m,dp(b,k));<br>    d[b][e]=S[e]-S[b-1]-m;<br>    return d[b][e];<br>}</p>\n<p>int main(){<br>    int n;S[0]=0;<br>    while(~scanf(“%d”,&amp;n) &amp;&amp; n){<br>        for(int i=1;i&lt;=n;++i){**<br> <strong>scanf(“%d”,&amp;A[i]);</strong><br> <strong>S[i]=S[i-1]+A[i];</strong><br> <strong>}</strong><br> <strong>memset(vis,0,sizeof(vis));</strong><br> <strong>printf(“%d\\n”,2*dp(1,n)-S[n]);///=&gt;dp(1,n)-(S[n]-dp(1,n))<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Game of Sum 【题意】 给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B). 【题解】 因为任意时刻游戏的状态都是连续子序列. 用d(i,j)","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11021","slug":"uva-11021","date":"2018-03-13T01:56:34.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/uva-11021.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-概率\"><a href=\"#Type-概率\" class=\"headerlink\" title=\"Type: 概率\"></a>Type: 概率</h1><h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>有点难以理解题解的递推式,把那句f(i-1)表示i-1天后全部死亡改成f(i-1)表示i-1天后一个不生的概率可能更好理解一点吧 不知道怎么证明这个式子,思维还是不强</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1010;\n\ndouble f[maxn],P[maxn];;\nint n,k,m,T;\n\nint main(){\n    cin&gt;&gt;T;\n    for(int i=1;i&lt;=T;++i){\n        cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;\n        for(int j=0;j&lt;n;++j) cin&gt;&gt;P[j];\n        f[0]=0;f[1]=P[0];\n        for(int j=2;j&lt;=m;++j){\n            f[j]=0;\n            for(int t=0;t&lt;n;++t){\n                f[j]+=(P[t]*pow(f[j-1],t));\n            }\n        }\n        printf(&quot;Case #%d: %.7lf\\n&quot;,i,pow(f[m],k));\n    }\n    return 0;\n}</code></pre>","text":"Type: 概率题解有点难以理解题解的递推式,把那句f(i-1)表示i-1天后全部死亡改成f(i-1)表示i-1天后一个不生的概率可能更好理解一点吧 不知道怎么证明这个式子,思维还是不强Code#include&lt;bits/stdc++.h&gt;using namespac","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11078","slug":"uva-11078","date":"2017-04-04T11:57:26.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11078.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Credit 信誉,信用,相信,信任</strong> <strong>senior 上司,高级的</strong> <strong>as if 犹如,好似</strong> <strong>attend 出席,致力于,照料</strong> <strong>requisite 必需品,必需的</strong> <strong>advance 发展,前行,增长</strong> <strong>assess 评定,估价</strong> <strong>amount 数量,总数,总计</strong> <strong>figure out 计算出,估计</strong> <strong>【题解】</strong> <strong>记录输入时队列前面的最大值,然后用最大值依次减去后面比他小的数,维护ans.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int ans,T,N,Max,c;</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        scanf(“%d”,&amp;N);** **        ans=-INF;Max=-INF;** **        for(int i=0;i&lt;N;++i){** **                scanf(“%d”,&amp;c);** **                ans=max(ans,Max-c);** **                Max=max(Max,c);** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Credit 信誉,信用,相信,信任 senior 上司,高级的 as if 犹如,好似 attend 出席,致力于,照料 requisite 必需品,必需的 advance 发展,前行,增长 assess 评定,估价 amount 数量,总数,总计 figure ou","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11181 + UVa 10491","slug":"uva-11181-uva-10491","date":"2017-01-15T15:14:56.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-11181-uva-10491.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 第一题:dfs 全概率 回溯 第二题:全概率 【Tip】 条件概率: P(A|B)=P(AB)|P(B).  P(A|B)指.在事件B的前提下,发生A的概率. P(AB)指两个时间A和B同时发生的概率.P(AB)=P(A)P(B). 全概率: P(A)=P(A|B1)_P(B1)+P(A|B2)_P(B2)+…+P(A|Bn)*P(Bn). 【Code】 11181:</p>\n<blockquote>\n<p><em>#include &lt;stdio.h&gt;</em> <em>#include &lt;string.h&gt;</em> <em>const int N = 30;</em> <em>int n;</em> <em>double p[N], ans[N];</em> <em>double dfs(int c, int k, double pi) {</em> _    if (c &gt; n) return k ? 0 : pi;_ _    double sum = 0;_ _       if (k) {_ _        sum += dfs(c + 1, k - 1, pi * p[c]);//选择_ _        ans[c] += sum;_ _    }_ _    sum += dfs(c + 1, k, pi * (1 - p[c])); //回溯_ _    return sum;_ <em>}</em> <em>int main () {</em> _    int r, cas = 1;_ _    while (scanf(“%d%d”, &amp;n, &amp;r), n + r) {_ _        for (int i = 1; i &lt;= n; i++)_ _            scanf(“%lf”, &amp;p[i]);_ _        memset(ans, 0, sizeof(ans));_ _        printf(“Case %d:\\n”, cas++);_ _        double P = dfs(1, r, 1);_ _        for (int i = 1; i &lt;= n; i++)_ _            printf(“%.6lf\\n”, ans[i] / P);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>10491：</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>int main(){</em> _    int a,b,c;_ _    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c){_ _        printf(“%.5lf\\n”,1.0<em>(a*b+b\\</em>(b-1))/((a+b-c-1)*(a+b)));_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n","text":"【类型】 第一题:dfs 全概率 回溯 第二题:全概率 【Tip】 条件概率: P(A|B)=P(AB)|P(B).  P(A|B)指.在事件B的前提下,发生A的概率. P(AB)指两个时间A和B同时发生的概率.P(AB)=P(A)P(B). 全概率: P(A)=P(A|B1)_","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11384","slug":"uva-11384","date":"2017-04-04T09:45:31.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11384.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>screen 屏幕</strong> <strong>subtract 减去,扣掉</strong> <strong>objective 目标,目的</strong> <strong>Her objective will be to make all the numbers 0.  他的目标是将所有的数字变成0.</strong> <strong>as 作为</strong> <strong>twist 扭曲,拧,拧伤,使苦恼</strong> <strong>for each 为每一个</strong> <strong>determine 下决心,决定,确定</strong> <strong>terminated 终止于</strong> <strong>separate 单独的</strong> <strong>【题解】</strong> <strong>蓝书P26</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>int N,cnt;</strong> <strong>//可以发现..其实右边界并没有用到= =Orz</strong> <strong>int solve(int l,int r,int num){</strong> **    if(l==1 &amp;&amp; r==1){** **        printf(“%d\\n”,num);** **        return num;** **    }** **    solve((l-1)/2+1,l-1,num+1);** <strong>}</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;N)){** **        cnt=0;** **        cnt=solve(N/2+1,N,1);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 screen 屏幕 subtract 减去,扣掉 objective 目标,目的 Her objective will be to make all the numbers 0.  他的目标是将所有的数字变成0. as 作为 twist 扭曲,拧,拧伤,使苦恼 for ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11401","slug":"uva-11401","date":"2018-02-04T10:10:32.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11401.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11401\" title=\"https://vjudge.net/problem/UVA-11401\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11401</a></p>\n<h1 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h1><p>组合数学,加法原理,三角形三边定理</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>考虑三角形三边定理.</p>\n<blockquote>\n<p>设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条边. 则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边) 考虑y的取值,确定z的取值.</p>\n<blockquote>\n<p>y∈[1,x-1] 当y取1时,z无值.当y取2时,z有唯一值x-1 当y取3时,z可以取(x-1),(x-2). 故y取x-1时,z可以取的种数为x-2种.</p>\n<blockquote>\n<p>根据等差数列求和公式: 总种类数Sn = 0+1+2+…+(x-2)</p>\n</blockquote>\n<p>Sn = (x-2)(x-1)/2(种) 但这个值并不等于c(x) 因为:</p>\n<blockquote>\n<p>1.对于每个三角形都计数了两遍 =&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2 2.以上的计算方式存在y=z的情况 (这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z) =&gt; 比如x=7 y=4时,z就可以取到4</p>\n<blockquote>\n<p>对于第二种问题的解决很简单. 对于每个x考虑y==z的情况: 设t为c(x)中y=z时的情况总数: 则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.</p>\n</blockquote>\n<p>故t=(x-1)-(x/2+1)+1=x-1-(int)x/2</p>\n</blockquote>\n</blockquote>\n<p>故c(x)=(Sn-t)/2</p>\n<blockquote>\n<p>又因为c(x)是最长边为x时的种类数.</p>\n</blockquote>\n<p>故设f(n)为最长边不超过n时的种类数 根据加法原理,因为互无交集 故 f(n)=c(1)+c(2)+c(3)+…+c(n)</p>\n</blockquote>\n<p>化成递推: f(n)=f(n-1)+c(n)</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11401\ntype: 组合数学,加法原理,三角形三边定理\n题意: 给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形\n\n题解:\n考虑三角形三边定理.\n设c(x)为以x为最长边的可拼成三角形的数目.\n设y,z为另外两条边.\n则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边)\n考虑y的取值,确定z的取值.\ny∈[1,x-1]\n当y取1时,z无值.当y取2时,z有唯一值x-1\n当y取3时,z可以取(x-1),(x-2).\n故y取x-1时,z可以取的种数为x-2种.\n根据等差数列求和公式:\n总种类数Sn\n= 0+1+2+...+(x-2)\n= (x-2)(x-1)/2(种)\n但这个值并不等于c(x)\n因为:\n1.对于每个三角形都计数了两遍\n=&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2\n2.以上的计算方式存在y=z的情况\n(这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z)\n=&gt; 比如x=7 y=4时,z就可以取到4\n对于第二种问题的解决很简单.\n对于每个x考虑y==z的情况:\n设t为c(x)中y=z时的情况总数:\n则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.\n故t=(x-1)-(x/2+1)+1=x-1-(int)x/2\n故c(x)=(Sn-t)/2\n又因为c(x)是最长边为x时的种类数.\n故设f(n)为最长边不超过n时的种类数\n根据加法原理,因为互无交集\n故 f(n)=c(1)+c(2)+c(3)+...+c(n)\n化成递推: f(n)=f(n-1)+c(n)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nlong long sum[maxn];\nint n;\ninline void init(){\n    long long Sn,Cn,t;\n    memset(sum,0,sizeof(sum));\n    for(long long i=4;i&lt;=1000000;++i){\n        Sn=(i-2)*(i-1)/2;\n        t=i-1-i/2;\n        Cn=(Sn-t)&gt;&gt;1;\n        int id=(int)i;\n        sum[id]=sum[id-1]+Cn;\n    }\n}\nint main(){\n    init();\n    while(cin&gt;&gt;n){\n        if(n&lt;3)break;\n        cout&lt;&lt;sum[n]&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11401type组合数学,加法原理,三角形三边定理题意给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形题解考虑三角形三边定理.设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11426","slug":"uva-11426","date":"2018-02-12T08:37:59.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11426.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11426\" title=\"https://vjudge.net/problem/UVA-11426\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11426</a></p>\n<h1 id=\"Type-数论-欧拉函数-递推-思维\"><a href=\"#Type-数论-欧拉函数-递推-思维\" class=\"headerlink\" title=\"Type: 数论,欧拉函数,递推,思维\"></a>Type: 数论,欧拉函数,递推,思维</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n∈[1,4000000]</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>首先我们应该清楚</p>\n<blockquote>\n<p>4000000的数据,用暴力 - 对每个gcd求值相加复杂度是i*j*O(gcd) 你懂就行,这么大的复杂度肯定爆炸.</p>\n</blockquote>\n<p>所以我们第一想法肯定是预处理.</p>\n<blockquote>\n<p>我们设 f(n) 为 (1,n)+(2,n)+(3,n)+…+(n-1,n) 则 S(n)=f(1)+f(2)+…+f(n)</p>\n<blockquote>\n<p>通过这个公式我们就可以递推出所有的 S(n)</p>\n<blockquote>\n<p>S(n)=S(n-1)+f(n)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>然后我们的问题就转化成了求f(n)</p>\n<blockquote>\n<p>首先我们会自然地想到,与n互素的答案是1.即(k,n)的结果都是n的约数</p>\n<blockquote>\n<p>我们可以按照这个约数来进行分类, 用 g(n,i)表示满足gcd(x,n)=i 且 x\\&lt;n 的正整数x的个数 则: f(n)=Sum(i*g(n,i) | i是n的约数,g(n,i)是1~n中gcd(k,n)=i的k的个数)</p>\n<blockquote>\n<p>然后我们注意到: -gcd(x,n)=i -则gcd(x/i,n/i)=1 -即x/i与n/i互质</p>\n</blockquote>\n<p>然后我们就可以将 g(n,i) 看做1~n中与 n/i 互质的数的个数,即</p>\n</blockquote>\n<p>g(n,i) = phi(n/i) 然后我们预处理phi[maxn],预处理完以后处理f(n),这里如果用二重循环依然是接受不了的 所以我们沿用筛法的思想对f[maxn]数组进行预处理,遇到i 是 k 的约数时,直接f[k]+=(i*phi[n/i])</p>\n</blockquote>\n<p>最后预处理S[maxn]即可</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\n我们要求:\nG=Sigma(i=1~N) Sigma(j=i+1~N) GCD(i,j)\nN&lt;=4000000，这样的范围二次循环+GCD肯定是不行的\n所以我们考虑\nf(n)=Sigma(i=1~n-1) gcd(i,n)\n则\nG(n)=Sigma(i=1~n) f(i)\n=G(n-1)+f(n)\n所以我们的问题转换为如何求f(n)\n\n即k都是n的约数\n可以按照约数进行分类,用g(n,i)表示满足 (x,n)=i且x&lt;n的正整数x的个数\n则 f(n)=sum(i\\*g(n,i)|i是n的约数)\n\n再重提: g(n,i)代表满足(x,n)=i,且x&lt;n的正整数x的个数\n\n我们知道,如果 (a,n)=k\n则 (a/k,n/k)=1\n\n所以我们可以理解为g(n,i)代表的是x/i与n/i互质的数的个数\n即满足条件的x/i 有 phi(n/i)个\ng(n,i)=phi(n/i)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=4000000+10;\nLL phi[maxn];\n\nLL f[maxn];\n\nLL g[maxn];\nvoid phi_table(){\n    for(int i=2;i&lt;maxn;++i) phi[i]=0;\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nvoid init(){\n    phi_table();\n    memset(f,0,sizeof(f));\n    for(int i=1;i&lt;maxn;++i){\n        for(int j=i*2;j&lt;maxn;j+=i){\n            f[j]+=(i*phi[j/i]);\n        }\n    }\n    memset(g,0,sizeof(g));\n    for(int i=1;i&lt;maxn;++i) g[i]=g[i-1]+f[i];\n}\n\nint main(){\n    init();\n    int k;\n    while(~scanf(&quot;%d&quot;,&amp;k) &amp;&amp; k){\n        printf(&quot;%lld\\n&quot;,g[k]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11426Type: 数论,欧拉函数,递推,思维题意输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"数论","slug":"UVa/思维/数论","count":1,"path":"api/categories/UVa/思维/数论.json"},{"name":"欧拉函数","slug":"UVa/思维/数论/欧拉函数","count":1,"path":"api/categories/UVa/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11462","slug":"uva-11462","date":"2017-04-04T10:51:00.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11462.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题解】</strong> <strong>数据过大,因为年龄只有120左右,所以用数组映射,计数排序.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>//isdigit宏在cctype中</strong> <strong>using namespace std;</strong> <strong>inline int readint(){</strong> **    char c=getchar();** **    while(!isdigit(c)) c=getchar();** **    int x=0;** **    while(isdigit(c)){** **        x=x<em>10+c-‘0’;*</em> **        c=getchar();** **    }** **    return x;** <strong>}</strong> <strong>int buf[10]; //声明成全局变量可以减小开销</strong> <strong>inline void writeint(int i){</strong> **    int p=0;** **    if(i==0)p++;//特殊情况:i等于0的时候需要输出0,而不是什么也不输出;** **    else while(i){** **        buf[p++]=i%10;** **        i/=10;** **    }** **    for(int j=p-1;j&gt;=0;j–) putchar(‘0’+buf[j]);//逆序输出** <strong>}</strong> <strong>int main(){</strong> **    int n,x,c[101];** **    while(n=readint()){** **        memset(c,0,sizeof(c));** **        for(int i=0;i&lt;n;++i) c[readint()]++;** **        int first=1;** **        for(int i=1;i&lt;=100;++i)** **            for(int j=0;j&lt;c[i];++j){** **                if(!first) putchar(‘ ‘);** **                first=0;** **                writeint(i);** **            }** **        putchar(‘\\n’);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【题解】 数据过大,因为年龄只有120左右,所以用数组映射,计数排序. 【Code】#include&lt;bits/stdc++.h&gt; //isdigit宏在cctype中 using namespace std; inline int readint(){ **    ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa  11464","slug":"uva-11464","date":"2017-03-31T12:59:56.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-11464.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>gird 网格,格子</strong> <strong>so taht 以便</strong> <strong>The parity 奇偶校验</strong> <strong>even 有偶数意</strong> <strong>transformation 转化</strong> <strong>achieve 取得,获得,实现,成功</strong> <strong>requirement 要求</strong> <strong>indicates 表明</strong> <strong>character 性格,品质</strong> <strong>separated 分开,隔开</strong> <strong>instead 代替,反而,相反</strong> <strong>【题解】</strong> <strong>蓝书 P16</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<algorithm></algorithm></strong> <strong>using namespace std;</strong> <strong>const int INF=0x3f3f3f3f;</strong> <strong>const int maxn=20;</strong> <strong>int A[maxn][maxn],B[maxn][maxn],n,T,ca=1;</strong> <strong>int check(int s){</strong> **    memset(B,0,sizeof(B));** <strong>//先初始化第一行</strong> **    for(int i=0;i&lt;n;++i){** **        if(s &amp; (1&lt;&lt;i)) B[0][i]=1;//这句意思是判断每一位上是否是1** <strong>//即(1&lt;&lt;n)只有第n位是1,其他位都是0 为真即为1</strong> <strong>else if(A[0][i]==1) return INF;//1不能变成0</strong> **    }** **    for(int i=1;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            int sum=0;//元素B[i-1][0]的上,左,右元素之和** **            if(i&gt;1)sum+=B[i-2][j];** **            if(j&gt;0)sum+=B[i-1][j-1];** <strong>if(j&lt;n-1)sum+=B[i-1][j+1];</strong> **            B[i][j]=sum%2;//sum是偶数,=0,奇数,=1** **            if(A[i][j]==1 &amp;&amp; B[i][j]==0) return INF;** <strong>//不存在1-&gt;0的操作.</strong> <strong>}</strong> **    }** **    int cnt=0;** **    for(int i=0;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            if(A[i][j]!=B[i][j])** <strong>cnt++;</strong> <strong>}</strong> <strong>}</strong> <strong>return cnt;</strong> <strong>}</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        printf(“Case %d: “,ca++);** **        scanf(“%d”,&amp;n);** **        for(int i=0;i&lt;n;++i)** **            for(int j=0;j&lt;n;++j)** **                scanf(“%d”,&amp;A[i][j]);** <strong>int ans=INF;</strong> **        for(int i=0;i&lt;(1&lt;&lt;n);++i)** <strong>ans=min(ans,check(i));</strong> **        if(ans==INF) ans=-1;** <strong>printf(“%d\\n”,ans);</strong> <strong>}</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 gird 网格,格子 so taht 以便 The parity 奇偶校验 even 有偶数意 transformation 转化 achieve 取得,获得,实现,成功 requirement 要求 indicates 表明 character 性格,品质 separ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"枚举","slug":"UVa/位操作/枚举","count":1,"path":"api/categories/UVa/位操作/枚举.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"}]},{"title":"UVa 11538","slug":"uva-11538","date":"2018-02-04T04:55:35.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11538.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"题目连接：\"><a href=\"#题目连接：\" class=\"headerlink\" title=\"题目连接：\"></a>题目连接：</h1><p><a href=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" title=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" target=\"_blank\" rel=\"noopener\">https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087</a> PS: 蓝书P105，书上有一个错误的地方,Sigma(1<del>n-1) i(i-1)那里书上得到的结果是2*Sigma(1</del>n-1) i(i-1)的结果.我在代码中标注了.</p>\n<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link:\"></a>Link:</h1><p><a href=\"https://vjudge.net/problem/UVA-11538\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11538</a> type: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意:\"></a>题意:</h1><p>有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解:\"></a>题解:</h1><blockquote>\n<p>分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线</p>\n<blockquote>\n<p>同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1) 同一列: 合同一行类似,结果是nm(n-1) 同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)</p>\n<blockquote>\n<p>可以观测到所有’/‘方向的斜线长度为: 1,2,3,…,n,n,n,n-1,n-2…,2,1 其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可) 其中每条斜线上的取法种数 = i<em>(i-1) diagonal=Sigma(1~n-1) i(i-1) =&gt; i==1时确实是0种可能,因为皇后是放在块内而不是点上的. 则 All_diagonal = 2(2*diagonal+(m-n+1)*n</em>(n-1)) =&gt; 这里的乘2是因为有两种斜线’/‘和’\\‘的可能 其中</p>\n<blockquote>\n<p>diagonal =Sigma(1<del>n-1) i^2 - Sigma(1</del>n-1) i =n(n-1)(2n-1)/6 - n(n-1)/2 =n(n-1)(2n-4)/6 All_diagonal = 2(2<em>(n(n-1)(2n-4)/6)+(m-n+1)*n\\</em>(n-1)) = 2n(n-1)(3m-n-1)/3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>这三种情况互不相交,最终答案就等于三者和.</p>\n</blockquote>\n<p>Code:</p>\n<pre><code>/*\nLink: https://vjudge.net/problem/UVA-11538\ntype: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6\n\n题意: 有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.\n\n题解: 分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线\n\n同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1)\n同一列: 合同一行类似,结果是nm(n-1)\n同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)\n    可以观测到所有&apos;/&apos;方向的斜线长度为: 1,2,3,...,n,n,n,n-1,n-2...,2,1\n    其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可)\n    其中每条斜线上的取法种数 = i*(i-1)\n    diagonal=Sigma(1~n-1) i(i-1)   =&gt;   i==1时确实是0种可能,因为皇后是放在块内而不是点上的.\n    则   All_diagonal = 2(2*diagonal+(m-n+1)*n*(n-1))  =&gt; 这里的乘2是因为有两种斜线&apos;/&apos;和&apos;\\&apos;的可能\n    其中diagonal=Sigma(1~n-1) i^2 - Sigma(1~n-1) i  =&gt;n方和展开公式,等差数列求和\n                =n(n-1)(2n-1)/6 - n(n-1)/2\n                =n(n-1)(2n-4)/6\n\n        All_diagonal = 2(2*(n(n-1)(2n-4)/6)+(m-n+1)*n*(n-1))\n                     = 2n(n-1)(3m-n-1)/3\n\n这三种情况互不相交,最终答案就等于三者和.\n*/\n\n//Code\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nunsigned long long N,M;\nint main(){\n    while(cin&gt;&gt;N&gt;&gt;M){\n        if(N==0&amp;&amp;M==0)break;\n        unsigned long long row=N*M*(M-1);\n        unsigned long long column=N*M*(N-1);\n\n        if(N&gt;M) swap(N,M);\n        cout&lt;&lt;row+column+2*N*(N-1)*(3*M-N-1)/3&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"题目连接：https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087 PS: 蓝书P105，书上有一个错误的地方,Sigma(1n-1) i(i-1)那里书上得到的结果是2*Sigma(1n-","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11806","slug":"uva-11806","date":"2018-02-05T09:48:17.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11806.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11806\" title=\"https://vjudge.net/problem/UVA-11806\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11806</a></p>\n<h1 id=\"Type\"><a href=\"#Type\" class=\"headerlink\" title=\"Type:\"></a>Type:</h1><blockquote>\n<p>组合数学,排列预处理,容斥原理,减法取模公式</p>\n</blockquote>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,</p>\n<blockquote>\n<p>问最上边,最左边,最下边,最右边都有石子的种数为多少?</p>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>我们可以将问题转化为:</p>\n<blockquote>\n<p>全集|S|-至少有一条边上没有棋子的种类个数. 并且我们可以发现,当四条边上都没有棋子时的种类个数为</p>\n<blockquote>\n<p>C((m-2)*(n-2),k).</p>\n</blockquote>\n<p>我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,D为下边没有石子. 则(我们设~A为非A集合):</p>\n<blockquote>\n<p>ans=|(<del>A)∩(</del>B)∩(<del>C)∩(</del>D)|</p>\n</blockquote>\n<p>可以发现就是容斥原理 至于每个集合的计算,在图中就相当于少了一行或一列, 即:</p>\n<blockquote>\n<p>C(row*column,k)</p>\n</blockquote>\n<p>因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能 即 可以用四位2进制表示</p>\n<blockquote>\n<p>0000 0001 0010</p>\n</blockquote>\n<p>我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行)) 等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0</p>\n</blockquote>\n<p>答案为全部的和.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11806\nType: 组合数学,排列预处理,容斥原理,减法取模公式\n题意: 给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,\n问最上边,最左边,最下边,最右边都有石子的种数为多少?\n\n题解:\n我们可以将问题转化为:\n全集|S|-至少有一条边上没有棋子的种类个数.\n并且我们可以发现,当四条边上都没有棋子时的种类个数为\nC((m-2)*(n-2),k).\n我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,\nD为下边没有石子.\n则(我们设~A为非A集合):\nans=|(~A)∩(~B)∩(~C)∩(~D)|\n可以发现就是容斥原理\n至于每个几何的计算,在图中就相当于少了一行或一列,\n即:\nC(row*column,k)\n因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能\n即 可以用四位2进制表示\n0000\n0001\n0010\n我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行))\n等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0\n答案为全部的和.\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11806Type:组合数学,排列预处理,容斥原理,减法取模公式题意给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,问最上边,最左边,最下边,最右边都有石子的种数为多少?题解我们可以将","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"容斥原理","slug":"UVa/容斥原理","count":1,"path":"api/categories/UVa/容斥原理.json"},{"name":"数论","slug":"UVa/容斥原理/数论","count":1,"path":"api/categories/UVa/容斥原理/数论.json"},{"name":"组合数学","slug":"UVa/容斥原理/数论/组合数学","count":1,"path":"api/categories/UVa/容斥原理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11825","slug":"uva-11825","date":"2017-07-14T16:41:09.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-11825.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-11825\" target=\"_blank\" rel=\"noopener\">Hackers’ Crackdown</a></strong> <strong>【题意】</strong> <strong>有N台机器，每台机器上有N个服务</strong> <strong>你可以对每台机器选择关闭他以及和他相邻的机器的一种服务</strong> <strong>当所有机器不能运行一个服务时，就是摧毁了一种服务</strong> <strong>问你最多能摧毁多少个服务</strong> <strong>【题解】</strong> <strong>就是把n台电脑看成n个集合,每个集合的成员就是这台电脑,以及和这台电脑相邻的电脑;</strong> <strong>我们就是要求把这些集合合并成尽量多的大集合,使每个集合都等于全集;也就是因为最开始的小集合,我们可以让它里面全部电脑的某一项服务全部失误,那如果合并成一个大集合,则这个大集合的某一项服务可以全部失效;所以能合并成几个等于全集的大集合,就可以让几项服务失效;</strong> <strong>【Tip】</strong> <strong>状态压缩,异或操作是相同得0,不同得1.LRJ这道题的位运算用的好…</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2011825.cpp\" target=\"_blank\" rel=\"noopener\">Uva 11825.cpp</a></strong></p>\n<hr>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int N,T,P[1&lt;&lt;17],f[1&lt;&lt;17],cover[1&lt;&lt;17],ca=1;<br>int main(){<br>    while(~scanf(“%d”,&amp;N),N){<br>        ///初始化第i台计算机的相邻集合<br>        for(int i=0;i&lt;N;++i){<br>            int n,m;<br>            scanf(“%d”,&amp;n);<br>            P[i]=1&lt;&lt;i;<br>            for(int j=0;j&lt;n;++j){<br>                scanf(“%d”,&amp;m);<br>                P[i] |= 1&lt;&lt;m;<br>            }<br>        }<br>        ///S是N个计算机的所有组合的集合,二进制表示,cover[S]是集合的并<br>        for(int S=0;S&lt;(1&lt;&lt;N);++S){<br>            cover[S]=0;<br>            for(int i=0;i&lt;N;++i){<br>                if(S &amp; (1&lt;&lt;i)) cover[S] |= P[i];///第i台机器选/不选<br>            }<br>        }<br>        f[0]=0;<br>        int ALL=(1&lt;&lt;N)-1;///全集二进制表示<br>        for(int S=1;S&lt;(1&lt;&lt;N);++S){<br>            f[S]=0;<br>            ///筛出S的子集进行动态规划<br>            for(int S0=S;S0;S0=(S0-1)&amp;S){<br>                if(cover[S0]==ALL)///如果子集S的子集的并是全集<br>                    f[S]=max(f[S],f[S^S0]+1);<br>            }<br>        }<br>        printf(“Case %d: %d\\n”,ca++,f[ALL]);<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Hackers’ Crackdown 【题意】 有N台机器，每台机器上有N个服务 你可以对每台机器选择关闭他以及和他相邻的机器的一种服务 当所有机器不能运行一个服务时，就是摧毁了一种服务 问你最多能摧毁多少个服务 【题解】 就是把n台电脑看成n个集合,每","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"动态规划","slug":"UVa/位操作/动态规划","count":1,"path":"api/categories/UVa/位操作/动态规划.json"},{"name":"状态压缩","slug":"UVa/位操作/动态规划/状态压缩","count":1,"path":"api/categories/UVa/位操作/动态规划/状态压缩.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}]},{"title":"UVa 1262","slug":"uva-1262","date":"2017-01-13T15:45:11.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1262.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 组合数学 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-1262\" target=\"_blank\" rel=\"noopener\">UVa-1262-Password</a> 【思路】 见紫书P323例10-8 【WA Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;</cstring></p>\n<p>char m[8][8];<br>char a[8][8];<br>int reg[8][8]={0},n;</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=reg[i][0];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=reg[i][0];<br>        j=n/tot;<br>        printf(“%c”,reg[i][j+1]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        memset(reg,0,sizeof(reg));<br>        int flag=1;<br>        cin&gt;&gt;n;<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>for(int i=1;i&lt;=6;++i)\n        scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\nfor(int j=1;j&lt;=5;++j)\n    for(int t=1;t&lt;=6;++t)\n        for(int i=1;i&lt;=6;++i)\n            if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\]){\n                reg\\[j\\]\\[++reg\\[j\\]\\[0\\]\\]=a\\[t\\]\\[j\\];\n                break;\n            }\n\nfor(int t=1;t&lt;=5;++t){\n    if(reg\\[t\\]\\[0\\]==0) flag=0;\n    sort(&amp;reg\\[t\\]\\[1\\],&amp;reg\\[t\\]\\[reg\\[t\\]\\[0\\]+1\\]);\n}</code></pre><p> /*<br>        for(int t=1;t&lt;=5;++t){<br>            for(int q=1;q&lt;=reg[t][0];++q)<br>                printf(“%c “,reg[t][q]);<br>            printf(“\\n”);<br>        }<br>        */</p>\n<pre><code>    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n<p>【AC Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>char m[10][10];<br>char a[10][10];<br>int n,k[10];<br>vector<char> v[10];</char></p>\n<p>bool init(){</p>\n<p>}</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=k[i];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=k[i];<br>        j=n/tot;<br>        printf(“%c”,v[i][j]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    scanf(“%d”,&amp;N);<br>    while(N–){<br>        for(int i=1;i&lt;=5;++i) v[i].clear();<br>        int flag=1;<br>        scanf(“%d”,&amp;n);<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>    for(int i=1;i&lt;=6;++i)\n            scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\n    for(int j=1;j&lt;=5;++j)\n        for(int t=1;t&lt;=6;++t)\n            for(int i=1;i&lt;=6;++i)\n                if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\])\n                    v\\[j\\].push_back(a\\[t\\]\\[j\\]);\n\n    for(int i=1;i&lt;=5;++i){\n        if(v\\[i\\].empty()){\n            flag=0;\n            break;\n        }\n        sort(v\\[i\\].begin(),v\\[i\\].end());\n        unique(v\\[i\\].begin(),v\\[i\\].end());\n        k\\[i\\]=0;\n        while(k\\[i\\]&lt;v\\[i\\].size()-1 &amp;&amp; v\\[i\\]\\[k\\[i\\]+1\\]&gt;v\\[i\\]\\[k\\[i\\]\\]) k\\[i\\]++;\n        k\\[i\\]++;\n    }\n\n    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n","text":"【类型】 组合数学 【题目来源】 UVa-1262-Password 【思路】 见紫书P323例10-8 【WA Code】#include#include#include#include<br>using namespace std;char m[8][8];<br>char ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 12716","slug":"uva-12716","date":"2016-12-24T13:35:57.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-12716.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【思路】: P318: （1）gcd(a,b)=c； （2）(a^b)=c；通过观察容易发现如果gcd(a,b)=(a^b)=c，那么c=a-b，因此可以事先枚举所有a的因数c，利用b=a-c计算b,然后只需验证是否满足(a^b)==c即可。但本题的数据太大，而且枚举约数不容易，因此可以利用约数c枚举倍数a，这样就会方便很多，打表的效率也足够高；而且，由于a=k_c,b=a-c=(k-1)_c，因此，必有gcd(a,b)=gcd(k_c,(k-1)_c)=c。这样只需比较(a^b)和c即可算出a的所有解数，由于本题要的是前n项的解数，因此最后要累加之间的所有解。 【Code】: (VJ-UVa炸了..还没尝试能否A).</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;</algorithm></p>\n<p>const int maxn = 30000030;<br>int d[maxn];</p>\n<p>void init(){<br>    for(int c=1;c&lt;maxn/2;++c)<br>        for(int a=c+c;a&lt;maxn;a+=c){//a=K*C b=(K-1)*C<br>                int b=a-c;//必有gcd(a,b)=c<br>                if((a^b)==c)d[a]++;<br>        }<br>    for(int i=2;i&lt;maxn;++i)<br>        d[i]+=d[i-1];<br>}</p>\n<p>int main(){<br>    init();<br>    int N,Q=0;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        int M;<br>        cin&gt;&gt;M;<br>        cout&lt;&lt;”Case “&lt;&lt;++Q&lt;&lt;”: “&lt;&lt;d[M]&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"【思路】: P318: （1）gcd(a,b)=c； （2）(a^b)=c；通过观察容易发现如果gcd(a,b)=(a^b)=c，那么c=a-b，因此可以事先枚举所有a的因数c，利用b=a-c计算b,然后只需验证是否满足(a^b)==c即可。但本题的数据太大，而且枚举约数不容易，","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1339","slug":"uva-1339-2","date":"2017-03-25T10:42:04.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-1339-2.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词记录】</strong> <strong>empire 帝国</strong> <strong>various 各种各样的,多样的</strong> <strong>departments 部(门)</strong> <strong>provinces 地方,职权</strong> <strong>encrypted 把…编码；把…加密</strong> <strong>prevent eavesdropping. 防止窃听</strong> <strong>ciphers 密码,编码</strong> <strong>substitution 代替/代替物</strong> <strong>permutation 排列/置换</strong> <strong>occurrences 发生,出现,事件</strong> <strong>coincide 一致</strong> <strong>apply 申请,适用</strong> <strong>alphabet 字母表</strong> <strong>separately 分别得,分离的,个别的</strong> <strong>rather 宁可宁愿,相当</strong> <strong>combined 使适合,组合,结合</strong> <strong>those times 大部分条件下？</strong> <strong>Thus 因此</strong> <strong>Archeologists 考古学家</strong> <strong>recently 最近</strong> <strong>engraved 被牢记的,雕刻</strong> <strong>plate 碟,金属板,装甲</strong> <strong>glance 一瞥,扫视</strong> <strong>meaningless 无意义的</strong> <strong>conjecture 推测,猜想</strong> <strong>check 制止,校验,核对</strong> <strong>contains 包含</strong> <strong>several 几个</strong> <strong>consists 由…构成</strong> <strong>punctuation 标点符号</strong> <strong>capital 首都</strong> <strong>do not exceed XXX 不超过</strong> <strong>【题意】</strong> <strong>古老的碑文上雕刻着密文,有两种加密方法,subsitution ciphers和permutation chipers.</strong> <strong>问:判断输入密文str1和破解明文str2是否可以通过以上两种encrypted方式转换.</strong> <strong>subsitution ciphers:一一映射.</strong> <strong>permutation ciphers:位置置换.</strong> <strong>【错解】</strong> <strong>思路:因为后者是由前者重新排序然后重新映射来的,所以第一想法是直接统计Ascii码,然后再判断两者差的绝对值取余字符串长度是否为0.</strong> <strong>错例:AAA,BBB</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>char str1[120],str2[120];</strong> <strong>int len1,len2,sum1,sum2;</strong> <strong>int main(){</strong> **    while(cin&gt;&gt;str1){** **        cin&gt;&gt;str2;** **        len1=strlen(str1),len2=strlen(str2);** **        sum1=sum2=0;** **        if(len1!=len2){** **            puts(“NO”);** **            continue;** **        }** **        for(int i=0;i&lt;len1;++i)** **            sum1+=str1[i];** **        for(int i=0;i&lt;len2;++i)** **            sum2+=str2[i];** **        if(abs(sum1-sum2)%len1==0)** **            puts(“YES”);** **        else** **            puts(“NO”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【正解】</strong> <strong>思路:既然字母可以重排,则每个字母的位置并不重要,重要的是每个字母出现的次数,</strong> <strong>这样可以先统计出两个字符串中各个字母出现的次数.得到两个数组cnt1[26]，cnt2[26]</strong> <strong>然后将数目从大到小排列,如果数组相同,则YES,其他NO.</strong> <strong>一点:没看样例直接搞,按照思路来的,看完题面以后觉得字母映射是全部平移的一一映射,但书上说的是(无规律)一一映射(需要每个字母都要映射,并且映射都不相同,比如不可能:B-&gt;Q,Q-&gt;Q;但可以:B-&gt;Q,Q-&gt;D,C-&gt;C).</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>char str1[120],str2[120];</strong> <strong>int len1,len2,cnt1[30],cnt2[30],sum,flag;</strong> <strong>bool cmp(int a,int b){</strong> **    return a&gt;b;** <strong>}</strong> <strong>int main(){</strong> **    while(cin&gt;&gt;str1){** **        cin&gt;&gt;str2;** **        len1=strlen(str1),len2=strlen(str2);** **        memset(cnt1,0,sizeof(cnt1));** **        memset(cnt2,0,sizeof(cnt2));** **        sum=flag=0;** **        if(len1!=len2){** **            puts(“NO”);** **            continue;** **        }** **        for(int i=0;i&lt;len1;++i){** **            if(cnt1[str1[i]-‘A’]==0)** **                sum++;** **            cnt1[str1[i]-‘A’]++;** **        }** **        for(int i=0;i&lt;len2;++i)** **            cnt2[str2[i]-‘A’]++;** **        sort(cnt1,cnt1+26,cmp);** **        sort(cnt2,cnt2+26,cmp);** **        for(int i=0;i&lt;sum;++i){** **            if(cnt1[i]!=cnt2[i]){** **                flag=1;** **                break;** **            }** **        }** **        puts(flag?”NO”:”YES”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词记录】 empire 帝国 various 各种各样的,多样的 departments 部(门) provinces 地方,职权 encrypted 把…编码；把…加密 prevent eavesdropping. 防止窃听 ciphers 密码,编码 substituti","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1339","slug":"uva-1339","date":"2016-12-22T12:09:09.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/uva-1339.json","excerpt":"","keywords":null,"cover":null,"content":"<p>算法竞赛入门经典 P75</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio><br>using namespace std;<br>int main(){<br>    char s[101],t[101];<br>    while(cin&gt;&gt;s&gt;&gt;t){<br>        int cnt1[27]={0},cnt2[27]={0},flag=0;<br>        for(int i=0;s[i]!=’\\0’;++i){<br>            if((s[i]==’\\0’&amp;&amp;t[i]!=’\\0’)||(t[i]==’\\0’&amp;&amp;s[i]!=’\\0’)){<br>                cout&lt;&lt;”NO”&lt;&lt;endl;<br>                flag=1; break;<br>            }<br>            cnt1[s[i]-‘A’]++;<br>            cnt2[t[i]-‘A’]++;<br>        }<br>        if(flag)<br>            continue;<br>        sort(cnt1,cnt1+27);<br>        sort(cnt2,cnt2+27);<br>        for(int i=0;i&lt;27;++i)<br>            if(cnt1[i]!=cnt2[i]){<br>                cout&lt;&lt;”NO”&lt;&lt;endl;<br>                flag=1;break;<br>            }<br>        if(flag)<br>            continue;<br>        cout&lt;&lt;”YES”&lt;&lt;endl;<br>    }<br>    return 0;<br>}</cstdio></p>\n","text":"算法竞赛入门经典 P75#include#include#include<br>using namespace std;<br>int main(){<br>    char s[101],t[101];<br>    while(cin&gt;&gt;s&gt;&gt;t){<","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1588","slug":"uva-1588","date":"2016-12-22T13:27:56.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/uva-1588.json","excerpt":"","keywords":null,"cover":null,"content":"<p>算法竞赛入门经典 P59 (好恶心的模拟) 参考(思路对,写不出来Orz):<a href=\"http://www.cnblogs.com/luruiyuan/p/5562520.html\" target=\"_blank\" rel=\"noopener\">仰望高端玩家的小清新</a></p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstring></cstring></p>\n<p>#define FOR(i,j,k) for(int i=j,i&lt;k;++i)<br>using namespace std;<br>char a[101],b[101];<br>int n1,n2;</p>\n<p>int solve(char *s1,char *s2,int n){<br>    int sumlen=n1+n2,len=sumlen,minn=min(n1,n2);<br>    for(int i=0;i&lt;n;++i){<br>            int flag=1,fix=min(n-i,minn);<br>            for(int j=0;j&lt;fix;++j)<br>                if(s1[i+j]==’2’ &amp;&amp; s2[j]==’2’){<br>                        flag=0;break;<br>                }<br>            if(flag &amp;&amp; len&gt;sumlen-fix) len=sumlen-fix;<br>        }<br>        return len;<br>}</p>\n<p>int main(){<br>    char a[101],b[101];<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>        n1=strlen(a),n2=strlen(b);<br>        cout&lt;&lt;min(solve(a,b,n1),solve(b,a,n2))&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"算法竞赛入门经典 P59 (好恶心的模拟) 参考(思路对,写不出来Orz):仰望高端玩家的小清新#include#include#include#define FOR(i,j,k) for(int i=j,i&lt;k;++i)<br>using namespace std;<b","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1635","slug":"uva-1635","date":"2017-01-10T11:13:32.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1635.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 <a href=\"https://vjudge.net/problem/UVA-1635\" target=\"_blank\" rel=\"noopener\">UVa-1635-Irrelevant Elements</a> 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)<em>(n-k+1)/k. 即 C[i]=C[i-1]</em>(n-i+1)/i. 注意,应该先乘再除,因为C[i-1]/i可能不是整数.但结果一定是整数.而且,因为二项式是递归乘法,所以有时可能会溢出long long,这题就是个例子. 【思路】 因为C(n,i)可能会爆long long,所以先对m做唯一分解，分解成若干素数,并记录每个素数的指数.然后以此计算m的唯一分解式中哥哥素因子在C(n-1,i-1)中的指数即可完成判断.这些指数依然可以用上面那个递推式递推,并且不会涉及高精度. 【参考】 <a href=\"http://blog.csdn.net/u014800748/article/details/43927205\" target=\"_blank\" rel=\"noopener\">Hengjie Yang</a> 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cmath></cmath></p>\n<p>#include<cstring><br>using namespace std;<br>typedef long long LL;<br>LL C[100005];<br>int prime[101][2];<br>int fac_c[100];<br>int N,M;</cstring></p>\n<p>int initM(int m){<br>    int primenum=0;<br>    for(int i=2;i&lt;=sqrt(m);++i){<br>        if(m%i==0){<br>            prime[++primenum][0]=i;<br>            prime[primenum][1]=0;<br>            while(m%i==0){<br>                prime[primenum][1]++;<br>                m/=i;<br>            }<br>        }<br>    }<br>    if(m&gt;1){<br>        prime[++primenum][0]=m;<br>        prime[primenum][1]=1;<br>    }<br>    return primenum;<br>}</p>\n<p>bool check(int m,int k,int primenum){<br>    int a=m-k;<br>    int b=k;<br>    for(int i=1;i&lt;=primenum;++i){<br>        for(;a%prime[i][0]==0;a/=prime[i][0],fac_c[i]++);<br>        for(;b%prime[i][0]==0;b/=prime[i][0],fac_c[i]–);<br>    }<br>    for(int i=1;i&lt;=primenum;++i)<br>        if(prime[i][1]&gt;fac_c[i])<br>        return false;<br>    return true;<br>}</p>\n<p>int main(){<br>    while(cin&gt;&gt;N&gt;&gt;M){<br>        int primenum=initM(M);//唯一分解M,防止爆LL<br>        memset(fac_c,0,sizeof(fac_c));<br>        int cnt=0;//无关数个数<br>        for(int i=1;i&lt;N;++i){<br>            //0~(n-1),这个是组合数C(m,n)的n.  m=n-1 index=i+1<br>            if(check(N,i,primenum))<br>                C[cnt++]=i+1;<br>        }<br>        printf(“%d\\n”,cnt);<br>        for(int i=0;i&lt;cnt;++i)<br>            printf(i==(cnt-1)?”%d\\n”:”%d “,C[i]);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 UVa-1635-Irrelevant Elements 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)(n-k+1)/k. 即 C[i]=C[i-1](n-i+1","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"二项式定理","slug":"UVa/二项式定理","count":1,"path":"api/categories/UVa/二项式定理.json"},{"name":"唯一分解定理","slug":"UVa/二项式定理/唯一分解定理","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理.json"},{"name":"数论","slug":"UVa/二项式定理/唯一分解定理/数论","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论.json"},{"name":"组合数学","slug":"UVa/二项式定理/唯一分解定理/数论/组合数学","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1636","slug":"uva-1636","date":"2017-01-14T16:07:54.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-1636.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 概率论 【思路】 水题一发. 紫书 P326.</p>\n<blockquote>\n<p>第一个</p>\n<blockquote>\n<p>A: 第二枪无子弹 B: 第一枪无子弹 第二种情况是随机转到0的概率是多大</p>\n<blockquote>\n<p>即 0的个数/n</p>\n</blockquote>\n<p>P(A|B)=P(AB) / P(B) = 00个数/0个数</p>\n</blockquote>\n</blockquote>\n<p>【Code】</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    char str[200];\n    while(scanf(&quot;%s&quot;,str)!=EOF){\n        int a=0,b=0;\n        int len=strlen(str);\n        for(int i=0;i&lt;len;++i){\n            if(str[i]==&apos;0&apos;){\n                b++;\n                if(str[(i+1)%len]==&apos;0&apos;) a++;\n            }\n        }\n        if(a*len==b*b) printf(&quot;EQUAL\\n&quot;);\n        if(a*len&gt;b*b) printf(&quot;SHOOT\\n&quot;);\n        if(a*len&lt;b*b) printf(&quot;ROTATE\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【类型】 概率论 【思路】 水题一发. 紫书 P326.第一个A: 第二枪无子弹 B: 第一枪无子弹 第二种情况是随机转到0的概率是多大即 0的个数/nP(A|B)=P(AB) / P(B) = 00个数/0个数【Code】#include&lt;iostream&gt;#inc","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"},{"name":"算法学习","slug":"UVa/概率论/算法学习","count":1,"path":"api/categories/UVa/概率论/算法学习.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1658","slug":"uva-1658","date":"2017-04-18T02:19:05.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-1658.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>SPFA最小费用最大流,构图</strong> <strong>【Tip】</strong> <strong>这道题说每个节点只能访问一次,所以只需要把每个节点分为两个节点i和i’,且这两个节点的容量为1,费用为0.然后题目要求求两条不相交的路径使得权和最小,所以只需要求1~v的流量为2的最小费用即可.添加一个超级节点0-&gt;1和超级节点v-&gt;2*v+1.且这两条边的容量为2,费用为0.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=5000,maxm=50000;</strong> <strong>int v,e;</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];//maxm最大边数** **    int nume;** **    int src,sink;** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    queue<int> que;** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        while(!que.empty()) que.pop();** **        que.push(src);** **        cle(dist,63);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    ll mincostflow(){** **        ll cur=0;** **        while(Spfa()){** **            cur+=augment();** **  //          if(cur&lt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>};</strong> <strong>int main(){</strong> **    while(~SII(v,e)){** **        MCMF mcmf;** **        mcmf.init();** **        mcmf.src=1;** **        mcmf.sink=2<em>v+1;*</em> **        int a,b,c;** **        rez(i,2,v-1)** **            mcmf.Addedge(i,i+v,1,0);** **        mcmf.Addedge(0,1,2,0);//限制流量为2** **        mcmf.Addedge(v,2<em>v+1,2,0);*</em> **        rep(i,e){** **            SIII(a,b,c);** **            if(a!=1 &amp;&amp; a!=v)** **                mcmf.Addedge(a+v,b,1,c);** **            else mcmf.Addedge(a,b,1,c);** **        }** **        printf(“%lld\\n”,mcmf.mincostflow());** **    }** **    return 0;** <strong>}</strong></int></p>\n</blockquote>\n","text":"【类型】 SPFA最小费用最大流,构图 【Tip】 这道题说每个节点只能访问一次,所以只需要把每个节点分为两个节点i和i’,且这两个节点的容量为1,费用为0.然后题目要求求两条不相交的路径使得权和最小,所以只需要求1~v的流量为2的最小费用即可.添加一个超级节点0-&gt;1和超","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"最小费用最大流","slug":"UVa/最小费用最大流","count":1,"path":"api/categories/UVa/最小费用最大流.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"path":"api/tags/最小费用最大流.json"}]},{"title":"UVa 210","slug":"uva-210","date":"2017-01-24T06:09:29.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-210.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构&lt;双端队列&gt;,STL 【Tip】 deque容器的介绍.这里我看的是C++标准程序库P160.队头操作用 <strong>front();队尾</strong>back(); 【题意】 紫书P139 给定n个程序，每种程序有五种操作，分别为 var = constant(赋值)，print var (打印)， lock, unlock，end 变量用小写字母表示，初始化为0，为程序所公有（一个程序里对某个变量修改可以会影响其他程序里的这个变量）， 常数小于100（也就是说最多两位数）。 每个时刻都只能有一个程序处于运行状态，其他的都在等待，上述五种操作用时分别是t1, t2, t3, t4, t5。运行中的程序， 每次最多能运行q个时间，当q个时间被用完后，它会被放在等待队列的尾部，然后再从首部取出一个程序运行，初始等待队列按输入顺序， 但是lock和unlock会改变顺序，它们总是成对出现，不会出现嵌套。如果某个程序已经执行了lock，后面还有程序执行lock， 那么这个程序就会马上被放到一个阻止队列的尾部（当然如果运行时间还没用完也就浪费了）。当unlock结束后，阻止队列中的第一个程序进入等待队列的首部。 (敲一遍就知道什么意思了.) 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<queue></queue></em> <em>#include<cstring></cstring></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>const int maxn=1000;</em> <em>deque<int> readyQ;</int></em> <em>queue<int> blockQ;</int></em> <em>int n,quantum,c[5],var[26],ip[maxn];//ip为指令的位置</em> <em>bool locked;</em> <em>char prog[maxn][10];//指令</em> <em>void run(int pid){</em> _    int q=quantum;_ _    while(q&gt;0){_ _        char* p=prog[ip[pid]];_ _        switch(p[2]){_ _            case ‘=’://var=constant_ _                var[p[0]-‘a’]=isdigit(p[5])?(p[4]-‘0’)*10+p[5]-‘0’ : p[4]-‘0’;_ _                q-=c[0];_ _                break;_ _            case ‘i’://print_ _                printf(“%d: %d\\n”,pid+1,var[p[6]-‘a’]);_ _                q-=c[1];_ _                break;_ _            case ‘c’://lock_ _                if(locked) { blockQ.push(pid); return; }_ _                locked=true;_ _                q-=c[2];_ _                break;_ _            case ‘l’://unlock_ _                locked=false;_ _                if(!blockQ.empty()){_ _                    int pid2=blockQ.front(); blockQ.pop();_ _                    readyQ.push_front(pid2);_ _                }_ _                q-=c[3];_ _                break;_ _            case ‘d’://end_ _                return;_ _        }_ _        ip[pid]++;_ _    }_ _    readyQ.push_back(pid);_ <em>}</em> <em>int main(){</em> _    int T;_ _    scanf(“%d”,&amp;T);_ _    while(T–){_ _            scanf(“%d %d %d %d %d %d %d\\n”,&amp;n,&amp;c[0],&amp;c[1],&amp;c[2],&amp;c[3],&amp;c[4],&amp;quantum);_ _            memset(var, 0, sizeof(var));_ _            int line=0;_ _            for(int i=0;i&lt;n;++i){_ _                fgets(prog[line++],maxn,stdin);_ _                ip[i]=line-1;_ _                while(prog[line-1][2]!=’d’)_ _                    fgets(prog[line++],maxn,stdin);_ _                readyQ.push_back(i);_ _            }_ _            locked=false;_ _            while(!readyQ.empty()){_ _                int pid=readyQ.front(); readyQ.pop_front();_ _                run(pid);_ _            }_ _          if(T) printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>Save</p>\n","text":"【类型】 数据结构&lt;双端队列&gt;,STL 【Tip】 deque容器的介绍.这里我看的是C++标准程序库P160.队头操作用 front();队尾back(); 【题意】 紫书P139 给定n个程序，每种程序有五种操作，分别为 var = constant(赋值)，pr","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 213","slug":"uva-213","date":"2017-03-26T08:09:55.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-213.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>schemes 计划,阴谋,方案</strong> ** require 需求,要求,指令** <strong>pattern 模式,图案,样品,模仿</strong> <strong>represents 代表,表现,表示</strong> <strong>The heart of 称心的,乱了粉粹的,中心的,核心的</strong> <strong>adjacent 邻近的,毗邻的</strong> <strong>obtained 获得(obtain)</strong> <strong>Notice 通知,布告,公告</strong> <strong>consist 由什么组成</strong> <strong>mapped 映射</strong> <strong>in order 整齐,秩然有序</strong> <strong>That is 即,就是说,换言之</strong> <strong>suppose 假设</strong> <strong>segment 片段</strong> <strong>binary 二进制的</strong> <strong>representation 表示法</strong> <strong>of …的</strong> <strong>terminated 终止，结束</strong> <strong>entire 全部的,整个的</strong> <strong>signify 表示,意味</strong> <strong>one-at-a-time 一次一个</strong> <strong>extend 扩展</strong> <strong>111 in binary 111的二进制表示</strong> <strong>There be 有</strong> <strong>multiple 倍数的,几倍的</strong> <strong>copies 复制品</strong> <strong>legitimate 合法的,正当的</strong> <strong>appropriate 适当的,恰当的,合适的</strong> <strong>correspond 符合,一致,相应,通信</strong> <strong>separate 单独的</strong> <strong>【题面】</strong> <strong>粉书P83，这个自己看的时候有点迷糊..</strong> <strong>【问题】</strong> <strong>粉书的读入代码(AC)</strong></p>\n<blockquote>\n<p><strong>inline int readText(){</strong> **    fill(code);** <strong>code[1][0]=readchar();//因为</strong> **    for(int plie=2;plie&lt;=7;++plie) {** **        for(int i=0;i&lt;(1&lt;&lt;plie)-1;++i){** <strong>int c=getchar();</strong> <strong>if(c==EOF) return 0;</strong> **            if(c==’\\n’ || c==’\\r’) return 1;** **            code[plie][i]=c;** **        }** **    }    ** <strong>return 1;</strong> <strong>}</strong></p>\n</blockquote>\n<p><strong>我的读入代码(WA)</strong></p>\n<blockquote>\n<p><strong>inline int readText(){</strong> **    int plie=2;** **    int max=3,cnt=0;** **    fill(code);** **    code[1][0]=readchar();//因为** **    for(;;) {** **        int c=getchar();** **        if(c==EOF) return 0;** **        if(c==’\\n’ || c==’\\r’) return 1;** **        code[plie][cnt++]=c;** **        if(cnt==max){** **            max=1&lt;&lt;(plie+1)-1;** **            cnt=0;** **            plie++;** **        }** **    }    ** **    return 1;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【Code】</strong></p>\n<blockquote>\n<p>**`#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#define fill(x) memset(x,0,sizeof(x))<br>using namespace std;<br>int code[8][1&lt;&lt;8];<br>inline char readchar(){<br>    char sta;<br>    while(~scanf(“%c”,&amp;sta) &amp;&amp; sta==’\\n’ || sta==’\\r’){}<br>        //这里的scanf()不要忘了加取反符,否则督导EOF不会存下来.<br>    return sta;<br>}<br>inline int readint(int l){<br>    int v=0;<br>    while(l–) v=v*2+readchar()-‘0’;<br>    return v;<br>}<br>inline int readText(){<br>    fill(code);<br>    code[1][0]=readchar();//因为<br>    for(int plie=2;plie&lt;=7;++plie) {<br>        for(int i=0;i&lt;(1&lt;&lt;plie)-1;++i){<br>            int c=getchar();<br>            if(c==EOF) return 0;<br>            if(c==’\\n’ || c==’\\r’) return 1;<br>            code[plie][i]=c;<br>        }<br>    }<br>    return 1;<br>}</p>\n<p>int main(){<br>    while(readText()){<br>        int digit;<br>        char dig[3],slist;<br>        for(;;){<br>            int len=readint(3);<br>            if(len==0) break;<br>            for(;;){<br>                digit=readint(len);<br>                if(digit==(1&lt;&lt;len)-1)<br>                    break;<br>                putchar(code[len][digit]);<br>            }<br>        }<br>        putchar(‘\\n’);<br>    }<br>    return 0;<br>}`**</p>\n</blockquote>\n","text":"【生词】 schemes 计划,阴谋,方案 ** require 需求,要求,指令** pattern 模式,图案,样品,模仿 represents 代表,表现,表示 The heart of 称心的,乱了粉粹的,中心的,核心的 adjacent 邻近的,毗邻的 obtained","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 437","slug":"uva-437","date":"2017-04-16T14:34:35.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-437.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>DAG上的DP</strong> <strong>下面的代码一是转换成最长单增子序列LIS做的</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=300;</strong> <strong>struct star{</strong> **    int a,b,c;** **    bool operator&lt;(const star &amp;A)const{** **        return a==A.a?b&lt;A.b:a&lt;A.a;** **    }** <strong>};</strong> <strong>star S[maxn];</strong> <strong>int N,kase=1;</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        int x,y,z,k=0;** **        rep(i,N){** **            SIII(x,y,z);** **            S[k].a=x;S[k].b=y;S[k++].c=z;** **            S[k].a=x;S[k].c=y;S[k++].b=z;** **            S[k].b=x;S[k].a=y;S[k++].c=z;** **            S[k].b=x;S[k].c=y;S[k++].a=z;** **            S[k].c=x;S[k].b=y;S[k++].a=z;** **            S[k].c=x;S[k].a=y;S[k++].b=z;** **        }** **        sort(S,S+k);** **        int ans=-INF,dp[maxn];** **        rep(i,k){** **            dp[i]=S[i].c;** **            rep(j,i){** **                if(S[j].a&lt;S[i].a &amp;&amp; S[j].b&lt;S[i].b){** **                    dp[i]=max(dp[i],dp[j]+S[i].c);** **                }** **            }** **            ans=max(ans,dp[i]);** **        }** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>代码二</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=30+5;</strong> <strong>int N,kase=1,blocks[maxn][3],d[maxn][3];</strong> <strong>void get_dimensions(int* v,int b,int dim){</strong> **    int idx=0;** **    rep(i,3) if(i!=dim) v[idx++]=blocks[b][i];** <strong>}</strong> <strong>int dp(int i,int j){</strong> **    int&amp; ans=d[i][j];** **    if(ans&gt;0) return ans;** **    ans=0;** **    int v[2],v2[2];** **    get_dimensions(v,i,j);** **    rep(a,N) rep(b,3){** **        get_dimensions(v2,a,b);** **        if(v2[0]&lt;v[0] &amp;&amp; v2[1]&lt;v[1]) ans=max(ans,dp(a,b));** **    }** **    ans+=blocks[i][j];** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        rep(i,N){** **            rep(j,3) SI(blocks[i][j]);** **            sort(blocks[i],blocks[i]+3);** **        }** **        cle(d,0);** **        int ans=0;** **        rep(i,N) rep(j,3) ans=max(ans,dp(i,j));** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 DAG上的DP 下面的代码一是转换成最长单增子序列LIS做的 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 442","slug":"uva-442","date":"2017-01-24T15:17:02.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-442.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构,栈,STL 【Tip】 这道题和四则运算入栈规则一样,是数字入栈,凡遇到 ‘)’ 则操作前两个字符(这里是矩阵). 矩阵链乘,A(m,n),B(n,d).A(n)==B(n)才成立. 注意.入栈顺序与出栈顺序是相反的,而矩阵链乘不满足乘法交换律.所以(AB)!=(BA)也存在(AB)有值(BA)无值. (这道题没在每条语句执行结束时清空栈,意在.in数据全部有效?)(大雾 【Code】</p>\n<blockquote>\n<p><strong><em>#include<iostream></iostream></em></strong> <strong><em>#include<algorithm></algorithm></em></strong> <strong><em>#include<cstdio></cstdio></em></strong> <strong><em>#include<cstring></cstring></em></strong> <strong><em>#include<stack></stack></em></strong> <strong><em>#include<string></string></em></strong> <strong><em>using namespace std;</em></strong> <strong><em>struct Matrix{</em></strong> <strong>_    int m,n;_</strong> <strong>_    Matrix(int a=0,int b=0):m(a),n(b) {}_</strong> <strong><em>}m[27];</em></strong> <strong><em>stack<matrix> s;</matrix></em></strong> <strong><em>int main(){</em></strong> <strong>_    int n;_</strong> <strong>_    scanf(“%d”,&amp;n);_</strong> <strong>_    for(int i=0;i&lt;n;++i){_</strong> <strong>_        string name;_</strong> <strong>_        cin&gt;&gt;name;_</strong> <strong>_        int k=name[0]-‘A’;_</strong> <strong>_        scanf(“%d%d”,&amp;m[k].m,&amp;m[k].n);_</strong> <strong>_    }_</strong> <strong>_    string expt;_</strong> <strong>_    while(cin&gt;&gt;expt){_</strong> <strong>_        int len=expt.length();_</strong> <strong>_        bool error=false;_</strong> <strong>_        int ans=0;_</strong> <strong>_        for(int i=0;i&lt;len;++i){_</strong> <strong>_            if(isalpha(expt[i])) s.push(m[expt[i]-‘A’]);_</strong> <strong>_            else if(expt[i]==’)’){_</strong> <strong>_                Matrix m2=s.top();s.pop();//这两句注意顺序.比如(AB)肯定是A先入栈,所以第一个出栈的肯定是B_</strong> <strong>_                Matrix m1=s.top();s.pop();_</strong> <strong>_                if(m1.n!=m2.m){_</strong> <strong>_                    error=true;_</strong> <strong>_                    break;_</strong> <strong>_                }else{_</strong> <strong>_                    ans+=m1.n*m1.m*m2.n;_</strong> <strong>_                    s.push(Matrix(m1.m,m2.n));_</strong> <strong>_                }_</strong> <strong>_            }_</strong> <strong>_        }_</strong> <strong>_        if(error) printf(“error\\n”);_</strong> <strong>_        else printf(“%d\\n”,ans);_</strong> <strong>_    }_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>Save</p>\n","text":"【类型】 数据结构,栈,STL 【Tip】 这道题和四则运算入栈规则一样,是数字入栈,凡遇到 ‘)’ 则操作前两个字符(这里是矩阵). 矩阵链乘,A(m,n),B(n,d).A(n)==B(n)才成立. 注意.入栈顺序与出栈顺序是相反的,而矩阵链乘不满足乘法交换律.所以(AB)!","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 489","slug":"uva-489","date":"2017-03-26T02:13:52.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-489.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>series 系列,连续,串联</strong> <strong>Hangman 侩子手</strong> <strong>puzzle 使…疑惑,迷惑,难题,为难</strong> <strong>as well as 也,和,一样,不但…而且</strong> <strong>guesses 猜测</strong> <strong>be the same as 与..一样</strong> <strong>classic 名著,经典著作</strong> <strong>Follows 跟随,遵照</strong> <strong>contestant 竞争者,参赛人</strong> <strong>try-&gt;tries 尝试</strong> <strong>characters 特性,角色.V.描述</strong> <strong>match 比赛,竞赛,对手,匹配</strong> <strong>counted 认为</strong> <strong>as 因为,随着,虽然,依照,当…时,如同,当做</strong> <strong>stroke 划,画一道</strong> <strong>chicken out &lt;美俚&gt;</strong></p>\n<ul>\n<li><strong>因害怕而停止做某事，因胆小而放弃</strong></li>\n<li><strong>临阵退缩</strong></li>\n<li><strong>怯步</strong></li>\n<li><strong>由于胆怯而收兵</strong></li>\n</ul>\n<p><strong>determine 下定决心</strong> <strong>or fails to finish a game 或未能完成比赛</strong> <strong>status 地位,状态</strong> <strong>lower 下游的,下级的,下等的</strong> <strong>section 截面,部分,部门,地区,章节</strong> <strong>indicate 表明,指出,预示,象征</strong> <strong>currently 一般的,当前的</strong> <strong>【题意】</strong> <strong>你在和侩子手玩一个游戏,侩子手有一个单词,你需要猜测单词中有哪些字母,当你猜中一个字母时,正确单词里所有该字母都被标记为correct,(如果你再猜就被认为是错的),当你猜错时侩子手将会划一道,当侩子手划到第7道时,你就挂了,如果在侩子手之前你猜中了全部字母,You win.当然,如果最终你猜测的结果在正确和错误之间,You chickened out.</strong> <strong>【Code】</strong> <strong>好像数组开得太大memset也会耗费不少时间.或者是一开始的cin(关了同步)仍然很慢,第一次TLE了.</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#define fill(A) memset(A,0,sizeof(A))</strong> <strong>using namespace std;</strong> <strong>char contestant[10000],correct[10000];</strong> <strong>int Round,T[30],C[30],flag,fcnt,pcnt,ccnt;</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;Round) &amp;&amp; Round!=-1){** **        fcnt=pcnt=ccnt=0;flag=3;** **        fill(T);fill(C);** **        scanf(“\\n%s\\n%s”,correct,contestant);** **        printf(“Round %d\\n”,Round);** **        for(int i=0;correct[i]!=’\\0’;++i){** **            int t=correct[i]-‘a’;** **            if(C[t]==0)** **                C[t]=1,pcnt++;** **        }** **        for(int i=0;contestant[i]!=’\\0’;++i){** **            int t=contestant[i]-‘a’;** **            if(!T[t] &amp;&amp; C[t])** **                ccnt++,T[t]=1;** **            else** **                fcnt++;** **            if(fcnt==7 &amp;&amp; ccnt&lt;pcnt){** **                puts(“You lose.”),flag=2;** **                break;** **            }** **            if(fcnt&lt;7 &amp;&amp; ccnt&gt;=pcnt){** **                puts(“You win.”),flag=1;** **                break;** **            }    ** **        }** **        if(flag==3)** **            puts(“You chickened out.”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 series 系列,连续,串联 Hangman 侩子手 puzzle 使…疑惑,迷惑,难题,为难 as well as 也,和,一样,不但…而且 guesses 猜测 be the same as 与..一样 classic 名著,经典著作 Follows 跟随,遵照 ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 514","slug":"uva-514","date":"2017-01-24T13:11:51.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-514.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 数据结构,栈,STL 【Tip】 印象中好像可以不模拟栈的操作,根据定义来判断？(雾 水题. 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>#include<cstring></cstring></em> <em>#include<stack></stack></em> <em>#define maxn 2000</em> <em>using namespace std;</em> <em>int N,target[maxn],B;</em> <em>bool locked;</em> <em>int main(){</em> _    while(scanf(“%d”,&amp;N),N){_ _        while(scanf(“%d”,&amp;target[0]),target[0]){_ _            stack<int> s;_ _            locked=false;_ _            B=target[0]+1;//B用来记录入栈后最大的那个元素,之后入栈以它为下限._ _            for(int i=1;i&lt;target[0];++i)_ _                s.push(i);_ _            for(int i=1;i&lt;N;++i){_ _                scanf(“%d”,&amp;target[i]);_ _                if(!s.empty() &amp;&amp; !locked){_ _                    if(s.top()==target[i]) s.pop();_ _                    else if(target[i]&lt;s.top()) locked=true;_ _                    else if(target[i]&gt;s.top() &amp;&amp; B){_ _                        for(int j=B;j&lt;target[i];++j)_ _                            s.push(j);_ _                        B=target[i]+1;_ _                    }_ _                }else if(!locked){_ _                    for(int j=B;j&lt;target[i];++j)_ _                            s.push(j);_ _                    B=target[i]+1;_ _                }_ _            }_ _            printf(“%s\\n”,locked?”No”:”Yes”);_ _        }_ _        printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></int></p>\n</blockquote>\n","text":"【类型】 数据结构,栈,STL 【Tip】 印象中好像可以不模拟栈的操作,根据定义来判断？(雾 水题. 【Code】#include #include #include #include #include #define maxn 2000 using namespace std","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"优化 模板","slug":"youhua-muban","date":"2017-04-04T10:49:58.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/youhua-muban.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【I/O优化】</strong> <strong>UVA11462   非负整数I/O优化</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>//isdigit宏在cctype中</strong> <strong>using namespace std;</strong> <strong>inline int readint(){</strong> **    char c=getchar();** **    while(!isdigit(c)) c=getchar();** **    int x=0;** **    while(isdigit(c)){** **        x=x<em>10+c-‘0’;*</em> **        c=getchar();** **    }** **    return x;** <strong>}</strong> <strong>int buf[10]; //声明成全局变量可以减小开销</strong> <strong>inline void writeint(int i){</strong> **    int p=0;** **    if(i==0)p++;//特殊情况:i等于0的时候需要输出0,而不是什么也不输出;** **    else while(i){** **        buf[p++]=i%10;** **        i/=10;** **    }** **    for(int j=p-1;j&gt;=0;j–) putchar(‘0’+buf[j]);//逆序输出** <strong>}</strong> <strong>int main(){</strong> **    int n,x,c[101];** **    while(n=readint()){** **        memset(c,0,sizeof(c));** **        for(int i=0;i&lt;n;++i) c[readint()]++;** **        int first=1;** **        for(int i=1;i&lt;=100;++i)** **            for(int j=0;j&lt;c[i];++j){** **                if(!first) putchar(‘ ‘);** **                first=0;** **                writeint(i);** **            }** **        putchar(‘\\n’);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【I/O优化】 UVA11462   非负整数I/O优化#include&lt;bits/stdc++.h&gt; //isdigit宏在cctype中 using namespace std; inline int readint(){ **    char c=getchar","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"模板","slug":"UVa/模板","count":1,"path":"api/categories/UVa/模板.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}