{"name":"并查集","slug":"HDU/并查集","count":1,"postlist":[{"title":"数据结构补充","slug":"datastruct-add","date":"2018-02-13T13:12:07.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/datastruct-add.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…</p>\n<blockquote>\n<p>注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.</p>\n</blockquote>\n</blockquote>\n<h1 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h1><h2 id=\"要领\"><a href=\"#要领\" class=\"headerlink\" title=\"要领\"></a>要领</h2><blockquote>\n<p>以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.</p>\n<blockquote>\n<p>并查集是不可能分割的,即只能合并,不可分割.</p>\n<blockquote>\n<p>在牛客上听大佬讲课貌似存在可分割并查集,带权并查集.</p>\n</blockquote>\n</blockquote>\n<p>现在拓宽下,并查集常用于判断加入一个点后是否会在原图上形成环. 或者判断有几个连通分量(通常是无向图),然后问你这些节点全部关联起来至少需要添加几条边.</p>\n</blockquote>\n<h2 id=\"实现前奏\"><a href=\"#实现前奏\" class=\"headerlink\" title=\"实现前奏\"></a>实现前奏</h2><blockquote>\n<p>首先是逻辑,并查集实现规则是一个点一个点入图时进行合并,即join,然后在合并时进行find,查找根节点是否相同,不同则将浅的树合并到深的树上,判断深浅通过每次合并时对rank进行操作,然后在一个优化是路径压缩,即如果a节点的最高根节点是c,则直接将a记录为c即可.</p>\n<blockquote>\n<p>以上实现的前提是我们只需要逻辑上正确即可.</p>\n</blockquote>\n</blockquote>\n<h2 id=\"以题为马\"><a href=\"#以题为马\" class=\"headerlink\" title=\"以题为马\"></a>以题为马</h2><blockquote>\n<p>HDU 1232 判断有多少个连通块,然后答案就是ans-1</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nstruct DisjointSet{\n    vector&lt;int&gt; father,rank;\n    int Num;\n    DisjointSet(int n):father(n),rank(n),Num(n){\n        for(int i=1;i&lt;n;++i){\n            father[i]=i;\n        }\n    }\n\n    int find(int v){\n        return father[v]=father[v]==v?v:find(father[v]);\n    }\n\n    void merge(int x,int y){\n        int a=find(x),b=find(y);\n        if(rank[a]&lt;rank[b]){\n            father[a]=b;\n        }else{\n            father[b]=a;\n            if(rank[a]==rank[b]){\n                ++rank[a];\n            }\n        }\n    }\n\n    int getCnum(){\n        int ans=0;\n        for(int i=1;i&lt;Num;++i){\n            if(father[i]==i) ans++;\n        }\n        return ans-1;\n    }\n};\n\nint main(){\n    int m,n;\n\n    while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        DisjointSet ds(n+1);\n        int s,t;\n        scanf(&quot;%d&quot;,&amp;m);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d %d&quot;,&amp;s,&amp;t);\n            ds.merge(s,t);\n        }\n        printf(&quot;%d\\n&quot;,ds.getCnum());\n    }\n    return 0;\n}</code></pre><h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><h1 id=\"线段树区间更新和查询\"><a href=\"#线段树区间更新和查询\" class=\"headerlink\" title=\"线段树区间更新和查询\"></a>线段树区间更新和查询</h1><p>POJ 3468</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q;\nLL lazy[maxn];\nLL sum[maxn];\nLL tree[maxn];\nLL a[maxn];\n\nvoid build(int p,int l,int r){\n    if(l==r){tree[p]=a[l];return;}\n    int mid=(l+r)&gt;&gt;1;\n    build(p&lt;&lt;1,l,mid);\n    build(p&lt;&lt;1|1,mid+1,r);\n    tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];\n}\n\nvoid PushDown(int p,int m){\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nLL find(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return tree[p];\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=find(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=find(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n    for(int i=1;i&lt;=N;++i) scanf(&quot;%lld&quot;,&amp;a[i]);\n    build(1,1,N);\n    char op;\n    int l,r,c;\n    while(Q--){\n        cin&gt;&gt;op;\n        if(op==&apos;Q&apos;){\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            printf(&quot;%lld\\n&quot;,Query(1,1,N,l,r)+find(1,1,N,l,r));\n        }else if(op==&apos;C&apos;){\n            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);\n            update(1,1,N,c,l,r);\n        }\n    }\n    return 0;\n}</code></pre>","text":"2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.并查集要领以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.并查集是不可能分割的,即只能合并,不可分割.在牛客上听大","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"并查集","slug":"HDU/并查集","count":1,"path":"api/categories/HDU/并查集.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"}]}]}