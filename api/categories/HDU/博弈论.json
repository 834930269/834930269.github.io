{"name":"博弈论","slug":"HDU/博弈论","count":5,"postlist":[{"title":"HDU 1846","slug":"hdu-1846","date":"2018-01-24T08:33:41.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1846.json","excerpt":"","keywords":null,"cover":null,"content":"<p>裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        if((n)%(m+1)==0) printf(&quot;second\\n&quot;);\n        else printf(&quot;first\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"裸的巴什博奕,这道题出现了一个问题就是,我想~scanf(“%d”,&amp;T),结果一直是wrong,所以如果是单纯用T的题还是不要这样写了.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ ","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"巴什博奕","slug":"巴什博奕","count":1,"path":"api/tags/巴什博奕.json"}]},{"title":"HDU 1847","slug":"hdu-1847","date":"2018-01-24T09:54:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1847.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"博弈论-sg函数\">【博弈论 - SG函数】</span></h1><h2><span id=\"题目\">题目:</span></h2><h3><span id=\"good-luck-in-cet-4-everybody\">Good Luck in CET-4 Everybody!</span></h3><p>Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 11483 Accepted Submission(s): 7446 大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。 “升级”？“双扣”？“红五”？还是“斗地主”？ 当然都不是！那多俗啊~ 作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的： 1、 总共n张牌; 2、 双方轮流抓牌； 3、 每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…） 4、 抓完牌，胜负结果也出来了：最后抓完牌的人为胜者； 假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？ 当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。 Good luck in CET-4 everybody!</p>\n<h2><span id=\"input\">Input</span></h2><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p>\n<h2><span id=\"output\">Output</span></h2><p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p>\n<h2><span id=\"sampleinput\">SampleInput</span></h2><p>1 3</p>\n<h2><span id=\"sampleoutput\">SampleOutput</span></h2><p>Kiki Cici</p>\n<h2><span id=\"题解\">题解</span></h2><p>首先我们要知道SG函数代表的是当前状态的数值.如果是0,则为先手必败(SG函数值为可到达状态中未出现的最小的整数).然后我们从SG函数延伸一下– 1.我们假设当n=0时,先手必败. 2.当n=1时,因为S(0)=0，所以当前状态是非奇异局势.先手必胜,即,你可以通过拿走一定的牌使下一个拿牌的人的局势变成奇异局势(必败态). 即转移给下一个抽牌者状态为S(0). 3.当n=2是,因为S(0)=0，S(1)=1.所以当前状态是非奇异局势,先手必胜. 即你可以把下一个抽牌者状态转换成S(0). 4.当n=3时,可到达状态为S(3-1)=S(2)=1.S(3-2)=S(1)=1.因为无论往那个状态走,都会使对方先手必胜,所以该局势为奇异局势.先手必败. 故我们可以根据以上推理过程将全部的1000个状态是否必胜预处理处来.其预处理过程为<strong>检查可以到达的状态是否存在奇异局势,如果存在,则该局势为非奇异局势,即先手必胜态</strong>. 因为可拿牌数都是2^n.所以预处理复杂度为O(nlg(n)). PS…:其实预处理完以后你会发现.每当n%3==0时,为奇异局势. Code:</p>\n<pre><code>//SG函数\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nbool game[1001];\n\nvoid init(){\n    memset(game,false,sizeof(game));\n    for(int i=1;i&lt;=1000;++i){\n        int t=1;\n        while(i-t&gt;=0){\n            //如果i-t是奇异局势,则先手必胜\n            if(!game[i-t]){\n                game[i]=true;\n                break;\n            }\n            t&lt;&lt;=1;\n        }\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(game[n]){\n            printf(&quot;Kiki\\n&quot;);\n        }else{\n            printf(&quot;Cici\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【博弈论 - SG函数】题目:Good Luck in CET-4 Everybody!Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submissio","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 1849","slug":"hdu-1849","date":"2018-01-24T10:35:08.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1849.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg","content":"<p>【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/C101-1004-1.jpg\" alt></a> 原题说我们需要将每个格子内的棋子进行移动,当所有棋子都位于最左边编号为0的格子时,游戏结束. 首先我们将棋盘竖起来(自己画的,所以会少一点,但大体意思一样). <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124182908.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124182908.png\" alt></a> 然后我们将其中的棋子分开来: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180124183152.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180124183152.png\" alt></a> 这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时,即代表石子已取空. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int K;\n    while(~scanf(&quot;%d&quot;,&amp;K)){\n        if(K==0) break;\n        int ans=0;\n        while(K--){\n            int a;\n            scanf(&quot;%d&quot;,&amp;a);\n            ans^=a;\n        }\n        if(ans==0)puts(&quot;Grass Win!&quot;);\n        else puts(&quot;Rabbit Win!&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【Nim博弈】 这道题一开始看上去不像Nim博弈,但它为什么会是Nim博弈呢? 首先我们可以看原题上的那个图:  [Figure]  这样我们就可以将其转化为Nim博弈了.我们可以视为当前棋子所在的位置代表当前堆的石子个数.因为只能向左移动,即只能减少石子的数量.当棋子移动到0时","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2149","slug":"hdu-2149","date":"2018-01-24T08:16:55.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2149.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"巴什博奕\">【巴什博奕】</span></h1><h2><span id=\"题目\">题目:</span></h2><p>虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。 后来发现，整个拍卖会只有Lele和他的死对头Yueyue。 通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。 Lele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。 由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候， Lele要出多少才能保证自己买得到这块地呢？</p>\n<h2><span id=\"input\">Input:</span></h2><p>本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。 每组测试包含两个整数M和N(含义见题目描述，0&lt;N，M&lt;1100)</p>\n<h2><span id=\"output\">Output:</span></h2><p>对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。 如果Lele在第一次无论如何出价都无法买到这块土地，就输出”none”。</p>\n<h2><span id=\"sample-input\">Sample Input:</span></h2><p>4 2 3 2 3 5</p>\n<h2><span id=\"sample-output\">Sample Output:</span></h2><p>1 none 3 4 5</p>\n<h2><span id=\"题解\">题解</span></h2><p>我们知道,在巴士博弈中,n=0为先手必输态,之后n=m+1为下一个先手必输态. 而当Lele在竞拍的时候,如果他所在的初始状态是如上所述的这样一个奇异局势(即先手必输局势),那他一定输(none). 当Lele在竞拍处于非奇异局势时,在选择最优的情况下,他一定可以赢得竞拍.即他只需要通过增价将对手置于奇异状态即可. 所以当我们想要找出Lele第一次出家的可能性时,只需要先找出Lele的第一个置对方为奇异局势的 价格 .然后在寻找下一个的时候只需要依次++,直到下一次加价会给对方一个 非奇异局势前 结束循环. 当然,存在一种可能性就是,初次加价可能会溢出n的价格范围.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n,m;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        if(n%(m+1)==0) printf(&quot;none\\n&quot;);\n        else{\n            int next=0;\n            while(1){\n                next++;\n                if((n-next)%(m+1)==0){\n                    printf(&quot;%d&quot;,next);\n                    break;\n                }\n            }\n            while(next&lt;m){\n                next++;\n                if((n-next)%(m+1)==0 || next&gt;=n){\n                    printf(&quot; %d&quot;,next);\n                }else{\n                    break;\n                }\n            }\n            printf(&quot;\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】题目:虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2188","slug":"hdu-2188","date":"2018-01-24T07:49:43.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-2188.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"巴什博奕\">【巴什博奕】</span></h1><p>可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.</p>\n<pre><code>//巴什博奕\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,n,m;\n    while(~scanf(&quot;%d&quot;,&amp;T)){\n        while(T--){\n            scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n            if((n)%(m+1)==0) printf(&quot;Rabbit\\n&quot;);\n            else printf(&quot;Grass\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"【巴什博奕】可以将题意转换为: 有n块石子,每次最多取m个,Grass先取.则转换成裸巴什博奕.//巴什博奕#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int T,n,m;    while(~s","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]}]}