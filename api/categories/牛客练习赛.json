{"name":"牛客练习赛","slug":"牛客练习赛","count":2,"postlist":[{"title":"牛客练习赛11","slug":"nklxs11","date":"2018-01-26T15:39:55.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/nklxs11.json","excerpt":"","keywords":null,"cover":"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2","content":"<h1><span id=\"a假的线段树\">A:假的线段树</span></h1><h2><span id=\"题目\">题目</span></h2><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/A</a> 来源：牛客网 给你一个长为n的序列a，有m次操作 1.把区间[l,r]内所有x变成y 2.查询区间[l,r]内第k小值 对于100%的数据，1 &lt;= n, m , ai &lt;= 1000</p>\n<h2><span id=\"输入描述\">输入描述</span></h2><p>第一行两个数n,m 第二行n个数表示序列a 后面m行 1 l r x y :把区间[l,r]中所有x变成y 2 l r k :查询区间[l,r]中的第k小值</p>\n<h2><span id=\"输出描述\">输出描述</span></h2><p>对于每个询问，输出一个数表示答案</p>\n<h2><span id=\"示例输入\">示例输入</span></h2><p>3 3 2 3 3 2 1 3 1 1 1 3 3 1 2 1 3 2</p>\n<h2><span id=\"示例输出\">示例输出</span></h2><p>2 1</p>\n<h2><span id=\"题解\">题解</span></h2><p>数据量小.1000*1000的复杂度,可以暴力过.第K小直接排序即可.</p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1010;\nint n,m;\nint num[maxn];\n\nvoid solve1(){\n    int l,r,x,y;\n    scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;r,&amp;x,&amp;y);\n    for(int i=l;i&lt;=r;++i){\n        if(num[i]==x)num[i]=y;\n    }\n}\n\nvoid solve2(){\n    int l,r,k;\n    scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);\n    int copy[maxn];\n    for(int i=l;i&lt;=r;++i){\n        copy[i]=num[i];\n    }\n    sort(copy+l,copy+r+1);\n    printf(&quot;%d\\n&quot;,copy[l+k-1]);\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n    }\n    int query;\n    for(int i=0;i&lt;m;++i){\n        scanf(&quot;%d&quot;,&amp;query);\n        if(query==1) solve1();\n        else solve2();\n    }\n\n    return 0;\n}</code></pre><h1><span id=\"d求距离\">D:求距离</span></h1><h2><span id=\"题目\">题目</span></h2><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/D\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/D</a> 来源：牛客网 给你一个1 -&gt; n的排列，现在有一次机会可以交换两个数的位置，求交换后最小值和最大值之间的最大距离是多少？</p>\n<h2><span id=\"水题\">水题</span></h2><p>输入输出格式看链接吧</p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn=110;\nint num[maxn];\nint main(){\n    int n,mi=1,ma=1;\n    num[0]=0;\n    scanf(&quot;%d&quot;,&amp;n);\n    scanf(&quot;%d&quot;,&amp;num[1]);\n    for(int i=2;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n        if(num[i]&lt;num[mi]) mi=i;\n        if(num[i]&gt;num[ma]) ma=i;\n    }\n    int min_id=min(mi,ma),max_id=max(mi,ma);\n    int a=n-min_id,b=min_id-1,c=n-max_id,d=max_id-1;\n    printf(&quot;%d\\n&quot;,max(a,max(b,max(c,d))));\n    return 0;\n}</code></pre><h1><span id=\"e求最值\">E:求最值</span></h1><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/E\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/E</a> 来源：牛客网 给你一个长为n的序列a 定义f(i,j)=(i-j)2+g(i,j)2 g是这样的一个函数 <a href=\"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2\" target=\"_blank\" rel=\"noopener\"><img src=\"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2\" alt></a> 求最小的f(i,j)的值，i!=j</p>\n<h2><span id=\"题解\">题解</span></h2><p>这道题数据水,可以直接枚举距离1和距离2水过.</p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\n#define TREE_SIZE (1&lt;&lt;(20))\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn=100010;\nlong long sum_z[maxn],sum_f[maxn];\nint n,num[maxn];\n\ninline long long g(int i,int j){\n    register long long sum=0;\n    long long k=min(i,j),l=max(i,j);\n    sum=sum_z[n]-(sum_z[k]+sum_f[j+1]);\n    return sum;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    sum_z[0]=0;\n    for(int i=1;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n\n        sum_z[i]=sum_z[i-1]+num[i];\n    }\n    sum_f[n]=0;\n    for(int i=n;i&gt;=1;--i){\n        sum_f[i]=sum_f[i+1]+num[i];\n    }\n    long long res=1000000000;\n    for(int i=2;i&lt;=n;++i){\n        int T=min(1000,i);\n        for(int j=1;j&lt;T;++j){\n            long long reg=g(i-j,i);\n            //printf(&quot;i:%d,j:%d,reg:%d\\n&quot;,i,j,reg);\n            long long ans=j*j+reg*reg;\n            res=min(res,ans);\n        }\n    }\n    printf(&quot;%lld\\n&quot;,res);\n    return 0;\n}</code></pre><h2><span id=\"但是这道题是平面最近点对\">但是这道题是平面最近点对</span></h2>","text":"A:假的线段树题目链接：https://www.nowcoder.com/acm/contest/59/A 来源：牛客网 给你一个长为n的序列a，有m次操作 1.把区间[l,r]内所有x变成y 2.查询区间[l,r]内第k小值 对于100%的数据，1 &lt;= n, m , a","link":"","raw":null,"photos":[],"categories":[{"name":"牛客练习赛","slug":"牛客练习赛","count":2,"path":"api/categories/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"}]},{"title":"Wannafly 挑战赛11","slug":"wannafly-cha-11","date":"2018-03-10T00:53:16.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/wannafly-cha-11.json","excerpt":"","keywords":null,"cover":null,"content":"<p>A. 水</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nint main(){\n    LL n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;n+1&lt;&lt;endl;\n    return 0;\n}</code></pre><p>B: 组合数学, 预处理阶乘逆元</p>\n<blockquote>\n<p>因为不可能暴力,所以我们想到是推式子 我们可以把前几项放在Excel表中推一下 然后我们会发现 关于m,n的式子为</p>\n<blockquote>\n<p>常数k*b^(m-1)*a^(n-m)</p>\n<blockquote>\n<p>该式子即为目标结果</p>\n</blockquote>\n<p>如何求常数k呢</p>\n<blockquote>\n<p>设k[n][m] 为n行m列的常数</p>\n<blockquote>\n<p>我们发现 k[n][m]=k[n-1][m]+k[n-1][m-1] 这个式子和组合数学里的 C(n,k)+C(n,k+1)=C(n+1,k+1) 相似</p>\n</blockquote>\n</blockquote>\n<p>所以 k[n][m]=C(n-1,m-1)</p>\n<blockquote>\n<p>但因为我们无法以O（N^2）解决这道题,所以不能用递推式求组合数</p>\n<blockquote>\n<p>那我们就直接用 组合数的公式求</p>\n<blockquote>\n<p>C(n,m)=n!/((n-m)!*m!)</p>\n</blockquote>\n</blockquote>\n<p>预处理n!和n!的逆元</p>\n<blockquote>\n<p>这里因为数组有限,无法使用递推式求逆元,</p>\n<blockquote>\n<p>所以我们用费马小定理求逆元</p>\n</blockquote>\n<p>a^(p-1)≡1(mod p)</p>\n</blockquote>\n<p>则 a^(p-2) 即为 a 对于 p 的逆元.</p>\n</blockquote>\n<p>预处理即可</p>\n</blockquote>\n<p>当n &lt; m时,ans=0</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 998244353;\nconst int maxn = 100000;\n\nint a,b,n,m;\nint T;\n\nll inv[maxn+10],fac[maxn+10];\n///预处理N!的逆元\n//费马小定理\n/*\n *假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡1（mod p）\n *根据这个性质我们可以知道 a的逆元为a^(p-2)\n */\nll fast_pow(ll a,ll b)\n{\n    ll ans=1;\n    while(b){\n        if(b&amp;1ll)ans=a*ans%MOD;\n        a=a*a%MOD;\n        b&gt;&gt;=1ll;\n    }\n    return ans;\n}\nvoid pre()\n{\n    inv[0]=1ll;\n    fac[0]=1ll;\n    for(int i=1;i&lt;=maxn;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=fast_pow(fac[i],MOD-2ll);\n    }\n}\nll C(ll a,ll b)\n{\n    return fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}\n\nint main(){\n    pre();\n    scanf(&quot;%d&quot;,&amp;T);\n    for(int k=0;k&lt;T;++k){\n        scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;n,&amp;m);\n        if(n&lt;m){\n            printf(&quot;0\\n&quot;);\n            continue;\n        }\n        int t=n-1,s=m-1;\n        ll ans=1;\n\n        ans=ans*C(n-1,m-1)%MOD*fast_pow(a,n-m)%MOD*fast_pow(b,m-1)%MOD;\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n/// C(N-1,M-1)*b^(M-1)*a^(N-M)\n/// N&lt;M 0</code></pre>","text":"A. 水#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main(){    LL n;    cin&gt;&gt;n;    cout&lt;&lt;n+1&lt;&lt;en","link":"","raw":null,"photos":[],"categories":[{"name":"牛客练习赛","slug":"牛客练习赛","count":2,"path":"api/categories/牛客练习赛.json"},{"name":"组合数学","slug":"牛客练习赛/组合数学","count":1,"path":"api/categories/牛客练习赛/组合数学.json"},{"name":"逆元","slug":"牛客练习赛/组合数学/逆元","count":1,"path":"api/categories/牛客练习赛/组合数学/逆元.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"}]}]}