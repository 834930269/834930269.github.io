{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"postlist":[{"title":"玲珑杯 R7 D-Pick Up Coin","slug":"linglong-r7-d-pick-up-coin","date":"2016-12-24T13:51:29.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/linglong-r7-d-pick-up-coin.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:</p>\n<p>dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }</p>\n<p>  【Code】(不会,代码搁置,回头看)</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int Q[1010];<br>int dp[1005][1005];<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int n;<br>    cin&gt;&gt;n;<br>    while(n–){<br>        int M;<br>        cin&gt;&gt;M;<br>        for(int i=1;i&lt;=M;++i)<br>            cin&gt;&gt;Q[i];<br>        Q[0]=Q[M+1]=1;<br>        for(int i=0;i&lt;=M+1;++i)<br>            for(int j=0;j&lt;=M+1;++j)<br>                dp[i][j]=0;<br>        for(int len=1;len&lt;=M;++len)<br>                for(int i=1,j=i+len-1;j&lt;=M;++i,++j)<br>                    for(int k=i;k&lt;=j;++k)<br>                        dp[i][j]=max(dp[i][j],dp[i][k-1]+dp[k+1][j]+Q[k]*Q[i-1]*Q[j+1]);</algorithm></p>\n<pre><code>        cout&lt;&lt;dp\\[1\\]\\[M\\]&lt;&lt;endl;\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }  【Code】(不会,代码搁置,回头看)#incl","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"玲珑杯 Round#18 C","slug":"round18-c","date":"2017-07-15T10:45:01.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/round18-c.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1146\" target=\"_blank\" rel=\"noopener\">1146 - 图论你先敲完模板</a></strong> <strong>【题解】</strong> <strong>首先我们可以想到一个简单的dp方程</strong> <strong>dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a</strong> <strong>1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算.</strong> <strong>所以我们可以从i-1往回(1)递推,如果某一点距离差大于30.则直接退出循环即可.</strong> <strong>最终结果为dp[n].且结果需要用long long存.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20C.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 C.cpp</a></strong></p>\n<hr>\n<p> **#include&lt;bits/stdc++.h&gt;</p>\n<p>#define fill(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f</p>\n<p>#pragma comment(linker, “/STACK:102400000,102400000”)<br>using namespace std;<br>const int maxn=100000+10;<br>int n;<br>long long dp[maxn],a,dt[100000+10];<br>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%lld”,&amp;n,&amp;a);<br>        for(int i=1;i&lt;=n;++i){<br>            dp[i]=1000000000000000000;<br>            scanf(“%lld”,&amp;dt[i]);<br>            for(int j=i-1;j&gt;=1;–j){<br>                long long t;<br>                if(dt[i]-dt[j]&gt;30)break;<br>                if(dp[j]!=1000000000000000000) t=dp[j];<br>                else t=0;<br>                dp[i]=min(dp[i],t+(1&lt;&lt;(dt[i]-dt[j]))+a);<br>            }<br>        }<br>        printf(“%lld\\n”,dp[n]);<br>    }<br>    return 0;<br>}**</p>\n","text":"【Topic Link】 1146 - 图论你先敲完模板 【题解】 首先我们可以想到一个简单的dp方程 dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a 1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算. 所","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]}]}