{"name":"编辑距离","slug":"动态规划/编辑距离","count":1,"postlist":[{"title":"POJ 3356 AGTC","slug":"poj-3356-agtc","date":"2017-01-07T09:16:52.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-3356-agtc.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 动态规划:编辑距离 【题目来源】 <a href=\"http://poj.org/problem?id=3356\" target=\"_blank\" rel=\"noopener\">POJ-3356-AGTC</a> 【思路来源】 <a href=\"http://www.cnblogs.com/dongsheng/archive/2013/05/27/3102498.html\" target=\"_blank\" rel=\"noopener\">可笑痴狂</a> 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==A[i]，这样做的话， 至少需要 dp[i - 1][j] + 1步操作，即 dp[i][j] = dp[i - 1][j] + 1。 ②、我们可以删除 B[j]，这样的话，B[1…j] 变为A[1…i] 需要 dp[i][j - 1]步， 即 dp[i][j] = dp[i][j - 1] + 1。 ③、我们也可以考虑修改 B[j]，使它变为A[j]，但是如果 B[j]本来就等于 A[i]的话， 那修改其实相当于用了 0步，如果 B[j] != A[i] 的话，那修改相当于用了 1步。 所以 dp[i][j] = dp[i - 1][j - 1] + （A[i] == B[j] ? 0, 1）。 决策： 决策就很简单了，从上面三种状态转移中选择一个最小值就可以了。 处理边界： 处理好边界非常重要，这里需要注意的是对dp[0][0….m],dp[0…..n][0]的初始化， 可以这样看，dp[0][i],就是说A[1…n]是一个空串，而B[1…m]十个长度为i的串， 很显然B串变为A串就是删除i个核苷酸。 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<string></string></p>\n<p>#include<cstring><br>using namespace std;<br>char s1[1005],s2[1005];<br>int dp[1005][1005];<br>int s1l,s2l;</cstring></p>\n<p>int DP(){<br>        for(int i=0;i&lt;s1l;++i){<br>            for(int j=0;j&lt;s2l;++j){<br>                if(s1[i]==s2[j])<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]);<br>                else<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]+1);<br>            }<br>        }<br>    return dp[s1l][s2l];<br>}</p>\n<p>void init(){<br>    memset(dp,0,sizeof(dp));<br>    int tmp=max(s1l,s2l);<br>    for(int i=1;i&lt;=tmp;++i)<br>        dp[i][0]=dp[0][i]=i;<br>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;s1l&gt;&gt;s1){<br>        cin&gt;&gt;s2l&gt;&gt;s2;<br>        init();<br>        cout&lt;&lt;DP()&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 动态规划:编辑距离 【题目来源】 POJ-3356-AGTC 【思路来源】 可笑痴狂 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"编辑距离","slug":"动态规划/编辑距离","count":1,"path":"api/categories/动态规划/编辑距离.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"编辑距离","slug":"编辑距离","count":1,"path":"api/tags/编辑距离.json"}]}]}