{"name":"线段树","slug":"POJ/线段树","count":2,"postlist":[{"title":"POJ 2991","slug":"poj-2991","date":"2017-08-05T14:44:10.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/poj-2991.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树 题目连接: :earth_asia:<a href=\"http://poj.org/problem?id=2991\" title=\"Crane\" target=\"_blank\" rel=\"noopener\">POJ-Crane</a> 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子区间的向量+右子区间的向量。 求一个向量（x0,y0）逆时针旋转B度后的向量有一个公式： x1= x0 * cosB - y0 * sinB y1 = x0 * sinB + y0 * cosB 顺时针就把-B代入： x1= x0 * cosB + y0 * sinB y1 = -x0 * sinB + y0 * cosB github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-2991.CPP\" title=\"POJ 2991.cpp\" target=\"_blank\" rel=\"noopener\">POJ 2991.cpp</a> Code:</p>\n<pre><code>#define _USE_MATH_DEFINES///使用math库中的定义\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\nusing namespace std;\n\nconst int ST_SIZE=(1&lt;&lt;15)-1;\nconst int MAX_N=10010;\nconst int MAX_C=10010;\n\nint N,C;\nint L[MAX_N];\nint S[MAX_C],A[MAX_N];\n\ndouble vx[ST_SIZE],vy[ST_SIZE]; ///各节点的向量\ndouble ang[ST_SIZE]; ///各节点的角度\n\ndouble prv[MAX_N];\n\n///初始化线段树\nvoid init(int k,int l,int r){\n    ang[k]=vx[k]=0.0;\n    if(r-l==1){\n        ///叶子结点\n        vy[k]=L[l];\n    }else{\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        init(chl,l,(l+r)&gt;&gt;1);\n        init(chr,(l+r)&gt;&gt;1,r);\n        vy[k]=vy[chl]+vy[chr];\n    }\n}\n\n///把s和s+1的角度变为a\n///v是节点编号,l,r表示当前结点对应的是[l,r]区间\nvoid update(int s,double a,int k,int l,int r){\n    if(s&lt;=l) return;\n    else if(s&lt;r){\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        int m=(l+r)&gt;&gt;1;\n        update(s,a,chl,l,m);\n        update(s,a,chr,m,r);\n        if(s&lt;=m) ang[k]+=a;\n\n        double s=sin(ang[k]),c=cos(ang[k]);\n        vx[k]=vx[chl]+(c*vx[chr]-s*vy[chr]);\n        vy[k]=vy[chl]+(s*vx[chr]+c*vy[chr]);\n    }\n}\n\nvoid solve(){\n    init(0,0,N);\n    for(int i=0;i&lt;C;++i){\n        int s=S[i];\n        double a=A[i]/360.0*2*M_PI;///把角度换算成弧度\n        update(s,a-prv[s],0,0,N);\n        prv[s]=a;\n\n        printf(&quot;%.2f %.2f\\n&quot;,vx[0],vy[0]);\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;C)==2){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;L[i]);\n            prv[i]=M_PI;///180°的弧度值\n        }\n        for(int i=0;i&lt;C;++i)\n            scanf(&quot;%d%d&quot;,&amp;S[i],&amp;A[i]);\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树 题目连接: :earth_asia:POJ-Crane 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3468","slug":"poj-3468","date":"2017-08-07T11:10:00.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/poj-3468.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:<a href=\"https://vjudge.net/problem/POJ-3468\" title=\"POJ-3468\" target=\"_blank\" rel=\"noopener\">POJ-3468</a> 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问a<del>b这段数的和，‘C a b c’是把a</del>b这段数都加上c。 题解: 区间问题,首先想到线段树,这里我们建两个线段树.data,datb. data用来维护区间所更新的值. datb则用来维护区间的和. 计算的时候只需要 每部分的区间和 + 每部分更新的值 即为最终答案.(百度说这叫Lazy思想.) github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-3468.cpp\" title=\"POJ-3468.cpp\" target=\"_blank\" rel=\"noopener\">POJ-3468.cpp</a> Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n///区间更新\ntypedef long long ll;\n\nconst int DAT_SIZE=(1&lt;&lt;18)-1;\nconst int MAX_N=100000+10;\nconst int MAX_Q=100000+10;\n\nint N,Q;\nint A[MAX_N];\nchar T[MAX_Q];\nint L[MAX_Q],R[MAX_Q],X[MAX_Q];\n\n///线段树,a维护区间应加值,b维护区间和\nll data[DAT_SIZE],datb[DAT_SIZE];\n\n///对区间[a,b]同时加x\n///k是节点编号,对应的区间是[l,r)\nvoid add(int a,int b,int x,int k,int l,int r){\n    if(a&lt;=l&amp;&amp;r&lt;=b){\n        data[k]+=x;\n    }else if(l&lt;b &amp;&amp; a&lt;r){\n        datb[k]+=(min(b,r)-max(a,l))*x;\n        add(a,b,x,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        add(a,b,x,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n    }\n}\n\n///计算[a,b)的和\nll sum(int a,int b,int k,int l,int r){\n    if(b&lt;=l || a&gt;=r){\n        return 0;\n    }else if(a&lt;=l &amp;&amp; r&lt;=b){\n        return data[k]*(r-l)+datb[k];\n    }else{\n        ll res=(min(b,r)-max(a,l))*data[k];\n        res+=sum(a,b,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        res+=sum(a,b,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n        return res;\n    }\n}\n\n///下标0开头的线段树初始化\n///开区间[a,b)\nvoid solve(){\n    for(int i=0;i&lt;N;++i){\n        add(i,i+1,A[i],0,0,N);\n//        printf(&quot;\\nadd: %d -&gt; %d\\n&quot;,i,A[i]);\n    }\n    for(int i=0;i&lt;Q;++i){\n        if(T[i]==&apos;C&apos;){\n            add(L[i],R[i]+1,X[i],0,0,N);\n        }else{\n            printf(&quot;%lld\\n&quot;,sum(L[i],R[i]+1,0,0,N));\n        }\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;Q)==2){\n        memset(data,0,sizeof(data));\n        memset(datb,0,sizeof(datb));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;A[i]);\n        }\n        ///区间是[0...N)所以要减一\n        for(int i=0;i&lt;Q;++i){\n            scanf(&quot;%*c%c&quot;,&amp;T[i]);\n            if(T[i]==&apos;C&apos;){\n                scanf(&quot;%d%d%d&quot;,&amp;L[i],&amp;R[i],&amp;X[i]);\n                L[i]-=1;R[i]-=1;\n            }else{\n                scanf(&quot;%d%d&quot;,&amp;L[i],&amp;R[i]);\n                L[i]-=1;R[i]-=1;\n            }\n        }\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:POJ-3468 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问ab这段数的和，‘C a b c’是把ab这段数都加上c。 题解: 区间问题,首先想","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]}]}