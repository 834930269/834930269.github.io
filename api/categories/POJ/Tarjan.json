{"name":"Tarjan","slug":"POJ/Tarjan","count":1,"postlist":[{"title":"POJ 2186","slug":"poj-2186","date":"2018-04-22T15:05:21.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/poj-2186.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Tarjan</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;stack&gt;\nusing namespace std;\nconst int maxn=100000+10;\n/*\n　　有n只牛，牛之间存在一些关系，比如a认为b很受欢迎\n，b认为c很受欢迎，这样呢，a也会认为c很受欢迎，问根据\n给出的关系，有多少头牛被其他所有的牛都认为是受欢迎的？\n\n解:\n　　对于一个有向无环图来说，其中有且仅有一个点出度为零\n，那么这个特殊的点，可以由其他任何点到达。那么接下来我\n们直接对所给的图进行强连通分量划分，然后把每个强连通分\n量看做一个点，判定出度为零的点有几个，如果有一个就输出\n这个点对应的强连通分量含有的节点个数，否则为零。\n*/\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint vis[maxn];\n\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    ///如果点从1开始计数,这里改成-1即可\n    G[u-1].push_back(v-1);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    ///缩点,同一scc缩到同一点中\n    for(int i=0;i&lt;n;++i){\n        for(int j=0;j&lt;G[i].size();++j){\n            ///如果i到G[i][j]这条边不在强连通分量中\n            ///说明是一个连接外面的点\n            if(sccno[i]!=sccno[G[i][j]]){\n                vis[sccno[i]]++;\n            }\n        }\n    }\n\n    int sum=0,ans=0,cnt=0;\n    for(int i=1;i&lt;=scc_cnt;++i){\n        if(!vis[i]){\n            ///如果出度是0,则是一个边界点\n            sum++;\n            ans=i;\n        }\n    }\n    ///如果只有一个点的话,代表存在一个万人敬仰团体\n    if(sum==1){\n        for(int i=0;i&lt;n;++i){\n            if(sccno[i]==ans){\n                cnt++;\n            }\n        }\n        printf(&quot;%d\\n&quot;,cnt);\n    }else{\n        printf(&quot;0\\n&quot;);\n    }\n    return 0;\n}\n/*\n3 3\n1 2\n2 1\n2 3\n\n1\n*/</code></pre>","text":"Tarjan#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"Tarjan","slug":"POJ/Tarjan","count":1,"path":"api/categories/POJ/Tarjan.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]}]}