{"name":"Codeforce","slug":"Codeforce","count":6,"postlist":[{"title":"Codeforce 1A Theatre Square","slug":"codeforce-1a-theatre-square","date":"2018-01-13T11:38:33.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/codeforce-1a-theatre-square.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题意: 给你一个N*M的矩阵,和a*a的陶瓷,陶瓷不允许被破坏，问最少需要多少陶瓷能铺满矩阵.</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define EPS 1e-9\nusing namespace std;\n\nint n,m,a;\n\nlong long up_bound(double s){\n    long long ans=s;\n    if(s-ans&gt;EPS){\n        ans++;\n    }\n    return ans;\n}\n\nint main(){\n    while(scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;a)!=EOF){\n        long long row = up_bound(1.0*m/a);\n        long long column = up_bound(1.0*n/a);\n        long long ans=row*column;\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"题意: 给你一个N*M的矩阵,和a*a的陶瓷,陶瓷不允许被破坏，问最少需要多少陶瓷能铺满矩阵.#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define EPS 1e-9using ","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"Codeforce 1B Spreadsheet","slug":"codeforce-1b-spreadsheet","date":"2018-01-13T13:12:09.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/codeforce-1b-spreadsheet.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题意: 26进制的转换,需要注意的是,A &lt;=&gt; 0.所以处理的时候需要注意一下10禁止转26进制的时候是 以(num-1)作为当前数. 另外就是 10转26进制直接从0开始依次*26即可.以及 sscanf() 和 %[A-Z]的用法.</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\n#include&lt;stack&gt;\nusing namespace std;\nconst int MAXN=100;\nint N;\nchar Q[MAXN];\n//10进制转26进制\nvoid solveToAlpha(){\n    stack&lt;char&gt; ans;\n    int a,num;\n    sscanf(Q,&quot;R%dC%d&quot;,&amp;a,&amp;num);\n    int i;\n    for(i=0;num&gt;0;i++){\n        char c=(num-1)%26+&apos;A&apos;;\n        ans.push(c);\n        num=(num-1)/26;\n    }\n    while(!ans.empty()){\n        printf(&quot;%c&quot;,ans.top());\n        ans.pop();\n    }\n    printf(&quot;%d\\n&quot;,a);\n}\n//26进制转10进制\nvoid solveToNum(){\n    int a;\n    char b[MAXN];\n    sscanf(Q,&quot;%[A-Z]%d&quot;,b,&amp;a);\n    long long ans=0;\n    int len=strlen(b);\n    for(int i=0;i&lt;len;++i){\n        ans*=26;\n        ans=ans+b[i]-&apos;A&apos;+1;\n    }\n    printf(&quot;R%dC%lld\\n&quot;,a,ans);\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;N);\n    for(int i=0;i&lt;N;++i){\n        scanf(&quot;%s&quot;,Q);\n        int a,b;\n        //sscanf()\n        if(sscanf(Q,&quot;R%dC%d&quot;,&amp;a,&amp;b)==2){\n            solveToAlpha();\n        }else{\n            solveToNum();\n        }\n    }\n    return 0;\n}</code></pre>","text":"题意: 26进制的转换,需要注意的是,A &lt;=&gt; 0.所以处理的时候需要注意一下10禁止转26进制的时候是 以(num-1)作为当前数. 另外就是 10转26进制直接从0开始依次*26即可.以及 sscanf() 和 %[A-Z]的用法.#include&lt;std","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"Codeforce 915 A、B、C","slug":"codeforce-915-a-b-c","date":"2018-01-14T03:28:45.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/codeforce-915-a-b-c.json","excerpt":"","keywords":null,"cover":null,"content":"<p>A. Garden <strong>【题意】</strong> 选择一个桶可以以最少的小时浇满花园,花园不能重复浇.</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nconst int MAXN=200;\nint n,k;\nint min_bucket_fill;\n\nint main(){\n    while(cin&gt;&gt;n&gt;&gt;k){\n        min_bucket_fill=0x3f3f3f3f;\n        for(int i=0;i&lt;n;++i){\n            int a;\n            cin&gt;&gt;a;\n            if(k%a==0)min_bucket_fill=min(k/a,min_bucket_fill);\n        }\n        printf(&quot;%d\\n&quot;,min_bucket_fill);\n    }\n    return 0;\n}</code></pre><p>B. Browser <strong>【题意】</strong> 给定初始位置,需要使用的页面区间【l,r】,问,从初始位置开始,到关闭所有非区间内标签最少需要多少次点击鼠标.关闭页面也需要点击一次.</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\nusing namespace std;\n\nint n,pos,l,r;\nint main(){\n    while(cin&gt;&gt;n&gt;&gt;pos&gt;&gt;l&gt;&gt;r){\n        if(l==1&amp;&amp;r==n){printf(&quot;0\\n&quot;);continue;}\n        int ans=0;\n        ans=abs(min(abs(pos-l),abs(pos-r))+2+r-l);\n        if(l==1)ans=abs(pos-r)+1;\n        if(r==n)ans=abs(pos-l)+1;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>C. Permute Digits <strong>【题意】</strong> 给定a,b.对a进行任意排列,得到小于等于b且大于等于a的c.问这个c最大是多少. Tip: 注意a,b取值范围是1e18 string数字无法比较大小.</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nlong long str_2_num(string str){\n    long long reg=0;\n    int len=str.size();\n    for(int i=0;i&lt;len;++i){\n        reg*=10;\n        reg+=(str[i]-&apos;0&apos;);\n    }\n    return reg;\n}\n\nint main(){\n    string a,b;\n    string ans;\n    while(cin&gt;&gt;a&gt;&gt;b){\n        int len=a.size();\n        sort(a.begin(),a.end());\n        for(int i=0;i&lt;len;++i){\n            for(int j=i;j&lt;len;++j){\n                string tmp=a;\n                swap(tmp[i],tmp[j]);\n                sort(tmp.begin()+i+1,tmp.end());\n                if(str_2_num(tmp)&lt;=str_2_num(b)&amp;&amp;str_2_num(tmp)&gt;=str_2_num(a))swap(a[i],a[j]);\n            }\n        }\n        cout&lt;&lt;a&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"A. Garden 【题意】 选择一个桶可以以最少的小时浇满花园,花园不能重复浇.#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;usi","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"Codeforces 232A Cycles","slug":"codeforces-232a-cycles","date":"2017-03-25T06:43:14.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/codeforces-232a-cycles.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>思路,逻辑题.</strong> <strong>【参考】</strong> <strong>WannaFlyUnion</strong> <strong>【题解】</strong> <strong>每次加入一个点时让他先于点1相连,贡献为0,然后与点2相连,贡献为1,与三相连,贡献为2…依此类推.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>using namespace std;</strong> <strong>const int MAXN=111;</strong> <strong>int mapp[MAXN][MAXN];</strong> <strong>int main(){</strong> **    int n;** **    cin&gt;&gt;n;** **    int l=2;** **    int ant=0;** **    mapp[1][2]=mapp[2][1]=1;** **    for(int i=3;i&lt;=100;++i){** **        l=max(l,i);** **        mapp[i][1]=mapp[1][i]=1;** <strong>//都与点1相连</strong> **        for(int j=2;j&lt;i;++j){** **            mapp[i][j]=mapp[j][i]=1;** <strong>//比如4个点,2和4连贡献了一个,3和4连贡献了两个…</strong> **            ant+=j-1;** **            if(ant==n)** **                break;** **            else if(ant&gt;n){** **                ant-=j-1;** **                mapp[i][j]=mapp[j][i]=0;** **                break;** **            }** **        }** **        if(ant==n)** **            break;** **    }** **    printf(“%d\\n”,l);** **    for (int i = 1 ; i &lt;= l ; i++)  ** **    {  ** **        for (int j = 1 ; j &lt; l ; j++)  ** **            printf (“%d”,mapp[i][j]);  ** **        printf (“%d\\n”,mapp[i][l]);  ** **    }  ** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 思路,逻辑题. 【参考】 WannaFlyUnion 【题解】 每次加入一个点时让他先于点1相连,贡献为0,然后与点2相连,贡献为1,与三相连,贡献为2…依此类推. 【Code】#include  using namespace std; const int MAXN=","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"Educational Codeforces Round 25 B","slug":"educational-codeforces-round-25-b","date":"2017-07-16T18:37:23.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/educational-codeforces-round-25-b.json","excerpt":"","keywords":null,"cover":null,"content":"<p> 【题目】</p>\n<h2 id=\"B-Five-In-a-Row\"><a href=\"#B-Five-In-a-Row\" class=\"headerlink\" title=\"B. Five-In-a-Row\"></a>B. Five-In-a-Row</h2><h5 id=\"time-limit-per-test1-second-memory-limit-per-test256megabytes\"><a href=\"#time-limit-per-test1-second-memory-limit-per-test256megabytes\" class=\"headerlink\" title=\"time limit: per test1 second memory limit: per test256megabytes\"></a>time limit: per test1 second memory limit: per test256megabytes</h5><h5 id=\"input-standard-input-output-standard-output\"><a href=\"#input-standard-input-output-standard-output\" class=\"headerlink\" title=\"input: standard input output: standard output\"></a>input: standard input output: standard output</h5><p>Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts. In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately. Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.</p>\n<p><strong>Input</strong></p>\n<p>You are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell. It is guaranteed that in the current arrangement nobody has still won.</p>\n<p><strong>Output</strong></p>\n<p>Print ‘YES’ if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print ‘NO’.</p>\n<p><strong>Examples</strong></p>\n<p><strong>Input</strong></p>\n<p>XX.XX…..<br>…..OOOO.<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….</p>\n<p><strong>Output</strong></p>\n<p>YES</p>\n<p><strong>Input</strong></p>\n<p>XXOXX…..<br>OO.O……<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….</p>\n<p><strong>Output</strong></p>\n<p>NO Link: <a href=\"http://codeforces.com/contest/825/problem/B\" target=\"_blank\" rel=\"noopener\">http://codeforces.com/contest/825/problem/B</a> 【题意】 X是否能在一步以内连成五子.可以则赢. 【题解】 数据量不大,枚举八个方向即可,注意,每次只能往一个方向走,不能拐弯.而且必须枚举八方向,不能只枚举向下的几个方向. 如果找到第一个五子,则往后就不需要计算了. 【Sourcr Code】 github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/Educational%20Codeforces%20Round%2025%20%20B.cpp\" target=\"_blank\" rel=\"noopener\">Educational Codeforces Round 25 B.cpp</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>char mp[11][11];<br>bool re;<br>int d[8][3]={ {0,1},{1,0},{1,1},{1,-1},{-1,1},{-1,-1},{0,-1},{-1,0}};</p>\n<p>bool check(int x,int i,int y,int j){<br>    if(x+i&gt;=0&amp;&amp;x+i&lt;10&amp;&amp;y+j&gt;=0&amp;&amp;y+j&lt;=10)<br>        return true;<br>    else return false;<br>}</p>\n<p>void dfs(int x,int y,int win,int ct,int dir){<br> //   if(dir==3)<br> //       printf(“(%d,%d):%d %d\\n”,x,y,win,dir);<br>    if(win==5 || re){re=true;return;}<br>    int i=d[dir][0],j=d[dir][1];<br>    if(check(x,i,y,j)){<br>        if(mp[x+i][y+j]==’X’) dfs(x+i,y+j,win+1,ct,dir);<br>        if(mp[x+i][y+j]==’.’ &amp;&amp; ct==0) dfs(x+i,y+j,win+1,1,dir);<br>    }<br>}</p>\n<p>int main(){<br>    re=false;<br>    for(int i=0;i&lt;10;++i)<br>        gets(mp[i]);<br>    for(int i=0;i&lt;10;++i){<br>        if(re)break;<br>        for(int j=0;j&lt;10;++j){<br>            if(mp[i][j]==’X’){<br>                for(int k=0;k&lt;8;++k){<br>                    dfs(i,j,1,0,k);<br>                    if(re)break;<br>                }<br>                if(re)break;<br>            }<br>        }<br>    }<br>    if(re)printf(“YES\\n”);<br>    else printf(“NO\\n”);<br>    return 0;<br>}</p>\n<p>/**<br>….X…..<br>…X.OOOO.<br>..X…….<br>.X……..<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>**/</p>\n","text":" 【题目】B. Five-In-a-Rowtime limit: per test1 second memory limit: per test256megabytesinput: standard input output: standard outputAlice and B","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"},{"name":"dfs","slug":"Codeforce/dfs","count":1,"path":"api/categories/Codeforce/dfs.json"},{"name":"图论","slug":"Codeforce/dfs/图论","count":1,"path":"api/categories/Codeforce/dfs/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]},{"title":"Educational Codeforces Round 25 A","slug":"educational-codeforces-round-25-a-cpp","date":"2017-07-16T18:26:21.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/educational-codeforces-round-25-a-cpp.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题目以及连接】</strong></p>\n<h2 id=\"A-Binary-Protocol\"><a href=\"#A-Binary-Protocol\" class=\"headerlink\" title=\"A. Binary Protocol\"></a>A. Binary Protocol</h2><h5 id=\"time-limit-per-test-1-second\"><a href=\"#time-limit-per-test-1-second\" class=\"headerlink\" title=\"time limit per test:1 second\"></a>time limit per test:1 second</h5><h5 id=\"memory-limit-per-test-256-megabytes\"><a href=\"#memory-limit-per-test-256-megabytes\" class=\"headerlink\" title=\"memory limit per test:256 megabytes\"></a>memory limit per test:256 megabytes</h5><h5 id=\"input-standard-input\"><a href=\"#input-standard-input\" class=\"headerlink\" title=\"input: standard input\"></a>input: standard input</h5><h5 id=\"output-standard-output\"><a href=\"#output-standard-output\" class=\"headerlink\" title=\"output: standard output\"></a>output: standard output</h5><p>Polycarp has just invented a new binary protocol for data transmission. He is encoding positive integer decimal number to binary string using following algorithm:</p>\n<ul>\n<li>Each digit is represented with number of ‘1’ characters equal to the value of that digit (for 0 it is zero ones).</li>\n<li>Digits are written one by one in order corresponding to number and separated by single ‘0’ character.</li>\n</ul>\n<p>Though Polycarp learnt how to encode the numbers, he has no idea how to decode them back. Help him calculate the decoded number.</p>\n<p><strong>Input</strong></p>\n<p>The first line contains one integer number <em>n</em> (1 ≤ <em>n</em> ≤ 89) — length of the string <em>s</em>. The second line contains string <em>s</em> — sequence of ‘0’ and ‘1’ characters, number in its encoded format. It is guaranteed that the number corresponding to the string is positive and doesn’t exceed 109. The string always starts with ‘1’.</p>\n<p><strong>Output</strong></p>\n<p>Print the decoded number.</p>\n<p><strong>Examples</strong></p>\n<p><strong>Input</strong></p>\n<p>3<br>111</p>\n<p><strong>Output</strong></p>\n<p>3</p>\n<p><strong>Input</strong></p>\n<p>9<br>110011101</p>\n<p><strong>Output</strong></p>\n<p>2031 Link: <a href=\"http://codeforces.com/contest/825/problem/A\" target=\"_blank\" rel=\"noopener\">Codeforce Educational Codeforces Round 25 A</a> <strong>【题意】</strong> 给出一串二进制字符串,翻译成原来的数字.规则为数字间以单独的0为分隔符.多余的0当做一个0输出,最后有几个0输出几个0. (后面那个意思蒙出来的,英语渣,有点没搞懂最后一个条件是为什么). <strong>【题解】</strong> 逐位记录即可. <strong>【Source Code】</strong> github:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/Educational%20Codeforces%20Round%2025%20%20A.cpp\" target=\"_blank\" rel=\"noopener\">Educational Codeforces Round 25 A.cpp –忽然发现–原来链接中有空格使用%20处理的.但是空格多了,复制的时候不会复制上%20..要手敲</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int n;<br>    while(~scanf(“%d”,&amp;n)){<br>        char digit,pre=’0’;<br>        int cnt=0;<br>        for(int i=0;i&lt;n;++i){<br>            cin&gt;&gt;digit;<br>            if(digit==’1’) cnt++;<br>            if(digit==’0’) {printf(“%d”,cnt);cnt=0;}<br>        }<br>        if(digit==’1’) printf(“%d”,cnt);<br>        if(digit==’0’) printf(“0”);<br>        printf(“\\n”);<br>    }<br>    return 0;<br>}</p>\n","text":"【题目以及连接】A. Binary Protocoltime limit per test:1 secondmemory limit per test:256 megabytesinput: standard inputoutput: standard outputPolycar","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"},{"name":"未分类","slug":"Codeforce/未分类","count":1,"path":"api/categories/Codeforce/未分类.json"},{"name":"枚举","slug":"Codeforce/未分类/枚举","count":1,"path":"api/categories/Codeforce/未分类/枚举.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"},{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"}]}]}