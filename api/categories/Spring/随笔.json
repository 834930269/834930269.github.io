{"name":"随笔","slug":"Spring/随笔","count":1,"postlist":[{"title":"基础概念、项目结构和配置","slug":"spring","date":"2019-01-18T11:03:03.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/spring.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2019/01/%E6%8D%95%E8%8E%B72.png","content":"<h1><span id=\"1-实现简单三层架构单体应用登入\">1 - 实现简单三层架构单体应用(登入)</span></h1><h2><span id=\"项目架构\">项目架构</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/%E6%8D%95%E8%8E%B72.png\" alt></p>\n<h2><span id=\"注意\">注意</span></h2><blockquote>\n<p>不使用新建项目,而采用单独新建文件夹架构项目的方式.</p>\n</blockquote>\n<ol>\n<li>Mark Directory <code>src/main/java</code> as Sources Root</li>\n<li>Mark Directory <code>src/main/resources</code> as Resources Root</li>\n<li>将webapp设置为web目录</li>\n</ol>\n<h2><span id=\"宏观流程\">宏观流程</span></h2><blockquote>\n<p>即不深入运行过程,仅从简单逻辑层面来判断.</p>\n</blockquote>\n<p>document.write(“graph TD\\nA[客户端请求] –&gt;|请求到达| B(Controller中 Get/Post处理方法)\\nB –&gt; C(ServiceImpl - extends Service)\\nC –&gt; D(DaoImpl - extends Dao)\\nD –&gt; E(Model实体)\\n”);</p>\n<h2><span id=\"xml配置以及基本框架\">xml配置以及基本框架</span></h2><blockquote>\n<p>对于servlet的配置</p>\n<blockquote>\n<p>WEB-INF下web.xml -&gt; 将Controller映射到某一个Uri上</p>\n</blockquote>\n<p>pom.xml</p>\n<blockquote>\n<p>Maven配置依赖项</p>\n</blockquote>\n<p>spring-context.xml</p>\n<blockquote>\n<p>控制反转,将bean交给SpringIoC容器</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"webxml\">web.xml</span></h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n         version=&quot;4.0&quot;&gt;\n&lt;/web-app&gt;</code></pre><h3><span id=\"pomxml\">pom.xml</span></h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-demo&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.12&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;1.7.25&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;</code></pre><h3><span id=\"spring-contextxml\">spring-context.xml</span></h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n&lt;/beans&gt;</code></pre><h2><span id=\"代码\">代码</span></h2><p><a href=\"https://github.com/834930269/Spring_demo/tree/master/demo/login-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/834930269/Spring_demo/tree/master/demo/login-demo</a></p>\n<hr>\n<h1><span id=\"2-理解依赖注入和控制反转\">2 - 理解依赖注入和控制反转</span></h1><h2><span id=\"项目结构\">项目结构</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/SPRING-DEMO.png\" alt> Tip: 如果文件名显示,而没有任何错误，大抵是开了版本控制,比如Git.在.idea的vcs.xml文件中将git删掉即可</p>\n<h2><span id=\"依赖注入\">依赖注入</span></h2><h3><span id=\"背景\">背景</span></h3><p>DI: Dependency injection From Spring实战(第四版) P5</p>\n<blockquote>\n<p>背景: 任何一个实际意义的应用,都会由两个或者更多的类组成.这些类相互协作形成应用.</p>\n<blockquote>\n<p>这样子导致的直接结果是耦合度过高.</p>\n</blockquote>\n<p>DI: 为了解决这一问题,Spring提供了依赖注入这一解决方案.</p>\n</blockquote>\n<h3><span id=\"什么叫依赖注入\">什么叫依赖注入?</span></h3><p>举个栗子: 我们想要实现骑士探险这一类,可以自由的为骑士选择探险任务. Knight.java</p>\n<pre><code>package DI;\n\npublic interface Knights {\n    public void embarkOnQuest();\n}</code></pre><p>探险任务</p>\n<pre><code>package DI;\n\npublic class RescueDamselQuest {\n    public void embark(){\n        System.out.println(&quot;已接收&quot;);\n    }\n}</code></pre><p>骑士接受任务</p>\n<pre><code>package DI;\n\npublic class DamselRescuingKnight implements Knights {\n    private RescueDamselQuest quest;\n\n    public DamselRescuingKnight() {\n        quest=new RescueDamselQuest();\n    }\n\n    @Override\n    public void embarkOnQuest() {\n        quest.embark();\n    }\n}</code></pre><p>我们会发现这样写代码使得探险和骑士的耦合度达到了密不可分的地步,写一个探险就要新建一个结合类. 改进措施,提出了依赖注入:</p>\n<blockquote>\n<p>构造器注入</p>\n<blockquote>\n<p>这个比较简单,即将探险类作为构造参数传递进来,但这样依然没有达到代码层面的解耦.</p>\n</blockquote>\n</blockquote>\n<pre><code>public class DamselRescuingKnight implements Knights {\n    private RescueDamselQuest quest;\n\n    public DamselRescuingKnight(Quest quest) {\n        this.quest=quest;\n    }\n\n    @Override\n    public void embarkOnQuest() {\n        quest.embark();\n    }\n}</code></pre><blockquote>\n<p>mock注入</p>\n<blockquote>\n<p>和Spring的依赖注入很像.</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"spring的依赖注入\">Spring的依赖注入</span></h3><blockquote>\n<p>接上本小节一开始的那张项目结构图.</p>\n</blockquote>\n<p>Spring是这样做的.你将需要解耦的类交给Spring的容器去保管,需要使用时直接从Spring中取出来即可,而不需要有任何new出来的类.</p>\n<blockquote>\n<p>比如Service,Bean等,都可以交给Spring保管.</p>\n</blockquote>\n<p>举个栗子: UserService.java(接口)</p>\n<pre><code>package com.funtl.spring.service;\n\npublic interface UserService {\n    public void sayhi();\n}</code></pre><p>UserServiceImpl.java</p>\n<pre><code>package com.funtl.spring.service.impl;\n\nimport com.funtl.spring.service.UserService;\n\npublic class UserServiceImpl implements UserService {\n    public void sayhi() {\n        System.out.println(&quot;hello&quot;);\n    }\n}</code></pre><p>resources/spring-context.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;userService&quot; class=&quot;com.funtl.spring.service.impl.UserServiceImpl&quot; /&gt;\n&lt;/beans&gt;</code></pre><p>OK,前序工作做完了,我们在运行时就已经将这个类托管给了Spring容器. 那么我们该如何取出来呢? MyTest.java</p>\n<pre><code>package com.funtl.spring;\n\nimport com.funtl.spring.service.UserService;\nimport com.funtl.spring.service.impl.UserServiceImpl;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args){\n        //获取Spring容器\n        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);\n\n        //从Spring容器中获取对象\n        UserService userService= (UserService) applicationContext.getBean(&quot;userService&quot;);\n        userService.sayhi();\n\n    }\n}</code></pre><p>我们可以看到,上面的代码并没有new一个Service,而是从Spring上下文中取出了userService这个对象. 仔细想想,这样是不是就类似于调用静态的工具类那样轻松了呢?</p>\n<blockquote>\n<p>依赖注入的魅力就在于此.</p>\n<blockquote>\n<p>而将类的加载交给容器时,这个容器的模式就叫做 IoC(控制反转)</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"最终架构\">最终架构</span></h1><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/%E6%8D%95%E8%8E%B73.png\" alt></p>\n","text":"1 - 实现简单三层架构单体应用(登入)项目架构 [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"Spring","slug":"Spring","count":4,"path":"api/categories/Spring.json"},{"name":"随笔","slug":"Spring/随笔","count":1,"path":"api/categories/Spring/随笔.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}]}]}