{"name":"思维","slug":"Floyd判圈法/UVa/思维","count":1,"postlist":[{"title":"UVa 11549","slug":"uva-11549","date":"2017-04-05T05:00:42.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11549.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题解】</strong> <strong>Floyd判圈法</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>int buf[200];</strong> <strong>int next(int n,int k){</strong> **    if(!k) return 0;** **    int p=0,i=0;** **    long long RES=(long long)k<em>k;*</em> **    while(RES&gt;0){buf[i++]=RES%10;RES/=10;}** **    if(n&gt;i)n=i;** **    for(int t=0;t&lt;n;++t)p=p<em>10+buf[–i];*</em> **    return p;** <strong>}</strong> <strong>void floyd_check(int n,int k){</strong> **        int k1=k,k2=k,ans=k;//ans=k** **        do{** **            k1=next(n,k1);** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **        }while(k1!=k2);** **        printf(“%d\\n”,ans);** <strong>}</strong> <strong>int main(){</strong> **    int T,n,go;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        scanf(“%d%d”,&amp;n,&amp;go);** **        floyd_check(n,go);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【题解】 Floyd判圈法 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; int buf[200]; int next(int n,int k){ **    if(!k) return 0;** **    i","link":"","raw":null,"photos":[],"categories":[{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/categories/Floyd判圈法.json"},{"name":"UVa","slug":"Floyd判圈法/UVa","count":1,"path":"api/categories/Floyd判圈法/UVa.json"},{"name":"思维","slug":"Floyd判圈法/UVa/思维","count":1,"path":"api/categories/Floyd判圈法/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/tags/Floyd判圈法.json"}]}]}