{"name":"网络编程","slug":"Java/tcp/网络编程","count":1,"postlist":[{"title":"聊天室架构从0开始 - 1 TCP&UDP问题","slug":"type-1","date":"2019-01-01T01:00:24.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/type-1.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/12/ServerSocket%E4%B8%8ESocket.png","content":"<blockquote>\n<p>最后更新于2019/1/1</p>\n</blockquote>\n<h1><span id=\"课设过程中的记录\">课设过程中的记录</span></h1><h2><span id=\"序言-tcp与udp的族谱\">序言 - tcp与udp的族谱</span></h2><h3><span id=\"借助工具-流式读取\">借助工具 - 流式读取</span></h3><p><a href=\"http://be-sunshine.cn/index.php/2018/06/21/javaweb-two/\" title=\"java流式读取\" target=\"_blank\" rel=\"noopener\">戳-&gt;java流式读取</a></p>\n<h3><span id=\"简单tcp问题\">简单tcp问题</span></h3><p>因为要求服务端是无限接收客户端的请求,所以服务端必须用线程来新建和处理请求.</p>\n<h4><span id=\"服务端代码\">服务端代码</span></h4><pre><code>import javax.print.DocFlavor;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.SQLTransactionRollbackException;\n\npublic class Server {\n    public static void main(String[] args)throws IOException {\n        //如果不指定端口号和ip地址,默认是本地\n        ServerSocket server=new ServerSocket(2019);\n        System.out.println(&quot;服务器准备就绪~&quot;);\n        System.out.println(&quot;服务器信息: &quot;+server.getInetAddress()+&quot; P:&quot;+server.getLocalPort() );\n\n        //等待客户端连接\n        while(true) {\n            //得到客户端\n            Socket client = server.accept();\n            //客户端构建异步线程\n            ClientHandler clientHandler = new ClientHandler(client);\n            //启动线程\n            clientHandler.start();\n        }\n    }\n\n    //处理多个请求时要用异步\n    private static class ClientHandler extends Thread{\n        private Socket socket;\n        private boolean flag=true;\n\n        ClientHandler(Socket socket){\n            this.socket=socket;\n        }\n\n        //运行时运行run\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;新客户端连接: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n            try{\n                //得到打印流,用于数据输出：服务器回送数据使用\n                PrintStream socketOutput=new PrintStream(socket.getOutputStream());\n                //得到输入流,用于接收数据\n                BufferedReader socketInput=new BufferedReader(new InputStreamReader(\n                        socket.getInputStream()));\n\n                do{\n                    String str=socketInput.readLine();\n                    //equalsIgnoreCase忽略大小写\n                    if(&quot;bye&quot;.equalsIgnoreCase(str)){\n                        flag=false;\n                        //回送\n                        socketOutput.println(&quot;bye&quot;);\n                    }else{\n                        System.out.println(str);\n                        socketOutput.println(&quot;回送： &quot;+ str.length());\n                    }\n                }while(flag);\n\n                socketInput.close();\n                socketOutput.close();\n            }catch(Exception e){\n                System.out.println(&quot;连接异常断开&quot;);\n            }finally {\n                //连接关闭(每个线程)\n                try{\n                    socket.close();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(&quot;客户端已退出: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n        }\n    }\n}</code></pre><h4><span id=\"客户端代码\">客户端代码</span></h4><pre><code>import java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class Client {\n    public static void main(String[] args)throws IOException {\n        Socket socket=new Socket();\n        ///超时时间\n        socket.setSoTimeout(3000);\n        //连接本地,端口2000,超时时间3000ms\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),2019),3000);\n        System.out.println(&quot;已发起服务器连接,并进入后续流程~&quot;);\n        System.out.println(&quot;客户端信息: &quot;+socket.getLocalAddress()+&quot; P:&quot;+socket.getLocalPort());\n        System.out.println(&quot;服务器信息: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort() );\n\n        try{\n            //发送接收数据\n            todo(socket);\n        }catch(Exception e){\n            System.out.println(&quot;异常关闭&quot;);\n        }\n        //释放资源\n        socket.close();\n        System.out.println(&quot;客户端已关闭&quot;);\n    }\n\n    private static void todo(Socket client) throws IOException{\n        //构建键盘输入流\n        InputStream in=System.in;\n        BufferedReader  input=new BufferedReader(new InputStreamReader(in));\n\n        //得到Socket输出流,并转换为打印流\n        OutputStream output=client.getOutputStream();\n        PrintStream socketPrintStream=new PrintStream(output);\n\n        //得到Socket输入流,并转换为BufferedReader\n        InputStream inputStream=client.getInputStream();\n        BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n        boolean flag=true;\n        do{\n            //键盘读一行\n            String str=input.readLine();\n            //发送到服务器\n            socketPrintStream.println(str);\n\n            //从服务器读取一行\n            String echo=socketBufferedReader.readLine();\n            if(&quot;bye&quot;.equalsIgnoreCase(echo)){\n                flag=false;\n            }else{\n                System.out.println(echo);\n            }\n        }while(flag);\n\n        //关闭全部流,资源释放\n        socketBufferedReader.close();\n        socketPrintStream.close();\n        input.close();\n    }\n}</code></pre><h3><span id=\"常见协议端口号\">常见协议端口号</span></h3><p>协议</p>\n<p>端口</p>\n<p>TCP or UDP</p>\n<p>FTP</p>\n<p>20,21</p>\n<p>TCP</p>\n<p>SSH</p>\n<p>22</p>\n<p>TCP</p>\n<p>Telnet</p>\n<p>23</p>\n<p>TCP</p>\n<p>SMTP</p>\n<p>25</p>\n<p>TCP</p>\n<p>DNS</p>\n<p>53</p>\n<p>UDP</p>\n<p>TFTP</p>\n<p>69</p>\n<p>UDP</p>\n<p>HTTP</p>\n<p>80</p>\n<p>TCP</p>\n<p>POP3</p>\n<p>110</p>\n<p>TCP</p>\n<p>IMAP4</p>\n<p>143</p>\n<p>TCP</p>\n<p>HTTPS</p>\n<p>443</p>\n<p>TCP</p>\n<p>其中49152~65535号端口属于动态端口,没有端口可以被正式注册.</p>\n<h3><span id=\"udp\">UDP</span></h3><h4><span id=\"介绍\">介绍</span></h4><p>UDP是不可靠连接的协议,它的结构简单,不保留数据备份,无校验,速度快,容易丢包,可广播. 自身协议占用64位. 0-15(2个字节,短整型):发送源ip 16-31：接收源ip 32-47:长度 48-64:校验字段和header 其余均为data域: 最大的数据长度为65507 Bite,超过的要自行分包.</p>\n<h4><span id=\"udp能做什么\">UDP能做什么?</span></h4><ol>\n<li>解析ip时的DNS就是依赖于UDP,以及TFTP,SNMP</li>\n<li>视频,音频,普通数据(无关紧要的数据),但若下载时用的是tcp</li>\n</ol>\n<h4><span id=\"udp-核心api\">UDP 核心API</span></h4><ol>\n<li>UDP并未合并到Socket核心包中.</li>\n</ol>\n<p>API</p>\n<p>作用</p>\n<p>DatagramSocket()</p>\n<p>创建简单实例,不指定端口和ip</p>\n<p>DatagramSocket(int port)</p>\n<p>创建监听某端口实例</p>\n<p>DatagramSocket(int port，InetAddress localAddr)</p>\n<p>创建固定端口指定ip的实例</p>\n<p>receive(DatagramPacket d)</p>\n<p>继续DatagramPacket后-接收</p>\n<p>sent(DatagramPacket d)</p>\n<p>继续DatagramPacket后-发送</p>\n<p>setSoTimeout(int timeout)</p>\n<p>设置传输/监听时超时时间,毫秒</p>\n<p>close()</p>\n<p>关闭,释放资源</p>\n<p>DatagramPacket(byte[] buf,int offset,int length,InetAddress address,int port)</p>\n<p>用于处理报文,拆包,封包,是发送/接收实体 - byte数组，可用区间(offset,length),接收者(发送时有效)地址(address,port)</p>\n<p>DatagramPacket(byte[] buf,int length,SocketAddress address)</p>\n<p>用Socket封装</p>\n<p>setData(byte[] buf,int offset,int length)</p>\n<p>DatagramPacket.setData构造一,指定偏移</p>\n<p>setData(byte[] buf)</p>\n<p>DatagramPacket无偏移</p>\n<p>setLength(int length)</p>\n<p>DatagramPacket单独指定长度</p>\n<p>getData(),getOffset(),getLength()</p>\n<p>DatagramPacket获取信息</p>\n<p>setAddress(InetAddress address),setPort(int iport)</p>\n<p>DatagramPacket指定发送时接收端ip</p>\n<p>setSocketAddress(SocketAddress address)</p>\n<p>DatagramPacket指定封装ip端口后的SocketAddress</p>\n<p>get…()</p>\n<p>DatagramPacket获取这些信息</p>\n<h4><span id=\"单播广播和多播\">单播,广播和多播</span></h4><ol>\n<li>单播: 将信息传给单点，两者间</li>\n<li>多播(组播): 给一组设备发送</li>\n<li>广播: 给所有设备(同一网段)发送</li>\n</ol>\n<h4><span id=\"udp点对点\">UDP点对点</span></h4><h5><span id=\"服务提供方代码\">服务提供方代码</span></h5><pre><code>import javax.xml.crypto.Data;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\n/*\n UDP 服务提供方\n */\npublic class UDPProvider {\n    public static void main(String[] args)throws IOException {\n        System.out.println(&quot;Provider Started.&quot;);\n\n        //作为接受者,制定一个端口用于数据接收\n        DatagramSocket ds=new DatagramSocket(20000);\n\n        //构建接收实体\n        final byte[] buf=new byte[512];\n        DatagramPacket receivePack=new DatagramPacket(buf,buf.length);\n\n        //接收\n        ds.receive(receivePack);\n\n        //打印接收到的信息与发送者的信息\n        //发送端ip地址\n        String ip=receivePack.getAddress().getHostAddress();\n        int port=receivePack.getPort();\n        int dataLen=receivePack.getLength();\n        String data=new String(receivePack.getData(),0,dataLen);\n        System.out.println(&quot;UDPProvider receive from ip:&quot;+ip+&quot;\\tport:&quot;+port+&quot;\\tdata:&quot;+data);\n\n        //构建一份回送数据\n        String responseData=&quot;Receive data with len：&quot;+dataLen;\n        byte[] responseDataBytes=responseData.getBytes();\n        //直接根据发送者构建一份回送信息\n        DatagramPacket responsePacket= new DatagramPacket(responseDataBytes,responseDataBytes.length,receivePack.getAddress(),receivePack.getPort());\n        ds.send(responsePacket);\n\n        //完成\n        System.out.println(&quot;UDPProvider Finished.&quot;);\n        ds.close();\n    }\n}</code></pre><h5><span id=\"服务请求方代码\">服务请求方代码</span></h5><pre><code>import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\n/*\n    UDP搜索者,用于搜索服务支持方\n */\npublic class UDPSearcher {\n    public static void main(String[] args)throws IOException {\n        System.out.println(&quot;UDPSearcher Started.&quot;);\n\n        //作为搜索方,系统直接分配端口\n        DatagramSocket ds=new DatagramSocket();\n\n        //构建一份请求数据\n        String requestData=&quot;HelloWorld&quot;;\n        byte[] requestDataBytes=requestData.getBytes();\n        //直接根据构建一份请求信息\n        DatagramPacket requestPacket= new DatagramPacket(requestDataBytes,requestDataBytes.length);\n        requestPacket.setAddress(InetAddress.getLocalHost());\n        requestPacket.setPort(20000);\n\n        ds.send(requestPacket);\n\n        //构建接收实体\n        final byte[] buf=new byte[512];\n        DatagramPacket receivePack=new DatagramPacket(buf,buf.length);\n\n        //接收\n        ds.receive(receivePack);\n\n        //打印接收到的信息与发送者的信息\n        //发送端ip地址\n        String ip=receivePack.getAddress().getHostAddress();\n        int port=receivePack.getPort();\n        int dataLen=receivePack.getLength();\n        String data=new String(receivePack.getData(),0,dataLen);\n        System.out.println(&quot;UDPSearcher receive from ip:&quot;+ip+&quot;\\tport:&quot;+port+&quot;\\tdata:&quot;+data);\n\n\n        //完成\n        System.out.println(&quot;UDPSearcher Finished.&quot;);\n        ds.close();\n    }\n}</code></pre><h4><span id=\"udp广播\">UDP广播</span></h4><h5><span id=\"前置知识\">前置知识</span></h5><ol>\n<li>线程中的CountDownLatch异步通知外部.</li>\n<li>线程关闭</li>\n<li>局域网广播地址255.255.255.255</li>\n<li>唯一标识库 UUID</li>\n<li>字符串处理API （startsWith(String),substring(length)）</li>\n<li>DatagramSocket和DatagramPacket</li>\n</ol>\n<h5><span id=\"简单架构\">简单架构</span></h5><ol>\n<li>无论客户端还是服务端,在发送前首先要保证自己的监听时开启的,否则可能因为指令优化导致先发送而却无法接收.</li>\n<li>搜索端用内部类建立Device来保存设备数据.</li>\n<li>搜索端用CountDownLatch来通知监听器该请求已成功.</li>\n<li>搜索端和客户端共用一个MessageCreator类来解析互传的消息.</li>\n<li>DatapramSocket是监听端口,DatapramPacket是封装/拆封报文.</li>\n</ol>\n<h5><span id=\"解析信息代码\">解析信息代码</span></h5><pre><code>import org.omg.CORBA.INTERNAL;\n\npublic class MessageCreator{\n    private static final String SN_HEADER = &quot;收到暗号,我是(SN): &quot;;\n    private static final String PORT_HEADER=&quot;这是暗号,请回电端口(Port)&quot;;\n\n    public static String buildWithPort(int port){\n        return PORT_HEADER+port;\n    }\n\n    public static int parsePort(String data){\n        if(data.startsWith(PORT_HEADER)){\n            return Integer.parseInt(data.substring(PORT_HEADER.length()));\n        }\n        return -1;\n    }\n\n    public static String buildWithSN(String SN){\n        return SN_HEADER+SN;\n    }\n\n    public static String parseSN(String data){\n        if(data.startsWith(SN_HEADER)){\n            return data.substring(PORT_HEADER.length());\n        }\n        return null;\n    }\n}</code></pre><h5><span id=\"服务提供端代码\">服务提供端代码</span></h5><pre><code>import javax.xml.crypto.Data;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.util.UUID;\n\n/*\n UDP 服务提供方\n */\npublic class UDPProvider {\n    public static void main(String[] args)throws IOException {\n        //生成一份唯一标识\n        String sn= UUID.randomUUID().toString();\n        //开启监听\n        Provider provider=new Provider(sn);\n        provider.start();\n\n        //本地读取任意键盘信息后可以退出\n        System.in.read();\n        provider.exit();\n    }\n\n    private static class Provider extends Thread{\n        private final String sn;\n        private boolean done=false;\n        private DatagramSocket ds=null;\n        public Provider(String sn){\n            super();\n            this.sn=sn;\n        }\n\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;Provider Started.&quot;);\n            try {\n                //作为接受者,制定一个端口用于监听数据接收\n                ds = new DatagramSocket(20000);\n\n                while (!done) {\n                    //构建接收实体\n                    final byte[] buf = new byte[512];\n                    DatagramPacket receivePack = new DatagramPacket(buf, buf.length);\n\n                    //接收\n                    ds.receive(receivePack);\n\n                    //打印接收到的信息与发送者的信息\n                    //发送端ip地址\n                    String ip = receivePack.getAddress().getHostAddress();\n                    int port = receivePack.getPort();\n                    int dataLen = receivePack.getLength();\n                    String data = new String(receivePack.getData(), 0, dataLen);\n                    System.out.println(&quot;UDPProvider receive from ip:&quot; + ip + &quot;\\tport:&quot; + port + &quot;\\tdata:&quot; + data);\n\n                    //解析回送端口号\n                    int responsePort = MessageCreator.parsePort(data);\n                    if(responsePort !=-1) {\n                        //构建一份回送数据\n                        String responseData = MessageCreator.buildWithSN(sn);\n                        byte[] responseDataBytes = responseData.getBytes();\n                        //直接根据发送者构建一份回送信息,发送到指定Port上去,并附上口令sn\n                        DatagramPacket responsePacket =\n                                new DatagramPacket(responseDataBytes,\n                                responseDataBytes.length,\n                                receivePack.getAddress(),\n                                responsePort);\n                        ds.send(responsePacket);\n                    }\n\n                }\n            }catch (Exception ignore){\n            }finally {\n                //done退出后阻塞异常到这里再判断一次是否需要退出\n                close();\n            }\n            //完成\n            System.out.println(&quot;UDPProvider Finished.&quot;);\n        }\n\n        private void close(){\n            if(ds!=null){\n                ds.close();\n                ds=null;\n            }\n        }\n\n        ///提供随时停止的方法\n        void exit(){\n            done=true;\n            close();\n        }\n    }\n}</code></pre><h5><span id=\"客户搜索端代码\">客户搜索端代码</span></h5><pre><code>import java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n/*\n    UDP搜索者,用于搜索服务支持方\n */\npublic class UDPSearcher {\n    //监听端口\n    private static final int LISTEN_PORT=30000;\n\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        System.out.println(&quot;UDPSearcher Started.&quot;);\n\n        Listener listener=listen();\n        sendBroadcast();\n\n        //本地读取任意键盘信息后可以退出\n        System.in.read();\n        List&lt;Device&gt; devices=listener.getDevicesAndClose();\n        for (Device device: devices) {\n            System.out.println(&quot;Device:&quot; + device.toString());\n        }\n\n        System.out.println(&quot;完成&quot;);\n    }\n\n    //用于监听请求服务端后的回发\n    private static  Listener listen() throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(1);\n        Listener listener=new Listener(LISTEN_PORT,countDownLatch);\n        listener.start();\n\n        //执行countdownlatch.countdown()后await释放\n        countDownLatch.await();\n        return listener;\n    }\n\n    //广播\n    private static void sendBroadcast() throws IOException {\n        System.out.println(&quot;UDPSearcher sendBroadcast Started.&quot;);\n\n        //作为搜索方,系统直接分配端口\n        DatagramSocket ds=new DatagramSocket();\n\n        //构建一份请求数据\n        String requestData=MessageCreator.buildWithPort(LISTEN_PORT);\n        byte[] requestDataBytes=requestData.getBytes();\n        //直接根据构建一份请求信息\n        DatagramPacket requestPacket= new DatagramPacket(requestDataBytes,\n                requestDataBytes.length);\n        requestPacket.setAddress(InetAddress.getByName(&quot;255.255.255.255&quot;));\n        requestPacket.setPort(20000);\n\n        ds.send(requestPacket);\n        ds.close();\n        System.out.println(&quot;发送已完成.&quot;);\n    }\n\n    public static class Device{\n        ///必须要\n        final int port;\n        final String ip;\n        final String sn;\n        public Device(int port, String ip, String sn) {\n            this.port = port;\n            this.ip = ip;\n            this.sn = sn;\n        }\n\n        @Override\n        public String toString() {\n            return &quot;Device{&quot; +\n                    &quot;port=&quot; + port +\n                    &quot;, ip=&apos;&quot; + ip + &apos;\\&apos;&apos; +\n                    &quot;, sn=&apos;&quot; + sn + &apos;\\&apos;&apos; +\n                    &apos;}&apos;;\n        }\n    }\n\n    private static class Listener extends Thread{\n        private final int listenPort;\n        //用CountDownLatch通知外部已启动\n        private final CountDownLatch countDownLatch;\n        private final List&lt;Device&gt; devices=new ArrayList&lt;&gt;();\n        private boolean done=false;\n        private DatagramSocket ds=null;\n\n        public Listener(int listenPort,CountDownLatch countDownLatch){\n            super();\n            this.listenPort=listenPort;\n            this.countDownLatch=countDownLatch;\n        }\n        @Override\n        public void run(){\n            super.run();\n\n            //通知已启动\n            countDownLatch.countDown();\n            try{\n                //监听端口\n                ds=new DatagramSocket(listenPort);\n                while(!done) {\n                    //构建接收实体\n                    final byte[] buf = new byte[512];\n                    DatagramPacket receivePack = new DatagramPacket(buf, buf.length);\n\n                    //接收\n                    ds.receive(receivePack);\n\n                    //打印接收到的信息与发送者的信息\n                    //发送端ip地址\n                    String ip = receivePack.getAddress().getHostAddress();\n                    int port = receivePack.getPort();\n                    int dataLen = receivePack.getLength();\n                    String data = new String(receivePack.getData(), 0, dataLen);\n                    System.out.println(&quot;UDPSearcher receive from ip:&quot; + ip + &quot;\\tport:&quot; + port + &quot;\\tdata:&quot; + data);\n\n                    String sn=MessageCreator.parseSN(data);\n                    if(sn!=null){\n                        Device device=new Device(port,ip,sn);\n                        devices.add(device);\n                    }\n                }\n            }catch(Exception ignore){\n\n            }finally {\n                close();\n            }\n            System.out.println(&quot;UDPSearcher listener finished&quot;);\n        }\n\n        private void close(){\n            if(ds!=null){\n                ds.close();\n                ds=null;\n            }\n        }\n\n        List&lt;Device&gt; getDevicesAndClose(){\n            done=true;\n            close();\n            return devices;\n        }\n    }\n\n}</code></pre><h3><span id=\"tcp\">TCP</span></h3><h4><span id=\"介绍\">介绍</span></h4><p>tcp是传输控制协议,是一种面向连接,可靠的,基于字节流的传输曾通信协议. 区别于UDP: udp基于数字报,不可靠. 相同: 完成第四层所指定的职责.</p>\n<h4><span id=\"机制\">机制</span></h4><ol>\n<li>三次握手、四次挥手</li>\n<li>具有校验机制、可靠、数据传输稳定</li>\n<li>建立连接后,传递字节流数据</li>\n</ol>\n<h4><span id=\"tcp能做什么\">TCP能做什么?</span></h4><ol>\n<li>聊天消息传输、推送</li>\n<li>单人语音、视频聊天(信息要求完全准确用tcp)</li>\n<li>几乎udp可以做的tcp都可以做,只不过需要考虑复杂性和心跟那个问题</li>\n<li>限制: 无法进行广播,多播</li>\n</ol>\n<h4><span id=\"tcp核心api\">TCP核心API</span></h4><p>API</p>\n<p>功能</p>\n<p>socket()</p>\n<p>创建一个socket</p>\n<p>bind()</p>\n<p>绑定一个Socket到一个本地地址和端口上</p>\n<p>connect()</p>\n<p>连接到远程套接字</p>\n<p>accept()</p>\n<p>接受一个新的连接,调用该方法时,服务端会进入阻塞状态,直到有一个套接字到达</p>\n<p>write()</p>\n<p>把数据写入到Socket输出流</p>\n<p>read()</p>\n<p>从Socket输入流中读取数据</p>\n<h4><span id=\"创建流程\">创建流程</span></h4><h5><span id=\"客户端\">客户端</span></h5><ol>\n<li>创建 Socket</li>\n<li>bind本地套接字(占用一个端口)</li>\n<li>connect远程套接字(成功)</li>\n<li>客户端与远程套接字通信</li>\n</ol>\n<h5><span id=\"服务端\">服务端</span></h5><ol>\n<li>创建 SeverSocket</li>\n<li>bind本地套接字(占用一个端口)</li>\n<li>connect客户端套接字(成功)</li>\n<li>客户端与远程套接字通信</li>\n</ol>\n<h4><span id=\"socket也可以创建进程与进程间通信\">Socket也可以创建进程与进程间通信</span></h4><h4><span id=\"三次握手\">三次握手</span></h4><ol>\n<li>客户端发起的(SYN 连接请求)</li>\n<li>服务端回送ACK</li>\n<li>匹配成功,客户端在发送给服务端一个ACK</li>\n</ol>\n<h4><span id=\"四次挥手断开\">四次挥手(断开)</span></h4><p>FIN是申请结束字段. 1. 客户端发送: FIN=1,seq=u 2. 服务端发送: ACK=1,seq=v,ack=u+1 这之后因为可能会有一些信息还未发送完毕,所以需要发送完再进行断开确认.</p>\n<ol start=\"3\">\n<li>服务端发送: FIN=1,ACK=1,seq=w,ack=u+1</li>\n<li>客户端发送: ACK=1,seq=u+1,ack=w+1</li>\n</ol>\n<h4><span id=\"前置知识\">前置知识</span></h4><h5><span id=\"客户端\">客户端</span></h5><h6><span id=\"nagle算法\">Nagle算法</span></h6><p>当我们在发送报文时,如果报文是成块的发送,那么对报文的利用率将会很高,但如果是一小段一小段的发送的话,对于当前tcp的链接将会是很低效的,因为每次都需要额外处理的开销. 而Nagle算法就是为了解决小包的问题.</p>\n<blockquote>\n<p>其核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送</p>\n</blockquote>\n<h6><span id=\"心跳包\">心跳包</span></h6><blockquote>\n<p>人活着的证明之一是心跳依然在跳动,心跳包就是用于判断在长时间无活动的前提下连接是否已断开.</p>\n<blockquote>\n<p>socket.setKeepAlive(true)</p>\n</blockquote>\n</blockquote>\n<h6><span id=\"连接关闭缓冲\">连接关闭缓冲</span></h6><blockquote>\n<p>在两端连接执行关闭操作前必须要保证两端数据已经传输完成. 如果没有传输完成就关闭大概率会导致数据异常,而socket库对于关闭有三种方式.（内置于socket.setSoLinger()函数中）</p>\n<blockquote>\n<ol>\n<li>socket.setSoLinger(false,0) 关闭时立即返回,底层系统接管出输出流,将缓冲区内数据发送完全.</li>\n<li>true,0:关闭时立即返回,抛弃缓冲区数据,直接发送RST结束命令到对方</li>\n<li>true,200: 关闭后等待200ms,然后按第二种方式处理.</li>\n</ol>\n</blockquote>\n</blockquote>\n<h6><span id=\"紧急数据内敛\">紧急数据内敛</span></h6><blockquote>\n<p>将某一块数据的优先级提至最高,一般不需要</p>\n<blockquote>\n<p>socket.setOOBInline(true) (默认false)</p>\n</blockquote>\n</blockquote>\n<h6><span id=\"设置缓冲区大小\">设置缓冲区大小</span></h6><blockquote>\n<p>1024是1kb,1024*1024是1mb</p>\n<blockquote>\n<p>加快速度可以用 data &lt;&lt; 10 代表1kb</p>\n<blockquote>\n<p>socket.setReceiveBufferSize(64 * 1024 * 1024); 接受缓冲区 socket.setSendBufferSize(64 * 1024 * 1024); 发送缓冲区</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h6><span id=\"设置性能参数\">设置性能参数</span></h6><blockquote>\n<p>短链接，延迟，带宽的相对重要性</p>\n<blockquote>\n<p>socket.setPerformancePreferences(1, 1, 0); 其中这三个参数代表的是权重占比,无实际意义.</p>\n</blockquote>\n</blockquote>\n<h6><span id=\"几种不同的套接字参数\">几种不同的套接字参数</span></h6><pre><code>// 无代理模式，等效于空构造函数\nSocket socket = new Socket(Proxy.NO_PROXY);\n\n// 新建一份具有HTTP代理的套接字，传输数据将通过www.baidu.com:8080端口转发\nProxy proxy = new Proxy(Proxy.Type.HTTP,\n        new InetSocketAddress(Inet4Address.getByName(&quot;www.baidu.com&quot;), 8800));\nsocket = new Socket(proxy);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上\nsocket = new Socket(&quot;localhost&quot;, PORT);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上\nsocket = new Socket(Inet4Address.getLocalHost(), PORT);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上，并且绑定到本地20001端口上\nsocket = new Socket(&quot;localhost&quot;, PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\nsocket = new Socket(Inet4Address.getLocalHost(), PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n\nSocket socket = new Socket();\n// 绑定到本地20001端口\nsocket.bind(new InetSocketAddress(Inet4Address.getLocalHost(), LOCAL_PORT));</code></pre><h6><span id=\"连接数据的流式操作\">连接数据的流式操作</span></h6><blockquote>\n<p>我仅用一串代码表示,但经过事实证明,各类型数据在ByteBuffer这个NIO库下只能传输一个数据,多了的话就会出现数据紊乱.除非用字符串传送.</p>\n</blockquote>\n<pre><code>//得到Socket输出流,并转换为打印流\n   OutputStream outputStream=client.getOutputStream();\n\n   //得到Socket输入流,并用ByteBuffer包裹起来\n   InputStream inputStream=client.getInputStream();\n   byte[] buffer=new byte[256];\n   ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n   // byte\n   byteBuffer.put((byte) 126);\n\n   // char\n   char c = &apos;a&apos;;\n   byteBuffer.putChar(c);\n\n   // int\n   int i = 2323123;\n   byteBuffer.putInt(i);\n\n   // bool\n   boolean b = true;\n   byteBuffer.put(b ? (byte) 1 : (byte) 0);\n\n   // Long\n   long l = 298789739;\n   byteBuffer.putLong(l);\n\n\n   // float\n   float f = 12.345f;\n   byteBuffer.putFloat(f);\n\n\n   // double\n   double d = 13.31241248782973;\n   byteBuffer.putDouble(d);\n\n   // String\n   String str = &quot;Hello你好！&quot;;\n   byteBuffer.put(str.getBytes());\n\n   //发送到服务器\n   outputStream.write(buffer,0,byteBuffer.position()+1);\n\n   //接受服务器返回\n   int read=inputStream.read(buffer);\n   System.out.println(&quot;收到数量: &quot;+read);\n\n   //资源释放\n   outputStream.close();\n   inputStream.close();</code></pre><h5><span id=\"服务端\">服务端</span></h5><h6><span id=\"serversocket\">ServerSocket</span></h6><blockquote>\n<p>对于服务端的Socket,为何要用ServerSocket?因为不一定只有一个客户端啊,课本部分会有一大堆Socket传过来啊,所以ServerSocket其实是用来处理多个Socket用的，最后仍然要回归到处理Socket</p>\n</blockquote>\n<h6><span id=\"serversocket-与-socket的关系\">ServerSocket 与 Socket的关系</span></h6><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/12/ServerSocket%E4%B8%8ESocket.png\" alt></p>\n<h6><span id=\"serversocket配置\">ServerSocket配置</span></h6><pre><code>ServerSocket serverSocket=new ServerSocket();\n// 绑定到本地端口20000上，并且设置当前可允许等待链接的队列为50个\n//serverSocket = new ServerSocket(PORT);\n\n// 等效于上面的方案，队列设置为50个\n//serverSocket = new ServerSocket(PORT, 50);\n\n// 与上面等同\n// serverSocket = new ServerSocket(PORT, 50, Inet4Address.getLocalHost());\n// 是否复用未完全关闭的地址端口\nserverSocket.setReuseAddress(true);\n\n// 等效Socket#setReceiveBufferSize\nserverSocket.setReceiveBufferSize(64 * 1024 * 1024);\n\n// 设置serverSocket#accept超时时间\n// serverSocket.setSoTimeout(2000);\n\n// 设置性能参数：短链接，延迟，带宽的相对重要性\nserverSocket.setPerformancePreferences(1, 1, 1);</code></pre><h4><span id=\"服务端代码\">服务端代码</span></h4><pre><code>import org.omg.CORBA.PRIVATE_MEMBER;\n\nimport javax.print.DocFlavor;\nimport java.io.*;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.sql.SQLTransactionRollbackException;\n\npublic class Server {\n    private static final int PORT=20000;\n    public static void main(String[] args)throws IOException {\n        //如果不指定端口号和ip地址,默认是本地\n        ServerSocket server=createServerSocket();\n\n        initServerSocket(server);\n\n        server.bind(new InetSocketAddress(Inet4Address.getLocalHost(),PORT),50);\n\n        System.out.println(&quot;服务器准备就绪~&quot;);\n        System.out.println(&quot;服务器信息: &quot;+server.getInetAddress()+&quot; P:&quot;+server.getLocalPort() );\n\n        //等待客户端连接\n        while(true) {\n            //得到客户端\n            Socket client = server.accept();\n            //客户端构建异步线程\n            ClientHandler clientHandler = new ClientHandler(client);\n            //启动线程\n            clientHandler.start();\n        }\n    }\n\n    private static ServerSocket createServerSocket() throws IOException {\n        ServerSocket serverSocket=new ServerSocket();\n        // 绑定到本地端口20000上，并且设置当前可允许等待链接的队列为50个\n        //serverSocket = new ServerSocket(PORT);\n\n        // 等效于上面的方案，队列设置为50个\n        //serverSocket = new ServerSocket(PORT, 50);\n\n        // 与上面等同\n        // serverSocket = new ServerSocket(PORT, 50, Inet4Address.getLocalHost());\n        return serverSocket;\n    }\n\n    private static void initServerSocket(ServerSocket serverSocket)throws IOException{\n        //是否复用未完全关闭的地址端\n        serverSocket.setReuseAddress(true);\n\n        // 等效Socket#setReceiveBufferSize\n        serverSocket.setReceiveBufferSize(64 * 1024 * 1024);\n\n        // 设置serverSocket#accept超时时间\n        // serverSocket.setSoTimeout(2000);\n\n        // 设置性能参数：短链接，延迟，带宽的相对重要性\n        serverSocket.setPerformancePreferences(1, 1, 1);\n    }\n\n    //处理多个请求时要用异步\n    private static class ClientHandler extends Thread{\n        private Socket socket;\n        private boolean flag=true;\n\n        ClientHandler(Socket socket){\n            this.socket=socket;\n        }\n\n        //运行时运行run\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;新客户端连接: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n            try{\n                //得到套接字流\n                OutputStream outputStream=socket.getOutputStream();\n                InputStream inputStream=socket.getInputStream();\n                byte[] buffer=new byte[256];\n                int readCount=inputStream.read(buffer);\n                ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n                // byte\n                byte be = byteBuffer.get();\n\n                // char\n                char c = byteBuffer.getChar();\n\n                // int\n                int i = byteBuffer.getInt();\n\n                // bool\n                boolean b = byteBuffer.get() == 1;\n\n                // Long\n                long l = byteBuffer.getLong();\n\n                // float\n                float f = byteBuffer.getFloat();\n\n                // double\n                double d = byteBuffer.getDouble();\n\n                // String\n                int pos = byteBuffer.position();\n\n                String str = new String(buffer, pos, readCount - pos - 1);\n\n                System.out.println(&quot;收到数量：&quot; + readCount + &quot; 数据：&quot;\n                        + be + &quot;\\n&quot;\n                        + c + &quot;\\n&quot;\n                        + i + &quot;\\n&quot;\n                        + b + &quot;\\n&quot;\n                        + l + &quot;\\n&quot;\n                        + f + &quot;\\n&quot;\n                        + d + &quot;\\n&quot;\n                        + str + &quot;\\n&quot;);\n                System.out.println(buffer.toString());\n\n                outputStream.write(buffer, 0, readCount);\n                outputStream.close();\n                inputStream.close();\n            }catch(Exception e){\n                System.out.println(&quot;连接异常断开&quot;);\n            }finally {\n                //连接关闭(每个线程)\n                try{\n                    socket.close();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(&quot;客户端已退出: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n        }\n    }\n}</code></pre><h4><span id=\"客户端代码\">客户端代码</span></h4><pre><code>import java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\n\npublic class Client {\n\n    private static final int PORT=20000;\n    private static final int LOCAL_PORT=20001;\n\n    public static void main(String[] args)throws IOException {\n        Socket socket=createSocket();\n\n        initSocket(socket);\n\n        //连接本地,端口20000,超时时间3000ms\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),PORT),3000);\n        System.out.println(&quot;已发起服务器连接,并进入后续流程~&quot;);\n        System.out.println(&quot;客户端信息: &quot;+socket.getLocalAddress()+&quot; P:&quot;+socket.getLocalPort());\n        System.out.println(&quot;服务器信息: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort() );\n\n        try{\n            //发送接收数据\n            todo(socket);\n        }catch(Exception e){\n            System.out.println(&quot;异常关闭&quot;);\n        }\n        //释放资源\n        socket.close();\n        System.out.println(&quot;客户端已关闭&quot;);\n    }\n\n    private static Socket createSocket() throws IOException{\n        /*\n        // 无代理模式，等效于空构造函数\n        Socket socket = new Socket(Proxy.NO_PROXY);\n\n        // 新建一份具有HTTP代理的套接字，传输数据将通过www.baidu.com:8080端口转发\n        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n                new InetSocketAddress(Inet4Address.getByName(&quot;www.baidu.com&quot;), 8800));\n        socket = new Socket(proxy);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上\n        socket = new Socket(&quot;localhost&quot;, PORT);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上\n        socket = new Socket(Inet4Address.getLocalHost(), PORT);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上，并且绑定到本地20001端口上\n        socket = new Socket(&quot;localhost&quot;, PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n        socket = new Socket(Inet4Address.getLocalHost(), PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n        */\n        Socket socket=new Socket();\n        //绑定到本地20001端口\n        socket.bind(new InetSocketAddress(Inet4Address.getLocalHost(),LOCAL_PORT));\n        return socket;\n    }\n\n    private static void initSocket(Socket socket)  throws SocketException{\n        //设置读取超时时间为2秒\n        socket.setSoTimeout(2000);\n        //是否复用未完全关闭的Socket地址,对于指定build操作后的套接字有效\n        socket.setReuseAddress(true);\n        //是否需要开启Nagle算法\n        socket.setKeepAlive(true);\n        //是否需要在长时间无数据时确认是否依然连接(类似于心跳包),时间大约为2h\n        socket.setKeepAlive(true);\n\n        // 对于close关闭操作行为进行怎样的处理；默认为false，0\n        // false、0：默认情况，关闭时立即返回，底层系统接管输出流，将缓冲区内的数据发送完成\n        // true、0：关闭时立即返回，缓冲区数据抛弃，直接发送RST结束命令到对方，并无需经过2MSL等待\n        // true、200：关闭时最长阻塞200毫秒，随后按第二情况处理\n        socket.setSoLinger(true,20);\n        // 是否让紧急数据内敛，默认false；紧急数据通过 socket.sendUrgentData(1);发送\n        socket.setOOBInline(true);\n\n        // 设置接收发送缓冲器大小\n        socket.setReceiveBufferSize(64 * 1024 * 1024);\n        socket.setSendBufferSize(64 * 1024 * 1024);\n\n        // 设置性能参数：短链接，延迟，带宽的相对重要性\n        socket.setPerformancePreferences(1, 1, 0);\n\n    }\n\n    private static void todo(Socket client) throws IOException{\n        //得到Socket输出流,并转换为打印流\n        OutputStream outputStream=client.getOutputStream();\n\n        //得到Socket输入流,并用ByteBuffer包裹起来\n        InputStream inputStream=client.getInputStream();\n        byte[] buffer=new byte[256];\n        ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n        // byte\n        byteBuffer.put((byte) 126);\n\n        // char\n        char c = &apos;a&apos;;\n        byteBuffer.putChar(c);\n\n        // int\n        int J = 12138;\n        byteBuffer.putInt(J);\n\n        // bool\n        boolean b = true;\n        byteBuffer.put(b ? (byte) 1 : (byte) 0);\n\n        // Long\n        long l = 298789739;\n        byteBuffer.putLong(l);\n\n\n        // float\n        float f = 12.345f;\n        byteBuffer.putFloat(f);\n\n\n        // double\n        double d = 13.31241248782973;\n        byteBuffer.putDouble(d);\n\n        // String\n        String str = &quot;Hello你好！&quot;;\n        byteBuffer.put(str.getBytes());\n\n        //发送到服务器\n        outputStream.write(buffer,0,byteBuffer.position()+1);\n\n        //接受服务器返回\n        int read=inputStream.read(buffer);\n        System.out.println(&quot;收到数量: &quot;+read);\n\n        //资源释放\n        outputStream.close();\n        inputStream.close();\n    }\n}</code></pre><h1><span id=\"聊天室架构从0开始-2-tcpudp-实现搜索ip与端口\">聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口</span></h1><p><a href=\"be-sunshine.cn/index.php/2019/01/14/ty2/\" title=\"聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口\">聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口</a></p>\n","text":"最后更新于2019/1/1课设过程中的记录序言 - tcp与udp的族谱借助工具 - 流式读取戳-&gt;java流式读取简单tcp问题因为要求服务端是无限接收客户端的请求,所以服务端必须用线程来新建和处理请求.服务端代码import javax.print.DocFlavor;","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"tcp","slug":"Java/tcp","count":1,"path":"api/categories/Java/tcp.json"},{"name":"网络编程","slug":"Java/tcp/网络编程","count":1,"path":"api/categories/Java/tcp/网络编程.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"},{"name":"网络编程","slug":"网络编程","count":4,"path":"api/tags/网络编程.json"},{"name":"tcp","slug":"tcp","count":3,"path":"api/tags/tcp.json"}]}]}