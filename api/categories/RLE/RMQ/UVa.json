{"name":"UVa","slug":"RLE/RMQ/UVa","count":1,"postlist":[{"title":"UVa 11235","slug":"uva-11235","date":"2017-07-20T06:41:58.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/uva-11235.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Topic Link】 :point_right:<a href=\"https://vjudge.net/problem/UVA-11235\" target=\"_blank\" rel=\"noopener\">Frequent values</a> 【类别】 RMQ,游程编码 【题意】 给出一个非降序的整数数组，你的任务是对于一系列询问，回答区间内出现最多的值的次数. 【题解】 题目给的数组是非降序的.所有相等的元素都会聚集到一起。这样就可以把整个数组进行游程编码(Run Length Encoding,RLE).比如 (-1,1,1,2,2,2,4)就可以编码成(-1,1),(1,2),(2,3),(4,1),其中(a,b)表示有b个连续的a。用value[i]和count[i]分别表示第i段的数值和出现次数,num[p]、left[p]、right[p]、分别表示位置p所在段的编号和左右端点的位置.每次查询(L,R)的结果为以下三个部分的最大值:</p>\n<ol>\n<li>从L到L所在段的结束处的元素个数(right[L]-L+1)</li>\n<li>从R所在段开始到R的元素个数(R-left[R]+1)</li>\n<li>中间第num[L]+1段到第num[R]-1段的count的最大值,这一步是典型的RMQ问题,主要的时间也就花费在这里.</li>\n<li>特殊:如果L和R在同一个段中,则答案是R-L+1</li>\n</ol>\n<p>【代码】 github:</p>\n<ol>\n<li><p>:point_right:<a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch3/UVa%2011235.cpp\" target=\"_blank\" rel=\"noopener\">UVa 11235.cpp</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>#define INF 0x3f3f3f3f<br>using namespace std;<br>const int maxn=100010;<br>vector<int> cnt;<br>int num[maxn],le[maxn],ri[maxn];<br>int dp[maxn][20];<br>int N,Q;</int></p>\n<p>void RMQ_init(){</p>\n<pre><code>int n=cnt.size();\nfor(int i=0;i&lt;n;++i) dp[i][0]=-cnt[i];\n///2*(2^(j-1))=2^j\n///dp(i,j)表示从i开始,长度为2^j的一段元素中的最小值.\nfor(int j=1;(1&lt;&lt;j)&lt;=n;++j)\n    for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i)\n        dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);</code></pre><p>}</p>\n<p>int RMQ(int L,int R){</p>\n<pre><code>if(L&gt;R) return 0;\nint k=0;\n///如果2^(k+1)&lt;=R-L+1,那么k还可以加一\nwhile((1&lt;&lt;(k+1)&lt;=R-L+1))k++;\nreturn min(dp[L][k],dp[R-(1&lt;&lt;k)+1][k]);</code></pre><p>}</p>\n<p>int main(){</p>\n<pre><code>while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n    scanf(&quot;%d&quot;,&amp;Q);\n    cnt.clear();\n    int pre=INF,ct=0;\n    for(int i=0;i&lt;N;++i){\n        int numpy;\n        scanf(&quot;%d&quot;,&amp;numpy);\n        if(numpy!=pre){\n            pre=numpy;\n            ct++;\n            num[i]=ct-1;\n            le[i]=i;\n            if(i&gt;=1)\n                for(int j=le[i-1];j&lt;i;++j)\n                    ri[j]=i-1;\n            cnt.push_back(1);\n        }else{\n            num[i]=num[i-1];\n            le[i]=le[i-1];\n            cnt[ct-1]++;\n        }\n        if(i==N-1)\n            for(int j=le[i];j&lt;=i;++j)\n                ri[j]=i;\n    }</code></pre><p>/**</p>\n<pre><code>for(int i=0;i&lt;cnt.size();i++)\n    cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;cnt[i]&lt;&lt;&quot; &quot;;\ncout&lt;&lt;endl;\nfor(int i=0;i&lt;N;i++)\n    printf(&quot;%d(left,right,num):%d %d %d\\n&quot;,i,le[i],ri[i],num[i]);</code></pre><p>**/</p>\n<pre><code>    RMQ_init();\n    for(int i=0;i&lt;Q;++i){\n        int a,b;\n        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n        if(num[--a]==num[--b])\n            printf(&quot;%d\\n&quot;,b-a+1);\n        else\n            printf(&quot;%d\\n&quot;,max(max((ri[a]-a+1),-RMQ(num[a]+1,num[b]-1)),(b-le[b]+1)));\n    }\n}\nreturn 0;</code></pre><p>}</p>\n</li>\n</ol>\n","text":"【Topic Link】 :point_right:Frequent values 【类别】 RMQ,游程编码 【题意】 给出一个非降序的整数数组，你的任务是对于一系列询问，回答区间内出现最多的值的次数. 【题解】 题目给的数组是非降序的.所有相等的元素都会聚集到一起。这样就可以","link":"","raw":null,"photos":[],"categories":[{"name":"RLE","slug":"RLE","count":1,"path":"api/categories/RLE.json"},{"name":"RMQ","slug":"RLE/RMQ","count":1,"path":"api/categories/RLE/RMQ.json"},{"name":"UVa","slug":"RLE/RMQ/UVa","count":1,"path":"api/categories/RLE/RMQ/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"RLE","slug":"RLE","count":1,"path":"api/tags/RLE.json"},{"name":"RMQ","slug":"RMQ","count":1,"path":"api/tags/RMQ.json"}]}]}