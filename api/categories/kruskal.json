{"name":"kruskal","slug":"kruskal","count":1,"postlist":[{"title":"POJ 3723","slug":"poj-3723","date":"2017-04-14T02:57:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3723.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>并查集优化kruskal</strong> <strong>【Tip】</strong> <strong>并查集使得可以判断任意两点是否可归溯于同一点,藉此来判断若链接两点是否会形成一个环.</strong> <strong>这道题的输入是两个人以及两个人之间的亲密关系,征募某个人的花费为10000-(已征募人中亲密关系和自己的最大值).</strong> <strong>这里我们在每征募某个人a时,若使用了a,b的关系,就连一条a,b的边。</strong> <strong>如果这个图中存在圈,则一定会出现矛盾(谁是第一个被征募的？).</strong> <strong>所以这个图一定是森林.</strong> <strong>把人看做顶点.关系看做边,则这个问题就可以转化为求解无向图中的最大权森林问题(即亲密度之和最大),最大权森林问题可以通过把所有边权取反来求最小生成树.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>using namespace std;</strong> <strong>const int MAX_N=60000;</strong> <strong>struct edge{</strong> <em>*    int u,v,cost;** <strong>};</strong> <strong>bool comp(const edge&amp; e1,const edge&amp; e2){</strong> **    return e1.cost&lt;e2.cost;** <strong>}</strong> <strong>edge es[MAX_N];</strong> <strong>int V,E;//顶点数和边数</strong> <strong>//并查集</strong> <strong>int par[MAX_N];//父亲</strong> <strong>int rank[MAX_N];//树的高度</strong> <strong>void init_union_find(int n){</strong> **    for(int i=0;i&lt;n;++i){** **        par[i]=i;** **        rank[i]=0;** **    }** <strong>}</strong> <strong>//查询树的根</strong> <strong>int find(int x){</strong> **    if(par[x]==x){** **        return x;** **    }else{** **        return par[x]=find(par[x]);** **    }** <strong>}</strong> <strong>//合并x和y所属集合</strong> <strong>void unite(int x,int y){</strong> **    x=find(x);** **    y=find(y);** **    if(x==y) return;** **    if(rank[x]&lt;rank[y]){** **        par[x]=y;** **    }else{** **        par[y]=x;** **        if(rank[x]==rank[y]) rank[x]++;** **    }** <strong>}</strong> <strong>//判断x和y是否属于同一个集合</strong> <strong>bool same(int x,int y){</strong> **    return find(x)==find(y);** <strong>}</strong> <strong>int kruskal(){</strong> **    sort(es,es+E,comp);** **    int res=0;** **    init_union_find(V);** **    for(int i=0;i&lt;E;++i){** **        edge e=es[i];** **        if(!same(e.u,e.v)){** **            unite(e.u,e.v);** **            res+=e.cost;** **        }** **    }** **    return res;** <strong>}</strong> <strong>int main(){</strong> **    int N;** **    scanf(“%d”,&amp;N);** **    while(N–){** **        int B,G,R;** **        scanf(“%d%d%d”,&amp;G,&amp;B,&amp;R);** **        V=G+B;** **        E=R;** **        for(int i=0;i&lt;R;++i){** **            int a,b,c;** **            scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **            es[i]=(edge){a,G+b,-c};** **        }** **        printf(“%d\\n”,10000</em>(V)+kruskal());** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 并查集优化kruskal 【Tip】 并查集使得可以判断任意两点是否可归溯于同一点,藉此来判断若链接两点是否会形成一个环. 这道题的输入是两个人以及两个人之间的亲密关系,征募某个人的花费为10000-(已征募人中亲密关系和自己的最大值). 这里我们在每征募某个人a时,若","link":"","raw":null,"photos":[],"categories":[{"name":"kruskal","slug":"kruskal","count":1,"path":"api/categories/kruskal.json"},{"name":"POJ","slug":"kruskal/POJ","count":1,"path":"api/categories/kruskal/POJ.json"},{"name":"并查集","slug":"kruskal/POJ/并查集","count":1,"path":"api/categories/kruskal/POJ/并查集.json"}],"tags":[{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"}]}]}