{"name":"未分类","slug":"未分类","count":16,"postlist":[{"title":"2322","slug":"2322","date":"2019-01-10T06:21:34.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/2322.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>终于狠下心花了181买了Gamemaker studio2!!!(little (⊙︿⊙) little (<em>^▽^</em>))</p>\n</blockquote>\n<p>:yum: :yum: :yum:</p>\n","text":"终于狠下心花了181买了Gamemaker studio2!!!(little (⊙︿⊙) little (^▽^)):yum: :yum: :yum:","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"Android 学习 使用限定符","slug":"android-limited","date":"2017-03-22T07:38:52.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/android-limited.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/%E9%99%90%E5%AE%9A%E7%AC%A6.png","content":"<p><strong>【reference】</strong> <strong>《第一行代码-第二版》 GuoLin</strong>   <strong>【目标】</strong> <strong>在不同分辨率下显示不同的Layout</strong>   <strong>【常见限定符】</strong> <strong><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/限定符.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/%E9%99%90%E5%AE%9A%E7%AC%A6.png\" alt></a></strong> <strong>【最小宽度限定符/Smallest-width Qualifier】</strong> <strong>例如:在res目录下新建layout-sw600dp文件夹=&gt;屏幕宽度大于600dp的设备运行时调用.</strong></p>\n","text":"【reference】 《第一行代码-第二版》 GuoLin   【目标】 在不同分辨率下显示不同的Layout   【常见限定符】  [Figure]  【最小宽度限定符/Smallest-width Qualifier】 例如:在res目录下新建layout-sw600dp文","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"三角函数+公式推导+部分C++函数","slug":"asadafas","date":"2018-03-18T02:16:49.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/asadafas.json","excerpt":"","keywords":null,"cover":null,"content":"<pre><code>两角和的公式\n\n  sin(A+B)=sinAcosB+cosAsinB sin(A-B)=sinAcosB-sinBcosA\n\n  cos(A+B)=cosAcosB-sinAsinB cos(A-B)=cosAcosB+sinAsinB\n\n  tan(A+B)=(tanA+tanB)/(1-tanAtanB) tan(A-B)=(tanA-tanB)/(1+tanAtanB)\n\n  cot(A+B)=(cotAcotB-1)/(cotB+cotA) cot(A-B)=(cotAcotB+1)/(cotB-cotA)\n\n  倍角的公式\n\n  tan2A=2tanA/(1-tan2A) cot2A=(cot2A-1)/2cota\n\n  cos2a=cos2a-sin2a=2cos2a-1=1-2sin2a\n\n  sinα+sin(α+2π/n)+sin(α+2π*2/n)+sin(α+2π*3/n)+……+sin[α+2π*(n-1)/n]=0\n\n  cosα+cos(α+2π/n)+cos(α+2π*2/n)+cos(α+2π*3/n)+……+cos[α+2π*(n-1)/n]=0 以及\n\n  sin^2(α)+sin^2(α-2π/3)+sin^2(α+2π/3)=3/2\n\n  tanAtanBtan(A+B)+tanA+tanB-tan(A+B)=0\n\n  四倍角之公式：\n\n  sin4A=-4*(cosA*sinA*(2*sinA^2-1))\n\n  cos4A=1+(-8*cosA^2+8*cosA^4)\n\n  tan4A=(4*tanA-4*tanA^3)/(1-6*tanA^2+tanA^4)\n\n  五倍将式：\n\n  sin5A=16sinA^5-20sinA^3+5sinA\n\n  cos5A=16cosA^5-20cosA^3+5cosA\n\n  tan5A=tanA*(5-10*tanA^2+tanA^4)/(1-10*tanA^2+5*tanA^4)\n\n  六倍将式：\n\n  sin6A=2*(cosA*sinA*(2*sinA+1)*(2*sinA-1)*(-3+4*sinA^2))\n\n  cos6A=((-1+2*cosA^2)*(16*cosA^4-16*cosA^2+1))\n\n  tan6A=(-6*tanA+20*tanA^3-6*tanA^5)/(-1+15*tanA^2-15*tanA^4+tanA^6)\n\n  七倍将式：\n\n  sin7A=-(sinA*(56*sinA^2-112*sinA^4-7+64*sinA^6))\n\n  cos7A=(cosA*(56*cosA^2-112*cosA^4+64*cosA^6-7))\n\n  tan7A=tanA*(-7+35*tanA^2-21*tanA^4+tanA^6)/(-1+21*tanA^2-35*tanA^4+7*tanA^6)\n\n  八倍将式：\n\n  sin8A=-8*(cosA*sinA*(2*sinA^2-1)*(-8*sinA^2+8*sinA^4+1))\n\n  cos8A=1+(160*cosA^4-256*cosA^6+128*cosA^8-32*cosA^2)\n\n  tan8A=-8*tanA*(-1+7*tanA^2-7*tanA^4+tanA^6)/(1-28*tanA^2+70*tanA^4-28*tanA^6+tanA^8)\n\n  九倍将式：\n\n  sin9A=(sinA*(-3+4*sinA^2)*(64*sinA^6-96*sinA^4+36*sinA^2-3))\n\n  cos9A=(cosA*(-3+4*cosA^2)*(64*cosA^6-96*cosA^4+36*cosA^2-3))\n\n  tan9A=tanA*(9-84*tanA^2+126*tanA^4-36*tanA^6+tanA^8)/(1-36*tanA^2+126*tanA^4-84*tanA^6+9*tanA^8)\n\n  十倍将式：\n\n  sin10A=2*(cosA*sinA*(4*sinA^2+2*sinA-1)*(4*sinA^2-2*sinA-1)*(-20*sinA^2+5+16*sinA^4))\n\n  cos10A=((-1+2*cosA^2)*(256*cosA^8-512*cosA^6+304*cosA^4-48*cosA^2+1))\n\n  tan10A=-2*tanA*(5-60*tanA^2+126*tanA^4-60*tanA^6+5*tanA^8)/(-1+45*tanA^2-210*tanA^4+210*tanA^6-45*tanA^8+tanA^10)\n\n  ·万能公式：\n\n  sinα=2tan(α/2)/[1+tan^2(α/2)]\n\n  cosα=[1-tan^2(α/2)]/[1+tan^2(α/2)]\n\n  tanα=2tan(α/2)/[1-tan^2(α/2)]\n\n  半将式\n\n  sin(A/2)=√((1-cosA)/2) sin(A/2)=-√((1-cosA)/2)\n\n  cos(A/2)=√((1+cosA)/2) cos(A/2)=-√((1+cosA)/2)\n\n  tan(A/2)=√((1-cosA)/((1+cosA)) tan(A/2)=-√((1-cosA)/((1+cosA))\n\n  cot(A/2)=√((1+cosA)/((1-cosA)) cot(A/2)=-√((1+cosA)/((1-cosA))\n\n  和差化积\n\n  2sinAcosB=sin(A+B)+sin(A-B) 2cosAsinB=sin(A+B)-sin(A-B)\n\n  2cosAcosB=cos(A+B)-sin(A-B) -2sinAsinB=cos(A+B)-cos(A-B)\n\n  sinA+sinB=2sin((A+B)/2)cos((A-B)/2 cosA+cosB=2cos((A+B)/2)sin((A-B)/2)\n\n  tanA+tanB=sin(A+B)/cosAcosB tanA-tanB=sin(A-B)/cosAcosB\n\n  cotA+cotBsin(A+B)/sinAsinB -cotA+cotBsin(A+B)/sinAsinB\n\n  某些数列前n项和\n\n  1+2+3+4+5+6+7+8+9+…+n=n(n+1)/2 1+3+5+7+9+11+13+15+…+(2n-1)=n2\n\n  2+4+6+8+10+12+14+…+(2n)=n(n+1) 1^2+2^2+3^2+4^2+5^2+6^2+7^2+8^2+…+n^2=n(n+1)(2n+1)/6\n\n  1^3+2^3+3^3+4^3+5^3+6^3+…n^3=(n(n+1)/2)^2 1*2+2*3+3*4+4*5+5*6+6*7+…+n(n+1)=n(n+1)(n+2)/3\n\n  正弦定理 a/sinA=b/sinB=c/sinC=2R 注： 其中 R 表示三角形的外接圆半径\n\n  余弦定理 b2=a2+c2-2accosB 注：角B是边a和边c的夹角\n\n  乘法与因式分 a2-b2=(a+b)(a-b) a3+b3=(a+b)(a2-ab+b2) a3-b3=(a-b(a2+ab+b2)\n\n  三角不等式 |a+b|≤|a|+|b| |a-b|≤|a|+|b| |a|≤b&lt;=&gt;-b≤a≤b\n\n  |a-b|≥|a|-|b| -|a|≤a≤|a|</code></pre><h1 id=\"推论\"><a href=\"#推论\" class=\"headerlink\" title=\"推论\"></a>推论</h1><pre><code>三角形ABC中: tan(a/2)tan(b/2)+tan(b/2)tan(c/2)+tan(a/2)tan(c/2)=1\n\nS(ABC)=[1/2(a+b+c)]r(△ABC内接圆半径)\n\n三角形ABC中: 设 1/2周长为 p=1/2(a+b+c) \n            tan(a/2)=r/(p-b)</code></pre>","text":"两角和的公式  sin(A+B)=sinAcosB+cosAsinB sin(A-B)=sinAcosB-sinBcosA  cos(A+B)=cosAcosB-sinAsinB cos(A-B)=cosAcosB+sinAsinB  tan(A+B)=(tanA+tanB)/(","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"C++操作CMD并返回结果","slug":"c-cmd","date":"2017-09-12T10:53:51.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/c-cmd.json","excerpt":"","keywords":null,"cover":null,"content":"<pre><code>#include &lt;iostream&gt;  \nusing namespace std ;  \n// 描述:execmd函数执行命令，并将结果存储到result字符串数组中   \n// 参数:cmd表示要执行的命令  \n// result是执行的结果存储的字符串数组  \n// 函数执行成功返回1，失败返回0    \nint execmd(char* cmd,char* result) {  \n    char buffer[128];                         //定义缓冲区                          \n    FILE* pipe = _popen(cmd, &quot;r&quot;);            //打开管道，并执行命令   \n    if (!pipe)  \n        return 0;                      //返回0表示运行失败   \n\n    while(!feof(pipe)) {  \n        if(fgets(buffer, 128, pipe)){             //将管道输出到result中   \n            strcat(result,buffer);  \n        }  \n    }  \n    _pclose(pipe);                            //关闭管道   \n    return 1;                                 //返回1表示运行成功   \n}  \n\nint main(){  \n    char result[1024*4]=&quot;&quot;;                   //定义存放结果的字符串数组   \n    if(1==execmd(&quot;ipconfig&quot;,result)){  \n        printf(result);  \n    }  \n    system(&quot;pause&quot;);                          //暂停以查看结果   \n}</code></pre>","text":"#include &lt;iostream&gt;  using namespace std ;  // 描述:execmd函数执行命令，并将结果存储到result字符串数组中   // 参数:cmd表示要执行的命令  // result是执行的结果存储的字符串数组  // 函数","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"博客开放注册了哦","slug":"dasdasd","date":"2017-11-25T03:18:04.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/dasdasd.json","excerpt":"","keywords":null,"cover":null,"content":"<p>可以直接在注册的时候填写密码了!</p>\n","text":"可以直接在注册的时候填写密码了!","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"旁观，生活","slug":"e6-97-81-e8-a7-82-ef-bc-8c-e7-94-9f-e6-b4-bb","date":"2019-01-10T12:44:34.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/e6-97-81-e8-a7-82-ef-bc-8c-e7-94-9f-e6-b4-bb.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>若能让我开心，今后所做的一切，为你罢，帮你也罢，都行. 但若我坦然处事，得不到任何，只为成就，未来，生活，那才可悲. 且若开心二字，你若安好，便是晴天.你若得到你想要的生活，便是晴天.</p>\n</blockquote>\n","text":"若能让我开心，今后所做的一切，为你罢，帮你也罢，都行. 但若我坦然处事，得不到任何，只为成就，未来，生活，那才可悲. 且若开心二字，你若安好，便是晴天.你若得到你想要的生活，便是晴天.","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"呼~咻~","slug":"hxx","date":"2017-10-06T15:58:53.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/hxx.json","excerpt":"","keywords":null,"cover":null,"content":"<p>欢迎光临记事版:kissing_heart: <a href=\"http://be-sunshine.cn:81/static/diary/index.html\" title=\"Diary-来自地平线的笔记本\" target=\"_blank\" rel=\"noopener\">Diary-来自地平线的笔记本</a></p>\n","text":"欢迎光临记事版:kissing_heart: Diary-来自地平线的笔记本","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"MooEC English Course","slug":"mooec-english-course","date":"2017-07-12T11:34:25.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/mooec-english-course.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"http://mooec.com/courses/topic-6-advanced/pages/topic-question\" target=\"_blank\" rel=\"noopener\">MOOEC</a></strong> <strong>【Topic6 Advanced】</strong> <strong>Chatterbox:喋喋不休的人 statement:声明,陈述 expensive:昂贵的</strong></p>\n<p><strong>Chatterbox: Hello, I’m Chatterbox! You heard what some students thought in the video above. Let’s see if you agree or disagreewith some opinions. Answer ‘Agree’ or ‘Disagree’ when you read the statements. Are you ready?</strong></p>\n<p><strong>me: Yes .</strong></p>\n<p><strong>Chatterbox: Here is the first statement: “It is more important to solve problems on Earth than it is to explore outer space.” Doyou Agree or Disagree?</strong></p>\n<p><strong>me: Agree .</strong></p>\n<p><strong>Chatterbox: Many people would agree with you.</strong></p>\n<p><strong>Chatterbox: “Research into outer space could be the solution to Earth’s problems.” Do you Agree or Disagree?</strong></p>\n<p><strong>me: Agree .</strong></p>\n<p><strong>Chatterbox: I see!</strong></p>\n<p><strong>Chatterbox: “Space exploration costs too much.” Do you Agree or Disagree?</strong></p>\n<p><strong>–太空探索花费非常巨大.</strong> <strong>me: Agree .</strong></p>\n<p><strong>Chatterbox: Interesting.</strong></p>\n<p><strong>Chatterbox: “Space exploration usually produces useless results.” Do you Agree or Disagree?</strong></p>\n<p><strong>–太空探索通常会得到无用的结果.</strong> <strong>me: Disagree .</strong></p>\n<p><strong>Chatterbox: You make a fair point.</strong></p>\n<p><strong>Chatterbox: “Knowledge and discovery is never too expensive.” Do you Agree or Disagree?</strong></p>\n<p><strong>me: Disagree .</strong></p>\n<p><strong>Chatterbox:</strong></p>\n<p><strong>Chatterbox: Great job! Now you’ve thought about the opinions surrounding the topic question, you’re ready to go thediscussion board and respond. Click ‘Next’ to continue.</strong></p>\n<p><strong>me: OK .</strong></p>\n","text":"【Link】 MOOEC 【Topic6 Advanced】 Chatterbox:喋喋不休的人 statement:声明,陈述 expensive:昂贵的Chatterbox: Hello, I’m Chatterbox! You heard what some student","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"Math & 基础知识 & 技巧 模板","slug":"muban","date":"2017-03-31T12:06:06.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/muban.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【文件头】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong></p>\n</blockquote>\n<p><strong>【判断奇偶性】</strong> <strong>1. t&amp;1,若结果为1则为奇数，0则为偶数，从而用做滚动数组的第一维下标等作用。 【位操作】 1. 1&lt;&lt;n 表示第n位为1,2^n 2. s &amp; (1&lt;&lt;n) 表示判断s的第n位是否为1 3. 问:一行有N格,每格只能填充0/1,则共有1&lt;&lt;n种填充方法.</strong> <strong>【中位数】 1. |**</strong>X1 – Ci|在数轴上就是x1到Ci的距离，所以问题变成了：给定数轴上的n个点，找 出一个到它们的距离之和尽量小的点。<strong>**这个最优的X1就是这些数的“中位数”。即排序以后位于中间的数。</strong> <strong>【自然常数e】</strong> <strong>e = 2.718281828459  exp(F(X))=e^F(X)  log()是以e为底的对数</strong> <strong>【素数筛法】</strong></p>\n<blockquote>\n<p><strong>int prime[MAX_N];//第i个素数</strong> <strong>bool is_prime[MAX_N+1];//is_prime[i]为true表示i是素数</strong> <strong>//返回n以内的素数的个数</strong> <strong>int sieve(int n){</strong> **    int p=0;** **    for(int i=0;i&lt;=n;i++) is_prime[i]=true;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;=n;i++){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=n;j+=i)*</em> **                is_prime[j]=false;** **        }** **    }** **    return p;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【异或操作】</strong> <strong>原地换值:</strong></p>\n<blockquote>\n<p><strong>stay=stay^to;</strong> <strong>to=to^stay;</strong> <strong>stay=stay^to;</strong></p>\n</blockquote>\n<p><strong>即:</strong></p>\n<blockquote>\n<p><strong>stay==to^stay^to.</strong> <strong>to==stay^to^stay.</strong></p>\n</blockquote>\n<p><strong>^的性质有:</strong></p>\n<blockquote>\n<p><strong>x^y==y^x, (x^y)^z==x^(y^z), x^x==0, x^0==x</strong> <strong>如果A,B不相同,A^B=1否则为1</strong> <strong>x^y^y=x</strong></p>\n</blockquote>\n<p><strong>【java:BigInteger】</strong> <strong>相加:</strong></p>\n<blockquote>\n<p><strong>import java.util.Scanner;</strong> <strong>import java.math.*;</strong> <strong>public class Main{</strong> **    public static void main(String[] rgs){** **        //系统输出的** **        Scanner cin=new Scanner(System.in);** **        BigInteger b=BigInteger.valueOf(0);** **        while(cin.hasNext()){//等同于!=EOF** **            BigInteger c;** **            c=cin.nextBigInteger();** **            b=b.add(c);** **        }** **        System.out.println(b);** **    }** <strong>}</strong></p>\n<p><em>*`import java.util.</em>;<br>import java.math.*;<br>public class Main{<br>    public static void main(String args[]){<br>       Scanner cin = new Scanner(System.in);<br>       BigInteger a, b;</p>\n<pre><code>   //以文件EOF结束\n   while (cin.hasNext()){\n       a = cin.nextBigInteger();\n       b = cin.nextBigInteger();\n\n       System.out.println(a.add(b)); //大整数加法\n       System.out.println(a.subtract(b)); //大整数减法\n       System.out.println(a.multiply(b)); //大整数乘法\n       System.out.println(a.divide(b)); //大整数除法(取整)\n       System.out.println(a.remainder(b)); //大整数取模\n\n       //大整数的比较\n       if( a.compareTo(b) == 0 ) System.out.println(&quot;a == b&quot;); //大整数a==b\n       else if( a.compareTo(b) &gt; 0 ) System.out.println(&quot;a &gt; b&quot;); //大整数a&gt;b\n       else if( a.compareTo(b) &lt; 0 ) System.out.println(&quot;a &lt; b&quot;); //大整数a&lt;b\n\n       //大整数绝对值\n       System.out.println(a.abs()); //大整数a的绝对值\n\n       //大整数的幂\n       int exponent=10;\n       System.out.println(a.pow(exponent)); //大整数a的exponent次幂\n\n       //返回大整数十进制的字符串表示\n       System.out.println(a.toString());\n\n       //返回大整数p进制的字符串表示\n       int p=8;\n       System.out.println(a.toString(p));\n   }\n}</code></pre><p>}`**</p>\n</blockquote>\n<p><strong>【字符串处理】</strong> <strong>正则式处理:</strong> <strong>%[^\\n] 读到回车结束,即读一行.</strong> <strong>【ln】</strong> <strong>ln2=1.693147</strong> <strong>【Floyd判圈法】</strong></p>\n<blockquote>\n<p><strong>void floyd_check(int n,int k){</strong> **        int k1=k,k2=k,ans=k;//ans=k** **        do{** **            k1=next(n,k1);** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **        }while(k1!=k2);** **        printf(“%d\\n”,ans);** <strong>}</strong></p>\n</blockquote>\n<p><strong>【k的个数】</strong></p>\n<blockquote>\n<p><strong>upper_bound(a,a+n,k)-lower_bound(a,a+n,k);</strong></p>\n</blockquote>\n","text":"【文件头】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define cle(a,val) memset(a,(val)","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"},{"name":"模板","slug":"未分类/模板","count":3,"path":"api/categories/未分类/模板.json"}],"tags":[]},{"title":"pta 5-13 肿瘤诊断   (30分)","slug":"pta-5-13","date":"2017-04-01T05:11:08.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/pta-5-13.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>BFS</strong> <strong>3 4 5 2</strong> <strong>注意只有6个方向,而不是26个方向</strong> <strong>1,0,0  ,-1,0,0  ,0,1,0  ,0,-1,0  ,0,0,1  ,0,0,-1</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cmath></cmath></strong> <strong>#include<queue></queue></strong> <strong>#define fill(x) memset(x,0,sizeof(x));</strong> <strong>using namespace std;</strong> <strong>struct Node{</strong> <strong>int x,y,z;</strong> <strong>};</strong> <strong>int M,N,L,T,cnt;//LMN</strong> <strong>int mp[62][1300][150];</strong> <strong>int order[6][3]={1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1};</strong> <strong>queue<node> q;</node></strong> <strong>int bfs(int x,int y,int z){</strong> **    q.push((Node){x,y,z});** **    mp[x][y][z]=0;** **    int pnt=0;** **    while(!q.empty()){** <strong>pnt++;</strong> **        Node a=q.front();** **        q.pop();** <strong>//操作只有 1,0,0  -1,0,0  0,1,0  0,-1,0  0,0,1  0,0,-1</strong> <strong>//不能用下面这个循环 下面这个等价于一个球的遍历</strong> <strong>//        for(int i=-1;i&lt;=1;++i)</strong> <strong>//            for(int j=-1;j&lt;=1;++j)</strong> <strong>//                for(int k=-1;k&lt;=1;++k)</strong> <strong>//                    if(mp[a.x+i][a.y+j][a.z+k]){</strong> <strong>//                        q.push((Node){a.x+i,a.y+j,a.z+k});</strong> <strong>//                        mp[a.x+i][a.y+j][a.z+k]=0;  ** **//                    }</strong> <strong>//    }</strong> **        for(int i=0;i&lt;6;++i)** **            if(mp[a.x+order[i][0]][a.y+order[i][1]][a.z+order[i][2]]){** **                q.push((Node){a.x+order[i][0],a.y+order[i][1],a.z+order[i][2]});** **                mp[a.x+order[i][0]][a.y+order[i][1]][a.z+order[i][2]]=0;** <strong>}</strong> **    }** **    if(pnt&gt;=T) return pnt;** <strong>else return 0;</strong> <strong>}</strong>  <strong>int main(){</strong> **    scanf(“%d%d%d%d”,&amp;M,&amp;N,&amp;L,&amp;T);** **    fill(mp);** <strong>cnt=0;</strong> **    for(int i=1;i&lt;=L;++i)** **        for(int j=1;j&lt;=M;++j)** **            for(int k=1;k&lt;=N;++k)** **                scanf(“%d”,&amp;mp[i][j][k]);** **    for(int i=1;i&lt;=L;++i)** **        for(int j=1;j&lt;=M;++j)** **            for(int k=1;k&lt;=N;++k)** **                if(mp[i][j][k])** **                    cnt+=bfs(i,j,k);** <strong>printf(“%d\\n”,cnt);</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 BFS 3 4 5 2 注意只有6个方向,而不是26个方向 1,0,0  ,-1,0,0  ,0,1,0  ,0,-1,0  ,0,0,1  ,0,0,-1 【Code】#include #include #include #include #include #inc","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[{"name":"pta","slug":"pta","count":2,"path":"api/tags/pta.json"}]},{"title":"tl2","slug":"tl2","date":"2019-01-10T06:13:33.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/tl2.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"主题迁移时的问题汇总\"><a href=\"#主题迁移时的问题汇总\" class=\"headerlink\" title=\"主题迁移时的问题汇总\"></a>主题迁移时的问题汇总</h2><blockquote>\n<p>1.鼠标,仅需要在style.css中加入以下代码即可,其中鼠标文件地址自己设置</p>\n<blockquote>\n<p>Tip：鼠标必须是cur格式</p>\n</blockquote>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn:9011/static/file/cur.css\" target=\"_blank\" rel=\"noopener\">cur.css</a></p>\n<blockquote>\n<p>2.雪花，直接将下面文件拆分,启动的那部分放到footer.php中,逻辑部分放在header.php中(均是主题).</p>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn:9011/static/file/Snow.js\" title=\"Snow.js\" target=\"_blank\" rel=\"noopener\">Snow.js</a></p>\n","text":"主题迁移时的问题汇总1.鼠标,仅需要在style.css中加入以下代码即可,其中鼠标文件地址自己设置Tip：鼠标必须是cur格式cur.css2.雪花，直接将下面文件拆分,启动的那部分放到footer.php中,逻辑部分放在header.php中(均是主题).Snow.js","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"STL & 函数","slug":"stl","date":"2017-04-12T02:45:11.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/stl.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【fill】</strong> <strong>等同memset.</strong> <strong>fill(起始地址,终止地址,元素);</strong> <strong>【优先队列】</strong> <strong>priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数:</strong> <strong>priority_queue&lt;Type, Container, Functional&gt;</strong> <strong>其中Type 为数据类型， Container 为保存数据的容器，Functional 为元素比较方式。</strong> <strong>Container 必须是用数组实现的容器，比如 vector, deque 但不能用 list.</strong> <strong>STL里面默认用的是 vector. 比较方式默认用 operator&lt; , 所以如果你把后面俩个参数缺省的话，</strong> <strong>优先队列就是大顶堆，队头元素最大。</strong></p>\n<p><strong><code>#include &lt;iostream&gt;</code></strong></p>\n<p><strong><code>#include &lt;queue&gt;</code></strong></p>\n<p><strong><code>using</code> <code>namespace</code> <code>std;</code></strong></p>\n<p><strong><code>int</code> <code>main(){</code></strong></p>\n<p><strong><code>priority_queue&lt;``int``&gt; q;</code></strong></p>\n<p><strong><code>for``(</code> <code>int</code> <code>i= 0; i&lt; 10; ++i ) q.push(</code> <code>rand``() );</code></strong></p>\n<p><strong><code>while``( !q.empty() ){</code></strong></p>\n<p><strong><code>cout &lt;&lt; q.top() &lt;&lt; endl;</code></strong></p>\n<p><strong><code>q.pop();</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong><code>getchar``();</code></strong></p>\n<p><strong><code>return</code> <code>0;</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong>如果要用到小顶堆，则一般要把模板的三个参数都带进去。</strong> <strong>STL里面定义了一个仿函数 greater&lt;&gt;，对于基本类型可以用这个仿函数声明小顶堆</strong></p>\n<p><strong><code>#include &lt;iostream&gt;</code></strong></p>\n<p><strong><code>#include &lt;queue&gt;</code></strong></p>\n<p><strong><code>using</code> <code>namespace</code> <code>std;</code></strong></p>\n<p><strong><code>int</code> <code>main(){</code></strong></p>\n<p><strong><code>priority_queue&lt;``int``, vector&lt;``int``&gt;, greater&lt;``int``&gt; &gt; q;</code></strong></p>\n<p><strong><code>for``(</code> <code>int</code> <code>i= 0; i&lt; 10; ++i ) q.push(</code> <code>rand``() );</code></strong></p>\n<p><strong><code>while``( !q.empty() ){</code></strong></p>\n<p><strong><code>cout &lt;&lt; q.top() &lt;&lt; endl;</code></strong></p>\n<p><strong><code>q.pop();</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong><code>getchar``();</code></strong></p>\n<p><strong><code>return</code> <code>0;</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong>ps:对于结构体Node,如果重载operator &gt; 可直接使用priority_queue&lt;Node,vector<node>,greater<node>&gt;.</node></node></strong></p>\n<p><strong>【set】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<set></set></strong> <strong>using namespace std;</strong> <strong>int main(){</strong> **    //声明** **    set<int> s;<strong>**    //插入元素</strong> **    s.insert(1);** **    s.insert(3);** **    s.insert(5);<strong>**    //查找元素</strong> **    set<int>::iterator ite;<strong>**    ite=s.find(1);</strong> **    if(ite==s.end()) puts(“not found”);** **    else puts(“found”);** **    //删除元素** **    s.erase(3);** **    //其他查找元素的方法** **    if(s.count(3)!=0)puts(“found”);** **    else puts(“not found”);** **    //遍历所有元素** **    for(ite=s.begin();ite!=s.end();++ite){** **        printf(“%d\\n”,<em>ite);*</em> **    }** **    return 0;** <strong>}</strong></int></int></p>\n</blockquote>\n<p><strong>【map】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<map></map></strong> <strong>#inlcude<string></string></strong> <strong>using namespace std;**</strong>int main(){<em>* **    //声明(int为键,const char<em>为值)*</em> **    map&lt;int,const char</em>&gt; m;<strong>**    //插入元素</strong> <em>*    //map里所有元素都是pair,pair是一个结构体** **    //有两个元素,第一个是first,第二个是second** **    m.insert(make_pair(1,”ONE”));** **    m.insert(make_pair(10,”TEN”));** **    m[100]=”HUNDREN”;  //其他的写法<strong>**    //查找元素</strong> **    map&lt;int,const char</em>&gt;::iterator ite;** **    ite=find(1);** **    puts(ite-&gt;second);    //输出ONE,so,这里为什么用second,懂了吧** **    ite=m.find(2);** **    if(ite==m.end()) puts(“not found”);** **    else puts(ite-&gt;second);** **    puts(m[10]);    //返回-&gt;second** **    //删除元素** **    m.erase();** **    //遍历等同于set,不过输出的是pair的first和second.** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【fill】 等同memset. fill(起始地址,终止地址,元素); 【优先队列】 priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数: priority_queue&lt;Type, Container, Functional&gt; 其","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"学堂在线-TSU-操作系统笔记","slug":"tsu-os","date":"2018-06-02T07:00:45.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/tsu-os.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"1-linux相关\"><a href=\"#1-linux相关\" class=\"headerlink\" title=\"1-linux相关\"></a>1-linux相关</h1><p>mkdir [name] -新建文件夹 pwd -显示当前目录 mv ../README.md~ . -移到当前目录下 rm [文件路径] -删除 ls -l -全部个数</p>\n","text":"1-linux相关mkdir [name] -新建文件夹 pwd -显示当前目录 mv ../README.md~ . -移到当前目录下 rm [文件路径] -删除 ls -l -全部个数","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"等放暑假了要来波大的更新了","slug":"waitmeamomment","date":"2017-06-13T18:15:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/waitmeamomment.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/04/timg-2.jpg","content":"<h1 id=\"攒了好久了TAT\"><a href=\"#攒了好久了TAT\" class=\"headerlink\" title=\"攒了好久了TAT!!!\"></a>攒了好久了TAT!!!</h1><h2 id=\"顺便安利一波YouTuBe上的语C伪动漫-不清楚-逃-—《A-Shark-puppy-comic》\"><a href=\"#顺便安利一波YouTuBe上的语C伪动漫-不清楚-逃-—《A-Shark-puppy-comic》\" class=\"headerlink\" title=\"顺便安利一波YouTuBe上的语C伪动漫(不清楚,逃. —《A Shark puppy comic》\"></a>顺便安利一波YouTuBe上的语C伪动漫(不清楚,逃. —《A Shark puppy comic》</h2><h1 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/04/timg-2.jpg\" alt></h1>","text":"攒了好久了TAT!!!顺便安利一波YouTuBe上的语C伪动漫(不清楚,逃. —《A Shark puppy comic》 [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]},{"title":"字符串匹配模板","slug":"zfcpp","date":"2017-04-16T14:03:29.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/zfcpp.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Trie树】</strong> <strong>–数组实现</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int sigma_size=26;</strong> <strong>const int maxnode=1000;</strong> <strong>//字母表为全体小写字母的Trie</strong> <strong>struct Trie{</strong> **    int ch[maxnode][sigma_size];** **    int val[maxnode];** **    int sz;         //节点总数** **    Trie() {sz=1; memset(ch[0],0,sizeof(ch[0])); }//初始时只有一个根节点** **    int idx(char c) {return c-‘a’;} //字符c的编号** **    //插入字符串s,附加信息为v。注意v必须非0,因为0代表”本节点不是单词结点”** **    void In(char <em>s,int v){*</em> **        int u=0,n=strlen(s);** **        for(int i=0;i&lt;n;++i){** **            int c=idx(s[i]);** **            if(!ch[u][c]){  //结点不存在** **                memset(ch[sz],0,sizeof(ch[sz]));** **                val[sz]=0;          //中间结点的附加信息为0** **                ch[u][c]=sz++;      //新建结点** **            }** **            u=ch[u][c];             //往下走** **        }** **        val[u]=v;                   //字符串的最后一个字符的附加信息为v** **    }** **    int Se(char <em>s){*</em> **        int u=0,n=strlen(s);** **        for(int i=0;i&lt;n;++i){** **            int c=idx(s[i]);** **            if(!ch[u][c]) return 0;//单词不存在** **            u=ch[u][c];** **        }** **        return 1;//存在单词** **    }** <strong>};</strong> <strong>int main(){</strong> **    int N;** **    Trie <em>tr=new Trie;*</em> **    char str[11]=””;** **    scanf(“%d”,&amp;N);** **    while(N–){** **        scanf(“%s”,str);** **        tr-&gt;In(str,66);** **    }** **    scanf(“%d”,&amp;N);** **    while(N–){** **        scanf(“%s”,str);** **        printf(“%d\\n”,tr-&gt;Se(str));//1为存在单词,0为不存在** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>–链表实现</strong></p>\n<blockquote>\n<p>**#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>struct Tree{//以0-26作为Tree的头结点<br>    int num;<br>    Tree* Next[26];<br>    Tree(){<br>        num=0;<br>        int i;<br>        for(i=0;i&lt;26;i++)<br>            Next[i]=NULL;<br>    }<br>}T;</p>\n<p>void In(char <em>str){<br>    Tree</em> H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL)//只有微为空才允许创建<br>            H-&gt;Next[str[i]-‘a’]=new Tree;//想调用构造函数必须new一个Tree<br>        H=H-&gt;Next[str[i]-‘a’];<br>        H-&gt;num++;<br>    }<br>}</p>\n<p>int Se(char *str){<br>    Tree *H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL) return 0;<br>        H=H-&gt;Next[str[i]-‘a’];<br>    }<br>    return H-&gt;num;<br>}</p>\n<p>int main(){<br>    int N;<br>    char str[11]=””;<br>    scanf(“%d”,&amp;N);</p>\n<pre><code>while(N--){\n    scanf(&quot;%s&quot;,str);\n    In(str);\n}\n\nscanf(&quot;%d&quot;,&amp;N);\nwhile(N--){\n    scanf(&quot;%s&quot;,str);\n    printf(&quot;%d\\\\n&quot;,Se(str));\n}\n\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n<p><strong>【KMP】</strong> <strong>kmpN() 作用:构造next数组 参数:模式串,模式串长度 kmpC() 作用:返回模式串在主串中出现的次数(可重复) 参数:模式串,模式串长度,主串,主串长度</strong></p>\n<blockquote>\n<p><em>*`int nex[maxn];<br>void kmpN(char</em> x,int len) {<br>  int i=0,j=nex[0]=-1;<br>  while(i&lt;len) {<br>    while(j!=-1&amp;&amp;x[i]!=x[j])j=nex[j];<br>    nex[++i]=++j;<br>  }<br>}</p>\n<p>int kmpC(char x[],int m,char y[],int n) {<br>  int i=0,j=0,ans=0;<br>  while(i&lt;n) {<br>    while(-1!=j&amp;&amp;y[i]!=x[j])j=nex[j];<br>    i++; j++;<br>    if(j&gt;=m) {<br>      ans++;<br>      j=nex[j];<br>    }<br>  }<br>  return ans;<br>}`** </p>\n</blockquote>\n<p><strong>【后缀数组】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=10000+10;</strong> <strong>char s[maxn];</strong> <strong>int sa[maxn],t[maxn],t2[maxn],c[maxn],n;//n是文本串的长度</strong> <strong>//构造字符串s的后缀数组。每个字符值必须为0~m-1</strong> <strong>void build_sa(int m){</strong> <em>*    int i,*x=t,*y=t2;** **    //基数排序** **    for(i=0;i&lt;m;++i) c[i]=0;** **    for(i=0;i&lt;n;++i) c[x[i]=s[i]]++;** **    for(i=1;i&lt;m;++i) c[i]+=c[i-1];** **    for(i=n-1;i&gt;=0;–i) sa[–c[x[i]]]=i;** **    for(int k=1;k&lt;=n;k&lt;&lt;=1){** **        int p=0;** **        //直接用sa数组排序第二关键字** **        for(i=n-k;i&lt;n;++i) y[p++]=i;** **        for(i=0;i&lt;n;++i) if(sa[i]&gt;=k) y[p++] = sa[i]-k;** **        //基数排序第一关键字** **        for(i=0;i&lt;m;++i) c[i]=0;** **        for(i=0;i&lt;n;++i) c[x[y[i]]]++;** **        for(i=0;i&lt;m;++i) c[i]+=c[i-1];** **        for(i=n-1;i&gt;=0;i–) sa[–c[x[y[i]]]]=y[i];** **        //根据sa和y数组计算新的x数组** **        swap(x,y);** **        p=1;x[sa[0]]=0;** **        for(i=1;i&lt;n;++i)** **            x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++;** **        if(p&gt;=n) break; //以后即使继续倍增,sa也不会改变,退出** **        m=p;    //下次基数排序的最大值** **    }** <strong>}</strong> <strong>int m;  //模板长度。简单起见,这里存在全局变量中</strong> **int cmp_suffix(char</em> pattern,int p){//判断模板s是否为后缀p的前缀<em>* **    return strncmp(pattern,s+sa[p],m);** <strong>}</strong> **int find(char</em> P){** **    m=strlen(P);** **    if(cmp_suffix(P,0)&lt;0) return -1;** **    if(cmp_suffix(P,n-1)&gt;0) return -1;** **    int L=0,R=n-1;** **    while(R&gt;=L){            //二分查找** **        int M=L+(R-L)/2;** **        int res=cmp_suffix(P,M);** **        if(!res) return M;** **        if(res&lt;0) R=M-1; else L=M+1;** **    }** **    return -1;              //找不到** <strong>}</strong> <strong>int main(){</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Trie树】 –数组实现#include&lt;bits/stdc++.h&gt; using namespace std; const int sigma_size=26; const int maxnode=1000; //字母表为全体小写字母的Trie struct Tr","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"},{"name":"模板","slug":"未分类/模板","count":3,"path":"api/categories/未分类/模板.json"}],"tags":[]},{"title":"图论 模板","slug":"graph-muban","date":"2017-04-03T13:17:38.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/graph-muban.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【前向星存储法】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include &lt;string.h&gt;</strong> <strong>#include <algorithm></algorithm></strong> <strong>using namespace std;</strong> <strong>int head[10005]; //存储起点为Vi的第一条边的位置</strong> <strong>struct note{</strong> **    int xx,yy,ww;  //起点，终点，权值** <strong>}e[10005];</strong> <strong>bool cmp(note a, note b){</strong> **    if(a.xx==b.xx &amp;&amp; a.yy==b.yy) return a.ww&lt;b.ww;** **    if(a.xx==b.xx)  return a.yy&lt;b.yy;** **    return a.xx&lt;b.xx;** <strong>}</strong> <strong>int main(){</strong> **     int n, m;** <strong>cin &gt;&gt; n &gt;&gt; m; //n个顶点, m条边</strong> <strong>for(int i=0; i&lt;m; i++) cin &gt;&gt; e[i].xx &gt;&gt; e[i].yy &gt;&gt; e[i].ww; //读入边</strong> <strong>sort(e,e+m,cmp); //将边按顶点从小到大排序</strong> <strong>memset(head, -1, sizeof(head));  //head初始化为-1</strong> **     head[e[0].xx]=0;** **     for(int i=1; i&lt;m; i++)** **        if(e[i].xx!=e[i-1].xx) head[e[i].xx]=i; //确定起点为Vi的第一条边的位置** **     int k;** **     for(int i=1;i&lt;=n;i++)** **         for(k=head[i]; e[k].xx==i &amp;&amp; k&lt;m; k++) cout &lt;&lt; e[k].xx&lt;&lt;” “ &lt;&lt; e[k].yy&lt;&lt;” “&lt;&lt; e[k].ww &lt;&lt; endl;** **     return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【邻接表存储法】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>struct edgenode{</strong> **    int to;** **    int w;** **    edgenode <em>next;*</em> <strong>}*N[10005];</strong> <strong>int main(){</strong> **    int i,j,w,n;** **    while(~scanf(“%d”,&amp;n)){** **        for(int kk=0;kk&lt;n;++kk){** **            cin&gt;&gt;i&gt;&gt;j&gt;&gt;w;** **            edgenode <em>p=new edgenode();*</em> **            p-&gt;to=j;** **            p-&gt;w=w;** <strong>p-&gt;next=N[i];//把该节点下所有的边用链表存下来</strong> **            N[i]=p;** **        }** <strong>cout&lt;&lt;endl;</strong> **        for(int i=1;i&lt;=n;++i)** **            for(edgenode <em>k=N[i];k!=NULL;k=k-&gt;next)*</em> **                cout &lt;&lt; i &lt;&lt; “ “ &lt;&lt; k -&gt;to &lt;&lt; “ “ &lt;&lt; k-&gt;w &lt;&lt; endl;** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【Dijstra模板】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>const int maxn=1000000;</strong> <strong>struct Edge{</strong> <strong>int from,to,dist;</strong> <strong>};</strong> <strong>struct HeapNode{  //Dijkstra算法用到的优先队列的节点</strong> **    int d,u;** **    bool operator&lt;(const HeapNode&amp; rhs)const{** <strong>return d&gt;rhs.d;</strong> <strong>}</strong> <strong>};</strong> <strong>struct Dijkstra{</strong> **    int n,m; //点数和边数** **    vector<edge> edges; //边列表** **    vector<int> G[maxn]; //每个节点出发的边编号(从0开始编号)** **    bool done[maxn];    //是否永久标号** **    int d[maxn];        //s到各个点的距离** <strong>int p[maxn];        //最短路中的上一条边</strong> **    void init(int n){** **        this-&gt;n=n;** **        for(int i=0;i&lt;n;++i) G[i].clear();//清空邻接表** <strong>edges.clear();//清空边表</strong> <strong>}</strong>  **    void AddEdge(int from,int to,int dist){** **        //如果是无向图,每条无向边需调用两次AddEdge** **        edges.push_back((Edge){from,to,dist});** **        m=edges.size();** <strong>G[from].push_back(m-1);</strong> <strong>}</strong>  **    void dijkstra(int s){//求s到所有点的距离** **         priority_queue<heapnode> Q;** **         for(int i=0;i&lt;n;++i) d[i]=INF;** **         d[s]=0;** **         fill(done);** **         Q.push((HeapNode){0,s});** **         while(!Q.empty()){** **             HeapNode x=Q.top(); Q.pop();** **            int u=x.u;** **            if(done[u])continue;** **            done[u]=true;** **            for(int i=0;i&lt;G[u].size();++i){** **                Edge &amp;e=edges[G[u][i]];** **                if(d[e.to]&gt;d[u]+e.dist){** **                    d[e.to]=d[u]+e.dist;** **                    p[e.to]=G[u][i];** <strong>Q.push((HeapNode){d[e.to],e.to});</strong> <strong>}</strong> <strong>}</strong> **         }** <strong>}</strong> <strong>};</strong> <strong>int main(){</strong>  <strong>return 0;</strong> <strong>}</strong></heapnode></int></edge></p>\n</blockquote>\n<p><strong>—题目应用,pat L3-005 垃圾箱分布</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>const int maxn=30000;</strong> <strong>int N,M,K,D;</strong> <strong>char alpha1[100],alpha2[100];</strong> <strong>int now,goal,di;</strong>  <strong>struct Edge{</strong> <strong>int from,to,dist;</strong> <strong>};</strong> <strong>struct HeapNode{  //Dijkstra算法用到的优先队列的节点</strong> **    int d,u;** **    bool operator&lt;(const HeapNode&amp; rhs)const{** <strong>return d&gt;rhs.d;</strong> <strong>}</strong> <strong>};</strong> <strong>struct Dijkstra{</strong> **    int n,m; //点数和边数** **    vector<edge> edges; //边列表** **    vector<int> G[maxn]; //每个节点出发的边编号(从0开始编号)** **    bool done[maxn];    //是否永久标号** **    int d[maxn];        //s到各个点的距离** <strong>int p[maxn];        //最短路中的上一条边</strong> **    void init(int n){** **        this-&gt;n=n;** **        for(int i=0;i&lt;n;++i) G[i].clear();//清空邻接表** <strong>edges.clear();//清空边表</strong> <strong>}</strong>  **    void AddEdge(int from,int to,int dist){** **        //如果是无向图,每条无向边需调用两次AddEdge** **        edges.push_back((Edge){from,to,dist});** **        m=edges.size();** <strong>G[from].push_back(m-1);</strong> <strong>}</strong>  **    void dijkstra(int s){//求s到所有点的距离** **         priority_queue<heapnode> Q;** **         for(int i=0;i&lt;n;++i) d[i]=INF;** **         d[s]=0;** **         fill(done);** **         Q.push((HeapNode){0,s});** **         while(!Q.empty()){** **             HeapNode x=Q.top(); Q.pop();** **            int u=x.u;** **            if(done[u])continue;** **            done[u]=true;** **            for(int i=0;i&lt;G[u].size();++i){** **                Edge &amp;e=edges[G[u][i]];** **                if(d[e.to]&gt;d[u]+e.dist){** **                    d[e.to]=d[u]+e.dist;** **                    p[e.to]=G[u][i];** <strong>Q.push((HeapNode){d[e.to],e.to});</strong> <strong>}</strong> <strong>}</strong> **         }** <strong>}</strong> <strong>};</strong> <strong>int main(){</strong> **    while(~scanf(“%d%d%d%d”,&amp;N,&amp;M,&amp;K,&amp;D)){** **        Dijkstra dj;** <strong>dj.init(N+M);</strong> **        for(int i=0;i&lt;K;++i){** <strong>scanf(“\\n%s %s %d”,alpha1,alpha2,&amp;di);</strong> **            //因为可能出现G10 123等字符串** **            //所以这里转换必须用atoi或stoi** <strong>//后者是c11的</strong> <strong>if(alpha1[0]==’G’){</strong> <strong>now = N-1 + atoi(alpha1+1);</strong> **            }else** <strong>now = atoi(alpha1)-1;</strong>  <strong>if(alpha2[0]==’G’){</strong> **                goal = N-1 + atoi(alpha2+1);** **            }else** **                goal = atoi(alpha2)-1;**  **            dj.AddEdge(now,goal,di);** <strong>dj.AddEdge(goal,now,di);</strong> <strong>}</strong> **        int ansid=-1,ansdis=INF;** <strong>double ansave=INF;</strong>  **        for(int i=0;i&lt;M;++i){** **            int index=i+N,mindis=INF;** **            bool flag=true;** **            double ave=0.0;** **            dj.dijkstra(index);** **            for(int j=0;j&lt;N;++j){** **                if(dj.d[j]&gt;D){** **                    flag=false;** **                    break;** **                }** **                ave+=1.0<em>dj.d[j];*</em> **                mindis=mindis&gt;dj.d[j]?dj.d[j]:mindis;** <strong>}</strong> **            if(!flag)** **                continue;** **            else{** **                if(ansdis==INF){** **                    ave=ave/N;** **                    ansave=ave;** **                    ansid=i;** **                    ansdis=mindis;** **                }else if(mindis&gt;ansdis){** **                    ave=ave/N;** **                    ansave=ave;** **                    ansid=i;** **                    ansdis=mindis;** **                }else if(ansdis==mindis){** **                    ave=ave/N;** **                    if(ave&lt;ansave){** **                        ansave=ave;** **                        ansid=i;** **                        ansdis=mindis;** **                    }else if(ave==ansave){** **                        ansid=i&gt;ansid?ansid:i;** **                        ansdis=mindis;** **                    }** **                }** **            }** **        }**  **        if(ansid==-1)** **            printf(“No Solution\\n”);** **        else{** **            printf(“G%d\\n”,ansid+1);** <strong>printf(“%.1f %.1f\\n”,1.0*ansdis,ansave);</strong> <strong>}</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></heapnode></int></edge></p>\n</blockquote>\n<p><strong>【Floyd-任意两点间最短路】</strong></p>\n<blockquote>\n<p><strong>int d[max_V][max_V];//d[u][v]表示e(u,v)的边权值(不存在时设为INF,不过d[i][i]=0)</strong> <strong>int V;</strong> <strong>void folyd(){</strong> **     for(int k=0;k&lt;V;++k)** **        for(int i=0;i&lt;V;++i)** **            for(int j=0;j&lt;V;++j)** **               d[i][j]=min(d[i][j],d[i][k]+d[k][j]);** <strong>}</strong></p>\n</blockquote>\n<p><strong>【并查集】</strong></p>\n<blockquote>\n<p><strong>//并查集</strong> <strong>int par[MAX_N];//父亲</strong> <strong>int rank[MAX_N];//树的高度</strong> <strong>void init(int n){</strong> **    for(int i=0;i&lt;n;++i){** **        par[i]=i;** **        rank[i]=0;** **    }** <strong>}</strong> <strong>//查询树的根</strong> <strong>int find(int x){</strong> **    if(par[x]==x){** **        return x;** **    }else{** **        return par[x]=find(par[x]);** **    }** <strong>}</strong> <strong>//合并x和y所属集合</strong> <strong>void unite(int x,int y){</strong> **    x=find(x);** **    y=find(y);** **    if(x==y) return;** **    if(rank[x]&lt;rank[y]){** **        par[x]=y;** **    }else{** **        par[y]=x;** **        if(rank[x]==rank[y]) rank[x]++;** **    }** <strong>}</strong> <strong>//判断x和y是否属于同一个集合</strong> <strong>bool same(int x,int y){</strong> **    return find(x)==find(y);** <strong>}</strong></p>\n</blockquote>\n<p><strong>【并查集优化Kruskal】</strong></p>\n<blockquote>\n<p><strong>struct edge{</strong> **    int u,v,cost;** <strong>};</strong> <strong>bool comp(const edge&amp; e1,const edge&amp; e2){</strong> **    return e1.cost&lt;e2.cost;** <strong>}</strong> <strong>edge es[MAX_N];</strong> <strong>int V,E;//顶点数和边数</strong> <strong>//并查集</strong> <strong>int par[MAX_N];//父亲</strong> <strong>int rank[MAX_N];//树的高度</strong> <strong>void init_union_find(int n){</strong> **    for(int i=0;i&lt;n;++i){** **        par[i]=i;** **        rank[i]=0;** **    }** <strong>}</strong> <strong>//查询树的根</strong> <strong>int find(int x){</strong> **    if(par[x]==x){** **        return x;** **    }else{** **        return par[x]=find(par[x]);** **    }** <strong>}</strong> <strong>//合并x和y所属集合</strong> <strong>void unite(int x,int y){</strong> **    x=find(x);** **    y=find(y);** **    if(x==y) return;** **    if(rank[x]&lt;rank[y]){** **        par[x]=y;** **    }else{** **        par[y]=x;** **        if(rank[x]==rank[y]) rank[x]++;** **    }** <strong>}</strong> <strong>//判断x和y是否属于同一个集合</strong> <strong>bool same(int x,int y){</strong> **    return find(x)==find(y);** <strong>}</strong> <strong>int kruskal(){</strong> **    sort(es,es+E,comp);** **    int res=0;** **    init_union_find(V);** **    for(int i=0;i&lt;E;++i){** **        edge e=es[i];** **        if(!same(e.u,e.v)){** **            unite(e.u,e.v);** **            res+=e.cost;** **        }** **    }** **    return res;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【最大流Dinic】</strong> <strong>对应例题 POJ 1273</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>//弧,从from到to的容量为cap,流量为flow的弧当cap=0时,意味此边是反向弧</strong> <strong>//当且仅当flow&lt;cap时,该弧存在于残量网络中</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int from,int to,int cap,int flow):from(from),to(to),cap(cap),flow(flow){}** **    int from,to,cap,flow;** <strong>};</strong> <strong>struct Dinic{</strong> **    int n,m,s,t; //节点数,边数** **    vector<edge> edges;//边表。edges[e]和edges[e^1]互为反向弧。** **    vector<int> G[maxn]; //邻接表,G[i][j]表示节点i的第j条边在e数组中的序号** **    bool vis[maxn]; //BFS使用** **    int d[maxn]; //从起点到i的距离** **    int cur[maxn]; //当前弧的下标** **    //插入弧,原图中的一条弧对应于两个Edge结构体,一个是这条弧本身,另一个是他的反向弧** **    //根据插入顺序不难看出,edges[0]和edges[1]互为反向弧,edges[2]和edges[3]** **    //一般的,edges[e]和edges[e^1]互为反向弧** **    void AddEdge(int from,int to,int cap){** **        edges.push_back((Edge){from,to,cap,0});** **        edges.push_back((Edge){to,from,0,0});** **        m=edges.size();** **        G[from].push_back(m-2);** **        G[to].push_back(m-1);** **    }** **    bool BFS(){** **        cle(vis,0);** **        queue<int> Q;** **        Q.push(s);** **        d[s]=0;** **        vis[s]=1;** **        while(!Q.empty()){** **            int x=Q.front();Q.pop();** **            for(int i=0;i&lt;G[x].size();++i){** **                Edge&amp; e=edges[G[x][i]];** **                if(!vis[e.to] &amp;&amp; e.cap&gt;e.flow){//只考虑残量网络中的狐** **                    vis[e.to]=1;** **                    d[e.to]=d[x]+1;** **                    Q.push(e.to);** **                }** **            }** **        }** **        return vis[t];** **    }** **    int DFS(int x,int a){** **        if(x==t || a==0) return a;** **        int flow=0,f;** **        for(int&amp; i=cur[x];i&lt;G[x].size();++i){//从上次考虑的弧** **            Edge&amp; e=edges[G[x][i]];** **            if(d[x]+1==d[e.to] &amp;&amp; (f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){** **                e.flow+=f;** **                edges[G[x][i]^1].flow-=f;** **                flow+=f;** **                a-=f;** **                if(a==0) break;** **            }** **        }** **        return flow;** **    }** **    int Maxflow(int s,int t){** **        this-&gt;s=s;this-&gt;t=t;** **        int flow=0;** **        while(BFS()){** **            cle(cur,0);** **            flow+=DFS(s,INF);** **        }** **        return flow;** **    }** <strong>};</strong> <strong>int main(){</strong> **    return 0;** <strong>}</strong></int></int></edge></p>\n</blockquote>\n<p><strong>【SPFA最小费用最大流】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];//maxm最大边数** **    int nume;** **    int src,sink;** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    queue<int> que;** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        while(!que.empty()) que.pop();** **        que.push(src);** **        cle(dist,63);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    ll mincostflow(){** **        ll cur=0;** **        while(Spfa()){** **            cur+=augment();** **  //          if(cur&lt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>};</strong></int></p>\n</blockquote>\n","text":"【前向星存储法】#include  #include &lt;string.h&gt; #include  using namespace std; int head[10005]; //存储起点为Vi的第一条边的位置 struct note{ **    int xx,yy,w","link":"","raw":null,"photos":[],"categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"},{"name":"模板","slug":"未分类/模板","count":3,"path":"api/categories/未分类/模板.json"}],"tags":[]}]}