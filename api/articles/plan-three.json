{"title":"计划:技术栈完善2-实战JAVA高并发程序设计-第三章","slug":"plan-three","date":"2018-06-19T01:06:07.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-three.json","photos":[],"link":"","excerpt":null,"covers":["http://be-sunshine.cn/wp-content/uploads/2018/06/482e4b0a1461a4d73d554ac253836c8a.png","http://be-sunshine.cn/wp-content/uploads/2018/06/88267587709716bb6b7d5a183b7bea85.png","http://be-sunshine.cn/wp-content/uploads/2018/06/2c1925682e53b6a81146256a57ce2e88.png","http://be-sunshine.cn/wp-content/uploads/2018/06/7c53caa4fa9b345ab9b03b92bda61465.png","http://be-sunshine.cn/wp-content/uploads/2018/06/852095dd0c714bd6f84dfbab510688f6.png","http://be-sunshine.cn/wp-content/uploads/2018/06/2fdb2eba1f1763034b55e7c321ef1bab.png","http://be-sunshine.cn/wp-content/uploads/2018/06/be5bdfeba0ba5e3d7cf870cdd78a0747.png","http://be-sunshine.cn/wp-content/uploads/2018/06/c06d16d76d0568a8e5133f62436d4b68.png","http://be-sunshine.cn/wp-content/uploads/2018/06/0096034273dcb98f075add481ae7e975.png"],"content":"<h1><span id=\"jdk并发包\">JDK并发包</span></h1><h2><span id=\"多线程间的团队协作-同步控制\">多线程间的团队协作: 同步控制</span></h2><p>比如之前的synchronized关键字就是一种最简单的控制方法.它决定了一个线程是否可以访问临界资源区. 还有wait和notify.</p>\n<h3><span id=\"synchronized的功能扩展-重入锁\">synchronized的功能扩展: 重入锁</span></h3><p>重入锁可以完全替代synchronized关键字. 重入锁使用 java.util.concurrent.locks.ReentrantLock 类来实现. 例:</p>\n<pre><code>import java.util.concurrent.locks.ReentrantLock;\npublic class p31 implements Runnable{\n\n    public static ReentrantLock lock=new ReentrantLock();\n    public static int i=0;\n    @Override\n    public void run(){\n        for(int j=0;j&lt;10000000;++j){\n            lock.lock();\n            try{\n                i++;\n            }finally{\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        p31 tl=new p31();\n        Thread t1=new Thread(tl);\n        Thread t2=new Thread(tl);\n        t1.start();t2.start();\n        t1.join();t2.join();\n        System.out.println(i);\n    }\n}</code></pre><p>可以看出这段代码是手动加锁的.故重入锁在逻辑控制的灵活性上远高于某关键字. <strong>但一定注意推出临界区要释放锁</strong> 为什么叫重入锁呢?因为允许一个线程获得N个锁,所以叫重入锁. <strong>一个线程获取多个锁后,也必须释放相同次数的锁</strong></p>\n<h4><span id=\"重入锁的中断响应\">重入锁的中断响应</span></h4><p>如果你一个线程一直等待锁,而拿锁的那个线程始终不放开锁,那不就死锁了么. 它提供了一种机制,即通知等待者无须再等待.即时停止工作. isHeldByCurrentThread()方法是返回当前线程是否拥有该锁. lockInterruptibly()方法是获取一个允许中断响应的锁. lock()方法获取的锁不允许中断. 例：</p>\n<pre><code>import java.util.concurrent.locks.ReentrantLock;\n\npublic class p32 implements Runnable {\n    public static ReentrantLock lock1=new ReentrantLock();\n    public static ReentrantLock lock2=new ReentrantLock();\n\n    int lock;\n    /*\n     * 控制加锁顺序,防止死锁\n     */\n    public p32(int lock){\n        this.lock=lock;\n    }\n\n    @Override\n    public void run(){\n        try{\n            if(lock==1){\n                lock1.lockInterruptibly();\n                try{\n                    Thread.sleep(500);\n                }catch(InterruptedException e){}\n                System.out.println(&quot;Lock1 Here IN&quot;);\n                lock2.lockInterruptibly();\n                System.out.println(&quot;Lock1 Here OUT&quot;);\n            }else{\n                lock2.lockInterruptibly();\n                try{\n                    Thread.sleep(500);\n                }catch(InterruptedException e){}\n                System.out.println(&quot;Lock2 Here IN&quot;);\n                lock1.lockInterruptibly();\n                System.out.println(&quot;Lock2 Here OUT&quot;);\n            }\n        }catch(InterruptedException e){\n            e.printStackTrace();\n        }finally{\n            if(lock1.isHeldByCurrentThread())\n                lock1.unlock();\n            if(lock2.isHeldByCurrentThread())\n                lock2.unlock();\n            System.out.println(Thread.currentThread().getId()+&quot;线程退出&quot;);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        p32 r1=new p32(1);\n        p32 r2=new p32(2);\n        Thread t1 = new Thread(r1);\n        Thread t2 = new Thread(r2);\n        t1.start();t2.start();\n        Thread.sleep(1000);\n        t2.interrupt();\n    }\n\n}</code></pre><p>线程启动后,r1先占用lock1,再请求lock2 r2相反,这也就导致了t1和t2互相等待,形成死锁. 而当我们将r2中断以后,r2释放了所有的锁,r1检测到了,故只有r1完全执行完毕,r2则会抛出一个中断异常.</p>\n<h4><span id=\"第二种中断方法\">第二种中断方法</span></h4><blockquote>\n<p>lock.tryLock(5,TimeUnit.SECONDS)</p>\n<blockquote>\n<p>县城在这个锁请求中等待5秒,如果五秒内无法得到锁,则False</p>\n</blockquote>\n</blockquote>\n<h4><span id=\"公平锁\">公平锁</span></h4><blockquote>\n<p>公平锁的效率不高,所以一般不用,因为公平锁需要维护一个优先队列. 公平锁是通过对谁先获得当前资源进行合理的调度来防止死锁的产生. 使用方法: ReentrantLock</p>\n<blockquote>\n<p>性质:</p>\n<blockquote>\n<p>1.原子状态 2.等待队列(没有请求到锁就进入等待队列) 3.阻塞原语pair()与unpair()</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4><span id=\"重入锁好搭档-condition条件\">重入锁好搭档: Condition条件</span></h4><blockquote>\n<p>Condition和wait与notify的用法大致相同</p>\n</blockquote>\n<pre><code>package s;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class p31 implements Runnable {\n\n    public static ReentrantLock lock=new ReentrantLock();\n    public static Condition condition=lock.newCondition();\n\n    @Override\n    public void run(){\n        try{\n            lock.lock();\n            System.out.println(&quot;SD&quot;);\n            condition.await();\n            System.out.println(&quot;This is going on.&quot;);\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally{\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        p31 tl=new p31();\n        Thread t1=new Thread(tl);\n        t1.start();\n        Thread.sleep(2000);\n        ///通知线程t1继续执行\n        lock.lock();\n        condition.signal();\n        System.out.println(&quot;AA&quot;);\n        lock.unlock();\n    }\n\n}</code></pre><blockquote>\n<p>注: Condition只能在lock和unlock保护下才可以解锁. wait 是等待,notify是返回通知开始执行</p>\n</blockquote>\n<h4><span id=\"允许多个线程同时访问-信号量semaphore\">允许多个线程同时访问: 信号量(Semaphore)</span></h4><blockquote>\n<p>构造函数:</p>\n<blockquote>\n<p>public Semaphore(int permits) public Semaphore(int permits,boolean fair) 第二个参数是是否公平</p>\n</blockquote>\n<p>信号量主要逻辑方法</p>\n<blockquote>\n<p>public void acquire() -准入许可,等待 public void acquireUninterruptibly() -不接收中断 public boolean tryAcquire() - 获得许可,不等待 public boolean tryAcquire(long timeout,TimeUnit unit) public void release() - 释放许可</p>\n</blockquote>\n</blockquote>\n<p>例子:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Semaphore;\n\npublic class p33 implements Runnable{\n    final Semaphore semp=new Semaphore(5);\n    public void run(){\n        try{\n            semp.acquire();\n            Thread.sleep(2000);\n            System.out.println(Thread.currentThread().getId()+&quot;:done!&quot;);\n            semp.release();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        ExecutorService exec =Executors.newFixedThreadPool(20);\n        final p33 t1= new p33();\n        for(int i=0;i&lt;20;++i){\n            exec.submit(t1);\n        }\n    }\n\n}</code></pre><p>为信号量传入的5代表线程队列中课同时存在的线程数量的最大值. 开启程序后,你会发现每一瞬间都会有5个线程执行并打印出数据,但在这5个释放占用的信号量后才会继续向下执行.</p>\n<h4><span id=\"readwritelock-读写锁\">ReadWriteLock 读写锁</span></h4><blockquote>\n<p>读操作不会破坏数据完整性,所以当读-读-…操作产生时,不需要加锁即可.这样使得大量读操作的系统会有很明显的效率上的提升. 但写会阻塞读,所以效率由写操作的次数来决定.</p>\n</blockquote>\n<p>锁的创建:</p>\n<pre><code>private static ReentrantReadWriteLock readWriteLock=new RenntrantReadWriteLock();\nprivate static Lock readLock=readWriteLock.readLock();\nprivate static Lock WriteLock=readWriteLock.WriteLock();</code></pre><h4><span id=\"倒计时器-countdownlatch\">倒计时器: CountDownLatch</span></h4><p>它可以让一个线程在倒计时结束后再执行. 执行方式如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/482e4b0a1461a4d73d554ac253836c8a.png\" alt> 必须所有的线程都完成任务后,等待在CountDownLatch上的线程才能继续执行. 例:</p>\n<pre><code>import java.util.Random;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class p34 implements Runnable{\n    static final CountDownLatch end=new CountDownLatch(10);\n\n    static final p34 demo=new p34();\n\n    public void run(){\n        try{\n            Thread.sleep(new Random().nextInt(10)*1000);\n            System.out.println(&quot;check complete&quot;);\n            end.countDown();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    public static class now{\n        public static void print() throws InterruptedException{\n            end.await();\n            System.out.println(&quot;我来了~~~~&quot;);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        final now t1=new now();\n        ExecutorService exec=Executors.newFixedThreadPool(10);\n        for(int i=0;i&lt;10;++i){\n            exec.submit(demo);\n        }\n        t1.print();\n        exec.shutdown();\n    }\n}</code></pre><h4><span id=\"循环栅栏-cyclicbarrier\">循环栅栏： CyclicBarrier</span></h4><blockquote>\n<p>它比上面那个更加复杂和强大</p>\n<blockquote>\n<p>可以将它理解为一种障碍物.它是用来阻止线程继续执行,并且这个计数器可以反复使用,比如,10个执行完以后,再来一遍.</p>\n</blockquote>\n</blockquote>\n<p>例:</p>\n<pre><code>import java.util.Random;\nimport java.util.concurrent.CyclicBarrier;\n\npublic class p35 {\n    public static class Soldier implements Runnable{\n        private String soldier;\n        private final CyclicBarrier cyclic;\n        Soldier(CyclicBarrier cyclic,String s){\n            this.cyclic=cyclic;\n            this.soldier=s;\n        }\n\n        public void run(){\n            try{\n                //等待所有士兵到齐\n                cyclic.await();\n                doWork();\n                //等待所有士兵完成工作\n                cyclic.await();\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n\n        void doWork(){\n            try{\n                Thread.sleep(Math.abs(new Random().nextInt()%10000));\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n            System.out.println(soldier+&quot;任务完成!&quot;);\n        }\n\n    }\n\n    public static class BarrierRun implements Runnable{\n        boolean flag;\n        int N;\n        public BarrierRun(boolean a,int b){\n            this.flag=a;\n            this.N=b;\n        }\n        public void run(){\n            if(flag){\n                System.out.println(&quot;司令:[士兵&quot;+N+&quot;个,任务完成!]&quot;);\n            }else{\n                System.out.println(&quot;司令:[士兵&quot;+N+&quot;个,集合完毕!]&quot;);\n                flag=true;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N=5;\n        Thread[] allSoldier=new Thread[10];\n        boolean flag=false;\n        CyclicBarrier cyclic=new CyclicBarrier(N,new BarrierRun(flag,N));\n        //设置屏障点\n        System.out.println(&quot;集合队伍!&quot;);\n        for(int i=0;i&lt;10;++i){\n            System.out.println(&quot;士兵&quot;+i+&quot;报道!&quot;);\n            allSoldier[i]=new Thread(new Soldier(cyclic,&quot;士兵 &quot;+i));\n            allSoldier[i].start();\n        }\n    }\n\n}</code></pre><p>输出: 集合队伍! 士兵0报道! 士兵1报道! 士兵2报道! 士兵3报道! 士兵4报道! 士兵5报道! 司令:[士兵5个,集合完毕!] 士兵6报道! 士兵7报道! 士兵8报道! 士兵9报道! 司令:[士兵5个,任务完成!] 士兵 8任务完成! 士兵 7任务完成! 士兵 1任务完成! 士兵 0任务完成! 士兵 4任务完成! 司令:[士兵5个,任务完成!] 士兵 5任务完成! 士兵 3任务完成! 士兵 9任务完成! 士兵 2任务完成! 士兵 6任务完成! 司令:[士兵5个,任务完成!] 你会发现是每5个释放一次锁.</p>\n<h4><span id=\"locksupport\">LockSupport</span></h4><blockquote>\n<p>它可以在线程内任意位置让其阻塞 之前suspend和resume时,如果resume在suspend前执行,则一定会出现线程被无限挂起,导致无法正常退出. 我们可以用LockSupport解决这一问题.</p>\n</blockquote>\n<p>因为LockSupport是用信号量来实现的.它为每一个线程准备了一个许可,如果许可可用,则park()函数会立即返回,并且消费许可(变为不可用).如果许可不可用,就会被阻塞. 但和信号量不同的是,许可永远只有一个. LockSupport.park() LockSupport.unpark(Runnable) LockSupport.parkNanos() LockSupport.parkUtil() 此外,如果是用park(Object),则这个阻塞对象会出现在线程Dump中(报错),分析问题就更方便了.</p>\n<h3><span id=\"线程复用-线程池\">线程复用: 线程池</span></h3><blockquote>\n<p>多线程的软件设计方法确实可以最大限度的发挥现代多核处理器的计算能力,提高生产系统的吞吐量和性能。但是,若不加控制和管理的随意使用线程,对系统的性能反而会产生不利影响.</p>\n</blockquote>\n<p>一种极简的处理方法:</p>\n<pre><code>new Thread(new Runnable(){\n    public void run(){\n        //do sth\n    }\n}).start();</code></pre><p>这样的线程在run完后就会自动回收,但线程量过大时,则会耗尽CPU和内存资源. 而且如果为每一个小程序都创建一个线程,就可能出现销毁时间远大于该线程实际工作所消耗的时间. 其次,可能因线程过多而爆栈/堆. 大量的线程回收也会给GC造成很大压力,延长GC的停顿时间.</p>\n<h4><span id=\"什么是线程池\">什么是线程池</span></h4><p>为了避免系统频繁的创建和销毁线程,我们会尽量的让线程复用. <strong>数据库连接池:</strong> 为了避免每次数据库查询都重新建立和销毁数据库连接,我们可以使用数据库连接池保护一些数据库连接,让他们长期在激活状态.当系统需要数据库时,并不是真正创建一个新的连接,而是从连接池中获得一个可用的连接即可.反之,当需要关闭连接时,并不是真的把链接关闭,而是将这个链接还给连接池即可. <strong>线程池</strong>: 线程池中,总有那么几个活跃线程,当你需要时,可以从池子中随便拿一个空闲线程,当完成工作时,并不着急关闭线程,而是将这个线程退回到池子,方便别人使用. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/88267587709716bb6b7d5a183b7bea85.png\" alt> 换言之,创建线程变成了从池子中获得线程,销毁变成了归还.</p>\n<h4><span id=\"jdk内置线程池框架-executor\">JDK内置线程池框架: Executor</span></h4><blockquote>\n<p>框架结构图</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2c1925682e53b6a81146256a57ce2e88.png\" alt> 关于Executor的设计模式: 生产者-消费者模式和工厂方法 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6085df9c51bc40c12d4bee50128f9130.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/25117913abc15c1b6a431d930ac4c390.png\" alt> 例子:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class p36 {\n    public static class MyTask implements Runnable{\n        public void run(){\n            System.out.println(System.currentTimeMillis()+&quot;:Thread ID:&quot;+Thread.currentThread().getId());\n            try{\n                Thread.sleep(1000);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args){\n        // TODO Auto-generated method stub\n        MyTask task=new MyTask();\n        ExecutorService es=Executors.newFixedThreadPool(5);\n        for(int i=0;i&lt;10;++i){\n            es.submit(task);\n        }\n        es.shutdown();\n    }\n\n}</code></pre><p>可能我们之前一直对<strong>为什么我们传入submit的是一个对象,但他们得ID却不同呢?</strong> 这是因为线程的ID与对象并无直接关系,线程的ID是直接分配好的. 我们可以尝试打印出<strong>this.toString()</strong>来查看是否是同一个对象,结果表明确实是同一个对象,如果不想使用用同一个对象来做测试,那就用new MyTask()作为参数就可以了. 但直接new的话,会出现一个很严重的问题,就是new出来的对象的执行顺序可能产生混乱.因为不是同一个对象,所以就不会按照顺序来执行了. 例:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class p36 { \n    public static ReentrantLock lock=new ReentrantLock();\n    public static class MyTask implements Runnable{\n        private int kt=0;\n        public void cal(int t){\n            kt=kt+t;\n        }\n        public void run(){\n            //lock.lock();\n            cal(1);\n            //lock.unlock();\n            //System.out.println(System.currentTimeMillis()+&quot;:Thread ID:&quot;+Thread.currentThread().getId());\n            if(kt&gt;9990)\n                System.out.println(this.toString()+&quot; &quot;+kt);\n            try{\n                Thread.sleep(1);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        MyTask tk=new MyTask(); \n        Thread pk=new Thread(tk);\n        ExecutorService es=Executors.newFixedThreadPool(10);\n\n        for(int i=0;i&lt;10000;++i){\n            es.submit(tk);\n        }\n        es.shutdown();\n        System.out.println(&quot;AAAAAA&quot;+tk.kt);\n    }\n\n}</code></pre><p>打印后会发现,结果并不是正确的,甚至10000的数据前提下9990也不能保证. 当然,加上锁以后就正常了.</p>\n<h4><span id=\"刨根问底-核心线程池的内部实现\">刨根问底: 核心线程池的内部实现</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/7c53caa4fa9b345ab9b03b92bda61465.png\" alt></p>\n<h4><span id=\"拒接策略\">拒接策略</span></h4><p>P108</p>\n<h4><span id=\"扩展线程池\">扩展线程池</span></h4><blockquote>\n<p>ThreadPoolExecutor是一个可扩展的线程池 它为我们提供了三个接口</p>\n<blockquote>\n<p>beforeExecute() afterExecute() terminated()</p>\n</blockquote>\n</blockquote>\n<p>字面意思 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/852095dd0c714bd6f84dfbab510688f6.png\" alt> 我们重写一下试试:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class p37 {\n    public static class MyTask implements Runnable{\n        public String name;\n\n        public MyTask(String name){\n            this.name=name;\n        }\n\n        public void run(){\n            System.out.println(&quot;正在执行&quot;+&quot;:Thread ID:&quot;+Thread.currentThread().getId()+&quot;:Task Name:&quot;+name);\n            try{\n                Thread.sleep(1000);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        ExecutorService es=new ThreadPoolExecutor(5,5,0L,TimeUnit.MILLISECONDS,new LinkedBlockingDeque&lt;Runnable&gt;()){\n            @Override\n            protected void beforeExecute(Thread t,Runnable r){\n                System.out.println(&quot;准备执行: &quot;+((MyTask)r).name);\n            }\n\n            @Override\n            protected void afterExecute(Runnable r,Throwable t){\n                System.out.println(&quot;执行完成: &quot;+((MyTask)r).name);\n            }\n\n            @Override\n            protected void terminated(){\n                System.out.println(&quot;线程池退出&quot;);\n            }\n        };\n        for(int i=0;i&lt;5;++i){\n            MyTask task=new MyTask(&quot;TASK-GEYM-&quot;+i);\n            es.execute(task);\n            Thread.sleep(10);\n        }\n        es.shutdown();\n    }\n}</code></pre><p>注: shutdown方法会等所有的线程执行结束后才关闭线程池.</p>\n<h4><span id=\"合理的选择-优化线程池线程数量\">合理的选择: 优化线程池线程数量</span></h4><p>线程池的大小对系统的性能也有影响.过大或过小都不可以.但也不需要特别精确. 一般来说确定线程池的大小需要考虑CPU的数量,内存大小等因素. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2fdb2eba1f1763034b55e7c321ef1bab.png\" alt></p>\n<h4><span id=\"注线程池可能会吃掉异常\">注:线程池可能会吃掉异常</span></h4><p>而 execute方法会打印出部分异常, 或者修改submit的使用: Future re=pools.submit(new DivTask(100,0)); re.get(); 这样也可以.</p>\n<h4><span id=\"扩展threadpoolexecutor以显示异常\">扩展ThreadPoolExecutor以显示异常</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/be5bdfeba0ba5e3d7cf870cdd78a0747.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ca0feb96b4362f4ca128ce48747e546a.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/bf9c0ac33c3b0339653f64917ef6eb1b.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/bf1b6e3a4fae52e8b048039894cc3cd6.png\" alt></p>\n<h3><span id=\"分而治之-forkjoin框架\">分而治之: Fork/Join框架</span></h3><p>著名的MapReduce也是采用了分而治之的思想,简单来说,如果你要处理1000个数据,但是你并不具备处理1000个数据的能力,那么你可以只处理10个,然后,分阶段处理100个,将100个结果进行合成.就是1000个结果. JDK为我们提供了ForkJoinPool线程池. <strong>Fork/join执行逻辑</strong> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c06d16d76d0568a8e5133f62436d4b68.png\" alt> <strong>互相帮助的线程</strong> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c68c5120e1a1f1e9216f0948c0e543ff.png\" alt> 其中ForkJoinTask有两个重要的子类.关系如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c706a5a90f343ea864742a01af91ca8e.png\" alt> RecursiveTask&lt;&gt; 是实现一个compute函数(返回值要与泛型一致)即可. 例:</p>\n<pre><code>import java.util.ArrayList;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\n\npublic class p38 extends RecursiveTask&lt;Long&gt; {\n    private static final int THRESHOLD = 10000;\n    private long start;\n    private long end;\n\n    public p38(long start,long end){\n        this.start=start;\n        this.end=end;\n    }\n\n    public Long compute(){\n        long sum=0;\n        boolean canCompute=(end-start)&lt;THRESHOLD;\n        if(canCompute){\n            ///如果大于THRESHOLD的话才进行分解,否则直接进行即可\n            for(long i=start;i&lt;=end;++i){\n                sum+=i;\n            }\n        }else{\n            //分成100个小任务(整块)\n            long step=(start+end)/100;\n            ArrayList&lt;p38&gt; subTasks=new ArrayList&lt;p38&gt;();\n            long pos=start;\n            for(int i=0;i&lt;100;++i){\n                long lastOne=pos+step;\n                if(lastOne&gt;end)lastOne=end;\n                p38 subTask=new p38(pos,lastOne);\n                pos+=step+1;\n                subTasks.add(subTask);\n                //使用fork提交子任务\n                subTask.fork();\n            }\n            //所有子任务结束后,再次求和\n            for(p38 t:subTasks){\n                sum+=t.join();\n            }\n        }\n        return sum;\n    }\n\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        ForkJoinPool forkjoinpool=new ForkJoinPool();\n        p38 task=new p38(0,200000L);\n        ForkJoinTask&lt;Long&gt; result=forkjoinpool.submit(task);\n        try{\n            long res=result.get();\n            System.out.println(&quot;sum=&quot;+res);\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n}</code></pre><h4><span id=\"什么时候要加锁\">什么时候要加锁?</span></h4><p>如果只是读操作，没有写操作，则可以不用加锁，此种情形下，变量加上final关键字； 如果有写操作，但是变量的写操作跟当前的值无关联，且与其他的变量也无关联，则可考虑变量加上volatile关键字，同时写操作方法通过synchronized加锁； 如果有写操作，且写操作依赖变量的当前值(如：i++)，则getXXX和写操作方法都要通过synchronized加锁。 线程池是自带锁的.</p>\n<h3><span id=\"jdk-并发容器\">JDK 并发容器</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0096034273dcb98f075add481ae7e975.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/a783c28c5e7b94a1fe4171318ae14cf4.png\" alt> Tip: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2dda3fce55b9b7aac0ae9da17b57d594.png\" alt> 这点有点迷:P128 其中CopyOnWrite是高效的读取,在这个容器中,写入不会阻塞读取.</p>\n<h4><span id=\"跳表\">跳表</span></h4><p>跳表是一种可以快速查找的数据结构,它有点类似于平衡树,它只需要部分锁即可,而跳表的时间复杂度也是O(log n) 更多的数据结构可以见线程那个包 Done</p>\n","categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]}