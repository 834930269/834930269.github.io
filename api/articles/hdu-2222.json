{"title":"HDU 2222","slug":"hdu-2222","date":"2018-03-10T13:20:19.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/hdu-2222.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1><span id=\"type-ac自动机\">Type: AC自动机</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你几个子串,再给你一个主串,问你有多少个子串在主串中出现过.</p>\n</blockquote>\n<h1><span id=\"输入\">输入</span></h1><blockquote>\n<p>T,N,接下来N行输入N个字符串,最后一行输入一个主串.</p>\n</blockquote>\n<h1><span id=\"输出\">输出</span></h1><blockquote>\n<p>一个整数,有多少子串可以在主串中被匹配到</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>注意,每个子串可能是相同的,所以我们不能在尾节点记录子串的下标,而应该记录子串的个数.最后加进去即可</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    int ch[maxn][sigma_size];\n    int f[maxn],last[maxn];\n    int cnt[maxn],val[maxn];\n    int siz;\n\n    int ans;\n\n    void init(){\n        siz=ans=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///表示以第u棵节点为字符串最后一个字符节点的个数\n       ///如果想存储该节点代表的是哪个字符串.即存储该字符串的下标\n       ///val[u]=v;(v是下标)\n       ///但是这样存储就会出现无法统计之前有多少个重复字符串\n       ///比如这道题如果输入\n       ///3\n       ///sha\n       ///sha\n       ///sha\n       ///shashasha\n       ///则用第一种方法最后结果是3\n       ///但用第二种方法只能匹配一次sha\n       val[u]++;\n    }\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        if(u){\n            if(!cnt[u]) ans+=val[u],cnt[u]=1;\n            add(last[u]);\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i]);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre>","categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"HDU","slug":"AC自动机/HDU","count":2,"path":"api/categories/AC自动机/HDU.json"},{"name":"字符串处理","slug":"AC自动机/HDU/字符串处理","count":2,"path":"api/categories/AC自动机/HDU/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]}