{"title":"UVa 442","slug":"uva-442","date":"2017-01-24T15:17:02.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-442.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>【类型】 数据结构,栈,STL 【Tip】 这道题和四则运算入栈规则一样,是数字入栈,凡遇到 ‘)’ 则操作前两个字符(这里是矩阵). 矩阵链乘,A(m,n),B(n,d).A(n)==B(n)才成立. 注意.入栈顺序与出栈顺序是相反的,而矩阵链乘不满足乘法交换律.所以(AB)!=(BA)也存在(AB)有值(BA)无值. (这道题没在每条语句执行结束时清空栈,意在.in数据全部有效?)(大雾 【Code】</p>\n<blockquote>\n<p><strong><em>#include<iostream></iostream></em></strong> <strong><em>#include<algorithm></algorithm></em></strong> <strong><em>#include<cstdio></cstdio></em></strong> <strong><em>#include<cstring></cstring></em></strong> <strong><em>#include<stack></stack></em></strong> <strong><em>#include<string></string></em></strong> <strong><em>using namespace std;</em></strong> <strong><em>struct Matrix{</em></strong> <strong>_    int m,n;_</strong> <strong>_    Matrix(int a=0,int b=0):m(a),n(b) {}_</strong> <strong><em>}m[27];</em></strong> <strong><em>stack<matrix> s;</matrix></em></strong> <strong><em>int main(){</em></strong> <strong>_    int n;_</strong> <strong>_    scanf(“%d”,&amp;n);_</strong> <strong>_    for(int i=0;i&lt;n;++i){_</strong> <strong>_        string name;_</strong> <strong>_        cin&gt;&gt;name;_</strong> <strong>_        int k=name[0]-‘A’;_</strong> <strong>_        scanf(“%d%d”,&amp;m[k].m,&amp;m[k].n);_</strong> <strong>_    }_</strong> <strong>_    string expt;_</strong> <strong>_    while(cin&gt;&gt;expt){_</strong> <strong>_        int len=expt.length();_</strong> <strong>_        bool error=false;_</strong> <strong>_        int ans=0;_</strong> <strong>_        for(int i=0;i&lt;len;++i){_</strong> <strong>_            if(isalpha(expt[i])) s.push(m[expt[i]-‘A’]);_</strong> <strong>_            else if(expt[i]==’)’){_</strong> <strong>_                Matrix m2=s.top();s.pop();//这两句注意顺序.比如(AB)肯定是A先入栈,所以第一个出栈的肯定是B_</strong> <strong>_                Matrix m1=s.top();s.pop();_</strong> <strong>_                if(m1.n!=m2.m){_</strong> <strong>_                    error=true;_</strong> <strong>_                    break;_</strong> <strong>_                }else{_</strong> <strong>_                    ans+=m1.n*m1.m*m2.n;_</strong> <strong>_                    s.push(Matrix(m1.m,m2.n));_</strong> <strong>_                }_</strong> <strong>_            }_</strong> <strong>_        }_</strong> <strong>_        if(error) printf(“error\\n”);_</strong> <strong>_        else printf(“%d\\n”,ans);_</strong> <strong>_    }_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>Save</p>\n","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}