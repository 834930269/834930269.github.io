{"title":"字符串匹配模板","slug":"zfcpp","date":"2017-04-16T14:03:29.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/zfcpp.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Trie树】</strong> <strong>–数组实现</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int sigma_size=26;</strong> <strong>const int maxnode=1000;</strong> <strong>//字母表为全体小写字母的Trie</strong> <strong>struct Trie{</strong> **    int ch[maxnode][sigma_size];** **    int val[maxnode];** **    int sz;         //节点总数** **    Trie() {sz=1; memset(ch[0],0,sizeof(ch[0])); }//初始时只有一个根节点** **    int idx(char c) {return c-‘a’;} //字符c的编号** **    //插入字符串s,附加信息为v。注意v必须非0,因为0代表”本节点不是单词结点”** **    void In(char <em>s,int v){*</em> **        int u=0,n=strlen(s);** **        for(int i=0;i&lt;n;++i){** **            int c=idx(s[i]);** **            if(!ch[u][c]){  //结点不存在** **                memset(ch[sz],0,sizeof(ch[sz]));** **                val[sz]=0;          //中间结点的附加信息为0** **                ch[u][c]=sz++;      //新建结点** **            }** **            u=ch[u][c];             //往下走** **        }** **        val[u]=v;                   //字符串的最后一个字符的附加信息为v** **    }** **    int Se(char <em>s){*</em> **        int u=0,n=strlen(s);** **        for(int i=0;i&lt;n;++i){** **            int c=idx(s[i]);** **            if(!ch[u][c]) return 0;//单词不存在** **            u=ch[u][c];** **        }** **        return 1;//存在单词** **    }** <strong>};</strong> <strong>int main(){</strong> **    int N;** **    Trie <em>tr=new Trie;*</em> **    char str[11]=””;** **    scanf(“%d”,&amp;N);** **    while(N–){** **        scanf(“%s”,str);** **        tr-&gt;In(str,66);** **    }** **    scanf(“%d”,&amp;N);** **    while(N–){** **        scanf(“%s”,str);** **        printf(“%d\\n”,tr-&gt;Se(str));//1为存在单词,0为不存在** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>–链表实现</strong></p>\n<blockquote>\n<p>**#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>struct Tree{//以0-26作为Tree的头结点<br>    int num;<br>    Tree* Next[26];<br>    Tree(){<br>        num=0;<br>        int i;<br>        for(i=0;i&lt;26;i++)<br>            Next[i]=NULL;<br>    }<br>}T;</p>\n<p>void In(char <em>str){<br>    Tree</em> H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL)//只有微为空才允许创建<br>            H-&gt;Next[str[i]-‘a’]=new Tree;//想调用构造函数必须new一个Tree<br>        H=H-&gt;Next[str[i]-‘a’];<br>        H-&gt;num++;<br>    }<br>}</p>\n<p>int Se(char *str){<br>    Tree *H=&T;<br>    for(int i=0;str[i];i++){<br>        if(H-&gt;Next[str[i]-‘a’]==NULL) return 0;<br>        H=H-&gt;Next[str[i]-‘a’];<br>    }<br>    return H-&gt;num;<br>}</p>\n<p>int main(){<br>    int N;<br>    char str[11]=””;<br>    scanf(“%d”,&amp;N);</p>\n<pre><code>while(N--){\n    scanf(&quot;%s&quot;,str);\n    In(str);\n}\n\nscanf(&quot;%d&quot;,&amp;N);\nwhile(N--){\n    scanf(&quot;%s&quot;,str);\n    printf(&quot;%d\\\\n&quot;,Se(str));\n}\n\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n<p><strong>【KMP】</strong> <strong>kmpN() 作用:构造next数组 参数:模式串,模式串长度 kmpC() 作用:返回模式串在主串中出现的次数(可重复) 参数:模式串,模式串长度,主串,主串长度</strong></p>\n<blockquote>\n<p><em>*`int nex[maxn];<br>void kmpN(char</em> x,int len) {<br>  int i=0,j=nex[0]=-1;<br>  while(i&lt;len) {<br>    while(j!=-1&amp;&amp;x[i]!=x[j])j=nex[j];<br>    nex[++i]=++j;<br>  }<br>}</p>\n<p>int kmpC(char x[],int m,char y[],int n) {<br>  int i=0,j=0,ans=0;<br>  while(i&lt;n) {<br>    while(-1!=j&amp;&amp;y[i]!=x[j])j=nex[j];<br>    i++; j++;<br>    if(j&gt;=m) {<br>      ans++;<br>      j=nex[j];<br>    }<br>  }<br>  return ans;<br>}`** </p>\n</blockquote>\n<p><strong>【后缀数组】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=10000+10;</strong> <strong>char s[maxn];</strong> <strong>int sa[maxn],t[maxn],t2[maxn],c[maxn],n;//n是文本串的长度</strong> <strong>//构造字符串s的后缀数组。每个字符值必须为0~m-1</strong> <strong>void build_sa(int m){</strong> <em>*    int i,*x=t,*y=t2;** **    //基数排序** **    for(i=0;i&lt;m;++i) c[i]=0;** **    for(i=0;i&lt;n;++i) c[x[i]=s[i]]++;** **    for(i=1;i&lt;m;++i) c[i]+=c[i-1];** **    for(i=n-1;i&gt;=0;–i) sa[–c[x[i]]]=i;** **    for(int k=1;k&lt;=n;k&lt;&lt;=1){** **        int p=0;** **        //直接用sa数组排序第二关键字** **        for(i=n-k;i&lt;n;++i) y[p++]=i;** **        for(i=0;i&lt;n;++i) if(sa[i]&gt;=k) y[p++] = sa[i]-k;** **        //基数排序第一关键字** **        for(i=0;i&lt;m;++i) c[i]=0;** **        for(i=0;i&lt;n;++i) c[x[y[i]]]++;** **        for(i=0;i&lt;m;++i) c[i]+=c[i-1];** **        for(i=n-1;i&gt;=0;i–) sa[–c[x[y[i]]]]=y[i];** **        //根据sa和y数组计算新的x数组** **        swap(x,y);** **        p=1;x[sa[0]]=0;** **        for(i=1;i&lt;n;++i)** **            x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++;** **        if(p&gt;=n) break; //以后即使继续倍增,sa也不会改变,退出** **        m=p;    //下次基数排序的最大值** **    }** <strong>}</strong> <strong>int m;  //模板长度。简单起见,这里存在全局变量中</strong> **int cmp_suffix(char</em> pattern,int p){//判断模板s是否为后缀p的前缀<em>* **    return strncmp(pattern,s+sa[p],m);** <strong>}</strong> **int find(char</em> P){** **    m=strlen(P);** **    if(cmp_suffix(P,0)&lt;0) return -1;** **    if(cmp_suffix(P,n-1)&gt;0) return -1;** **    int L=0,R=n-1;** **    while(R&gt;=L){            //二分查找** **        int M=L+(R-L)/2;** **        int res=cmp_suffix(P,M);** **        if(!res) return M;** **        if(res&lt;0) R=M-1; else L=M+1;** **    }** **    return -1;              //找不到** <strong>}</strong> <strong>int main(){</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"},{"name":"模板","slug":"未分类/模板","count":3,"path":"api/categories/未分类/模板.json"}],"tags":[]}