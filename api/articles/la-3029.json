{"title":"LA 3029","slug":"la-3029","date":"2017-04-05T13:07:21.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3029.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【类型】</strong> <strong>扫描线,悬线法</strong> <strong>【题解】</strong> <strong>蓝书P50</strong> <strong><a href=\"http://blog.csdn.net/qq415200973/article/details/11377199\" target=\"_blank\" rel=\"noopener\">扫描方程的解释</a></strong> <strong>我对代码的理解放在代码里了.</strong> <strong>如果为满：left[i][j]=0,right[i][j]=n,up[i][j]=0,这里是为了下一行的比较做准备。可以模拟试一试。</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>using namespace std;</strong> <strong>const int maxn=1000;</strong> <strong>int mat[maxn][maxn],up[maxn][maxn],left[maxn][maxn],right[maxn][maxn];</strong> <strong>int readchar(){</strong> <em>*    int a=getchar();** **    while(a!=’F’ &amp;&amp; a!=’R’) a=getchar();** **    return a;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int m,n;** **        scanf(“%d%d”,&amp;m,&amp;n);** **        for(int i=0;i&lt;m;++i)** **            for(int j=0;j&lt;n;++j){** **                int ch=getchar();** **                while(ch!=’F’ &amp;&amp; ch!=’R’) ch=getchar();** **                mat[i][j]=ch==’F’?0:1;** **            }** **        int ans=0;** **        for(int i=0;i&lt;m;++i){//从上到下逐行处理** **            int lo=-1,ro=n;** **            for(int j=0;j&lt;n;++j)//从左向右处理** **                if(mat[i][j]==1){left[i][j]=up[i][j]=0;lo=j;}** **                else{** **                    up[i][j]=i==0?1:up[i-1][j]+1;** **                    //lo存的是左边界的下标,而不是到左边将诶有多少空地** **                    //这里,每次遇到障碍(1)时,lo就等于j(重新开始计算左边界)** **                    //然后,left[i][j]存的是当前矩阵的右边界** **                    //这里是lo+1,而不是lo++,所以lo的值在碰到障碍前一直不变** **                    //因为受到上一行的影响,所以需要在上一行和本行中选取一个最大** **                    //下标的左边界.** **                    left[i][j]=i==0?lo+1:max(left[i-1][j],lo+1);** **                }** **            for(int j=n-1;j&gt;=0;–j)//从右往左扫描,维护right并更新答案** **                if(mat[i][j]==1){right[i][j]=n;ro=j;}** **                //为啥等于n捏？？？** **                //为了使其下一行若是空格,作比较的时候,会发现上一行的下标一定是最大的** **                //从而不影响下一行右边界的计算** **                else{** **                    right[i][j]=i==0?ro-1:min(right[i-1][j],ro-1);** **                    ans=max(ans,up[i][j]</em>(right[i][j]-left[i][j]+1));** **                }** **        }** **        printf(“%d\\n”,ans<em>3);*</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"悬线法","slug":"LA/思维/悬线法","count":1,"path":"api/categories/LA/思维/悬线法.json"}],"tags":[{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"}]}