{"title":"POJ 2739","slug":"poj-2739","date":"2017-04-02T04:46:21.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-2739.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【生词】</strong> <strong>Consecutive 连贯的,连续不断的</strong> <strong>represented 代表,表现,描写</strong> <strong>such 这样的</strong> <strong>【Tip】</strong> <strong>不能全部预处理,一旦发现往下加就退出循环,否则会TLE.当然,可以更加优化,不过过了= =///.</strong>   <strong>12：50 搜了一下题解,好吧,是尺取法.思路和我的差不多,选定好右端点,然后通过不断扩大左端点来寻找解.一旦脱离了最大范围,就退出循环.</strong> <strong>PS:这道题尺取法也可以继续优化..只需要遍历到5000就可以了,5000以后通过判断is_prime? it[i]+1 : it[i];来搞定?</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>const int maxn=20000;</strong> <strong>bool is_prime[maxn+1];</strong> <strong>int prime[maxn],p;</strong> <strong>void sieve(int n){</strong> **    p=0;** **    for(int i=0;i&lt;=n;i++) is_prime[i]=true;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;=n;i++){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=n;j+=i)*</em> **                is_prime[j]=false;** **        }** **    }** <strong>}</strong> <strong>int it[maxn];</strong> <strong>void init(int N){</strong> **    memset(it,0,sizeof(it));** **    //&amp;&amp; prime[i]&lt;N** **    for(int i=0;i&lt;p;++i){** **        int t=i;** **        while(t&gt;=0){** **            long long ans=0;** **            for(int j=t;j&lt;=i;++j)** **                ans+=prime[j];** **            if(ans&gt;=10000)** **                break;** **            it[ans]++;** **            t–;** **        }** **    }** <strong>}</strong> <strong>int main(){</strong> **    sieve(10000);** **    init(5000);** **    int T;** **    while(~scanf(“%d”,&amp;T) &amp;&amp; T){** <strong>//        if(T&lt;5000)</strong> **            printf(“%d\\n”,it[T]);** <strong>//        else if(is_prime[T])</strong> <strong>//            printf(“%d\\n”,it[T]+1);</strong> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]}