{"title":"Let's Gank Java - 7st","slug":"lets-gank-java-7st","date":"2017-11-17T14:09:00.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-7st.json","photos":[],"link":"","excerpt":null,"covers":["http://be-sunshine.cn/wp-content/uploads/2017/11/%E6%8D%95%E8%8E%B7-1.png"],"content":"<p>Action : Thread Unit. Demo:</p>\n<pre><code>import java.util.*;\nimport java.text.*;\npublic class ThreadDemo {\n    public static void main(String[] args){\n        Counter c1 = new Counter(1);\n        Thread t1=new Thread(c1);\n        Thread t2=new Thread(c1);\n        Thread t3=new Thread(c1);\n        Counter c2=new Counter(2);\n        Thread t4=new Thread(c2);\n        Thread t5=new Thread(c2);\n        Thread t6=new Thread(c2);\n        TimeDisplay timer = new TimeDisplay();\n        Thread t7 = new Thread(timer);\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        t6.start();\n        t7.start();\n    }\n}\n\nclass Counter implements Runnable{\n    int id;\n    Counter(int id){//构造函数,为count指定id\n        this.id = id;\n    }\n\n    public void run(){//重写runnable的run()\n        int i=0;\n        while(i++&lt;10){\n            System.out.println(&quot;ID: &quot;+id+&quot; No.&quot; + i);\n            try{\n                Thread.sleep(10);\n            }catch(InterruptedException e){}\n        }\n    }\n}\n\nclass TimeDisplay implements Runnable{\n    public void run(){//重写runnable的run()\n        int i=0;\n        while(i++&lt;=3){\n            System.out.println(\n                    new SimpleDateFormat().format(new Date()));\n            try{\n                Thread.sleep(40);\n            }catch(InterruptedException e){}\n        }\n    }\n}</code></pre><p>Output:</p>\n<pre><code>ID: 1 No.1\nID: 1 No.1\nID: 2 No.1\nID: 2 No.1\nID: 2 No.1\nID: 1 No.1\nID: 2 No.2\nID: 1 No.2\nID: 2 No.2\nID: 1 No.2\nID: 1 No.2\nID: 2 No.2\nID: 2 No.3\nID: 1 No.3\nID: 2 No.3\nID: 1 No.3\nID: 1 No.3\nID: 2 No.3\nID: 1 No.4\nID: 2 No.4\nID: 2 No.4\nID: 1 No.4\nID: 1 No.4\nID: 2 No.4\nID: 2 No.5\nID: 1 No.5\nID: 1 No.5\nID: 1 No.5\nID: 2 No.5\nID: 2 No.5\nID: 1 No.6\nID: 1 No.6\nID: 1 No.6\nID: 2 No.6\nID: 2 No.6\nID: 2 No.6\nID: 1 No.7\nID: 1 No.7\nID: 2 No.7\nID: 1 No.7\nID: 2 No.7\nID: 2 No.7\nID: 1 No.8\nID: 2 No.8\nID: 2 No.8\nID: 1 No.8\nID: 1 No.8\nID: 2 No.8\n17-11-18 下午1:50\nID: 1 No.9\nID: 2 No.9\nID: 1 No.9\nID: 1 No.9\nID: 2 No.9\nID: 2 No.9\nID: 2 No.10\nID: 1 No.10\nID: 2 No.10\nID: 1 No.10\nID: 1 No.10\nID: 2 No.10\n17-11-18 下午1:50\n17-11-18 下午1:50\n17-11-18 下午1:50</code></pre><p>可以看到他们并不是一个运行完才继续运行下一个的.这就是多线程. Demo 2: 多线程下载文件</p>\n<pre><code>import java.util.*;\nimport java.io.*;\nimport java.net.*;\npublic class ThreadDownload {\n    public static void main(String[] args)\n        throws IOException\n    {\n        //网址变量\n        final URL[] urls = {\n                new URL(&quot;http://www.pku.edu.cn&quot;),\n                new URL(&quot;http://www.baidu.com&quot;),\n                new URL(&quot;http://www.sina.com.cn&quot;),\n                new URL(&quot;http://www.dstang.com&quot;)\n        };\n        //下载完成后存储的文件名\n        final String[] files = {\n                &quot;pku.htm&quot;, \n                &quot;baidu.htm&quot;,\n                &quot;sina.htm&quot;, \n                &quot;study.htm&quot;,\n        };\n\n        for(int i=0;i&lt;urls.length;++i){\n            final int idx=i;\n            new Thread(()-&gt;{\n                try{\n                    System.out.println(urls[idx]);\n                    download( urls[idx], files[idx]);\n                }catch(Exception ex){\n                    ex.printStackTrace();\n                }\n            }).start();\n        }\n    }\n    static void download(URL url,String file)\n        throws IOException\n    {\n        //创建度入流和写入文件流\n        try(InputStream input=url.openStream();\n            OutputStream output = new FileOutputStream(\n            file))\n        {\n            //每次存入的byte数组\n            byte[] data = new byte[1024];\n            int length;\n            //存入，第二个参数offset表示从data的下标为几开始写入\n            while((length=input.read(data))!=-1){\n                output.write(data, 0, length);\n            }\n        }\n    }\n}</code></pre><p>Output:</p>\n<pre><code>http://www.pku.edu.cn\nhttp://www.baidu.com\nhttp://www.sina.com.cn\nhttp://www.dstang.com\n\n文件在主目录下.</code></pre><p>Demo 3: 多线程画图 结果图: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/捕获-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/%E6%8D%95%E8%8E%B7-1.png\" alt></a> Code:</p>\n<pre><code>import java.awt.*;\nimport java.applet.*;\nimport java.awt.event.*;\nimport javax.swing.*;\npublic class ThreadDrawJ extends JFrame {\n    MovingShape [] shapes;\n    public void init(){\n        setLayout(null);\n        setSize(426,266);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setVisible(true);\n\n        shapes = new MovingShape[10];\n        for(int i=0;i&lt;shapes.length;++i){\n            shapes[i] = new MovingShape(this);\n            shapes[i].start();\n        }\n    }\n    public static void main(String [] args) //加入main,使之能当Application应用\n    {\n        ThreadDrawJ f = new ThreadDrawJ();\n        f.init();\n    }\n}\n\nclass MovingShape extends Thread{\n    private int size = 100;\n    private int speed=10;\n    private Color color;\n    private int type;\n    private int x,y,w,h,dx,dy;\n    protected java.awt.Component app;\n\n    public boolean stopped;\n\n    MovingShape(JFrame app){\n        this.app=app;\n        x=(int)(Math.random()*app.getSize().width);\n        y=(int)(Math.random()*app.getSize().height);\n        w=(int)(Math.random()*size);\n        h=(int)(Math.random()*size);\n        dx = (int)(Math.random() * speed );\n        dy = (int)(Math.random() * speed );\n        color = new Color ( \n            (int)(Math.random()*128+128), \n            (int)(Math.random()*128+128),\n            (int)(Math.random()*128+128) );\n        type = (int)(Math.random() * 3 );\n    }\n\n    public void run(){\n        while(true){\n            if(stopped) break;\n\n            //draw(),多线程方法必须卸载invoke中\n            SwingUtilities.invokeLater( ()-&gt;{\n                draw(); \n            });\n\n            try{ Thread.sleep(130);}catch(InterruptedException e){}\n        }\n    }\n    void draw(){\n        x+=dx;\n        y+=dy;\n        //控制边界\n        if(x&lt;0 || x+w&gt;app.getSize().width) dx=-dx;\n        if(y&lt;0 || y+h&gt;app.getSize().height) dy=-dy;\n\n        Graphics g=app.getGraphics();\n        switch(type){\n            case 0:\n                //矩形\n                g.setColor(color);\n                g.fillRect( x,y,w,h ); \n                g.setColor( Color.black );\n                g.drawRect( x,y,w,h );\n                break;\n            case 1:\n                //椭圆\n                g.setColor(color);\n                g.fillOval( x,y,w,h ); \n                g.setColor( Color.black );\n                g.drawOval( x,y,w,h );\n                break;\n            case 2:\n                //圆角矩形\n                g.setColor(color);\n                g.fillRoundRect( x,y,w,h,w/5,h/5); \n                g.setColor( Color.black );\n                g.drawRoundRect( x,y,w,h,w/5,h/5 );\n                break;\n        }\n    }\n}</code></pre><p>针对线程全局变量不会因线程执行而改变混乱. JDK 1.5+ 提供了原子变量,以及并发的泛型类型.</p>\n","categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]}