{"title":"python3学习 生成器+杨辉三角+yield+异常StopIteration","slug":"python3-yield-stopiteration","date":"2017-07-12T08:04:07.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-yield-stopiteration.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/generator/%E7%94%9F%E6%88%90%E5%99%A8.py\" target=\"_blank\" rel=\"noopener\">github: 生成器.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>‘’’<br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，<br>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，<br>那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元<br>素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制<br>，称为生成器：generator。<br>‘’’</p>\n<p>#要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：<br>L=[x<em>x for x in range(10)]<br>print(L)<br>g=(x</em>x for x in range(10))<br>print(g)</p>\n<p>#out[1]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</p>\n<p>#out[2]:  at 0x0000000004C2FB48&gt;</p>\n<p># In[3]:</p>\n<p>‘’’<br>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>\n<p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？</p>\n<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：<br>generator必须紧跟着输入,否则用next()只能输出一次循环</p>\n<p>‘’’<br>g=(x*x for x in range(10))<br>i=0<br>while i&lt;10:<br>    print(next(g))<br>    i+=1</p>\n<p># In[10]:</p>\n<p>#用for<br>g=(x*x for x in range(10))<br>for n in g:<br>    print(n)</p>\n<p># In[6]:</p>\n<p>#斐波那契</p>\n<p>#注意,赋值语句 a,b=b,a+b</p>\n<p>#相当于<br>‘’’<br>t = (b, a + b) # t是一个tuple<br>a = t[0]<br>b = t[1]</p>\n<p>‘’’<br>def fib(max):<br>    n,a,b=0,0,1<br>    while n</p>\n<p>#想要在循环中得到fib2的return值,必须捕获StopIteration错误返回值包括在</p>\n<p>#其中的value中<br>while True:<br>    try:<br>        x=next(f)<br>        print(‘f:’,x)<br>    except StopIteration as ev:<br>        print(‘Generator return value:’,ev.value)<br>        break</p>\n<p># In[17]:</p>\n<p>#yield举例<br>def odd():<br>    print(‘step 1’)<br>    yield 1<br>    print(‘step 2’)<br>    yield(3)<br>    print(‘step 3’)<br>    yield(5)<br>o=odd()<br>print(‘之前没输出’)<br>for n in o:<br>    print(n)</p>\n<p># In[ ]:</p>\n<p>#test<br>‘’’<br>杨辉三角定义如下：</p>\n<pre><code>      1\n    1   1\n  1   2   1\n1   3   3   1</code></pre><p>  1   4   6   4   1<br>1   5   10  10  5   1<br>‘’’<br>def triangles():<br>    L=[1]<br>    while True:<br>        yield L<br>        l=len(L)<br>        R=[1]<br>        for i in range(1,l):<br>            R.append(L[i-1]+L[i])<br>        R.append(1)<br>        L=R[:]<br>‘’’<br>第二种解法,中间为中间列表,和上面一样,只不过直接加起来了,避免了中间变量<br>def triangles():<br>l = [1]<br>while True:<br>    yield l<br>    l = [1] + [l[i]+l[i+1] for i in range(len(l)-1)] + [1]<br>‘’’<br># 期待输出:<br># [1]<br># [1, 1]<br># [1, 2, 1]<br># [1, 3, 3, 1]<br># [1, 4, 6, 4, 1]<br># [1, 5, 10, 10, 5, 1]<br># [1, 6, 15, 20, 15, 6, 1]<br># [1, 7, 21, 35, 35, 21, 7, 1]<br># [1, 8, 28, 56, 70, 56, 28, 8, 1]<br># [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]<br>n = 0<br>for t in triangles():<br>    print(t)<br>    n = n + 1<br>    if n == 10:<br>        break**</p>\n","categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}