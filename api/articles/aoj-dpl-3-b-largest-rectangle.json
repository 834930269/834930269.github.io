{"title":"AOJ DPL_3 B Largest Rectangle","slug":"aoj-dpl-3-b-largest-rectangle","date":"2017-11-19T08:22:23.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-dpl-3-b-largest-rectangle.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"Largest-Rectangle\"><a href=\"#Largest-Rectangle\" class=\"headerlink\" title=\"Largest Rectangle\"></a>Largest Rectangle</h1><p>Given a matrix (H × W) which contains only 1 and 0, find the area of the largest rectangle which only contains 0s.</p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>H W<br>c1,1 c1,2 … c1,W<br>c2,1 c2,2 … c2,W<br>:<br>cH,1 cH,2 … cH,W</p>\n<p>In the first line, two integers H and W separated by a space character are given. In the following H lines, ci,j, elements of the H × W matrix, are given.</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>Print the area (the number of 0s) of the largest rectangle.</p>\n<h2 id=\"Constraints\"><a href=\"#Constraints\" class=\"headerlink\" title=\"Constraints\"></a>Constraints</h2><ul>\n<li>1 ≤ H, W ≤ 1,400</li>\n</ul>\n<h2 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h2><p>4 5<br>0 0 1 0 0<br>1 0 0 0 0<br>0 0 0 1 0<br>0 0 0 1 0</p>\n<h2 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h2><p>6</p>\n<p>最大子矩阵(直方图)的变形. 首先需要把每一行都预处理成<code>距离第0行</code>的高度的表.然后每一行都相当于一个直方图,对每个直方图求可以围成的所有矩形面积,用<code>maxv维护</code>最大矩形的值.</p>\n<pre><code>例 处理前:\n    0 0 1 0 0\n    1 0 0 0 0\n    0 0 0 1 0\n    0 0 0 1 0\n\nAfter 处理后:\n    1 1 0 1 1\n    0 2 1 2 2\n    1 3 2 0 3\n    2 4 3 0 4</code></pre><p>Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size,int buffer[]){\n    stack&lt;Rectangle&gt; S;\n    int maxv=0;\n    //通过后一位向前面的计算\n    //这里用到的DP大概是无参数getLargestRectangle里面的预处理\n    //这里用到的更多是思维吧,对每一行进行计算,最后求出最大值.\n    buffer[size]=0;\n\n    for(int i=0;i&lt;=size;++i){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height &lt; rect.height){\n                S.push(rect);\n            }else if(S.top().height &gt; rect.height){\n                int target=i;\n                while(!S.empty() &amp;&amp; S.top().height &gt;= rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    //printf(&quot;\\nmaxv: %d\\n&quot;,maxv);\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    //预处理每个点离他最近的上边未被污染地板的高度\n    for(int j=0;j&lt;W;++j){\n        for(int i=0;i&lt;H;++i){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i&gt;0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    /*\n    例:\n        0 0 1 0 0\n        1 0 0 0 0\n        0 0 0 1 0\n        0 0 0 1 0\n\n    After:\n        1 1 0 1 1\n        0 2 1 2 2\n        1 3 2 0 3\n        2 4 3 0 4\n    */\n    int maxv=0;\n    //传入两个值 W,列数,处理后T[i]第i行的首地址\n    for(int i=0;i&lt;H;++i){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(&quot;%d %d&quot;,&amp;H,&amp;W);\n    for(int i=0;i&lt;H;++i){\n        for(int j=0;j&lt;W;++j){\n            scanf(&quot;%d&quot;,&amp;buffer[i][j]);\n        }\n    }\n\n    printf(&quot;%d\\n&quot;,getLargestRectangle());\n    return 0;\n}</code></pre>","categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"动态规划","slug":"AOJ/动态规划","count":1,"path":"api/categories/AOJ/动态规划.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}