{"title":"Node.js-Koa-渲染","slug":"node-js-koa-render","date":"2017-10-02T07:30:56.000Z","updated":"2019-07-03T13:51:36.854Z","comments":true,"path":"api/articles/node-js-koa-render.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>模块依赖的是:</p>\n<pre><code>&quot;dependencies&quot;: {\n    &quot;nunjucks&quot;: &quot;2.4.2&quot;\n}</code></pre><p>nunjucks. 廖大说很像Jinja2,确实. 首先依然是目录结构,与其他无大差异. 然后是编写app.js中调用渲染的模块:</p>\n<pre><code>const nunjucks = require(&apos;nunjucks&apos;);\n\nfunction createEnv(path,opts){\n    var\n        autoescape=opts.autoescape===undefined?true:opts.autoescape,\n        noCache = opts.noCache || false,\n        watch = opts.watch || false,\n        throwOnUndefined = opts.throwOnUndefined || false,\n        env = new nunjucks.Environment(\n            new nunjucks.FileSystemLoader(&apos;views&apos;,{\n                noCache:noCache,\n                watch:watch,\n            }),{\n                autoescape: autoescape,\n                throwOnUndefined: throwOnUndefined\n            });\n    if(opts.filters){\n        for(var f in opts.filters){\n            env.addFilter(f,opts.filters[f]);\n        }\n    }\n    return env;\n}\n\nvar env=createEnv(&apos;views&apos;,{\n    watch:true,\n    filters:{\n        hex:function(n){\n            return &apos;0x&apos;+n.toString(16);\n        }\n    }\n});</code></pre><p>其中noCache是禁止缓冲,当程序发布时,这个必须是Cache,否则对性能的影响略大. 接下来就对模板html进行渲染了! 首先我们编写一个hello.html:</p>\n<pre><code> &lt;h1&gt;Hello { { name }}&lt;/h1&gt;\n&lt;!-- 循环输出名字 --&gt;\n&lt;body&gt;\n    &lt;h3&gt;Fruits List&lt;/h3&gt;\n    {% for f in fruits %}\n        <p>{ { f }}</p>\n        {% endfor %}\n&lt;/body&gt;</code></pre><p>对其中的 name 和 fruits(List)进行渲染: 代码位于app.js</p>\n<pre><code>var s=env.render(&apos;hello.html&apos;,{name:&apos;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&apos;,fruits:[123,456]});\nconsole.log(s);</code></pre><p>输出结果如下:</p>\n<pre><code>&lt;h1&gt;Hello &lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&lt;/h1&gt;\n&lt;!-- 循环输出名字 --&gt;\n&lt;body&gt;\n    &lt;h3&gt;Fruits List&lt;/h3&gt;\n\n    &lt;p&gt;123&lt;/p&gt;\n\n    &lt;p&gt;456&lt;/p&gt;\n\n&lt;/body&gt;</code></pre><p>可以看到,渲染成功.即简单的拼接字符串. 接下来我们进行网页模板页渲染: 首先我们写一个 base.html:</p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    {% block header %}<h3>Unnamed</h3>{% endblock %}\n        {% block body %}<div>No body</div>{% endblock %}\n    {% block footer %}<div>copyright</div>{% endblock %}\n    \n    \n    \n\n可以看到确实很像jinja2~ 然后我们再写一个继承自base.html的 extend.html:\n\n    {% extends 'base.html' %}\n    \n    {% block header %}<h1>{ { header }}</h1>{% endblock %}\n\n{% block body %}<p>{ { body }}</p>{% endblock %}</code></pre><p>渲染:</p>\n<pre><code>console.log(env.render(&apos;extend.html&apos;,{\n    header: &apos;Hello&apos;,\n    body: &apos;bla bla bla...&apos;\n}));</code></pre><p>结果如下:</p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;p&gt;bla bla bla...&lt;/p&gt;\n    &lt;div&gt;copyright&lt;/div&gt;\n&lt;/body&gt;</code></pre><p>End</p>\n","categories":[{"name":"JS","slug":"JS","count":3,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]}