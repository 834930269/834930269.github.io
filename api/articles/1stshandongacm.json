{"title":"山东省第一届省赛","slug":"1stshandongacm","date":"2018-02-25T14:00:45.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/1stshandongacm.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1><span id=\"a-可水可trietrie解法\">A: 可水可Trie,Trie解法</span></h1><blockquote>\n<p>数据不大,因为题目没有给出字符串的大小,害怕暴力超时,所以用Trie写的.</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int CHARSET=10,BASE=&apos;0&apos;,MAX_NODE=10100;\nstruct Trie{\n    int tot,root,child[MAX_NODE][CHARSET];\n    bool flag[MAX_NODE];\n    bool has_prefix;\n    bool is_root[MAX_NODE][CHARSET];\n    Trie(){\n        //printf(&quot;New Trie\\n&quot;);\n        memset(child[1],0,sizeof(child[1]));\n        memset(is_root,false,sizeof(is_root));\n        flag[1]=false;\n        has_prefix=false;\n        root=tot=1;\n    }\n    void insert(const char *str){\n        int *cur=&amp;root;\n        char last_char;\n        for(const char *p=str;*p;++p){\n            cur=&amp;child[*cur][*p-BASE];\n            last_char=*p;\n            if(is_root[*cur][last_char])has_prefix=true;\n            if(*cur==0){\n                *cur=++tot;\n                memset(child[tot],0,sizeof(child[tot]));\n                flag[tot]=false;\n            }\n        }\n        flag[*cur]=true;\n        is_root[*cur][last_char]=true;\n    }\n\n};\nint main(){\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        Trie te;\n        char str[10000];\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            if(!te.has_prefix){\n                te.insert(str);\n            }\n        }\n        if(te.has_prefix){\n            printf(&quot;NO\\n&quot;);\n        }else{\n            printf(&quot;YES\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre><h1><span id=\"b思路比较清晰就是写的时间长我写了两份代码\">B:思路比较清晰,就是写的时间长,我写了两份代码</span></h1><h2><span id=\"单树map套结构体point重载lt二分-内存小时间长\">单树(map)套结构体Point重载&lt;+二分: 内存小,时间长</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\nstruct Point{\n    int x,y;\n    bool operator &lt; (const Point&amp; a)const{\n        if(x&lt;a.x) return true;\n        else if(x==a.x &amp;&amp; y&lt;a.y) return true;\n        return false;\n    }\n    bool operator == (const Point&amp; a)const{\n        if(x==a.x &amp;&amp; y==a.y) return true;\n        return false;\n    }\n\n};\nint N,kase=1;\n\nint xx,yy;\nchar opt[10];\n\nmap&lt;Point,bool&gt; G;//x点集0,true为未删除,false为删除\nmap&lt;Point,bool&gt;::iterator it;\n\nvoid init(){\n    G.clear();\n}\n\nbool cmp(Point a,Point b){\n    if(a.x&lt;b.x &amp;&amp; a.y&lt;b.y)\n        return true;\n    return false;\n}\n\nvoid add(){\n    G[(Point){xx,yy}]=true;\n}\n\nvoid find_(int a,int b){\n    it=G.upper_bound((Point){a,b});\n    if(it==G.end()){\n        printf(&quot;-1\\n&quot;);\n        return;\n    }\n    Point nw=it-&gt;first;\n    if(it-&gt;second &amp;&amp; nw.x&gt;xx &amp;&amp; nw.y&gt;yy){\n        printf(&quot;%d %d\\n&quot;,nw.x,nw.y);\n    }else{\n        do{\n            it++;\n            if(it==G.end()){printf(&quot;-1\\n&quot;);return;}\n            if(it-&gt;second &amp;&amp; (it-&gt;first).x&gt;xx &amp;&amp; (it-&gt;first).y&gt;yy){\n                printf(&quot;%d %d\\n&quot;,(it-&gt;first).x, (it-&gt;first).y);\n                return;\n            }\n        }while(1);\n    }\n}\n\nvoid remove_(){\n    G[(Point){xx,yy}]=false;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s %d %d&quot;,opt,&amp;xx,&amp;yy);\n            if(opt[0]==&apos;a&apos;){\n                add();\n            }else if(opt[0]==&apos;f&apos;){\n                find_(xx,yy);\n            }else{\n                remove_();\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 904ms\nTake Memory: 5752KB\nSubmit time: 2018-02-27 17:08:24\n****************************************************/</code></pre><h2><span id=\"树map二分套树map二分代码少时间短内存大\">树(map)+二分套树(map)+二分,代码少,时间短,内存大</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\n\nint N,kase=1;\n\nint xx,yy;\nchar opt[10];\n\nmap&lt;int,map&lt;int,bool&gt; &gt; G;//x点集0,true为未删除,false为删除\nmap&lt;int,bool&gt;::iterator ity;\nmap&lt;int,map&lt;int,bool&gt; &gt;::iterator itx;\n\nvoid init(){\n    G.clear();\n}\n\nvoid add(){\n    (G[xx])[yy]=true;\n}\n\nvoid find_(){\n    itx=G.upper_bound(xx);\n    while(1){\n        if(itx!=G.end()){\n            ity=(itx-&gt;second).upper_bound(yy);\n            if(ity!=(itx-&gt;second).end() &amp;&amp; ity-&gt;second){\n                printf(&quot;%d %d\\n&quot;,itx-&gt;first,ity-&gt;first);\n                return;\n            }\n            if(ity!=(itx-&gt;second).end()){\n                for(ity++;ity!=(itx-&gt;second).end();ity++){\n                    if(ity-&gt;second){\n                        printf(&quot;%d %d\\n&quot;,itx-&gt;first,ity-&gt;first);\n                        return;\n                    }\n                }\n            }\n        }else break;\n        itx++;\n    }\n    printf(&quot;-1\\n&quot;);\n}\n\nvoid remove_(){\n    (G[xx])[yy]=false;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s %d %d&quot;,opt,&amp;xx,&amp;yy);\n            if(opt[0]==&apos;a&apos;){\n                add();\n            }else if(opt[0]==&apos;f&apos;){\n                find_();\n            }else{\n                remove_();\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 516ms\nTake Memory: 12712KB\nSubmit time: 2018-02-27 17:24:44\n****************************************************/</code></pre><h2><span id=\"然后我百度一下原题发现set直接删除就好还是stl不太熟内存小用时也少不过没第二份少\">然后我百度一下原题,发现set直接删除就好…还是STL不太熟,内存小,用时也少,不过没第二份少</span></h2><pre><code>#include &lt;iostream&gt;  \n#include &lt;stdio.h&gt;  \n#include &lt;algorithm&gt;  \n#include &lt;set&gt;  \n#include &lt;string&gt;  \nusing namespace std;  \n\nint main()  \n{  \n    pair&lt;int,int&gt;p;  \n    int n;char str[10];  \n    int c=1;  \n    while(cin&gt;&gt;n&amp;&amp;n)  \n    {  \n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;c++&lt;&lt;&quot;:&quot;&lt;&lt;endl;  \n        set&lt; pair&lt;int,int&gt; &gt;s;  \n        while(n--)  \n        {  \n            scanf(&quot;%s&quot;,str);  \n            scanf(&quot;%d%d&quot;,&amp;p.first,&amp;p.second);  \n            if(str[0]==&apos;a&apos;)  \n                s.insert(p);  \n            else if(str[0]==&apos;r&apos;)  \n                s.erase(p);  \n            else if(str[0]==&apos;f&apos;)  \n            {  \n                set&lt; pair&lt;int,int&gt; &gt;::iterator it;  \n                it=s.lower_bound(p);//找到set中第一个比p大的元素的位置，找不到则为s.end()  \n                for(;it!=s.end();it++)  \n                {  \n                    if(it-&gt;first&gt;p.first&amp;&amp;it-&gt;second&gt;p.second)//都大于才符合题意  \n                    {  \n                        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;  \n                        break;  \n                    }  \n                }  \n                if(it==s.end())//找不到  \n                    cout&lt;&lt;-1&lt;&lt;endl;  \n            }  \n        }  \n        cout&lt;&lt;endl;  \n    }  \n    return 0;  \n}  </code></pre><h2><span id=\"貌似还可以用线段树优化\">貌似还可以用线段树优化..</span></h2><h3><span id=\"fk\">F**k</span></h3><h1><span id=\"c排序水过别问我为啥写的那么麻烦因为我半截才想到懒得改了\">C:排序水过,别问我为啥写的那么麻烦…因为我半截才想到,懒得改了</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=310;\nstruct Query{\n    int s,t;\n};\nint N,kase=1;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; G[maxn];\n        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; it;\n        vector&lt;Query&gt; Q;\n        for(int i=1;i&lt;=N;++i){\n            int s,t;\n            scanf(&quot;%d%d&quot;,&amp;s,&amp;t);\n            G[s].push(t);\n            Q.push_back((Query){s,t});\n        }\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        for(int i=0;i&lt;Q.size();++i){\n            int s=Q[i].s,t=Q[i].t;\n            bool has_ans=false;\n            for(int j=s+1;j&lt;=309 &amp;&amp; !has_ans;++j){\n                it=G[j];\n                while(!it.empty()){\n                    int nw=it.top();it.pop();\n                    if(nw&gt;t){\n                        has_ans=true;\n                        printf(&quot;%d %d\\n&quot;,j,nw);\n                        break;\n                    }\n                }\n            }\n            if(!has_ans){\n                printf(&quot;-1 -1\\n&quot;);\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><h1><span id=\"d中途相遇法负值二分\">D:中途相遇法+负值二分</span></h1><blockquote>\n<p>因为内置的lower_bound只能查找第一个大于等于的,而我们需要的是小于等于的,所以将所有的值变成负数插入到vector中即可. 这道题N^4肯定是不可行的.所以我们考虑用中途相遇法,</p>\n<blockquote>\n<p>即先处理出任意两个值的和,然后遍历和数组,在原数组中查找是否存在一个值和当前和相加&lt;=M,如果等于M,break即可.</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2000;\nint N,M,KASE=1;\nint arr[maxn];\nvector&lt;int&gt; first;\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M) &amp;&amp; N+M){\n        first.clear();\n        int ans=0;\n        for(int i=0;i&lt;N;++i) scanf(&quot;%d&quot;,&amp;arr[i]);\n        for(int i=0;i&lt;N;++i){\n            for(int j=i;j&lt;N;++j){\n                first.push_back(-(arr[i]+arr[j]));\n            }\n        }\n        sort(first.begin(),first.end());\n        for(int i=0;i&lt;first.size();++i){\n            int need=M+first[i];\n            if(need&lt;=0) continue;\n            else{\n                int id=lower_bound(first.begin(),first.end(),-need)-first.begin();\n                int nw=-(first[i]+first[id]);\n                if(nw&lt;=M) ans=max(ans,nw);\n            }\n            if(ans==M)break;\n        }\n        printf(&quot;Case %d: %d\\n\\n&quot;,KASE++,ans);\n    }\n    return 0;\n}</code></pre><h1><span id=\"g排序水过\">G:排序水过</span></h1><blockquote>\n<p>一开始没读懂题意时最难受的</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100100;\nint Dist[maxn],N;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;Dist[i]);\n        }\n        sort(Dist,Dist+N);\n        LL ans=0ll;\n        for(int i=1;i&lt;N;++i){\n            ans+=((Dist[i]-Dist[i-1])&lt;&lt;1);\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><h1><span id=\"i分别进行两个dfs即可四方向和八方向\">I:分别进行两个dfs即可,四方向和八方向</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint move1[4][2]={ {0,-1},{0,1},{-1,0},{1,0}};\nint move2[8][2]={ {0,-1},{0,1},{-1,0},{1,0},\n                 {1,-1},{1,1},{-1,-1},{-1,1}};\nchar mp[110][110];\nint N,kase=1;\nint vis1[110][110],vis2[110][110];\n\nvoid init(){\n    memset(vis1,0,sizeof(vis1));\n    memset(vis2,0,sizeof(vis2));\n}\n\nbool check(int x,int y){\n    if(x&gt;=N || y&gt;=N || x&lt;0 || y&lt;0 || mp[x][y]==&apos;0&apos;)\n        return false;\n    return true;\n}\n\nvoid dfs4(int x,int y){\n    if(!check(x,y) || vis1[x][y]) return;\n    vis1[x][y]=1;\n    for(int i=0;i&lt;4;++i){\n        int nx=x+move1[i][0],ny=y+move1[i][1];\n        dfs4(nx,ny);\n    }\n}\n\nvoid dfs8(int x,int y){\n    if(!check(x,y) || vis2[x][y]) return;\n    vis2[x][y]=1;\n    for(int i=0;i&lt;8;++i){\n        int nx=x+move2[i][0],ny=y+move2[i][1];\n        dfs8(nx,ny);\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        init();\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,mp[i]);\n        }\n        int ans4=0,ans8=0;\n        for(int i=0;i&lt;N;++i){\n            for(int j=0;j&lt;N;++j){\n                if(mp[i][j]==&apos;1&apos; &amp;&amp; !vis1[i][j]){\n                    ans4++,dfs4(i,j);\n                }\n                if(mp[i][j]==&apos;1&apos; &amp;&amp; !vis2[i][j]){\n                    ans8++,dfs8(i,j);\n                }\n            }\n        }\n        printf(&quot;Case %d: %d %d\\n\\n&quot;,kase++,ans4,ans8);\n    }\n    return 0;\n}</code></pre><h1><span id=\"e大模拟\">E:大模拟</span></h1><p>大模拟</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long LL;\nconst int maxn=35;\nint N,kase=1;\nchar mp[maxn][maxn];\nint vis[maxn][maxn][maxn][maxn][5];\n///EWSN东西南北\nint dis[4][2]={ {0,1},{0,-1},{1,0},{-1,0}};\n///saya更喜欢EWNS\nint nt[4][2]={ {0,1},{0,-1},{-1,0},{1,0}};\n\nbool check(int x,int y){\n    if(x&lt;0||y&lt;0||x&gt;=N||y&gt;=N)return false;\n    return true;\n}\n///返回当前的朝向在,数组为dis\nint now_dir(int x,int y,int t){\n    char str=mp[x][y];\n    int in=0;\n    if(str==&apos;E&apos;) in=0;\n    else if(str==&apos;W&apos;) in=1;\n    else if(str==&apos;S&apos;) in=2;\n    else in=3;\n    in+=t;\n    return in%4;\n}\n\nint dist(int x,int y,int tx,int ty){\n    return (x-tx)*(x-tx)+(y-ty)*(y-ty);\n}\n\nint query_dir(int x,int y,int tx,int ty){\n    int mind=INF,dir_=-1;\n    for(int i=0;i&lt;4;++i){\n        int xx=x+nt[i][0],yy=y+nt[i][1];\n        if(!check(xx,yy)) continue;\n        int d=dist(xx,yy,tx,ty);\n        if(mind&gt;d){\n            mind=d;\n            dir_=i;\n        }\n    }\n    ///返回第一个想走的方向\n    return dir_;\n}\n\nint main(){\n    while(scanf(&quot;%d&quot;,&amp;N)!=EOF &amp;&amp; N!=0){\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,&amp;mp[i]);\n        }\n        int x=0,y=0,tx=N-1,ty=N-1,step=0;\n        int xx,yy,txx,tyy;\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        while(1){\n            if(step&gt;=100){\n                printf(&quot;Not sure.\\n&quot;);\n                break;\n            }\n            if(tx==x&amp;&amp;ty==y){\n                printf(&quot;Get the treasure! At step %d.\\n&quot;,step);\n                break;\n            }\n            ///saya第一步\n            int saya=now_dir(x,y,step);\n            xx=x+dis[saya][0],yy=y+dis[saya][1];\n            if(check(xx,yy)){\n                x=xx,y=yy;\n            }\n            ///saya第二步\n            if(!(x==tx&amp;&amp;y==ty)){\n                int goal=query_dir(x,y,tx,ty);\n                xx=x+nt[goal][0],yy=y+nt[goal][1];\n                if(check(xx,yy)){\n                    x=xx,y=yy;\n                }\n            }\n            ///宝藏走\n            int tres=now_dir(tx,ty,step);\n            txx=tx+dis[tres][0],tyy=ty+dis[tres][1];\n            if(check(txx,tyy)){\n                tx=txx,ty=tyy;\n            }\n\n            if(vis[x][y][tx][ty][step%4]){\n                printf(&quot;Impossible. At step %d.\\n&quot;,step);\n                break;\n            }else{\n                vis[x][y][tx][ty][step%4]=1;\n            }\n            step+=1;\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"STL","slug":"Sdut/STL","count":2,"path":"api/categories/Sdut/STL.json"},{"name":"Trie","slug":"Sdut/STL/Trie","count":1,"path":"api/categories/Sdut/STL/Trie.json"},{"name":"中途相遇法","slug":"Sdut/STL/Trie/中途相遇法","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法.json"},{"name":"二分搜索","slug":"Sdut/STL/Trie/中途相遇法/二分搜索","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索.json"},{"name":"数据结构","slug":"Sdut/STL/Trie/中途相遇法/二分搜索/数据结构","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索/数据结构.json"},{"name":"第一届ACM山东省塞","slug":"Sdut/STL/Trie/中途相遇法/二分搜索/数据结构/第一届ACM山东省塞","count":1,"path":"api/categories/Sdut/STL/Trie/中途相遇法/二分搜索/数据结构/第一届ACM山东省塞.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"中途相遇法","slug":"中途相遇法","count":2,"path":"api/tags/中途相遇法.json"},{"name":"Trie","slug":"Trie","count":1,"path":"api/tags/Trie.json"},{"name":"第一届ACM山东省塞","slug":"第一届ACM山东省塞","count":1,"path":"api/tags/第一届ACM山东省塞.json"}]}