{"title":"JeffE-3-1-递归起源","slug":"jeffe-3-1-dporigin","date":"2019-04-08T13:08:05.000Z","updated":"2019-07-03T16:17:14.054Z","comments":true,"path":"api/articles/jeffe-3-1-dporigin.json","photos":[],"link":"","excerpt":"[toc]3.1 matra-vrtta关于递归方法最早的例子之一是出现在距今2000多年前的古印度时期关于诗词韵律(arose)或者诗体韵律的学习中.古典梵语诗集(Classical Sanskrit poetry)有别于音节(syllables)的两种类型: 明亮和沉重.在一组韵律中(In one class of meters),韵律丰富的被叫做[matravrtta]或者[matrameru]或[matrachanda],诗的每一行都有固定个数的”beats”,如亮音节最后会有一个beat,而重音节最后会有两个beat.正规的matra-vrtta的学习要追溯到 Chandahsastra,出自Pingala学者(Scholar),公元前600年和200年间,Pingala发现 5-4节拍: –，-··，·-·，··-，····。（这里每个”-“代表了一个常寅杰,每个”·”代表了一个短音节.） 尽管Pingala的文章给计数音节一个系统化的提示了,这项规定仍花了大约一千年的时间才得以明确表述。【it took about,他花费了大约】在公元前七世纪,另一个印度学者Virahanka书写了一篇Pingala著作的评注,其中(in which)，他观察到n拍的节拍(meter)数是（n-2）拍的节拍数和（n-1）拍的节拍数之和。用更现代的符号表示,Virahanka的研究发现了总会出现一个循环当n-beat节拍的节拍总数M(n)满足M(n)=M(n-2)+M(n-1) 不难看出M(0)=1 (只存在一个空节拍)和M(1)=1(唯一的一个节拍由一个单独的短音节组成). 同样的循环结论出现在欧洲大约在Virahanka500年前,在Leonardo Pisano(莱昂纳多·比萨诺)的1202论文Liber Abaci中,这个欧洲最早关于”算法”的论文中,使用Virahanka的循环,用现代的Fibonacci number 定义了这一现象:  [Figure]  即,对于所有的n,我们规定 M(n)=F(n+1)","covers":["http://be-sunshine.cn/wp-content/uploads/2019/04/QQ%E6%88%AA%E5%9B%BE20190408205641.png","http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%811-1.png","http://be-sunshine.cn/wp-content/uploads/2019/04/%E9%80%9A%E8%A7%A32.png","http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%8E%9F%E6%96%871.png","http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%9B%BE1.png","http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%813.png","http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%814.png"],"content":"<p>[toc]</p>\n<h1><span id=\"31-matra-vrtta\">3.1 matra-vrtta</span></h1><hr>\n<p>关于<code>递归方法</code>最早的例子之一是出现在距今2000多年前的<code>古印度</code>时期关于诗词韵律(arose)或者诗体韵律的学习中.古典梵语诗集(Classical Sanskrit poetry)有别于音节(syllables)的两种类型: 明亮和沉重.在一组韵律中(In one class of meters),韵律丰富的被叫做[matravrtta]或者[matrameru]或[matrachanda],诗的每一行都有固定个数的”beats”,如亮音节最后会有一个beat,而重音节最后会有两个beat.正规的matra-vrtta的学习要追溯到 Chandahsastra,出自Pingala学者(Scholar),公元前600年和200年间,Pingala发现 5-4节拍: –，-··，·-·，··-，····。（这里每个”-“代表了一个常寅杰,每个”·”代表了一个短音节.） 尽管Pingala的文章给计数音节一个系统化的<code>提示</code>了,这项规定仍花了大约一千年的时间才得以明确表述。【it took about,他花费了大约】在公元前七世纪,另一个印度学者Virahanka书写了一篇Pingala著作的评注,其中(in which)，他观察到n拍的节拍(meter)数是（n-2）拍的节拍数和（n-1）拍的节拍数之和。</p>\n<blockquote>\n<p>用更现代的符号表示,Virahanka的研究发现了总会出现一个循环当n-beat节拍的节拍总数M(n)满足</p>\n</blockquote>\n<p><code>M(n)=M(n-2)+M(n-1)</code> 不难看出<code>M(0)=1</code> (只存在一个空节拍)和<code>M(1)=1</code>(唯一的一个节拍由一个单独的短音节组成). 同样的循环结论出现在欧洲大约在Virahanka500年前,在Leonardo Pisano(莱昂纳多·比萨诺)的1202论文<code>Liber Abaci</code>中,这个欧洲最早关于”算法”的论文中,使用Virahanka的循环,用现代的<code>Fibonacci number</code> 定义了这一现象: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/QQ截图20190408205641.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/QQ%E6%88%AA%E5%9B%BE20190408205641.png\" alt></a> 即,对于所有的n,我们规定 M(n)=F(n+1)</p>\n<a id=\"more\"></a>\n\n\n<h2><span id=\"回溯backtracking很慢\">回溯(Backtracking)很慢</span></h2><p>这个由递归定义的Fibonacci number 立即给了我们一种用递归处理的算法来解决他们.伪码如下: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码1-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%811-1.png\" alt></a> 不幸的是,这个naive的递归算法是令人窒息的慢.除了递归调用(calls),这整个算法全程只有一个常量,这个变量每轮递归的操作也只有一次: 一次比较或者一次加法运算. 我们让<code>T(n)</code>表示(denote)为RECFIBO的<code>递归调用次数</code>;这个函数满足这个循环: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/recurrence1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/recurrence1.png\" alt></a> 这(which)看起来很像(an awful lot like)斐波那契数列的递归式! 将T(n)的前几个值(the first several)写出来(writing out),就得到了 封闭解(close-form solution,即通解): <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/通解1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E9%80%9A%E8%A7%A31.png\" alt></a> 我们可以通过数学归纳法来证实它.</p>\n<h3><span id=\"下面是算法复杂度的\">下面是算法复杂度的</span></h3><p>所以计算F(n)使用这个算法计算的时间大约是普通递归算法的<code>一半时间</code>左右.还有一种超出了本书范围的方法来衡量时间,即<a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/通解2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E9%80%9A%E8%A7%A32.png\" alt></a>,其中<a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/通解3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E9%80%9A%E8%A7%A33.png\" alt></a>被叫做黄金分割比.简而言之(in short),这个递归算法的运行时间是n的指数倍。<code>[时间复杂度]</code></p>\n<blockquote>\n<p>下面这段翻译不是太好…</p>\n</blockquote>\n<p>我们可以很直接看到指数增长.考虑RECFIBO这个递归树作为一个累加的二叉树,叶子节点上只有0和1,因为最终输出的是F(n),恰好F(n)的叶子结点的值必有1;这些叶子节点表示调用RECRIBO(1).一个简单的归纳表示RECFIBO(0)被调用了F(n-1)次.(如果我们只想得到渐进界限(bound),他足够表明(observe)调用RECFIBO(0)的次数最多是(is at most number of)调用RECFIBO(1)的次数。)因此(thus),这个递归树正好有(has exactly)F(n)+F(n-1)=O(F(n))个叶子节点,因此(and therefore),因为他是满二叉树,所以总共有2F(n+1)-1=O(F(n))个节点. <code>原文:</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/原文1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%8E%9F%E6%96%871.png\" alt></a></p>\n<h2><span id=\"记忆化-超忆症-我要记住一切\">记忆化: 超忆症-我要记住一切</span></h2><p>关于这个递归算法的效率极其缓慢的一个<code>很明显的原因</code>是计算了相同的Fibonacci numbers 一次一次又一次.调用一次RECFIBO(n)导致(result in)调用了一次RECFIBO(n-1),两次递归的调用RECFIBO(n-2),三次递归的调用了RECFIBO(n-3),五次递归的调用了RECFIBO(n-4),总之(and in general)F(k-1)递归的调用RECFIBO(n-k)的次数是 <code>k∈[0,n]</code> 间的任意整数.每个调用都<code>从头开始(from scratch)</code>重新计算一些Fibonacci number. 我们可以通过记下(writing down)我们之前递归的调用的结果,在需要它们的时候重新查找(looking xx up again)它们来加速(speed up)我们的递归算法. <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/图1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%9B%BE1.png\" alt></a> 这个最优化(optimization)的技术(technique),现在被称为(known as)记忆化,通常认为是唐纳德·米奇1967年写的<code>[把...归功于,credited to]</code>,但实际上同样的技术早在1959年就被 Arthur Samuel提出了. <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%812.png\" alt></a> 记忆化明显的减少了算法的运行时间,但是究竟减少了多少呢?如果我们跟踪(trace through)MEMFIBO的递归调用，我们可以找到F数组是从下到上的填充的: 先是F[2],之后F[3]…直到(up to)F[n].这个模式可以用归纳法证明: 每个F[i]被填充的前提是他的前一个节点F[i-1]被填充.如果我们忽略递归的调用时间的话,计算到F[i]所需要花费的时间仅仅是常数时间.但是若特意的设计一下,这个循环到F[i]估计只需要遍历到n一次.我们推断MEMFIBO只需执行O(n)复杂度的加法,这是一个巨大的改善关于之前那个<code>naive</code>的递归算法! <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/图2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E5%9B%BE2.png\" alt></a></p>\n<h2><span id=\"动态规划-刻意填充-我就是故意的\">动态规划: 刻意填充-我就是故意的</span></h2><p>一旦我们清楚了F[]数组是如何填充的,我们可以将记忆化算法转换为一个简单的<code>for循环</code>来初始化该数组,以代替那个复杂度递归算法. <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%813.png\" alt></a> 那我们分析一下: ITERFIBO明显只用了O(n)的复杂度以及仅存了O(n)个整数. 这是我们第一个明确的动态规划算法.这个动态规划算法在1950年代中期被当时在RAND公司工作的<code>Richard Bellman</code>正式的推广开来,尽管他远不是第一个使用这种技术的人.尤其的是(In particular)这个Fibonacci number的迭代算法早在12世纪就被Virahanka和后来的Sanskrit提出,并且再一次被Fibonacci在13世纪提出! 事实上在多年之后,Bellman慎重(deliberately)的宣称(claimed)选择将其命名为<code>&quot;动态规划&quot;</code>来向他的军官隐藏其数学特征(mathematical character),这个对所有对凡和数学有关的研究都有敌意的军官. “Programming”这个单词不涉及编程,相反(but rather)的更多代表的是一种计划或者调度.其特色是填表.例如,运动项目和戏剧(theater)项目就是重要的事件(与广告)的时间调度表..(又举了三个例子).反正这些就叫做”Program”,即安排/调度.而”dynamic”这个单词不仅仅涉及多阶段的意思,在Bellman和他的同事(colleagues)尝试(attempt)优化(to optimize)时变过程(time-varying processes)时,这个单词也是XXXXX(专业术语-&gt;resonate with the Futuristic Can-Do Zeitgeist of post-WW II America)的流行词.多亏了(部分原因是-&gt;Thanks in part of)Bellman的劝说(proselytizing)动态规划现在已经成为了经济学,机器人学,控制论,和其他多决策问题的标准工具.</p>\n<h2><span id=\"其实俺也不想记住那么多\">其实俺也不想记住那么多</span></h2><p>在一些动态规划算法中,不需要在整个计算过程中(entire computation)保留所有中间结果(intermediate results).例如,我们可以明显的削减我们的算法<code>ITERFIBO</code>的必要空间通过维护两个数组中的新变量: <a href=\"http://be-sunshine.cn/wp-content/uploads/2019/04/伪码4.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/04/%E4%BC%AA%E7%A0%814.png\" alt></a> (这个算法使用的非标准但是最终返回的结果一致,即定义F(-1)=1)尽管在实践中节约空间很重要,但本书中并不关注空间问题.</p>\n","categories":[{"name":"随笔","slug":"随笔","count":28,"path":"api/categories/随笔.json"}],"tags":[]}