{"title":"CCF 2016-12/4 & POJ 1738","slug":"ccf-2016-124-poj-1738","date":"2017-08-31T12:45:36.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2016-124-poj-1738.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>类型: 石子合并问题 算法: GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn),也可以用动态规划,等等学一下再补充. GarsiaWachs算法(摘自别人的blog):</p>\n<pre><code>具体的算法及证明可以参见《The Art of Computer Programming》第3卷6.2.2节Algorithm G和Lemma W,Lemma X,Lemma Y,Lemma Z。\n只能说一个概要吧：\n设一个序列是A[0..n-1]，每次寻找最小的一个满足A[k-1]&lt;=A[k+1]的k，（方便起见设A[-1]和A[n]等于正无穷大）\n那么我们就把A[k]与A[k-1]合并，之后找最大的一个满足A[j]&gt;A[k]+A[k-1]的j,把合并后的值A[k]+A[k-1]插入A[j]的后面。\n有定理保证，如此操作后问题的答案不会改变。\n举个例子：\n186 64 35 32 103\n因为35&lt;103，所以最小的k是3，我们先把35和32删除，得到他们的和67，并向前寻找一个第一个超过67的数，把67插入到他后面\n186 64（k=3,A[3]与A[2]都被删除了） 103\n186 67（遇到了从右向左第一个比67大的数，我们把67插入到他后面） 64 103\n186 67 64 103 （有定理保证这个序列的答案加上67就等于原序列的答案）\n现在由5个数变为4个数了，继续！\n186 （k=2,67和64被删除了）103\n186 131（就插入在这里） 103\n186 131 103\n现在k=2（别忘了，设A[-1]和A[n]等于正无穷大）\n234 186\n420\n最后的答案呢？就是各次合并的重量之和呗。420+234+131+67=852，哈哈，算对了。\n\n证明嘛，基本思想是通过树的最优性得到一个节点间深度的约束，之后\n证明操作一次之后的解可以和原来的解一一对应，并保证节点移动之后他所在的\n深度不会改变。详见TAOCP。\n\n具体实现这个算法需要一点技巧，精髓在于不停快速寻找最小的k，即维护一个“2-递减序列”\n朴素的实现的时间复杂度是O(n*n)，但可以用一个平衡树来优化（好熟悉的优化方法），使得最终复杂度为O(nlogn)\n\n\n解题思路:（这是我找到的一个关于GarsiaWachs算法的解释）\n\n      1. 这类题目一开始想到是DP, 设dp[i][j]表示第i堆石子到第j堆石子合并最小得分.\n\n         状态方程: dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);\n\n         sum[i]表示第1到第i堆石子总和. 递归记忆化搜索即可.\n\n      2. 不过此题有些不一样, 1&lt;=n&lt;=50000范围特大, dp[50000][50000]开不到这么大数组.\n\n         问题分析:\n\n         (1). 假设我们只对3堆石子a,b,c进行比较, 先合并哪2堆, 使得得分最小.\n\n              score1 = (a+b) + ( (a+b)+c )\n\n              score2 = (b+c) + ( (b+c)+a )\n\n              再次加上score1 &lt;= score2, 化简得: a &lt;= c, 可以得出只要a和c的关系确定,\n\n              合并的顺序也确定.\n\n         (2). GarsiaWachs算法, 就是基于(1)的结论实现.找出序列中满足stone[i-1] &lt;=\n\n              stone[i+1]最小的i, 合并temp = stone[i]+stone[i-1], 接着往前面找是否\n\n              有满足stone[j] &gt; temp, 把temp值插入stone[j]的后面(数组的右边). 循环\n\n              这个过程一直到只剩下一堆石子结束.\n\n        (3). 为什么要将temp插入stone[j]的后面, 可以理解为(1)的情况\n\n             从stone[j+1]到stone[i-2]看成一个整体 stone[mid],现在stone[j],\n\n             stone[mid], temp(stone[i-1]+stone[i-1]), 情况因为temp &lt; stone[j],\n\n             因此不管怎样都是stone[mid]和temp先合并, 所以讲temp值插入stone[j]\n\n             的后面是不影响结果.</code></pre><p>代码实现:</p>\n<pre><code>///186 64 35 32 103\n///GarsiaWachs算法。时间复杂度为O(n^2),平衡树来优化，使得最终复杂度为O(nlogn)\n/*\n设序列是stone[]，从左往右，找一个满足\nstone[k-1] &lt;= stone[k+1]的k，找到后合\n并stone[k]和stone[k-1]，再从当前位置\n开始向左找最大的j，使其满足\nstone[j] &gt; stone[k]+stone[k-1]，\n插到j的后面就行。一直重复，直到只剩下\n一堆石子就可以了。在这个过程中，可以假设\nstone[-1]和stone[n]是正无穷的。\n*/\n\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=50005;\n\nint stone[maxn];\nint N,ans,T;\n///186 64 35 32 103\nvoid combine(int k){\n    int tmp=stone[k]+stone[k-1];\n    ans+=tmp;\n    for(int i=k;i&lt;T-1;++i)\n        stone[i]=stone[i+1];\n    T--;\n    int j=0;\n    for(j=k-1;j&gt;0&amp;&amp;stone[j-1]&lt;tmp;--j)\n        stone[j]=stone[j-1];\n    stone[j]=tmp;\n    while(j&gt;=2&amp;&amp;stone[j]&gt;=stone[j-2]){\n        int d=T-j;\n        combine(j-1);\n        j=T-d;\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=0;i&lt;N;++i) scanf(&quot;%d&quot;,&amp;stone[i]);\n        T=1;\n        ans=0;\n        for(int i=1;i&lt;N;++i){\n            stone[T++]=stone[i];\n            while(T&gt;=3&amp;&amp;stone[T-3]&lt;=stone[T-1]){\n                combine(T-2);\n            }\n        }\n        while(T&gt;1)combine(T-1);\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}\n///186 64 35 32 103</code></pre>","categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"GarsiaWachs","slug":"ccf/GarsiaWachs","count":1,"path":"api/categories/ccf/GarsiaWachs.json"},{"name":"POJ","slug":"ccf/GarsiaWachs/POJ","count":1,"path":"api/categories/ccf/GarsiaWachs/POJ.json"}],"tags":[{"name":"GarsiaWachs","slug":"GarsiaWachs","count":1,"path":"api/tags/GarsiaWachs.json"}]}