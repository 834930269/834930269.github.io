{"title":"Math & 基础知识 & 技巧 模板","slug":"muban","date":"2017-03-31T12:06:06.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/muban.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【文件头】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong></p>\n</blockquote>\n<p><strong>【判断奇偶性】</strong> <strong>1. t&amp;1,若结果为1则为奇数，0则为偶数，从而用做滚动数组的第一维下标等作用。 【位操作】 1. 1&lt;&lt;n 表示第n位为1,2^n 2. s &amp; (1&lt;&lt;n) 表示判断s的第n位是否为1 3. 问:一行有N格,每格只能填充0/1,则共有1&lt;&lt;n种填充方法.</strong> <strong>【中位数】 1. |**</strong>X1 – Ci|在数轴上就是x1到Ci的距离，所以问题变成了：给定数轴上的n个点，找 出一个到它们的距离之和尽量小的点。<strong>**这个最优的X1就是这些数的“中位数”。即排序以后位于中间的数。</strong> <strong>【自然常数e】</strong> <strong>e = 2.718281828459  exp(F(X))=e^F(X)  log()是以e为底的对数</strong> <strong>【素数筛法】</strong></p>\n<blockquote>\n<p><strong>int prime[MAX_N];//第i个素数</strong> <strong>bool is_prime[MAX_N+1];//is_prime[i]为true表示i是素数</strong> <strong>//返回n以内的素数的个数</strong> <strong>int sieve(int n){</strong> **    int p=0;** **    for(int i=0;i&lt;=n;i++) is_prime[i]=true;** **    is_prime[0]=is_prime[1]=false;** **    for(int i=2;i&lt;=n;i++){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=n;j+=i)*</em> **                is_prime[j]=false;** **        }** **    }** **    return p;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【异或操作】</strong> <strong>原地换值:</strong></p>\n<blockquote>\n<p><strong>stay=stay^to;</strong> <strong>to=to^stay;</strong> <strong>stay=stay^to;</strong></p>\n</blockquote>\n<p><strong>即:</strong></p>\n<blockquote>\n<p><strong>stay==to^stay^to.</strong> <strong>to==stay^to^stay.</strong></p>\n</blockquote>\n<p><strong>^的性质有:</strong></p>\n<blockquote>\n<p><strong>x^y==y^x, (x^y)^z==x^(y^z), x^x==0, x^0==x</strong> <strong>如果A,B不相同,A^B=1否则为1</strong> <strong>x^y^y=x</strong></p>\n</blockquote>\n<p><strong>【java:BigInteger】</strong> <strong>相加:</strong></p>\n<blockquote>\n<p><strong>import java.util.Scanner;</strong> <strong>import java.math.*;</strong> <strong>public class Main{</strong> **    public static void main(String[] rgs){** **        //系统输出的** **        Scanner cin=new Scanner(System.in);** **        BigInteger b=BigInteger.valueOf(0);** **        while(cin.hasNext()){//等同于!=EOF** **            BigInteger c;** **            c=cin.nextBigInteger();** **            b=b.add(c);** **        }** **        System.out.println(b);** **    }** <strong>}</strong></p>\n<p><em>*`import java.util.</em>;<br>import java.math.*;<br>public class Main{<br>    public static void main(String args[]){<br>       Scanner cin = new Scanner(System.in);<br>       BigInteger a, b;</p>\n<pre><code>   //以文件EOF结束\n   while (cin.hasNext()){\n       a = cin.nextBigInteger();\n       b = cin.nextBigInteger();\n\n       System.out.println(a.add(b)); //大整数加法\n       System.out.println(a.subtract(b)); //大整数减法\n       System.out.println(a.multiply(b)); //大整数乘法\n       System.out.println(a.divide(b)); //大整数除法(取整)\n       System.out.println(a.remainder(b)); //大整数取模\n\n       //大整数的比较\n       if( a.compareTo(b) == 0 ) System.out.println(&quot;a == b&quot;); //大整数a==b\n       else if( a.compareTo(b) &gt; 0 ) System.out.println(&quot;a &gt; b&quot;); //大整数a&gt;b\n       else if( a.compareTo(b) &lt; 0 ) System.out.println(&quot;a &lt; b&quot;); //大整数a&lt;b\n\n       //大整数绝对值\n       System.out.println(a.abs()); //大整数a的绝对值\n\n       //大整数的幂\n       int exponent=10;\n       System.out.println(a.pow(exponent)); //大整数a的exponent次幂\n\n       //返回大整数十进制的字符串表示\n       System.out.println(a.toString());\n\n       //返回大整数p进制的字符串表示\n       int p=8;\n       System.out.println(a.toString(p));\n   }\n}</code></pre><p>}`**</p>\n</blockquote>\n<p><strong>【字符串处理】</strong> <strong>正则式处理:</strong> <strong>%[^\\n] 读到回车结束,即读一行.</strong> <strong>【ln】</strong> <strong>ln2=1.693147</strong> <strong>【Floyd判圈法】</strong></p>\n<blockquote>\n<p><strong>void floyd_check(int n,int k){</strong> **        int k1=k,k2=k,ans=k;//ans=k** **        do{** **            k1=next(n,k1);** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **        }while(k1!=k2);** **        printf(“%d\\n”,ans);** <strong>}</strong></p>\n</blockquote>\n<p><strong>【k的个数】</strong></p>\n<blockquote>\n<p><strong>upper_bound(a,a+n,k)-lower_bound(a,a+n,k);</strong></p>\n</blockquote>\n","categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"},{"name":"模板","slug":"未分类/模板","count":3,"path":"api/categories/未分类/模板.json"}],"tags":[]}