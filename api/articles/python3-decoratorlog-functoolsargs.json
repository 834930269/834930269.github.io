{"title":"python3学习 装饰器Decorator+log(日志输出)+functools+args","slug":"python3-decoratorlog-functoolsargs","date":"2017-07-14T03:08:37.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-decoratorlog-functoolsargs.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Record】</strong> <strong>函数是对象,也有其属性,比如 f.</strong>name** 获取f控制的函数的名字.** <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/Decorator/Decorator.py\" target=\"_blank\" rel=\"noopener\">Decorator.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#函数也是一个对象,所以可以赋值给变量<br>def now():<br>    print(‘1997-02-10’)<br>f=now<br>f()</p>\n<p># In[3]:</p>\n<p>#函数对象有一个__name__属性,可以拿到其名字<br>print(f.__name__)</p>\n<p># In[5]:</p>\n<p>‘’’<br>现在，假设我们要增强now()函数的功能，比如，<br>在函数调用前后自动打印日志，但又不希望修改<br>now()函数的定义，这种在代码运行期间动态增<br>加功能的方式，称之为“装饰器”（Decorator）。<br>‘’’</p>\n<p>#本质上，decorator就是一个返回函数的高阶函数</p>\n<p>#。所以，我们要定义一个能打印日志的decorator，可以定义如下：<br>def log(func):<br>    def wrapper(*args,**kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args,**kw)<br>    return wrapper<br>‘’’<br>观察上面的log，因为它是一个decorator，所以接受<br>一个函数作为参数，并返回一个函数。我们要借助<br>Python的@语法，把decorator置于函数的定义处：</p>\n<p>调用now()函数，不仅会运行now()函数本身，还会在<br>运行now()函数前打印一行日志：<br>‘’’<br>@log<br>def now2():<br>    print(‘1997-12-11’)<br>now2() </p>\n<p># In[16]:</p>\n<p>#把@log放到now()函数的定义处，相当于执行了语句：</p>\n<p>#now=log(now)<br>‘’’<br>1.wrapper()函数的参数定义是(*args, **kw)，因此，<br>wrapper()函数可以接受任意参数的调用。在wrapper()<br>函数内，首先打印日志，再紧接着调用原始函数。</p>\n<p>2.如果decorator本身需要传入参数，那就需要编写一个返<br>回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>\n<p>‘’’<br>def log2(text):<br>    def decorator(func):<br>        def wrapper(*args,**kw):<br>            print(‘%s %s():’ %(text,func.__name__))<br>            return func(*args,**kw)<br>        return wrapper<br>    return decorator</p>\n<p>#这个3层嵌套的decorator用法如下：<br>@log2(‘execute’)<br>def now3():<br>    print(‘2015-3-25’)<br>now3()</p>\n<p>#三层嵌套是这样的:now = log(‘execute’)(now)</p>\n<p># In[17]:</p>\n<p>‘’’<br>我们来剖析上面的语句，首先执行log(‘execute’)，<br>返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>\n<p>以上两种decorator的定义都没有问题，但还差最后一步。<br>因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数<br>，它们的__name__已经从原来的’now’变成了’wrapper’：<br>‘’’<br>print(now.__name__)</p>\n<p># In[20]:</p>\n<p>‘’’<br>因为返回的那个wrapper()函数名字就是’wrapper’，所以，<br>需要把原始函数的__name__等属性复制到wrapper()函数中，<br>否则，有些依赖函数签名的代码执行就会出错。</p>\n<p>不需要编写wrapper.__name__ = func.__name__这样的代码，<br>Python内置的functools.wraps就是干这个事的，所以，一个<br>完整的decorator的写法如下：<br>‘’’<br>import functools</p>\n<p>def log3(func):<br>    @functools.wraps(func)<br>    def wrapper(*args, **kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args, **kw)<br>    return wrapper</p>\n<p>#或者针对带参数的decorator：<br>def log4(text):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(*args, **kw):<br>            print(‘%s %s():’ % (text, func.__name__))<br>            return func(*args, **kw)<br>        return wrapper<br>    return decorator</p>\n<p># In[22]:</p>\n<p>#题目<br>‘’’<br>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。<br>OOP的装饰模式需要通过继承和组合来实现，而Python除了能支<br>持OOP的decorator外，直接从语法层次支持decorator。Python<br>的decorator可以用函数实现，也可以用类实现。</p>\n<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使<br>用起来非常灵活和方便。</p>\n<p>请编写一个decorator，能在函数调用的前后打印出’begin call’<br>和’end call’的日志。</p>\n<p>再思考一下能否写出一个@log的decorator，使它既支持：</p>\n<p>@log<br>def f():<br>    pass</p>\n<p>又支持：</p>\n<p>@log(‘execute’)<br>def f():<br>    pass<br>‘’’<br>def log5(<em>args1):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(\\</em>args,**kw):<br>            print(‘args1 num =%d’ %len(args1))<br>            print(‘begin %s():’ % func.__name__)<br>            func()<br>            print(‘end %s().\\n’ % func.__name__)<br>        return wrapper<br>    return decorator</p>\n<p>@log5(‘123’,’a’)<br>def dream():<br>    print(‘My Dream.’)</p>\n<p>@log5()<br>def future():<br>    print(‘Must..’)</p>\n<p>dream()<br>future()</p>\n<p>‘’’<br>Out:<br>args1 num =2<br>begin dream():<br>My Dream.<br>end dream().</p>\n<p>args1 num =0<br>begin future():<br>Must..<br>end future().<br>‘’’</p>\n<p># In[ ]:**</p>\n","categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}