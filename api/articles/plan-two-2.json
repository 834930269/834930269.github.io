{"title":"计划:技术栈完善2-实战JAVA高并发程序设计-第二章","slug":"plan-two-2","date":"2018-06-17T06:41:01.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-two-2.json","photos":[],"link":"","excerpt":null,"covers":["http://be-sunshine.cn/wp-content/uploads/2018/06/d705faf4fec8f9026144efa61d6b9b6d.png","http://be-sunshine.cn/wp-content/uploads/2018/06/68a53d6f77b170185ae936fc85487b8c.png","http://be-sunshine.cn/wp-content/uploads/2018/06/d4573f33d24bfc236e8d0da6dae4a164.png","http://be-sunshine.cn/wp-content/uploads/2018/06/ec4bce7b33d0b7bbbb972f5ef2404bc2.png","http://be-sunshine.cn/wp-content/uploads/2018/06/b5e83f7565ce436cf16a37f5917f11ad.png","http://be-sunshine.cn/wp-content/uploads/2018/06/45787c634458f214da51856102ddff30.png","http://be-sunshine.cn/wp-content/uploads/2018/06/d05785fceddb6610ce2c0cf81eb21716.png","http://be-sunshine.cn/wp-content/uploads/2018/06/7be0b2035576e2b5202c4ba9360fb90d.png"],"content":"<h1><span id=\"java并行程序基础\">Java并行程序基础</span></h1><h2><span id=\"进程process\">进程(Process)</span></h2><p><strong>进程</strong>:</p>\n<blockquote>\n<p>1.是计算机中的程序关于某数据集合上的一次运行活动. 2.是系统进行资源分配和调度的基本单位 3.是操作系统结构的基础 4.早期,进程是程序的基本执行实体 5.当代,进程是线程的容器 6.程序是指令、数据及其组织形式的描述,进程是程序的实体</p>\n</blockquote>\n<p>我们使用多线程而非使用多进程去进行并发程序的设计,是因为线程间的切换和调度的成本<strong>远小于进程</strong>.</p>\n<h2><span id=\"线程的生命周期\">线程的生命周期</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d705faf4fec8f9026144efa61d6b9b6d.png\" alt> Java中的线程就是继承Runnable,故生命周期如上图所示. 以下是<code>Java.lang.Thread</code>中关于State的枚举定义源码:</p>\n<pre><code>public enum State {\n    /**\n     * Thread state for a thread which has not yet started.\n     */\n    NEW,\n\n    /**\n     * Thread state for a runnable thread.  A thread in the runnable\n     * state is executing in the Java virtual machine but it may\n     * be waiting for other resources from the operating system\n     * such as processor.\n     */\n    RUNNABLE,\n\n    /**\n     * Thread state for a thread blocked waiting for a monitor lock.\n     * A thread in the blocked state is waiting for a monitor lock\n     * to enter a synchronized block/method or\n     * reenter a synchronized block/method after calling\n     * {@link Object#wait() Object.wait}.\n     */\n    BLOCKED,\n\n    /**\n     * Thread state for a waiting thread.\n     * A thread is in the waiting state due to calling one of the\n     * following methods:\n     * &lt;ul&gt;\n     *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;\n     * &lt;/ul&gt;\n     *\n     * &lt;p&gt;A thread in the waiting state is waiting for another thread to\n     * perform a particular action.\n     *\n     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;\n     * on an object is waiting for another thread to call\n     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on\n     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;\n     * is waiting for a specified thread to terminate.\n     */\n    WAITING,\n\n    /**\n     * Thread state for a waiting thread with a specified waiting time.\n     * A thread is in the timed waiting state due to calling one of\n     * the following methods with a specified positive waiting time:\n     * &lt;ul&gt;\n     *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;\n     *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;\n     * &lt;/ul&gt;\n     */\n    TIMED_WAITING,\n\n    /**\n     * Thread state for a terminated thread.\n     * The thread has completed execution.\n     */\n    TERMINATED;\n}</code></pre><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/68a53d6f77b170185ae936fc85487b8c.png\" alt></p>\n<h2><span id=\"初始线程-线程的基本操作\">初始线程: 线程的基本操作</span></h2><h3><span id=\"新建线程\">新建线程</span></h3><p>线程启动时的调用顺序 start()-&gt;run() 所以,当我们使用start启动线程时是<code>真正</code>启动了一个线程,而在这个线程中调用run方法. 而如果使用了run(),则代表只是<code>调用了一次run函数</code>.</p>\n<blockquote>\n<p>使用匿名内部类修改run方法,然后启动线程</p>\n</blockquote>\n<pre><code>public class p21 {\n\n    public static void main(String[] args){\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                System.out.println(&quot;Hello, I&apos;m t1&quot;);\n            }\n        };\n        t1.start();\n    }\n}</code></pre><h3><span id=\"使用runnable接口来作为thread的构造参数传入\">使用Runnable接口来作为Thread的构造参数传入</span></h3><p>以下是Runnable接口的源码:</p>\n<pre><code>@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}</code></pre><p>可以发现,我们只需要实现run方法即可. 当我们调用Thread的run方法时,他会先判断下是否有Rannable,如果有,则调用Runnable的run方法.</p>\n<pre><code>@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}</code></pre><p>我们来使用Runnable接口实现线程</p>\n<pre><code>public class p21 implements Runnable {\n\n    public static void main(String[] args){\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                System.out.println(&quot;Hello, I&apos;m t1&quot;);\n            }\n        };\n        t1.start();\n        Thread t2=new Thread(new p21());\n        t2.start();\n    }\n\n    @Override\n    public void run(){\n        System.out.println(&quot;Hello,I&apos;m t2.&quot;);\n    }\n\n}</code></pre><p>这样就避免了重载Thread的run()方法,也是最常用的做法</p>\n<h3><span id=\"终止线程\">终止线程</span></h3><p>当我们在实现某些功能时,可能会让一些线程常驻在内存中. 那么我们该如何停止这些线程呢? Thread内部有一个Stop()的方法,但他已被标注为将废弃,因为该方法太过暴力,很有可能造成数据不一致的问题. 因为stop方法会在结束线程时,直接终止线程,并且释放掉这个线程的所有锁.而这些锁则是为了保证对象的一致性.如果此时,写线程写到一半,被强行终止,那么对象的完整性就可能会被破坏. 而因为锁被释放了,所以另一个线程就顺理成章的读到了这个不完整的对象… <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d4573f33d24bfc236e8d0da6dae4a164.png\" alt></p>\n<h4><span id=\"测试\">测试</span></h4><p>我们用一个程序来模拟下上面说的情况: 具体思路为-&gt;开启读取线程,如果User名字和id不一样,输出-&gt;不停地创建修改线程,修改的id和name一样-&gt;修改完成后stop()-&gt;观察结果</p>\n<pre><code>public class p22 {\n    public static User u=new User();\n    public static class User{\n        private int id;\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        private String name;\n        public User(){\n            id=0;\n            name=&quot;0&quot;;\n        }\n        @Override\n        public String toString(){\n            return &quot;User [id=&quot;+id+&quot;,name=&quot;+name+&quot;]&quot;;\n        }\n    }\n\n    public static class ChangeObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    int v=(int)(System.currentTimeMillis()/1000);\n                    u.setId(v);\n                    //Oh,do sth.else\n                    try{\n                        Thread.sleep(100);\n                    }catch(InterruptedException e){\n                        e.printStackTrace();\n                    }\n                    u.setName(String.valueOf(v));\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static class ReadObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(u.getId()!=Integer.parseInt(u.getName())){\n                        System.out.println(u.toString());\n                    }\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReadObjectThread().start();\n        while(true){\n            Thread t=new ChangeObjectThread();\n            t.start();\n            Thread.sleep(100);\n            t.stop();\n        }\n    }\n}</code></pre><p>输出: … User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] … 我们发现会出现很多如此的错误,为什么呢?和之前一样的原因,指令的顺序在优化中可能被更改,而线程的执行顺序也和调度算法有关,所以就造成了有可能某线程对User数据修改时sleep了一段时间,而这段时间内突然被stop了,其他的线程就拿到了不完整的数据. <strong>当然,如果你将两个sleep都设置为0就不会出现这种错误了.</strong></p>\n<h4><span id=\"自定义线程停止\">自定义线程停止</span></h4><blockquote>\n<p>如何解决这种问题呢?</p>\n</blockquote>\n<p>我们自行决定线程何时退出就可以了。</p>\n<ul>\n<li>volatile关键字 &gt; 添加该关键字的变量是: &gt;&gt; 不同线程访问和修改的变量</li>\n</ul>\n<blockquote>\n<p>即该指令不会因为编译器的优化而忽略,且要求每次直接读值.</p>\n</blockquote>\n<p>我们只需要为ChangeObjectThread添加一个方法stopMe(), 当stopme为true的时候才可以读取,为false的时候就禁止读取.并且直接退出run方法. 这也就保证了不会导致修改中途被撤销.</p>\n<pre><code>public class p22 {\n    public static User u=new User();\n    public static class User{\n        private int id;\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        private String name;\n        public User(){\n            id=0;\n            name=&quot;0&quot;;\n        }\n        @Override\n        public String toString(){\n            return &quot;User [id=&quot;+id+&quot;,name=&quot;+name+&quot;]&quot;;\n        }\n    }\n\n    public static class ChangeObjectThread extends Thread{\n\n        volatile boolean stopme=false;\n\n        public void stopMe(){\n            stopme=true;\n        }\n\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(stopme){\n                        System.out.println(&quot;exit by stop me&quot;);\n                        break;\n                    }\n                    int v=(int)(System.currentTimeMillis()/1000);\n                    u.setId(v);\n                    //Oh,do sth.else\n                    try{\n                        Thread.sleep(100);\n                    }catch(InterruptedException e){\n                        e.printStackTrace();\n                    }\n                    u.setName(String.valueOf(v));\n                }\n                Thread.yield();\n            }\n        }\n\n\n\n    }\n\n    public static class ReadObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(u.getId()!=Integer.parseInt(u.getName())){\n                        System.out.println(u.toString());\n                    }\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReadObjectThread().start();\n        while(true){\n            ChangeObjectThread t=new ChangeObjectThread();\n            t.start();\n            Thread.sleep(100);\n            t.stopMe();\n        }\n    }\n\n}</code></pre><h3><span id=\"线程中断\">线程中断</span></h3><p>为了解决stop可能会导致数据冲突的问题,JDK中提供了三个方法来实现线程中断.</p>\n<blockquote>\n<p>线程中断</p>\n<blockquote>\n<p>即线程中断不会使线程立即退出,而是给线程发一个通知,告知目标线程要中断了,至于如何处理,何时中断,<strong>由目标决定.</strong></p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ec4bce7b33d0b7bbbb972f5ef2404bc2.png\" alt></p>\n<pre><code>public class p23 {\n\n    public static void main(String[] args) throws Exception{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                while(true){\n                    if(Thread.currentThread().isInterrupted()){\n                        System.out.println(&quot;Interruted!&quot;);\n                        break;\n                    }\n                    Thread.yield();\n                }\n            }\n        };\n        t1.start();\n        Thread.sleep(100);\n        t1.interrupt();\n    }\n\n}</code></pre><h4><span id=\"threadsleep函数\">Thread.sleep函数</span></h4><p>他的签名如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b5e83f7565ce436cf16a37f5917f11ad.png\" alt> Thread.sleep()会让当前线程休眠若干时间,他会抛出一个InterruptedException中断异常,这个异常不是运行时异常,也就是说程序必须捕获并处理它,当线程休眠时,如果被中断,该异常就会产生.</p>\n<pre><code>public class p23 {\n\n    public static void main(String[] args) throws Exception{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                while(true){\n                    if(Thread.currentThread().isInterrupted()){\n                        System.out.println(&quot;Interruted!&quot;);\n                        break;\n                    }\n                    try{\n                        Thread.sleep(2000);\n                    }catch(InterruptedException e){\n                        System.out.println(&quot;Interrpted When Sleep&quot;);\n                        Thread.currentThread().interrupt();\n                    }\n                    Thread.yield();\n                }\n            }\n        };\n        t1.start();\n        Thread.sleep(100);\n        t1.interrupt();\n    }\n\n}</code></pre><p>所以我们必须在捕捉该异常的同时再次放出中断异常,这样才能保证该线程被正常中断.</p>\n<h4><span id=\"wait与notify\">wait()与notify()</span></h4><p>为了支持多线程间协作,JDK提供了等待wait()和通知notify()两个方法. 但这两个方法不存在Thread类中,而是输出Object类.这也就意味着任意的对象都可以调用该方法. 两个方法签名如下:</p>\n<pre><code>public final void wait() throws InterruptedException\npublic final native void notify()</code></pre><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/45787c634458f214da51856102ddff30.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b5278147272b76af3b33e061e68201b6.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b6d82ba876ebf51839908d5453046041.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b48a839ed1fa92328e6d7d2b3533f3ac.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/34da980742c79e179903c43f753e473a.png\" alt> 简单的例子:</p>\n<pre><code>public class p24 {\n    final static Object object = new Object();\n    public static class T1 extends Thread{\n        public void run(){\n            synchronized(object){\n                System.out.println(System.currentTimeMillis()+&quot;:T1 start!&quot;);\n                try{\n                    System.out.println(System.currentTimeMillis()+&quot;:T1 wait for object&quot;);\n                    object.wait();\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                }\n                System.out.println(System.currentTimeMillis()+&quot;:T1 end!&quot;);\n            }\n        }\n    }\n    public static class T2 extends Thread{\n        public void run(){\n            synchronized(object){\n                System.out.println(System.currentTimeMillis()+&quot;:T2 start! notify one thread&quot;);\n                object.notify();\n                System.out.println(System.currentTimeMillis()+&quot;:T2 end!&quot;);\n                try{\n                    Thread.sleep(2000);\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread t1=new T1();\n        Thread t2=new T2();\n        t1.start();\n        t2.start();\n    }\n\n}</code></pre><p>结果:</p>\n<pre><code>1529292002347:T1 start!\n1529292002347:T1 wait for object\n1529292002348:T2 start! notify one thread\n1529292002348:T2 end!\n1529292004348:T1 end!</code></pre><p>Tip: wait会释放所有的锁</p>\n<h4><span id=\"挂起suspend和继续执行resume线程\">挂起(suspend)和继续执行(resume)线程</span></h4><p>suspend乍看起来和stop或者wait相似简单的用法,但是,值得注意的是,suspend并不会释放任何资源和锁.所以就会导致其他想要索取资源的线程也被牵连. 而且resume也是存在问题,有可能在suspend前执行,这就会导致当前线程的状态被误判.</p>\n<h4><span id=\"等待线程结束join和谦让yield\">等待线程结束(join)和谦让(yield)</span></h4><p>一个线程需要等待另一个线程的结束才能继续执行(依赖输出)则用join. public final void join() throws InterruptedExcption public final synchronized void join(long millis) throws InterruptedException 第一个表示无限等待,他会一直阻塞线程,直到目标线程执行完毕. 第二个表示如果超过一段时间还没等到,则不等待,继续执行. 例:</p>\n<pre><code>public class p25 {\n    public volatile static int i=0;\n    public static class AddThread extends Thread{\n        @Override\n        public void run(){\n            for(i=0;i&lt;10000000;++i);\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        AddThread at=new AddThread();\n        at.start();\n        at.join();\n        System.out.println(i);\n\n    }\n\n}</code></pre><p>上述主函数中,如果不执行join来等待线程结束,则更多的可能是只会出现在线程结束前输出i的值(比如0)的情况. 如果用join来等待的话,则最终一定会输出1e7. join的本质是让调用线程wait()在当前线程对象实例上. 另一个: yield()方法是让当前线程让出CPU,然后重新加入到资源的争抢当中.如果觉得一个线程不是很重要,又害怕它占用过多的CPU,可以调用yield方法.</p>\n<h4><span id=\"volatile与java内存模型jmm\">volatile与Java内存模型(JMM)</span></h4><p>使用volatitle就表示告诉了虚拟机这个变量很可能被某线程修改. 虚拟机会特别小心的处理这个变量,尤其是当发现修改的顺序是反的时候. volatile可以很大程度上保证变量的完整性,但不保证操作的原子性,比如i++的原子操作完整性(i为32位下的长整型) 此外,volatile也能保证数据的可见性和有序性. 例:</p>\n<pre><code>public class p26 {\n\n    private volatile static boolean ready;\n    private static int number;\n\n    private static class ReaderThread extends Thread{\n        public void run(){\n            while(!ready);\n            System.out.println(number); \n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        new ReaderThread().start();\n        Thread.sleep(1000);\n        number=42;\n        ready=true;\n        Thread.sleep(10000);\n    }\n}</code></pre><p>因为指令的优化,在Server下线程无法”看到”ready”被修改.所以会无限的执行下去,这就是典型的可见性问题. 而加了volatiel修饰后的ready就不会出现这种情况了.</p>\n<h3><span id=\"线程组\">线程组</span></h3><p>一个系统中如果存在过多的线程,而且分工比较明确,就可以将相同功能的线程放置在一个线程组内.这样会使效率更高些.</p>\n<pre><code>public class p27 implements Runnable{\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        ThreadGroup tg=new ThreadGroup(&quot;PrintGroup&quot;);\n        Thread t1=new Thread(tg,new p27(),&quot;T1&quot;);\n        Thread t2=new Thread(tg,new p27(),&quot;T2&quot;);\n        t1.start();\n        t2.start();\n        System.out.println(tg.activeCount());\n        tg.list();\n        //tg.stop();-慎用\n    }\n    @Override\n    public void run(){\n        String groupAndName=Thread.currentThread().getThreadGroup().getName()\n                +&quot;-&quot;+Thread.currentThread().getName();\n        while(true){\n            System.out.println(&quot;I am &quot;+groupAndName);\n            try{\n                Thread.sleep(3000);\n            }catch(InterruptedException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre><h3><span id=\"驻守后台-守护线程daemon\">驻守后台-守护线程(Daemon)</span></h3><p>JVM内部的实现是如果运行的程序只剩下守护线程的话，程序将终止运行，直接结束。所以守护线程是作为辅助线程存在的</p>\n<h3><span id=\"线程优先级\">线程优先级</span></h3><p>Java可以自定义线程的优先级. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d05785fceddb6610ce2c0cf81eb21716.png\" alt> 设置优先级用 (Thread).setPriority(优先级(1~10))</p>\n<h3><span id=\"线程安全概念与synchronized\">线程安全概念与synchronized</span></h3><p>线程安全是并行程序开发的一大重点. 线程安全例子:</p>\n<pre><code>public class p28 implements Runnable{\n    static p28 instance=new p28();\n    static volatile int i=0;\n    public static void increase(){\n        i++;\n    }\n    @Override\n    public void run(){\n        for(int j=0;j&lt;10000000;++j){\n            increase();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(instance);\n        Thread t2=new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();t2.join();\n        System.out.println(i);\n    }\n}</code></pre><p>如果把t1.join()放到t1.start()后面的话,输出就为正常结果.但如上这样子放的话,也就代表了两个线程实际上是一起执行的.但在某一时刻t1.join开启以后t2就暂停执行等待t1执行完再继续. 我们可以使用synchronized关键字来对同步的代码加锁.使得每一次只能有一个线程进入同步块. 代码在书上的-P58,之前写过很多次了.</p>\n<h3><span id=\"并发下的arraylist\">并发下的ArrayList</span></h3><p>ArrayList是线程不安全的,用Vector代替线程不安全的ArrayList即可.</p>\n<h3><span id=\"并发下的hashmap\">并发下的HashMap</span></h3><p>并发下的HashMap可能会出现死循环的现象,为什么?下面来看一段代码 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/7be0b2035576e2b5202c4ba9360fb90d.png\" alt> 这段代码证明HashMap的插入是按照链表的方法插入的.而当死循环时就代表当前的HashMap链表被破坏成了环.也就导致了死循环. (但JDK8已经避免了这种情况的产生)</p>\n<h3><span id=\"jps和jstack工具\">jps和jstack工具</span></h3><p>jps是查看当前所有大线程 jstack是定位到对应的线程以及代码</p>\n<h3><span id=\"integer其实使用工厂方法进行赋值的\">Integer其实使用工厂方法进行赋值的</span></h3><p>如果我们想要给Integer加锁时,我们不能直接在Integer(int)变量上加锁,因为Integer是用工厂方法进行赋值,每次给int赋值时都会重新生成一个Integer对象. 所以我们需要在改变量所在的实例化对象上加锁. 比如: public class k implements Runnable{ int a; public void run(){ Code here. } } 我们就需要在实例化后的k对象上加锁,而不是在a上加锁.</p>\n","categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]}