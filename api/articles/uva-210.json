{"title":"UVa 210","slug":"uva-210","date":"2017-01-24T06:09:29.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-210.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>【类型】 数据结构&lt;双端队列&gt;,STL 【Tip】 deque容器的介绍.这里我看的是C++标准程序库P160.队头操作用 <strong>front();队尾</strong>back(); 【题意】 紫书P139 给定n个程序，每种程序有五种操作，分别为 var = constant(赋值)，print var (打印)， lock, unlock，end 变量用小写字母表示，初始化为0，为程序所公有（一个程序里对某个变量修改可以会影响其他程序里的这个变量）， 常数小于100（也就是说最多两位数）。 每个时刻都只能有一个程序处于运行状态，其他的都在等待，上述五种操作用时分别是t1, t2, t3, t4, t5。运行中的程序， 每次最多能运行q个时间，当q个时间被用完后，它会被放在等待队列的尾部，然后再从首部取出一个程序运行，初始等待队列按输入顺序， 但是lock和unlock会改变顺序，它们总是成对出现，不会出现嵌套。如果某个程序已经执行了lock，后面还有程序执行lock， 那么这个程序就会马上被放到一个阻止队列的尾部（当然如果运行时间还没用完也就浪费了）。当unlock结束后，阻止队列中的第一个程序进入等待队列的首部。 (敲一遍就知道什么意思了.) 【Code】</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<queue></queue></em> <em>#include<cstring></cstring></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>const int maxn=1000;</em> <em>deque<int> readyQ;</int></em> <em>queue<int> blockQ;</int></em> <em>int n,quantum,c[5],var[26],ip[maxn];//ip为指令的位置</em> <em>bool locked;</em> <em>char prog[maxn][10];//指令</em> <em>void run(int pid){</em> _    int q=quantum;_ _    while(q&gt;0){_ _        char* p=prog[ip[pid]];_ _        switch(p[2]){_ _            case ‘=’://var=constant_ _                var[p[0]-‘a’]=isdigit(p[5])?(p[4]-‘0’)*10+p[5]-‘0’ : p[4]-‘0’;_ _                q-=c[0];_ _                break;_ _            case ‘i’://print_ _                printf(“%d: %d\\n”,pid+1,var[p[6]-‘a’]);_ _                q-=c[1];_ _                break;_ _            case ‘c’://lock_ _                if(locked) { blockQ.push(pid); return; }_ _                locked=true;_ _                q-=c[2];_ _                break;_ _            case ‘l’://unlock_ _                locked=false;_ _                if(!blockQ.empty()){_ _                    int pid2=blockQ.front(); blockQ.pop();_ _                    readyQ.push_front(pid2);_ _                }_ _                q-=c[3];_ _                break;_ _            case ‘d’://end_ _                return;_ _        }_ _        ip[pid]++;_ _    }_ _    readyQ.push_back(pid);_ <em>}</em> <em>int main(){</em> _    int T;_ _    scanf(“%d”,&amp;T);_ _    while(T–){_ _            scanf(“%d %d %d %d %d %d %d\\n”,&amp;n,&amp;c[0],&amp;c[1],&amp;c[2],&amp;c[3],&amp;c[4],&amp;quantum);_ _            memset(var, 0, sizeof(var));_ _            int line=0;_ _            for(int i=0;i&lt;n;++i){_ _                fgets(prog[line++],maxn,stdin);_ _                ip[i]=line-1;_ _                while(prog[line-1][2]!=’d’)_ _                    fgets(prog[line++],maxn,stdin);_ _                readyQ.push_back(i);_ _            }_ _            locked=false;_ _            while(!readyQ.empty()){_ _                int pid=readyQ.front(); readyQ.pop_front();_ _                run(pid);_ _            }_ _          if(T) printf(“\\n”);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>Save</p>\n","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数据结构","slug":"UVa/数据结构","count":3,"path":"api/categories/UVa/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}