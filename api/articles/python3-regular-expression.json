{"title":"python3学习 正则表达式","slug":"python3-regular-expression","date":"2017-07-20T12:42:52.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-regular-expression.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>【Source Code】</p>\n<ul>\n<li><p>:point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Regular%20Expression\" title=\"Regular Expression模块\" target=\"_blank\" rel=\"noopener\">Regular Expression模块</a></p>\n<p>s=’ABC\\-001’#对应正则表达式字符串为’ABC-001’<br>#因为python本身需要转义,但用 r 前缀的话,就可以忽略转义字符了<br>s=r’ABC-001’<br>import re<br>print(‘成功的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010-12345’))<br>print(‘失败的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010 12345’))</p>\n<p>test=’用户输入的字符串’<br>if re.match(r’正则表达式’,test):</p>\n<pre><code>print(&apos;ok&apos;)</code></pre><p>else:</p>\n<pre><code>print(&apos;failed&apos;)</code></pre><p>#切分字符串<br>#用正则表达式切分字符串比用固定的字符更灵活,<br>print(‘a b   c’.split(‘ ‘))<br>#[‘a’, ‘b’, ‘’, ‘’, ‘c’],无法识别连续的空格<br>#用正则表达式试试<br>print(re.split(r’\\s+’,’a b   c’))<br>#[‘a’, ‘b’, ‘c’]<br>print(re.split(r’[\\s,;]+’, ‘a,b;; c  d’))<br>#[‘a’, ‘b’, ‘c’, ‘d’]</p>\n<p>#分组<br>m=re.match(r’^(\\d{3})-(\\d{3,8})$’,’010-12345’)<br>print(m)<br>print(‘m.group(0): ‘,m.group(0),’\\nm.group(1): ‘,m.group(1),’\\nm.group(2): ‘,m.group(2))</p>\n<p>‘’’<br>^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从<br>匹配的字符串中提取出区号和本地号码</p>\n<p>如果正则表达式中定义了组，就可以在Match对象上用<br>group()方法提取出子串来。<br>‘’’<br>#提取时间<br>t=’19:05:30’<br>m=re.match(r’^(0[0-9]|1[0-9]|2[0-3]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$’,t)<br>print(m.groups())</p>\n<p>#这样可以直接匹配出合法时间,但有些时候,正则也无法完全验证,这时候就要配合程序了</p>\n<p>#贪婪匹配<br>#正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符<br>print(re.match(r’^(\\d+)(0<em>)$’, ‘102300’).groups())<br>#Out[]:(‘102300’, ‘’)<br>#由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0</em>只能匹配空字符串了。</p>\n<p>#必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，<br>#加个?就可以让\\d+采用非贪婪匹配：</p>\n<p>#尽可能少 匹配<br>print(re.match(r’^(\\d+?)(0*)$’, ‘102300’).groups())<br>#out[]:(‘1023’, ‘00’)</p>\n<p>#编译<br>‘’’<br>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>\n<pre><code>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；\n\n用编译后的正则表达式去匹配字符串。</code></pre><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预<br>编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br>‘’’<br>re_telephone = re.compile(r’^(\\d{3})-(\\d{3,8})$’)<br>print(re_telephone.match(‘010-12345’).groups())<br>print(re_telephone.match(‘010-8086’).groups())</p>\n</li>\n</ul>\n<pre><code>#邮箱匹配1\nimport re\nEmail=input(&apos;please enter the Email:&apos;)\nre_mode=re.compile(r&apos;&lt;([a-zA-Z]* [a-zA-Z]*)&gt; [\\w.]*@\\w+.[a-z]*&apos;)\nwe=re_mode.match(Email)\nif we:\n    print(we.groups())\nelse:\n    print(&apos;failed!&apos;)\n\n#邮箱匹配2\nimport re\n&apos;&apos;&apos;\n&gt;&gt;&gt; 834930269@qq.com\nok!\n&apos;&apos;&apos;\ntest=input(&apos;please enter:&apos;)\nre_mode=re.compile(r&apos;[0-9a-zA-Z._]*@\\w+.com&apos;)\nif re_mode.match(test):\n    print(&apos;ok!&apos;)\nelse:\n    print(&apos;failed!&apos;)</code></pre>","categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}