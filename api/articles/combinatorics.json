{"title":"组合数学","slug":"combinatorics","date":"2018-01-25T13:04:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/combinatorics.json","photos":[],"link":"","excerpt":null,"covers":["http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png","http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215217.png","http://be-sunshine.cn/wp-content/uploads/2018/01/20170611212741764.jpg"],"content":"<blockquote>\n<p>因为组合数学涉及面广,采取边学边更新.</p>\n<blockquote>\n<p>预计大部分会摘自《组合数学》</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"鸽巢定理\">【鸽巢定理】</span></h1><p>也叫作<code>狄利克雷抽屉原理</code>以及<code>鞋盒原理</code>. 对于鸽巢定理的简单阐释,粗略的说就是如果有许多鸽子飞进不够多的鸽巢内。那么至少要有一个鸽巢被两个或多个鸽子占据.</p>\n<h2><span id=\"简单形式\">简单形式</span></h2><p>很通俗的定理 : 如果要把n+1个物体放进n个盒子内,那么至少有一个盒子包含两个或更多的物体.</p>\n<h2><span id=\"简单应用\">简单应用</span></h2><blockquote>\n<ol>\n<li><p>在13个人中存在两个人,他们的生日在同一个月份里.</p>\n</li>\n<li><p>设有n对已婚夫妻,至少从这2n个人中选出n+1个人可以保证有一对夫妻.</p>\n</li>\n</ol>\n</blockquote>\n<h2><span id=\"应用3\">应用3</span></h2><h3><span id=\"这一条要拿出来因为比较重要\">这一条要拿出来,因为比较重要</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png\" alt></p>\n<h3><span id=\"证明\">证明</span></h3><p>考虑$$m$$个和: $$a_1,a_1+a_2,a_1+a_2+a_3,…,a_1+a_2+a_3+…+a_m$$ 如果这些和当中的任意一个可被$$m$$整除,那么结论就成立。因此,我们可以假设这些和中的每一个除以$$m$$都有一个非零余数,余数等于$$1,2,3,4,…,m-1$$中的一个数。因为有$$m$$个和,而只有$$m-1$$个余数,所以必然有两个序列的和除以$$m$$有相同的余数.因此,存在整数$$k,l,k \\&lt; l$$,使得$$a_1+a_2+…+a_k$$和$$a_1+a_2+…+a_l$$除以$$m$$有相同的余数$$r$$: $$a_1+a_2+…+a_k = bm+r,a_1+a_2+…+a_l = cm+r$$ 二式相减,我们发现$$ a_{k+1} $$+$$a_{k+2}+…+a_l = (c-b)m$$。 从而推断出,$$m$$个正整数的序列.一定存在一组序列的和为$$m$$的整数倍. <strong>上面的Latex公示如果没显示完全看下面的图片(PS:Latex公式好麻烦,而且支持也好麻烦):</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180125215217.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215217.png\" alt></a></p>\n<h3><span id=\"具体应用poj2356\">具体应用POJ2356</span></h3><p>题意:输入N个正整数,选择序列中的一些数字,使其和为$$N\\*k$$(k为正整数). 代码:</p>\n<pre><code>//问从N个数中选取多少个数,使得这些数的和%N==0\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=10000+10;\nint num[maxn],sum[maxn];\nint r[maxn];\nint main(){\n    int N,ans=0,k=0,l=1;\n    memset(r,-1,sizeof(r));\n    scanf(&quot;%d&quot;,&amp;N);\n    sum[0]=0;\n\n    for(int i=1;i&lt;=N;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n        sum[i]=sum[i-1]+num[i];\n\n        int remainder=sum[i]%N;\n        if(remainder==0){\n            ans=i;\n            k=0;\n            l=i;\n        }else if(r[remainder]!=-1){\n            ans=i-r[remainder];\n            k=r[remainder];\n            l=i;\n        }else r[remainder]=i;\n    }\n    printf(&quot;%d\\n&quot;,ans);\n    for(int i=k+1;i&lt;=l;++i){\n        printf(&quot;%d\\n&quot;,num[i]);\n    }\n    return 0;\n}</code></pre><h1><span id=\"基本计数方法\">基本计数方法</span></h1><h2><span id=\"加法原理\">加法原理</span></h2><blockquote>\n<p>做一件事情有n种方法,第i中方法有Pi种方案,则一共有P1+P2+P3+…+Pn种方法.</p>\n</blockquote>\n<h2><span id=\"乘法原理\">乘法原理</span></h2><blockquote>\n<p>做一件事情有n个步骤,第i个步骤有Pi种方案,则一共有P1P2P3…Pn中方案.</p>\n</blockquote>\n<h2><span id=\"容斥原理\">容斥原理</span></h2><blockquote>\n<p>最基本的公式:</p>\n<blockquote>\n<p>|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"常见问题\">常见问题</span></h3><h4><span id=\"错位排列\">错位排列</span></h4><blockquote>\n<p>待填充</p>\n</blockquote>\n<h1><span id=\"组合问题\">组合问题</span></h1><blockquote>\n<p>有n个不同的数,选出k个(顺序无关),每个数最多选一次,有多少种选法?</p>\n<blockquote>\n<p>记答案为C(n,k)。把n选k的排列问题看成两个步骤,首先选出k个数的组合,然后把这k个数进行全排列.由乘法原理知:</p>\n<blockquote>\n<p>P(n,k)=C(n,k)*P(k,k) 即<br>C(n,k)=n!/((n-k)!k!)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2><span id=\"性质1\">性质1</span></h2><blockquote>\n<p>C(n,0)=C(n,n)=1</p>\n</blockquote>\n<h2><span id=\"性质2\">性质2</span></h2><blockquote>\n<p>C(n,k)=C(n,n-k)</p>\n</blockquote>\n<h2><span id=\"性质3\">性质3</span></h2><blockquote>\n<p>C(n,k)+C(n,k+1)=C(n+1,k+1) 通常用于预处理C(n+1,…)</p>\n</blockquote>\n<h2><span id=\"性质4\">性质4</span></h2><blockquote>\n<p>C(n,k+1)=C(n,k)*(n-k)/(k+1) 使用这个公式可以在O(n)的时间内求出C(n) 但注意不要发生乘法溢出.及后面的除法溢出</p>\n</blockquote>\n<h3><span id=\"性质4通常运用-gt-二项式展开\">性质4通常运用 =&gt; 二项式展开</span></h3><blockquote>\n<p>问题:</p>\n<blockquote>\n<p>求(a+b)^n展开式的各项系数</p>\n<blockquote>\n<p>二项式定理 (a+b)^n=Sigma(k=0~n)C(n,k)a^(n-k)b^k</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2><span id=\"其余三个问题\">其余三个问题</span></h2><h2><span id=\"有重复元素的全排列\">有重复元素的全排列</span></h2><blockquote>\n<p>有重复元素的全排列</p>\n<blockquote>\n<p>有k个元素,其中第i个元素有Ni个,求全排列个数.</p>\n<blockquote>\n<p>直接看结论,可以简单证得 N1!*N2!*N3!<em>…\\</em>Nn!*ans=N! (移项即可)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2><span id=\"可重复选择的组合\">可重复选择的组合</span></h2><blockquote>\n<p>可重复选择的组合</p>\n<blockquote>\n<p>有n个不同的元素,每个元素可以选择多次,一共选k个元素,有多少种选法?</p>\n<blockquote>\n<p>例如n=3,k=2有6种</p>\n<blockquote>\n<p>(1,1)、(1,2)、(1,3)、(2,2)、(2,3)、(3,3)</p>\n</blockquote>\n</blockquote>\n<p>分析:</p>\n<blockquote>\n<p>设第i个元素选xi个,问题转化为求方程x1+x2+…+x3=k的非负整数解的个数. 令yi=xi+1,则答案为 y1+y2+y3+…+yn=k+n</p>\n</blockquote>\n</blockquote>\n<p>没太搞懂,直接放答案吧 C(k+n-1,n-1) =C(n+k-1,k)(性质2)</p>\n</blockquote>\n<h2><span id=\"单色三角形\">单色三角形</span></h2><blockquote>\n<p>给定空间内的n(n&lt;=1000)个点,其中没有三点共线,每两个点之间都用红色或黑色线段链接.求三条边同色的三角形个数.</p>\n<blockquote>\n<p>考虑非单色三角形. 如果第i个点连接了ai条红边和n-1-ai条黑边,则这些边属于ai(n-1-ai)个非单色三角形。每个非单色三角形被考虑了两次,所以最终答案除以2 即 1/2*Sigma(i=1~n) ai(n-1-ai) 用总三角形减去非单色即为单色三角形个数</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"生成函数\">生成函数</span></h1><blockquote>\n<p>母函数是用于解决组合问题计数的一种方法。 在了解它之前我们先看看熟悉的杨辉三角。</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170611212741764.jpg\" alt></p>\n<blockquote>\n<p>杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)^n的展开式从低项到高项的各项系数，也可以表示为组合数的形式C(i,n)。如果将两者联系起来我们会发现，(1+x)可以看成对于一件取舍，1=x^0就是不取，x就是取。这样在(1+x)^n的展开式中x^i项的系数就是从n件物品选取i件的方案数。</p>\n</blockquote>\n<h2><span id=\"定义\">定义</span></h2><blockquote>\n<p>给定数列a0,a1,a2…an，构造函数</p>\n<blockquote>\n<p>G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)</p>\n<blockquote>\n<p>其中G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)为标志函数。 母函数主要有两种形式：普通型母函数和指数型母函数。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3><span id=\"普通型母函数\">普通型母函数</span></h3><blockquote>\n<p>先看一个例题：HDU 1085</p>\n<blockquote>\n<p>普通型母函数的标志函数一般为x^0,x^1,x^2…x^n</p>\n</blockquote>\n<p>因为每个硬币有个数限制，但是也不难构造出</p>\n<blockquote>\n<p>G(x)=(1+x+x^2+x^3+…+x^num1)(1+x^2+x^4+…+x^(2∗num2))(1+x^5+x^10+…+x^(5∗num5)) 。</p>\n</blockquote>\n<p>将多项式展开后，x^i项对应的系数就是组成面值为i的方案数。 例题: 51nod 1383</p>\n</blockquote>\n<h3><span id=\"指数型母函数\">指数型母函数</span></h3><blockquote>\n<p>再看一个例题：HDU 1521</p>\n<blockquote>\n<p>指数型母函数的标志函数一般为x^0/0!,x^1/1!,x^2/2!…x^n/n!，对于x^i/i!表示在一个方案中某个元素出现了i次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！</p>\n</blockquote>\n<p>对于这道题就不难构造出母函数为</p>\n<blockquote>\n<p>G(x)=(1/0!+X/1!+X^2/2!+…+X^a1/a1!)(1/0!+X/1!+X^2/2!+…+X^a2/a2!)(1/0!+X/1!+X^2/2!+…+X^an/an!)</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"catalan数列\">Catalan数列</span></h1><h2><span id=\"介绍\">介绍</span></h2><h3><span id=\"待整理\">待整理</span></h3><blockquote>\n<p>Catalan数列可以解决很多问题.</p>\n<blockquote>\n<p>比如51nod 1120</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"catalan前几项\">Catalan前几项</span></h2><pre><code>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, 18367353072152, 69533550916004, 263747951750360, 1002242216651368, 3814986502092304, 14544636039226909, 55534064877048198, 212336130412243110, 812944042149730764, 3116285494907301262, 11959798385860453492, 45950804324621742364, ...</code></pre><h2><span id=\"应用\">应用</span></h2><h3><span id=\"一个小链接\">一个小链接</span></h3><p><a href=\"https://www.cnblogs.com/yaoyueduzhen/p/5456490.html\" title=\"Catalan应用及介绍\" target=\"_blank\" rel=\"noopener\">Catalan应用及介绍</a></p>\n<h3><span id=\"待整理\">待整理</span></h3><h2><span id=\"三种方法求catalan整合\">三种方法求Catalan整合</span></h2><h3><span id=\"注其中有牵扯lucaslucas在下面直接放代码注释在代码中有对各个类型进行耗时对比\">注:其中有牵扯Lucas,Lucas在下面,直接放代码,注释在代码中,有对各个类型进行耗时对比</span></h3><h3><span id=\"注2求逆元中牵扯到了费马求逆元和欧拉求逆元\">注2:求逆元中牵扯到了费马求逆元和欧拉求逆元</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int maxn=1000000+10;\nLL h[10100];\n\n//函数功能: 预处理前N向Catalan\n//函数参数: n为项数\n//适合N比较小的情况\nvoid Catalan(int n){\n    h[0] = h[1] = 1;        //h(0)和h(1)\n    for(int i = 2; i &lt;= n; i++)    //依次计算h(2),h(3)...h(n)\n    {\n        h[i] = 0;\n        for(int j = 0; j &lt; i; j++) //根据递归式计算 h(i)= h(0)*h(i-1)+h(1)*h(i-2) + ... + h(i-1)h(0)\n            h[i] = (h[i]+(h[j] * h[i-1-j])%mod)%mod;\n    }\n}\n\n///h(n)=C(2n,n)/(n+1) (n=0,1,2,...)\n///+逆元+Lucas组合数取模\n///预处理逆元的话,大小会被限制,直接求的话可能会有常数\n///但是N就可以大一点\n///返回第N个catalan数\nLL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}\n///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nLL N_L_Catalan(int N){\n    return Lucas(2*N,N,mod)*inv[N+1]%mod;\n}\n\n///第三种方法\n///h(n)=C(2n,n)-C(2n,n+1)\n///由上式子可以直接两个Lucas+同余定理解决\n///复杂度可能会比第二种方法换成直接求逆元要高点\nLL T_Catalan(int N){\n    return (Lucas(2*N,N,mod)-Lucas(2*N,N+1,mod)+mod)%mod;\n}\n\n\n///第四种方法\n///直接求逆元(扩展欧几里得求逆元)+Lucas\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inverse(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nLL F_Catalan(int N){\n    return Lucas(2*N,N,mod)*inverse(1ll*N+1,1ll*mod)%mod;\n}\n\n///第五种\n///欧拉定理求逆元+Lucas\n///mod是素数且与N互质\nlong long Pow(long long a,long long b){\n    long long ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%mod;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%mod;\n    }\n    return ans;\n}\n\nlong long euler(int p)\n{\n    long long ans=p,a=p;\n    long long i;\n    for(i=2;i*i&lt;=a;i++)\n    {\n        if(a%i==0)\n        {\n            ans=ans/i*(i-1);\n            while(a%i==0)\n                a/=i;\n        }\n    }\n    if(a&gt;1)\n        ans=ans/a*(a-1);\n    return ans;\n}\n\nlong long eu=euler(mod)-1;\n\nlong long Einv(long long a)\n{\n    return Pow(a,eu);\n}\n\nLL Fi_Catalan(int N){\n    return Lucas(2*N,N,mod)*Einv(1ll*(N+1))%mod;\n}\n\nint main(){\n    Catalan(10000);\n    init();//初始化逆元\n    int k;\n    while(cin&gt;&gt;k){\n        if(k&lt;=10000)\n            cout&lt;&lt;&quot;第一种方法(预处理): &quot;&lt;&lt;h[k]&lt;&lt;endl;\n        if(k&lt;=1000000)\n            cout&lt;&lt;&quot;第二种方法(h(n)=C(2n,n)/(n+1),预处理逆元+Lucas): &quot;&lt;&lt;N_L_Catalan(k)&lt;&lt;endl;\n        clock_t startTime,endTime;\n        startTime = clock();\n        cout&lt;&lt;&quot;第三种方法(h(n)=C(2n,n)-C(2n,n+1),Lucas): &quot;&lt;&lt;T_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第四种方法(h(n)=C(2n,n)/(n+1),Lucas+扩欧求逆元): &quot;&lt;&lt;F_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第五种方法(h(n)=C(2n,n)/(n+1),Lucas+欧拉定理求逆元): &quot;&lt;&lt;Fi_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n    }\n    return 0;\n}</code></pre><h1><span id=\"lucas\">Lucas</span></h1><h2><span id=\"介绍\">介绍</span></h2><blockquote>\n<p>Lucas定理用于对组合数求模</p>\n<blockquote>\n<p>因为组合数是一个大式子,无法直接求模,所以用到了Lucas</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"code\">Code</span></h2><pre><code>///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}</code></pre>","categories":[{"name":"组合数学","slug":"组合数学","count":1,"path":"api/categories/组合数学.json"}],"tags":[{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"}]}