{"title":"动态规划模板","slug":"dynamic-muban","date":"2017-04-16T04:00:16.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dynamic-muban.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【多重部分和问题】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=100000+10;</strong> <strong>int A[maxn],M[maxn],N,K;</strong> <strong>int dp[maxn];//滚动数组,当前第i个数在第j权下剩余的数量</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;N) &amp;&amp; N){** **        for(int i=0;i&lt;N;++i)** **            scanf(“%d%d”,&amp;A[i],&amp;M[i]);** **        cin&gt;&gt;K;** **        fill(dp,dp+maxn,-1);** **        dp[0]=0;** **        for(int i=0;i&lt;N;++i)** **            for(int j=0;j&lt;=K;++j){** **                if(dp[j]&gt;=0){** **                    dp[j]=M[i];** **                }else if(j&lt;A[i] || dp[j-A[i]]&lt;=0){** **                    dp[j]=-1;** **                }else{** **                    dp[j]=dp[j-A[i]]-1;** **                }** **            }** **        if(dp[K]&gt;=0) printf(“YES\\n”);** **        else puts(“NO”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【不等概率掷硬币】</strong></p>\n<blockquote>\n<p><strong>小Hi有一枚神奇的硬币。已知第i次投掷这枚硬币时，正面向上的概率是Pi。  ** **现在小Hi想知道如果总共投掷N次，其中恰好M次正面向上的概率是多少。</strong> <strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>double dp[1005][1005];</strong> <strong>int main(){</strong> <em>*    int n,m;** **    scanf(“%d%d”,&amp;n,&amp;m);** **    dp[0][0]=1.0;** **    for(int i=0;i&lt;n;++i){** **        double x;** **        scanf(“%lf”,&amp;x);** **        for(int j=0;j&lt;=i;++j){** **            dp[i+1][j]+=dp[i][j]</em>(1.0-x);** **            dp[i+1][j+1]+=dp[i][j]<em>x;*</em> **        }** **    }** **    printf(“%.6lf\\n”,dp[n][m]);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【LIS最长上升子序列】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>int A[30]={1,2,12,4,7,6,32,54,2,8784,23,212,54,59,85,2,6,542,35},N=19;</strong> <strong>int dp[20],maxmum=-INF;</strong> <strong>int main(){</strong> **    rep(i,N){** **        dp[i]=1;** **        rep(j,i){** **            if(A[j]&lt;A[i])** **                dp[i]=max(dp[i],dp[j]+1);** **        }** **        maxmum=max(maxmum,dp[i]);** **    }** **    rep(i,N){** **        printf(“%d “,dp[i]);** **    }** **    printf(“\\n%d\\n”,maxmum);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【排除62和4-数位dp】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"模板","slug":"动态规划/模板","count":1,"path":"api/categories/动态规划/模板.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}