{"title":"UVa 11021","slug":"uva-11021","date":"2018-03-13T01:56:34.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/uva-11021.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"Type-概率\"><a href=\"#Type-概率\" class=\"headerlink\" title=\"Type: 概率\"></a>Type: 概率</h1><h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>有点难以理解题解的递推式,把那句f(i-1)表示i-1天后全部死亡改成f(i-1)表示i-1天后一个不生的概率可能更好理解一点吧 不知道怎么证明这个式子,思维还是不强</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1010;\n\ndouble f[maxn],P[maxn];;\nint n,k,m,T;\n\nint main(){\n    cin&gt;&gt;T;\n    for(int i=1;i&lt;=T;++i){\n        cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;\n        for(int j=0;j&lt;n;++j) cin&gt;&gt;P[j];\n        f[0]=0;f[1]=P[0];\n        for(int j=2;j&lt;=m;++j){\n            f[j]=0;\n            for(int t=0;t&lt;n;++t){\n                f[j]+=(P[t]*pow(f[j-1],t));\n            }\n        }\n        printf(&quot;Case #%d: %.7lf\\n&quot;,i,pow(f[m],k));\n    }\n    return 0;\n}</code></pre>","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}