{"title":"python3学习 定制类","slug":"python3-str-getatr","date":"2017-07-16T08:33:50.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-str-getatr.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Source Code】</strong> <strong>github:<a href=\"https://github.com/834930269/python_study/blob/master/oop/%E5%AE%9A%E5%88%B6%E7%B1%BB.py\" target=\"_blank\" rel=\"noopener\">定制类.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[3]:</p>\n<p>#__str__<br>class student(object):<br>    def __init__(self,name):<br>        self.name=name<br>    def __str__(self):<br>        return ‘Student object (name: %s)’ % self.name<br>    __repr__=__str__<br>s=student(‘Michael’)</p>\n<p>#__str__是控制打印时输出类型,__repr__是控制台直接s输出的类型</p>\n<p>#如果不重写,那会输出&lt;__main__.Student object at 地址&gt;<br>s<br>print(s)</p>\n<p># In[10]:</p>\n<p>#__iter__<br>‘’’<br>如果一个类想被用于for … in循环，类似list或tuple那样，就必<br>须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python<br>的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个<br>值，直到遇到StopIteration错误时退出循环。</p>\n<p>斐波那契:<br>‘’’<br>class Fib(object):<br>    def __init__(self):<br>        self.a, self.b = 0, 1 # 初始化两个计数器a，b</p>\n<pre><code>def \\_\\_iter\\_\\_(self):\n    return self # 实例本身就是迭代对象，故返回自己\n\ndef \\_\\_next\\_\\_(self):\n    self.a, self.b = self.b, self.a + self.b # 计算下一个值\n    if self.a &gt; 100000: # 退出循环的条件\n        raise StopIteration()\n    return self.a # 返回下一个值\ndef \\_\\_getitem\\_\\_(self, n):\n    if isinstance(n, int): # n是索引\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n    if isinstance(n, slice): # n是切片\n        start = n.start\n        stop = n.stop\n        if start is None:\n            start = 0\n        a, b = 1, 1\n        L = \\[\\]\n        for x in range(stop):\n            if x &gt;= start:\n                L.append(a)\n            a, b = b, a + b\n        return L</code></pre><p>for i in Fib():<br>    print(i)</p>\n<p># In[14]:</p>\n<p>#__getitem__</p>\n<p>#Fib实例虽然能作用于for循环，看起来和list有点像，</p>\n<p>#但是，把它当成list来使用还是不行</p>\n<p>#要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：<br>f=Fib()<br>print(f[0],f[1],f[2],f[100])<br>‘’’<br>但是list有个神奇的切片方法：</p>\n<blockquote>\n<blockquote>\n<p>&gt; list(range(100))[5:10]<br>[5, 6, 7, 8, 9]</p>\n</blockquote>\n</blockquote>\n<p>对于Fib却报错。原因是__getitem__()传入的参数<br>可能是一个int，也可能是一个 切片对象slice ，所以要做判断：</p>\n<p>class Fib(object):<br>    def __getitem__(self, n):<br>        if isinstance(n, int): # n是索引<br>        if isinstance(n, slice): # n是切片<br>‘’’<br>print(f[:20])#但是没有判断倒序切片以及没有对step参数作处理：</p>\n<p>‘’’<br>此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以<br>作key的object，例如str。</p>\n<p>与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋<br>值。最后，还有一个__delitem__()方法，用于删除某个元素。</p>\n<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的<br>list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”<br>，不需要强制继承某个接口。<br>‘’’</p>\n<p># In[18]:</p>\n<p>#__getattr__</p>\n<p>#正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：<br>class Student(object):<br>    def __init__(self):<br>        self.name = ‘Michael’<br>    def __getattr__(self, attr):<br>        if attr==’score’:<br>            return 99<br>        if attr==’age’:<br>            return lambda: 25<br>        raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)</p>\n<p>#调用name属性，没问题，但是，调用不存在的score属性，就有问题了<br>‘’’</p>\n<blockquote>\n<blockquote>\n<p>&gt; s = Student()<br>&gt; print(s.name)<br>Michael<br>&gt; print(s.score)<br>Traceback (most recent call last):<br>  …<br>AttributeError: ‘Student’ object has no attribute ‘score’<br>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>\n</blockquote>\n</blockquote>\n<p>要避免这个错误，除了可以加上一个score属性外，Python还有另<br>一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：<br>class Student(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self):\n    self.name = &apos;Michael&apos;\n\ndef \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;score&apos;:\n        return 99</code></pre><p>返回函数也是完全可以的：<br>class Student(object):</p>\n<pre><code>def \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;age&apos;:\n        return lambda: 25</code></pre><p>只是调用方式要变为：</p>\n<blockquote>\n<blockquote>\n<p>&gt; s.age()<br>25<br>注意，只有在没有找到属性的情况下，才调用__getattr__，<br>已有的属性，比如name，不会在__getattr__中查找。</p>\n</blockquote>\n</blockquote>\n<p>此外，注意到任意调用如s.abc都会返回None，这是因为我们<br>定义的__getattr__默认返回就是None。要让class只响应特定<br>的几个属性，我们就要按照约定，抛出AttributeError的错误：<br>raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)<br>‘’’<br>s=Student()<br>print(s.name,s.score,s.age())</p>\n<p># In[19]:</p>\n<p>‘’’<br>举个例子：</p>\n<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>\n<pre><code>http://api.server/user/friends\nhttp://api.server/user/timeline/list</code></pre><p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>\n<p>利用完全动态的__getattr__，我们可以写出一个链式调用：<br>‘’’<br>class Chain(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self, path=&apos;&apos;):\n    self._path = path\n\ndef \\_\\_getattr\\_\\_(self, path):\n    return Chain(&apos;%s/%s&apos; % (self._path, path))\n\ndef \\_\\_str\\_\\_(self):\n    return self._path\n\n\\_\\_repr\\_\\_ = \\_\\_str\\_\\_</code></pre><p>#try<br>print(Chain().status.user.timeline.list)</p>\n<p>#out[]: /status/user/timeline/list</p>\n<p>#这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，</p>\n<p>#而且，不随API的增加而改变！</p>\n<p>#还有些REST API会把参数放到URL中，比如GitHub的API：</p>\n<p>#GET /users/:user/repos</p>\n<p>#调用时，需要把:user替换为实际用户名。</p>\n<p># In[21]:</p>\n<p>#__call__<br>class Student(object):<br>    def __init__(self, name):<br>        self.name = name</p>\n<pre><code>def \\_\\_call\\_\\_(self):\n    print(&apos;My name is %s.&apos; % self.name)</code></pre><p>s = Student(‘Michael’)<br>s()</p>\n<p># In[29]:</p>\n<p>print(callable(max),callable(map),callable(str),callable(‘123’))</p>\n<p># In[ ]:**</p>\n","categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}