{"title":"Python Flask 6.0.2 相对路径","slug":"python-flask-6-0-2-path","date":"2017-10-13T04:17:13.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-6-0-2-path.json","photos":[],"link":"","excerpt":null,"covers":["http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg"],"content":"<p>在Python引入包时,我们会发现有这样的一种引用方法: <code>from . import XX</code>,以及<code>from .. import xx</code>. 这就是相对路径引用. 其中有几点需要注意. <code>1.</code>在编译时,存在这种相对引用的<code>.py</code>是无法被<code>单独编译</code>的,只有在编译最高级的<code>.py</code>时,才不会报<code>编译级别错误</code>. <code>2.</code>存在<code>跨文件夹引用</code>时,需要在相应文件夹内创建一个<code>__init__.py</code>才可以引用成功,(<code>就算该文件是空的也没关系</code>)因为加了这个文件,编译器才会把该文件夹看做一个<code>package</code>,即可以用<code>from 文件夹名 import 类/文件</code>等方式进行引用. <code>3.</code>在主程序运行后,调用每个包时会先调用该包的<code>__init__.py</code>文件,然后再调用对应<code>import</code>的内容. 这里我结合上一节的<code>Factory method</code>编写了一个简单的测试程序:</p>\n<pre><code>具体目录结构如下:\n--工厂函数/\n    --tests/\n        --abc/\n            --__init__.py\n            --qb.py\n        --__init__.py\n        --test2.py\n    --test.py(主程)</code></pre><p>项目地址: <a href=\"https://github.com/834930269/python_study/tree/master/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0\" title=\"&lt;code&gt;Click Here: 工厂函数&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>Click Here: 工厂函数</code></a> 运行<code>test.py</code>,<code>Result:</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg\" alt></a> <code>test.py</code>:</p>\n<pre><code>from tests.abc.qb import crete_factory_method\n\nfactory_test = crete_factory_method(&apos;这是第一个单元测试&apos;)\n\nfactory_test2 = crete_factory_method(&apos;这是第二个单元测试&apos;)\n\nfactory_test.print_str()\n\nfactory_test2.print_str()</code></pre><p><code>tests/__init__.py</code>:</p>\n<pre><code>print(&quot;I&apos;m Tom&apos;s __init__!&quot;)</code></pre><p><code>tests/test2.py</code>:</p>\n<pre><code>class mq(object):\n    def __init__(self,string_c):\n        self.config_str=string_c\n    def print_str(self):\n        print(self.config_str)</code></pre><p><code>tests/abc/__init__.py</code>:</p>\n<pre><code>print(&apos;由此可知,如果直接编译qb.py会报错,因为等级?错误,但是直接编译最顶层的test.py就不会报错了.&apos;)</code></pre><p><code>tests/abc/qb.py</code>:</p>\n<pre><code>from ..test2 import mq\n\ndef crete_factory_method(config_str):\n    tp=mq(config_str)\n    return tp</code></pre>","categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}