{"title":"Spring Validation-Spring后台验证框架","slug":"spring-validation-spring","date":"2019-02-09T15:34:46.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-validation-spring.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"JSR-303简介\"><a href=\"#JSR-303简介\" class=\"headerlink\" title=\"JSR-303简介\"></a>JSR-303简介</h1><p>JSR-303 是 JavaEE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator。 此实现与 Hibernate ORM 没有任何关系。JSR-303 用于对 Java Bean 中的字段的值进行验证。 Spring MVC 3.x 之中也大力支持 JSR-303，可以在控制器中使用注解的方式对表单提交的数据方便地验证。 Spring 4.0 开始支持 Bean Validation 功能。</p>\n<h1 id=\"JSR-303-基本的校验规则\"><a href=\"#JSR-303-基本的校验规则\" class=\"headerlink\" title=\"JSR-303 基本的校验规则\"></a>JSR-303 基本的校验规则</h1><p>注解</p>\n<p>作用</p>\n<p>@Null</p>\n<p>验证对象是否为 null</p>\n<p>@NotNull</p>\n<p>验证对象是否不为 null, 无法查检长度为 0 的字符串</p>\n<p>@NotBlank</p>\n<p>检查约束字符串是不是 Null 还有被 Trim 的长度是否大于 0,只对字符串,且会去掉前后空格</p>\n<p>@NotEmpty</p>\n<p>检查约束元素是否为 NULL 或者是 EMPTY</p>\n<p>@AssertTrue</p>\n<p>验证 Boolean 对象是否为 true</p>\n<p>@AssertFalse</p>\n<p>验证 Boolean 对象是否为 false</p>\n<p>@Size(min=, max=)</p>\n<p>验证对象（Array, Collection , Map, String）长度是否在给定的范围之内</p>\n<p>@Length(min=, max=)</p>\n<p>验证字符串长度介于 min 和 max 之间</p>\n<p>@Past</p>\n<p>验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期</p>\n<p>@Future</p>\n<p>验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期</p>\n<p>@Pattern</p>\n<p>验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式</p>\n<p>@Min</p>\n<p>验证 Number 和 String 对象是否大等于指定的值</p>\n<p>@Max</p>\n<p>验证 Number 和 String 对象是否小等于指定的值</p>\n<p>@DecimalMax</p>\n<p>被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过 BigDecimal 定义的最大值的字符串表示 .小数 存在精度</p>\n<p>@DecimalMin</p>\n<p>被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过 BigDecimal 定义的最小值的字符串表示 .小数 存在精度</p>\n<p>@Digits</p>\n<p>验证 Number 和 String 的构成是否合法</p>\n<p>@Digits(integer=,fraction=)</p>\n<p>验证字符串是否是符合指定格式的数字，integer 指定整数精度，fraction 指定小数精度</p>\n<p>@Range(min=, max=)</p>\n<p>被指定的元素必须在合适的范围内@Range(min=10000,max=50000,message=”range.bean.wage”)</p>\n<p>@Valid</p>\n<p>递归的对关联对象进行校验, 如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个 map，则对其中的值部分进行校验.(是否进行递归验证)</p>\n<p>@CreditCardNumber</p>\n<p>信用卡验证</p>\n<p>@Email</p>\n<p>验证是否是邮件地址，如果为 null，不进行验证，算通过验证</p>\n<h1 id=\"粘贴到Spring上\"><a href=\"#粘贴到Spring上\" class=\"headerlink\" title=\"粘贴到Spring上\"></a>粘贴到Spring上</h1><h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n    &lt;version&gt;5.3.4.Final&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><h2 id=\"定义验证工具类\"><a href=\"#定义验证工具类\" class=\"headerlink\" title=\"定义验证工具类\"></a>定义验证工具类</h2><blockquote>\n<p>把所有类型的异常都转换为List&lt;&gt;型异常,然后在出口函数除捕捉异常并打印出来.调用validation的方法即直接调用.</p>\n</blockquote>\n<pre><code>import org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.validation.ConstraintViolation;\nimport javax.validation.ConstraintViolationException;\nimport javax.validation.Validator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * JSR303 Validator(Hibernate Validator)工具类.\n * &lt;p&gt;\n * ConstraintViolation 中包含 propertyPath, message 和 invalidValue 等信息.\n * 提供了各种 convert 方法，适合不同的 i18n 需求:\n * 1. List&lt;String&gt;, String 内容为 message\n * 2. List&lt;String&gt;, String 内容为 propertyPath + separator + message\n * 3. Map&lt;propertyPath, message&gt;\n * &lt;p&gt;\n * 详情见wiki: https://github.com/springside/springside4/wiki/HibernateValidator\n *\n * &lt;p&gt;Title: BeanValidator&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/26 17:21\n */\npublic class BeanValidator {\n\n    @Autowired\n    private static Validator validator;\n\n    public static void setValidator(Validator validator) {\n        BeanValidator.validator = validator;\n    }\n\n    /**\n     * 调用 JSR303 的 validate 方法, 验证失败时抛出 ConstraintViolationException.\n     */\n    private static void validateWithException(Validator validator, Object object, Class&lt;?&gt;... groups) throws ConstraintViolationException {\n        Set constraintViolations = validator.validate(object, groups);\n        if (!constraintViolations.isEmpty()) {\n            throw new ConstraintViolationException(constraintViolations);\n        }\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 中为 List&lt;message&gt;.\n     */\n    private static List&lt;String&gt; extractMessage(ConstraintViolationException e) {\n        return extractMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 List&lt;message&gt;\n     */\n    private static List&lt;String&gt; extractMessage(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        List&lt;String&gt; errorMessages = new ArrayList&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 Map&lt;property, message&gt;.\n     */\n    private static Map&lt;String, String&gt; extractPropertyAndMessage(ConstraintViolationException e) {\n        return extractPropertyAndMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 Map&lt;property, message&gt;.\n     */\n    private static Map&lt;String, String&gt; extractPropertyAndMessage(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        Map&lt;String, String&gt; errorMessages = new HashMap&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.put(violation.getPropertyPath().toString(), violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(ConstraintViolationException e) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), &quot; &quot;);\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        return extractPropertyAndMessageAsList(constraintViolations, &quot; &quot;);\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath + separator + message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(ConstraintViolationException e, String separator) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), separator);\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 List&lt;propertyPath + separator + message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(Set&lt;? extends ConstraintViolation&gt; constraintViolations, String separator) {\n        List&lt;String&gt; errorMessages = new ArrayList&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getPropertyPath() + separator + violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 服务端参数有效性验证\n     *\n     * @param object 验证的实体对象\n     * @param groups 验证组\n     * @return 验证成功：返回 null；验证失败：返回错误信息\n     */\n    public static String validator(Object object, Class&lt;?&gt;... groups) {\n        try {\n            validateWithException(validator, object, groups);\n        } catch (ConstraintViolationException ex) {\n            List&lt;String&gt; list = extractMessage(ex);\n            list.add(0, &quot;数据验证失败：&quot;);\n\n            // 封装错误消息为字符串\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i &lt; list.size(); i++) {\n                String exMsg = list.get(i);\n                if (i != 0 ){\n                    sb.append(String.format(&quot;%s. %s&quot;, i, exMsg)).append(list.size() &gt; 1 ? &quot;&lt;br/&gt;&quot; : &quot;&quot;);\n                } else {\n                    sb.append(exMsg).append(list.size() &gt; 1 ? &quot;&lt;br/&gt;&quot; : &quot;&quot;);\n                }\n            }\n\n            return sb.toString();\n        }\n\n        return null;\n    }\n}</code></pre><h2 id=\"为实体类添加注解\"><a href=\"#为实体类添加注解\" class=\"headerlink\" title=\"为实体类添加注解\"></a>为实体类添加注解</h2><p>(domain,model,Entity)</p>\n<pre><code>@Length(min = 6, max = 20, message = &quot;用户名长度必须介于 6 和 20 之间&quot;)\nprivate String username;\n@Length(min = 6, max = 20, message = &quot;密码长度必须介于 6 和 20 之间&quot;)\nprivate String password;\n@Pattern(regexp = RegexpUtils.PHONE, message = &quot;手机号格式不正确&quot;)\nprivate String phone;\n@Pattern(regexp = RegexpUtils.EMAIL, message = &quot;邮箱格式不正确&quot;)\nprivate String email;</code></pre><h2 id=\"注入工具类\"><a href=\"#注入工具类\" class=\"headerlink\" title=\"注入工具类\"></a>注入工具类</h2><blockquote>\n<p>因为在工具类中,static修饰的对象,无法直接注入,所以需要手工注入</p>\n</blockquote>\n<h3 id=\"直接注入\"><a href=\"#直接注入\" class=\"headerlink\" title=\"直接注入\"></a>直接注入</h3><pre><code>&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;/&gt;</code></pre><h3 id=\"手工注入\"><a href=\"#手工注入\" class=\"headerlink\" title=\"手工注入\"></a>手工注入</h3><blockquote>\n<p>两个都必须有</p>\n</blockquote>\n<pre><code>&lt;!-- 配置 Bean Validator 定义 --&gt;\n&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;/&gt;\n&lt;bean id=&quot;beanValidator&quot; class=&quot;com.funtl.my.shop.commons.validator.BeanValidator&quot;&gt;\n    &lt;property name=&quot;validator&quot; ref=&quot;validator&quot; /&gt;\n&lt;/bean&gt;</code></pre>","categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"Spring","slug":"Java/Spring","count":1,"path":"api/categories/Java/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"},{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]}