{"title":"OpenJudge \t程序设计与算法（二）第五周作业(2017春季)","slug":"openjudge-two","date":"2017-03-03T05:38:27.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/openjudge-two.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>–动态规划 【1:拦截导弹】 【Code】</p>\n<blockquote>\n<p><strong><em>#include&lt;bits/stdc++.h&gt;</em></strong> <strong><em>using namespace std;</em></strong> <strong><em>const int maxn=70;</em></strong> <strong><em>int a[maxn],N;</em></strong> <strong><em>int maxlen[maxn],m=-1;</em></strong> <strong><em>int main(){</em></strong> <strong>_    cin&gt;&gt;N;_</strong> <strong>_    for(int i=1;i&lt;=N;++i){_</strong> <strong>_        cin&gt;&gt;a[i]; maxlen[i]=1;_</strong> <strong>_    }_</strong> <strong>_    for(int i=2;i&lt;=N;++i)_</strong> <strong>_        for(int j=1;j&lt;i;++j)_</strong> <strong>_            if(a[i]&lt;=a[j]){_</strong> <strong>_                maxlen[i]=max(maxlen[i],maxlen[j]+1);_</strong> <strong>_                if(maxlen[i]&gt;m) m=maxlen[i];_</strong> <strong>_            }_</strong> <strong>_    cout&lt;&lt;m&lt;&lt;endl;_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>最长上升序列问题,目前对动规的理解走到了明白1.动规是逆着的递归.2.动规是通过从尾开始动态的更改所有的最忧解,从而找到所需要的最优解.</p>\n","categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}