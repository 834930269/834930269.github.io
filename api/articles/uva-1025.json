{"title":"UVa 1025","slug":"uva-1025","date":"2016-12-25T13:49:54.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/uva-1025.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策 2:搭乘往右开的车(如果有)。 决策 3:搭乘往左开的车(如果有)。 【Code】 P268 A Spy in the Metro  </p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;<br>const int inf=0x3f3f3f3f;<br>int N,T,LN,RN,kase=0;<br>bool has_train[205][55][2];<br>int dp[205][55],ti[55];</cstring></p>\n<p>void solve(){</p>\n<pre><code>for(int i=1;i&lt;N;++i) dp\\[T\\]\\[i\\]=inf;\ndp\\[T\\]\\[N\\]=0;\n\nfor(int i=T-1;i&gt;=0;i--)\n    for(int j=1;j&lt;=N;++j){\n        dp\\[i\\]\\[j\\]=dp\\[i+1\\]\\[j\\]+1;//等待一个单位\n        if(j&lt;N&amp;&amp;has_train\\[i\\]\\[j\\]\\[0\\]&amp;&amp;i+ti\\[j\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j\\]\\]\\[j+1\\]);//右\n        if(j&gt;1&amp;&amp;has_train\\[i\\]\\[j\\]\\[1\\]&amp;&amp;i+ti\\[j-1\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j-1\\]\\]\\[j-1\\]);//左\n    }\n\n    cout&lt;&lt;&quot;Case Number &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;;\n    if(dp\\[0\\]\\[1\\]&gt;=inf) cout&lt;&lt;&quot;impossible\\\\n&quot;;\n    else cout&lt;&lt;dp\\[0\\]\\[1\\]&lt;&lt;&quot;\\\\n&quot;;</code></pre><p>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;N&amp;&amp;N){<br>        cin&gt;&gt;T;</p>\n<pre><code>    memset(has\\_train,0,sizeof(has\\_train));\n\n    for(int i=1;i&lt;=N-1;++i)\n        cin&gt;&gt;ti\\[i\\];\n    cin&gt;&gt;LN;//左端点向右开的车\n    for(int i=1;i&lt;=LN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=1;j&lt;=N-1;++j){\n            if(start&lt;=T)has_train\\[start\\]\\[j\\]\\[0\\]=true;//第t秒第j个站点有车\n            start+=ti\\[j\\];\n        }\n    }\n\n    cin&gt;&gt;RN;//右端点向左开的车\n    for(int i=1;i&lt;=RN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=N-1;j&gt;=1;--j){\n               if(start&lt;=T) has_train\\[start\\]\\[j+1\\]\\[1\\]=true;//第t秒第j个站点有车总共N个站台,往回走\n                start+=ti\\[j\\];\n        }\n    }\n    solve();\n\n}\n\nreturn 0;</code></pre><p>}</p>\n","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"},{"name":"算法学习","slug":"UVa/动态规划/算法学习","count":1,"path":"api/categories/UVa/动态规划/算法学习.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}