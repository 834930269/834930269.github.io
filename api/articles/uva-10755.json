{"title":"UVa 10755","slug":"uva-10755","date":"2017-04-08T08:04:53.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-10755.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【类型】</strong> <strong>最大子长方体和,降维.</strong> <strong>【题解】</strong> <strong>蓝书P56</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i)</strong> <strong>using namespace std;</strong> <strong>typedef long long LL;</strong> <strong>const int maxn=30;</strong> <strong>const LL INF=1LL&lt;&lt;60;</strong> <strong>LL S[maxn][maxn][maxn];</strong> <strong>void expand(int i,int&amp; b0,int&amp; b1,int&amp; b2){</strong> **    b0=i&1; i&gt;&gt;=1;** **    b1=i&1; i&gt;&gt;=1;** **    b2=i&1;** <strong>}</strong> <strong>int sign(int b0,int b1,int b2){</strong> **    return (b0+b1+b2)%2==1?1:-1;** <strong>}</strong> <strong>LL sum(int x1,int x2,int y1,int y2,int z1,int z2){</strong> **    int dx=x2-x1+1,dy=y2-y1+1,dz=z2-z1+1;** **    LL s=0;** **    for(int i=0;i&lt;8;++i){** **        int b0,b1,b2;** **        expand(i,b0,b1,b2);** **        s-=S[x2-b0*dx][y2-b1*dy][z2-b2*dz]*sign(b0,b1,b2);** **    }** **    return s;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int a,b,c,b0,b1,b2;** **        scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **        memset(S,0,sizeof(S));** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    scanf(“%lld”,&amp;S[x][y][z]);** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    for(int i=1;i&lt;=7;++i){** **                        //001 010 011 100 101 110 111三种位移** **                        expand(i,b0,b1,b2);** **                        //递推求和,sign()-&gt;加 or 减; expand()-&gt;状态** **                        S[x][y][z]+=S[x-b0][y-b1][z-b2]<em>sign(b0,b1,b2);*</em> **                    }** **        LL ans=-INF;** **        for(int x1=1;x1&lt;=a;++x1)** **            for(int x2=x1;x2&lt;=a;++x2)** **                for(int y1=1;y1&lt;=b;++y1)** **                    for(int y2=y1;y2&lt;=b;++y2){** **                        LL M=0;** **                        //对于每次求某个x1,x2,y1,y2区间上的最大子长方体和** **                        //M等价于寻找z区间上(1-z)中最小的子矩阵** **                        for(int z=1;z&lt;=c;++z){** **                            LL s=sum(x1,x2,y1,y2,1,z);** **                            ans=max(ans,s-M);** **                            M=min(M,s);** **                        }** **                    }** **                    printf(“%lld\\n”,ans);** **                    if(T) printf(“\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}