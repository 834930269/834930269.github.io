{"title":"python3学习 多-线-程","slug":"python3-multilwp","date":"2017-07-19T06:40:14.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-multilwp.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Source Code】</strong> <strong>github:</strong></p>\n<ol>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E5%A4%9A%E7%BA%BF%E7%A8%8B.py\" target=\"_blank\" rel=\"noopener\">多线程.py</a></strong></li>\n</ol>\n<p>**import time,threading</p>\n<p>#新线程执行的代码:<br>def loop():<br>    print(‘thread %s is running…’ % threading.current_thread().name)<br>    n=0<br>    while n&lt;5: n=n+1 print(‘thread %s &gt;&gt;&gt; %s’ % (threading.current_thread().name,n))<br>        time.sleep(1)<br>    print(‘thread %s ended.’ % threading.current_thread().name)</p>\n<p>print(‘thread %s is running…’ % threading.current_thread().name)<br>t=threading.Thread(target=loop,name=’LoopThread’)<br>t.start()<br>t.join()<br>print(‘thread %s ended.’ % threading.current_thread().name)</p>\n<p>‘’’<br>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷<br>贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共<br>享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共<br>享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br>‘’’</p>\n<p>#高级语言计算顺序<br>‘’’<br>    balance = balance + n</p>\n<p>分两步：</p>\n<pre><code>计算balance + n，存入临时变量中；\n将临时变量的值赋给balance。</code></pre><p>你也不希望你的存款莫名其妙变成负数吧.<br>所以如果想要计算正确,就要给change_it()上一把锁当某个线程开始执行<br>change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时<br>执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。由<br>于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以<br>，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现：<br>‘’’</p>\n<p>#但可能因为锁阻止了多线程并发执行，包含锁的代码只能单线程模式执行</p>\n<p>#另外,由于多个所由于可以存在多个锁，不同的线程持有不同的锁，并试图</p>\n<p>#获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执</p>\n<p>#行，也无法结束，只能靠操作系统强制终止。</p>\n<p>#–示例<br>import time, threading</p>\n<p># 假定这是你的银行存款:<br>balance = 0</p>\n<p>def change_it(n):<br>    # 先存后取，结果应该为0:<br>    global balance<br>    balance = balance + n<br>    balance = balance - n</p>\n<p>lock = threading.Lock()</p>\n<p>def run_thread(n):<br>    for i in range(100000):<br>        # 先要获取锁:<br>        lock.acquire()<br>        try:<br>            # 放心地改吧:<br>            change_it(n)<br>        finally:<br>            # 改完了一定要释放锁:<br>            lock.release()</p>\n<p>t1 = threading.Thread(target=run_thread, args=(5,))<br>t2 = threading.Thread(target=run_thread, args=(8,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)</p>\n<p>#由于Python历史遗留的GIL问题,如果一个线程满CPU</p>\n<p>#基本上只能以单核来执行线程,如果想要实现彻底的多核线程</p>\n<p>#要用C扩展**</p>\n","categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}