{"title":"51nod DP-矩阵取数问题","slug":"51nod-dp-study","date":"2016-12-24T14:22:05.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/51nod-dp-study.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x – 1, y) , f(x, y – 1) ) + A[x][y] 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<vector><br>using namespace std;<br>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    vector&lt;vector<int> &gt; ve(N+1,vector<int>(N+1,0)),dp(N+1,vector<int>(N+1,0));</int></int></int></vector></p>\n<pre><code>for(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        cin&gt;&gt;ve\\[i\\]\\[j\\];\n\nfor(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        dp\\[i\\]\\[j\\]=max(dp\\[i-1\\]\\[j\\],dp\\[i\\]\\[j-1\\])+ve\\[i\\]\\[j\\];\n\ncout&lt;&lt;dp\\[N\\]\\[N\\]&lt;&lt;endl;\n\nreturn 0;</code></pre><p>}</p>\n","categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"算法学习","slug":"51nod/动态规划/算法学习","count":1,"path":"api/categories/51nod/动态规划/算法学习.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}