{"title":"UVa 10859","slug":"uva-10859","date":"2017-07-18T07:52:02.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/uva-10859.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10859\" target=\"_blank\" rel=\"noopener\">Placing Lampposts</a></strong> <strong>【题意】</strong> <strong>给你一个ｎ个点ｍ条边的无向无环图，在尽量少的节点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。</strong> <strong>在灯的总数最小的前提下，被两盏灯同时被照亮的边数应该尽量大。</strong> <strong>【题解】</strong> <strong>树形dp,Lrj P70。</strong> <strong>这题教会了我一个很有用的技巧：有两个所求的值要优化，比如让a尽量小，ｂ也尽量小</strong> <strong>那么可以转化为让 M*a+b尽量小，其中Ｍ应该是一个比“a的最大值和b的最小值之差”还要大的数</strong> <strong>最终的答案为ans/M, ans%M</strong> <strong>回到这题，要求放的灯总数最小，被两盏灯同时照亮的边数尽量大。</strong> <strong>因为每条边要么被一盏灯照亮，要么被两盏灯照亮，所以可以转换为：</strong> <strong>求：放的灯总数量最少，被一盏灯照亮的边数尽量少。</strong> <strong>就可以变成球 M*a+b 的最小值，ａ为放置的灯数量，ｂ为被一盏灯照的边数</strong> <strong>f[u][1]表示u点放灯时的整个子树最小值</strong> <strong>f[u][0]表示u点不放灯时的整个子树最小值</strong> <strong>如果u放，那么u个子结点可以选择放，也可以不放，选择其中较小的值。如果选的是不照，就要增加一条只有一个灯照的边</strong> <strong>如果u不放，那么其子结点就必须选择要放，而且每条边都只有一个灯照</strong> <strong>【Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVA%2010859.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10859.cpp</a></strong></p>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int T,n,m,vis[2000][2],d[2000][2];<br>vector Graph[1010];</p>\n<p>int dp(int i,int j,int f){<br>    if(vis[i][j]) return d[i][j];<br>    vis[i][j]=1;<br>    int&amp; ans=d[i][j];</p>\n<pre><code>ans=2000;\nfor(int k=0;k&lt;Graph\\[i\\].size();++k)** \n    if(Graph\\[i\\]\\[k\\]!=f) \n       ans+=dp(Graph\\[i\\]\\[k\\],1,i); \nif(!j &amp;&amp; f&gt;=0)  ans++;\n\nif(j || f&lt;0){\n    int sum=0;\n    for(int k=0;k&lt;Graph\\[i\\].size();++k) \n       if(Graph\\[i\\]\\[k\\]!=f) \n          sum+=dp(Graph\\[i\\]\\[k\\],0,i); \n    if(f&gt;=0) sum++;\n    ans=min(ans,sum);\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d”,&amp;n,&amp;m);<br>        for(int i=0;i&lt;n;++i) Graph[i].clear();<br>        for(int i=0;i&lt;m;++i){<br>            int x,y;<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            Graph[x].push_back(y);<br>            Graph[y].push_back(x);<br>        }<br>        memset(vis,0,sizeof(vis));<br>        int ans=0;<br>        for(int i=0;i&lt;n;++i){<br>            if(!vis[i][0])///新的一棵树<br>                ans+=dp(i,0,-1);<br>        }<br>        printf(“%d %d %d\\n”,ans/2000,m-ans%2000,ans%2000);<br>    }<br>    return 0;<br>}</p>\n","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"树形dp","slug":"UVa/树形dp","count":1,"path":"api/categories/UVa/树形dp.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"树形dp","slug":"树形dp","count":1,"path":"api/tags/树形dp.json"}]}