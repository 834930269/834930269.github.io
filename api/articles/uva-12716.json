{"title":"UVa 12716","slug":"uva-12716","date":"2016-12-24T13:35:57.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-12716.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>【思路】: P318: （1）gcd(a,b)=c； （2）(a^b)=c；通过观察容易发现如果gcd(a,b)=(a^b)=c，那么c=a-b，因此可以事先枚举所有a的因数c，利用b=a-c计算b,然后只需验证是否满足(a^b)==c即可。但本题的数据太大，而且枚举约数不容易，因此可以利用约数c枚举倍数a，这样就会方便很多，打表的效率也足够高；而且，由于a=k_c,b=a-c=(k-1)_c，因此，必有gcd(a,b)=gcd(k_c,(k-1)_c)=c。这样只需比较(a^b)和c即可算出a的所有解数，由于本题要的是前n项的解数，因此最后要累加之间的所有解。 【Code】: (VJ-UVa炸了..还没尝试能否A).</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;</algorithm></p>\n<p>const int maxn = 30000030;<br>int d[maxn];</p>\n<p>void init(){<br>    for(int c=1;c&lt;maxn/2;++c)<br>        for(int a=c+c;a&lt;maxn;a+=c){//a=K*C b=(K-1)*C<br>                int b=a-c;//必有gcd(a,b)=c<br>                if((a^b)==c)d[a]++;<br>        }<br>    for(int i=2;i&lt;maxn;++i)<br>        d[i]+=d[i-1];<br>}</p>\n<p>int main(){<br>    init();<br>    int N,Q=0;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        int M;<br>        cin&gt;&gt;M;<br>        cout&lt;&lt;”Case “&lt;&lt;++Q&lt;&lt;”: “&lt;&lt;d[M]&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}