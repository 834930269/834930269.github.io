{"title":"python3学习 @property","slug":"python3-property","date":"2017-07-16T05:36:11.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-property.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/property.py\" target=\"_blank\" rel=\"noopener\">property.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[2]:</p>\n<p>‘’’<br>还记得装饰器（decorator）可以给函数动态加上功能吗？<br>对于类的方法，装饰器一样起作用。Python内置的@property<br>装饰器就是负责把一个方法变成属性调用的：<br>‘’’<br>class Student(object):<br>    @property<br>    def score(self):<br>        return self._score<br>    @score.setter<br>    def score(self,value):<br>        if not isinstance(value,int):<br>            raise ValueError(‘score must be an integer!’)<br>        if value &lt; 0 or value &gt; 100:<br>            raise ValueError(‘score must between 0 ~ 100!’)<br>        self._score = value<br>‘’’<br>@property的实现比较复杂，我们先考察如何使用。把一个getter方<br>法变成属性，只需要加上@property就可以了，此时，@property本身<br>又创建了另一个装饰器@score.setter，负责把一个setter方法变成属<br>性赋值，于是，我们就拥有一个可控的属性操作：</p>\n<p>相当于 Get Set<br>‘’’<br>a=Student()<br>a.score = 60 # OK，实际转化为a.set_score(60)<br>print(a.score)# OK，实际转化为s.get_score()</p>\n<p># In[3]:</p>\n<p>#a.score=9999  ValueError(‘score must between 0 ~ 100!’)</p>\n<p>#还可以定义只读属性，只定义getter方法，不定义setter方法</p>\n<p>#就是一个只读属性：<br>class Student(object):</p>\n<pre><code>@property\ndef birth(self):\n    return self._birth\n\n@birth.setter\ndef birth(self, value):\n    self._birth = value\n\n@property\ndef age(self):\n    return 2015 - self._birth</code></pre><p>#上面的birth是可读写属性，而age就是一个只读属性，因为age</p>\n<p>#可以根据birth和当前时间计算出来。</p>\n<p>‘’’<br>练习</p>\n<p>请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：<br>‘’’<br>class Screen(object):<br>    @property<br>    def width(self):<br>        return self._width<br>    @width.setter<br>    def width(self,value):<br>        self._width=value<br>    @property<br>    def height(self):<br>        return self._height<br>    @height.setter<br>    def height(self,value):<br>        self._height=value<br>    @property<br>    def resolution(self):<br>        return self.width*self.height<br># test:<br>s = Screen()<br>s.width = 1024<br>s.height = 768<br>print(s.resolution)<br>assert s.resolution == 786432, ‘1024 * 768 = %d ?’ % s.resolution</p>\n<p># In[ ]:**</p>\n","categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}