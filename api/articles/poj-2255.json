{"title":"POJ 2255","slug":"poj-2255","date":"2017-04-03T07:07:43.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-2255.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Tip】</strong> <strong>前序中序求后序</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream>  ** *<em>#include <cstring>  *</cstring></em> *<em>using namespace std;  *</em> *<em>char TF[27];  *</em> *<em>char TM[27];  *</em> *<em>void TL( int p1, int p2, int q1, int q2, int root )  *</em> *<em>{  *</em> **    if ( p1 &gt; p2 ) return;  ** **//q1,前序第一个,即根,root为中序中的根下标</iostream></strong> **    for ( root = q1 ; TM[root] != TF[p1] ; ++ root );** **    //root-q1=左子树节点个数,因为有前序,所以不需要root** **    //变量,这里的root做使用变量处理.** **    //第一个递归,前两个变量是前序中左子树的区间,** **    //后两个变量是中序中左子树的区间  ** **    TL( p1+1, p1+root-q1, q1, root-1, 0 );** **    //前两个是前序中** **    //右子树的区间,后两个是中序中右子树的区间  ** **    TL( p1+root-q1+1, p2, root+1, q2, 0 );  ** **    printf(“%c”,TM[root]);  ** *<em>}  *</em> *<em>int main()  *</em> *<em>{  *</em> **    while (~scanf(“%s%s”,TF,TM)) {  ** **        int L = strlen(TF)-1;  ** **        TL( 0, L, 0, L, 0 );  ** **        printf(“\\n”);  ** **    }  ** **    return 0;  ** *<em>} *</em></p>\n</blockquote>\n<p><strong>【补充】</strong> <strong>修改题意为根据后序中序求先序.</strong></p>\n<blockquote>\n<p><strong>#include <iostream>  ** *<em>#include <cstring>  *</cstring></em>  *<em>using namespace std;  *</em>  **char TA[27];  //后序</iostream></strong> <strong>char TM[27];  //中序</strong>  <strong>void TL( int p1, int p2, int q1, int q2 )  ** *<em>{  *</em> **    if ( p1 &gt; p2 ) return;  ** **    printf(“%c”,TA[p2]);</strong> **    int i;    ** <strong>for ( i =  q1; TM[i] != TA[p2] ; ++ i );</strong> **    TL( p1, p2-q2+i-1, q1, i-1);** **    TL( p2-q2+i, p2-1, i+1, q2 );  **  *<em>}  *</em>  *<em>int main()  *</em> *<em>{  *</em> **    while (~scanf(“%s%s”,TA,TM)) {  ** **        int L = strlen(TA)-1;  ** **        TL( 0, L, 0, L);  ** **        printf(“\\n”);  ** **    }  ** **    return 0;  ** *<em>} *</em></p>\n</blockquote>\n","categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"Tree","slug":"POJ/Tree","count":1,"path":"api/categories/POJ/Tree.json"},{"name":"数据结构","slug":"POJ/Tree/数据结构","count":1,"path":"api/categories/POJ/Tree/数据结构.json"}],"tags":[{"name":"binary_tree","slug":"binary-tree","count":1,"path":"api/tags/binary-tree.json"}]}