{"title":"2017多校训练1 HDU 6034 Balala Power!","slug":"2017-hdu-6034-balala-power","date":"2017-07-27T15:41:01.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6034-balala-power.json","photos":[],"link":"","excerpt":null,"covers":["http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg"],"content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6034\" title=\"Balala Power!\" target=\"_blank\" rel=\"noopener\">Balala Power!</a> <a href=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" title=\"Balala\" target=\"_blank\" rel=\"noopener\"><img src=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" alt=\"Balala\" title=\"Balala\"></a> 题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可以有前导0,规则是为0的字符不能位于len&gt;1的字符串的开头. 题解: 统计每个字符的总结果,排序,最大的字符赋值25,然后依次往下赋值.然后判断前导0,找到第一个可以为0的存在的字符,将它赋值为0,之后其他的左移一位.(出现前导0的情况表示26个字符都已经出现了). github: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/1/1002.cpp\" title=\"1002.cpp\" target=\"_blank\" rel=\"noopener\">1002.cpp</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1e5+5;\nconst int mod=1e9+7;\nstruct star{\n    int reg[100005];\n    bool vi;\n    int c;\n    bool operator &lt; (const star &amp;A)const{\n        for(int i=maxn-1;i&gt;=0;--i){\n            if(reg[i]&gt;A.reg[i]) return 1;\n            else if(reg[i]&lt;A.reg[i]) return 0;\n            else continue;\n        }\n    }\n}ch[30];\nchar str[100005];\nint Hash[30];///字符-权值映射\nlong long ans,fac[100005];\ninline void init(){\n    for(int i=0;i&lt;27;++i){\n        memset(ch[i].reg,0,sizeof(ch[i].reg));\n        ch[i].vi=true;\n        ch[i].c=0;\n    }\n    ans=0;\n}\nint main(){\n    int n,len,p,kase=0;\n    fac[0]=1;///预先处理26^i;\n    for(int i=1;i&lt;maxn;++i)\n        fac[i]=fac[i-1]*26%mod;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        init();\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            len=strlen(str);\n            for(int j=0;j&lt;len;++j){\n                p=str[j]-&apos;a&apos;;\n                ch[p].reg[len-j-1]++;\n            }\n            if(len&gt;1)\n                ch[str[0]-&apos;a&apos;].vi=false;\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                if(ch[i].reg[j]&gt;=26){\n                    ch[i].reg[j+1]+=ch[i].reg[j]/26;\n                    ch[i].reg[j]%=26;\n                }\n            }\n            ch[i].c=i;\n        }\n        sort(ch,ch+26);\n        for(int i=0;i&lt;26;++i)\n            Hash[ch[i].c]=26-i-1;\n        for(int i=25;i&gt;=0;--i){///从最小的开始判断是否可以为0\n            if(ch[i].vi){\n                for(int j=25;j&gt;i;--j)\n                    Hash[ch[j].c]=Hash[ch[j-1].c];\n                Hash[ch[i].c]=0;\n                break;\n            }\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                ans=(ans+fac[j]*ch[i].reg[j]*Hash[ch[i].c]%mod)%mod;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n    }\n    return 0;\n}</code></pre>","categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]}