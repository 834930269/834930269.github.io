{"title":"牛客练习赛11","slug":"nklxs11","date":"2018-01-26T15:39:55.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/nklxs11.json","photos":[],"link":"","excerpt":null,"covers":["https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2"],"content":"<h1 id=\"A-假的线段树\"><a href=\"#A-假的线段树\" class=\"headerlink\" title=\"A:假的线段树\"></a>A:假的线段树</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/A</a> 来源：牛客网 给你一个长为n的序列a，有m次操作 1.把区间[l,r]内所有x变成y 2.查询区间[l,r]内第k小值 对于100%的数据，1 &lt;= n, m , ai &lt;= 1000</p>\n<h2 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述\"></a>输入描述</h2><p>第一行两个数n,m 第二行n个数表示序列a 后面m行 1 l r x y :把区间[l,r]中所有x变成y 2 l r k :查询区间[l,r]中的第k小值</p>\n<h2 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述\"></a>输出描述</h2><p>对于每个询问，输出一个数表示答案</p>\n<h2 id=\"示例输入\"><a href=\"#示例输入\" class=\"headerlink\" title=\"示例输入\"></a>示例输入</h2><p>3 3 2 3 3 2 1 3 1 1 1 3 3 1 2 1 3 2</p>\n<h2 id=\"示例输出\"><a href=\"#示例输出\" class=\"headerlink\" title=\"示例输出\"></a>示例输出</h2><p>2 1</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>数据量小.1000*1000的复杂度,可以暴力过.第K小直接排序即可.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1010;\nint n,m;\nint num[maxn];\n\nvoid solve1(){\n    int l,r,x,y;\n    scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;r,&amp;x,&amp;y);\n    for(int i=l;i&lt;=r;++i){\n        if(num[i]==x)num[i]=y;\n    }\n}\n\nvoid solve2(){\n    int l,r,k;\n    scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);\n    int copy[maxn];\n    for(int i=l;i&lt;=r;++i){\n        copy[i]=num[i];\n    }\n    sort(copy+l,copy+r+1);\n    printf(&quot;%d\\n&quot;,copy[l+k-1]);\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n    }\n    int query;\n    for(int i=0;i&lt;m;++i){\n        scanf(&quot;%d&quot;,&amp;query);\n        if(query==1) solve1();\n        else solve2();\n    }\n\n    return 0;\n}</code></pre><h1 id=\"D-求距离\"><a href=\"#D-求距离\" class=\"headerlink\" title=\"D:求距离\"></a>D:求距离</h1><h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/D\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/D</a> 来源：牛客网 给你一个1 -&gt; n的排列，现在有一次机会可以交换两个数的位置，求交换后最小值和最大值之间的最大距离是多少？</p>\n<h2 id=\"水题\"><a href=\"#水题\" class=\"headerlink\" title=\"水题\"></a>水题</h2><p>输入输出格式看链接吧</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn=110;\nint num[maxn];\nint main(){\n    int n,mi=1,ma=1;\n    num[0]=0;\n    scanf(&quot;%d&quot;,&amp;n);\n    scanf(&quot;%d&quot;,&amp;num[1]);\n    for(int i=2;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n        if(num[i]&lt;num[mi]) mi=i;\n        if(num[i]&gt;num[ma]) ma=i;\n    }\n    int min_id=min(mi,ma),max_id=max(mi,ma);\n    int a=n-min_id,b=min_id-1,c=n-max_id,d=max_id-1;\n    printf(&quot;%d\\n&quot;,max(a,max(b,max(c,d))));\n    return 0;\n}</code></pre><h1 id=\"E-求最值\"><a href=\"#E-求最值\" class=\"headerlink\" title=\"E:求最值\"></a>E:求最值</h1><p>链接：<a href=\"https://www.nowcoder.com/acm/contest/59/E\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/59/E</a> 来源：牛客网 给你一个长为n的序列a 定义f(i,j)=(i-j)2+g(i,j)2 g是这样的一个函数 <a href=\"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2\" target=\"_blank\" rel=\"noopener\"><img src=\"https://uploadfiles.nowcoder.net/images/20180125/301599_1516886357781_321532365639F31B3B9F8EA8BE0C6BE2\" alt></a> 求最小的f(i,j)的值，i!=j</p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这道题数据水,可以直接枚举距离1和距离2水过.</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\n#define TREE_SIZE (1&lt;&lt;(20))\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn=100010;\nlong long sum_z[maxn],sum_f[maxn];\nint n,num[maxn];\n\ninline long long g(int i,int j){\n    register long long sum=0;\n    long long k=min(i,j),l=max(i,j);\n    sum=sum_z[n]-(sum_z[k]+sum_f[j+1]);\n    return sum;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    sum_z[0]=0;\n    for(int i=1;i&lt;=n;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n\n        sum_z[i]=sum_z[i-1]+num[i];\n    }\n    sum_f[n]=0;\n    for(int i=n;i&gt;=1;--i){\n        sum_f[i]=sum_f[i+1]+num[i];\n    }\n    long long res=1000000000;\n    for(int i=2;i&lt;=n;++i){\n        int T=min(1000,i);\n        for(int j=1;j&lt;T;++j){\n            long long reg=g(i-j,i);\n            //printf(&quot;i:%d,j:%d,reg:%d\\n&quot;,i,j,reg);\n            long long ans=j*j+reg*reg;\n            res=min(res,ans);\n        }\n    }\n    printf(&quot;%lld\\n&quot;,res);\n    return 0;\n}</code></pre><h2 id=\"但是这道题是平面最近点对\"><a href=\"#但是这道题是平面最近点对\" class=\"headerlink\" title=\"但是这道题是平面最近点对\"></a>但是这道题是平面最近点对</h2>","categories":[{"name":"牛客练习赛","slug":"牛客练习赛","count":2,"path":"api/categories/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"}]}