{"title":"Java I/O","slug":"java-i-o","date":"2018-01-16T05:43:46.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-i-o.json","photos":[],"link":"","excerpt":null,"covers":["http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png"],"content":"<p>[toc]</p>\n<h1><span id=\"io\">I/O</span></h1><h2><span id=\"文件对象\">文件对象</span></h2><h3><span id=\"创建一个文件对象\">创建一个文件对象</span></h3><pre><code>package file;\n\nimport java.io.File;\n\npublic class TestFile {\n    public static void main(String[] args){\n        //绝对路径\n        File f1=new File(&quot;d:/LOLFolder&quot;);\n        System.out.println(&quot;f1的绝对路径: &quot; + f1.getAbsolutePath());\n        //相对路径,相对于工作目录,如果在eclipse中,就是项目目录\n        File f2=new File(&quot;LOL.exe&quot;);\n        System.out.println(&quot;f2的绝对路径: &quot;+f2.getAbsolutePath());\n        //把f1作为父目录创建文件对象\n        File f3=new File(f1,&quot;LOL.exe&quot;);\n        System.out.println(&quot;f3的绝对路径: &quot;+f3.getAbsolutePath());\n    }\n}</code></pre><p>输出:</p>\n<pre><code>f1的绝对路径: d:\\LOLFolder\nf2的绝对路径: D:\\Java\\Learning\\LOL.exe\nf3的绝对路径: d:\\LOLFolder\\LOL.exe</code></pre><h3><span id=\"文件常用方法\">文件常用方法</span></h3><p>exists() -是否存在 isDirectory() -是否是文件夹 isFile() -是否是文件 length() -长度 lastModified() -文件最后修改时间 setlastModified() -修改文件最后修改时间 renameTo(f2 type is File) -把名字改成f2的名字,两个文件必须存在</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.util.Date;\n\npublic class Method {\n    public static void main(String args[]){\n        File f = new File(&quot;d:/LOLFolder/LOL.exe&quot;);\n        System.out.println(&quot;当前文件是：&quot; +f);\n        //文件是否存在\n        System.out.println(&quot;判断是否存在：&quot;+f.exists());\n\n        //是否是文件夹\n        System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());\n\n        //是否是文件（非文件夹）\n        System.out.println(&quot;判断是否是文件：&quot;+f.isFile());\n\n        //文件长度\n        System.out.println(&quot;获取文件的长度：&quot;+f.length());\n\n        //文件最后修改时间\n        long time = f.lastModified();\n        Date d = new Date(time);\n        System.out.println(&quot;获取文件的最后修改时间：&quot;+d);\n        //设置文件修改时间为1970.1.1 08:00:00\n        f.setLastModified(0);\n\n        //文件重命名\n        File f2 =new File(&quot;d:/LOLFolder/DOTA.exe&quot;);\n        f.renameTo(f2);\n        System.out.println(&quot;把LOL.exe改名成了DOTA.exe&quot;);\n\n        System.out.println(&quot;注意： 需要在D:\\\\LOLFolder确实存在一个LOL.exe,\\r\\n才可以看到对应的文件长度、修改时间等信息&quot;);\n    }\n}</code></pre><p>输出:</p>\n<pre><code>当前文件是：d:\\LOLFolder\\LOL.exe\n判断是否存在：false\n判断是否是文件夹：false\n判断是否是文件：false\n获取文件的长度：0\n获取文件的最后修改时间：Thu Jan 01 08:00:00 GMT+08:00 1970\n把LOL.exe改名成了DOTA.exe\n注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\n才可以看到对应的文件长度、修改时间等信息</code></pre><h3><span id=\"文件的常用方法2\">文件的常用方法2</span></h3><p>list() -以字符串数组的形式，返回当前文件夹下的所有文件 File[] fs=f.listFiles() -以文件数组的形式，返回当前文件夹下的所有文件 getParent() -以字符串形式返回所在文件夹 getParentFile() -以文件形式返回获取所在文件夹 mkdir() -创建文件夹,如果父目录不存在,创建失败 mkdirs() -如果父目录不存在,一样创建 createNewFile() -创建新文件,父目录不存在,抛异常 listRoots() -盘符c: d: delete() -删除 deleteOnExit() -JVM结束时删除</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class Method2 {\n    public static void main(String[] args) throws IOException {\n\n        File f = new File(&quot;d:/LOLFolder/skin/garen.ski&quot;);\n\n        // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）\n        f.list();\n\n        // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）\n        File[]fs= f.listFiles();\n\n        // 以字符串形式返回获取所在文件夹\n        f.getParent();\n\n        // 以文件形式返回获取所在文件夹\n        f.getParentFile();\n        // 创建文件夹，如果父文件夹skin不存在，创建就无效\n        f.mkdir();\n\n        // 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹\n        f.mkdirs();\n\n        // 创建一个空文件,如果父文件夹skin不存在，就会抛出异常\n        f.createNewFile();\n        // 所以创建一个空文件之前，通常都会创建父目录\n        f.getParentFile().mkdirs();\n\n        // 列出所有的盘符c: d: e: 等等\n        f.listRoots();\n\n        // 刪除文件\n        f.delete();\n\n        // JVM结束的时候，刪除文件，常用于临时文件的删除\n        f.deleteOnExit();\n\n    }\n}</code></pre><p>流<br>-</p>\n<h3><span id=\"什么是流\">什么是流</span></h3><p><strong>流即一系列数据.</strong> 当不同的介质之间有数据交互的时候，JAVA就使用流来实现。 数据源可以是文件，还可以是数据库，网络甚至是其他的程序 比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流 输入流： InputStream 输出流：OutputStream</p>\n<h3><span id=\"文件输入流\">文件输入流</span></h3><pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class Stream {\n    public static void main(String[] args) {\n        try {\n            File f = new File(&quot;d:/lol.txt&quot;);\n            // 创建基于文件的输入流\n            FileInputStream fis = new FileInputStream(f);\n            // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟中来，也就是读取到内存中\n\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3><span id=\"文件读入与输出\">文件读入与输出</span></h3><pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class bytes {\n    //FileInputStream是InputStream的子类\n    public static void main(String[] args){\n        try{\n            //从文件读入\n            File f=new File(&quot;log.txt&quot;);\n            //创建基于文件的输入流\n            FileInputStream fis=new FileInputStream(f);\n            //创建字节数组,其长度就是文件的长度\n            byte[] all=new byte[(int)f.length()];\n            //以字节流的形式读取文件所有内容\n            fis.read(all);\n            for(byte b:all){\n                System.out.println(b);\n            }\n\n            //每次使用完毕关闭\n            fis.close();\n\n\n            //向文件输出\n            File f1=new File(&quot;log1.txt&quot;);\n            byte data[]={88,89};\n            FileOutputStream fos=new FileOutputStream(f1);\n            fos.write(data);\n            fos.close();\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3><span id=\"关闭文件时需要注意\">关闭文件时需要注意</span></h3><p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端； 如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用 最标准的写法是在 finally 中关闭文件. 1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally. 2. 在finally关闭之前，要先判断该引用是否为空 3. 关闭的时候，需要再一次进行try catch处理 使用try()方式.其使用方法和C#的using(),Python的with一样.</p>\n<h3><span id=\"字符流\">字符流</span></h3><p>这节之前都是字节流 Reader字符输入流 Writer字符输出流 专门用于字符的形式读取和写入数据</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class CharacterStream {\n    public static void main(String[] args){\n        File f=new File(&quot;log.txt&quot;);\n        try(FileReader fr=new FileReader(f)){\n            //以字符流读入到char数组中\n            char[] all=new char[(int)f.length()];\n            fr.read(all);\n            for(char ch : all){\n                System.out.println(ch);\n            }\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n\n        File f1=new File(&quot;log1.txt&quot;);\n        try(FileWriter fr=new FileWriter(f1)){\n            String data=&quot;abcdefghijklmn123456789&quot;;\n            //字符串转字符数组\n            char[] cs=data.toCharArray();\n            fr.write(cs);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3><span id=\"中文编码问题\">中文编码问题</span></h3><p>1.中文编码</p>\n<pre><code>package file;\n\nimport java.io.UnsupportedEncodingException;\n//以字符 中 为例，查看其在不同编码方式下的值是多少\n\npublic class encode {\n    public static void main(String[] args){\n        String str = &quot;中&quot;;\n        showCode(str);\n    }\n\n    private static void showCode(String str){\n        String[] encodes={&quot;BIG5&quot;,&quot;GBK&quot;,&quot;GB2312&quot;,&quot;UTF-8&quot;,&quot;UTF-16&quot;,&quot;UTF32&quot;};\n        for(String encode : encodes){\n            showCode(str,encode);\n        }\n    }\n\n    private static void showCode(String str,String encode){\n        try{\n            //格式化输出用printf\n            System.out.printf(&quot;字符: \\&quot;%s\\&quot; 的在编码方式%s下的十六进制是%n&quot;,str,encode);\n            //str获取encode编码的byte数组 \n            byte[] bs=str.getBytes(encode);\n            for(byte b: bs){\n                //只显示每字节的低两位\n                int i=b&amp;0xff;\n                //toHex =&gt; 16进制\n                System.out.print(Integer.toHexString(i) + &quot;\\t&quot;);\n            }\n            System.out.println();\n            System.out.println();\n        }catch(UnsupportedEncodingException e){\n            System.out.printf(&quot;UnsupportedEncodingException: %s编码方式无法解析字符%s\\n&quot;, encode, str);\n        }\n    }\n}</code></pre><p>2.文件流读取中文</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\n\npublic class fileEncode {\n    public static void main(String[] args) throws UnsupportedEncodingException, FileNotFoundException {\n        File f = new File(&quot;test.txt&quot;);\n        System.out.println(&quot;默认编码方式:&quot;+Charset.defaultCharset());\n        //FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了\n        //而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK\n        try (FileReader fr = new FileReader(f)) {\n            char[] cs = new char[(int) f.length()];\n            fr.read(cs);\n            System.out.printf(&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;,Charset.defaultCharset());\n            System.out.println(new String(cs));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        //FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替\n        //并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式\n        try (InputStreamReader isr = new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))) {\n            char[] cs = new char[(int) f.length()];\n            isr.read(cs);\n            System.out.printf(&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;);\n            System.out.println(new String(cs));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}</code></pre><h3><span id=\"缓存流\">缓存流</span></h3><pre><code>package file;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n//缓存流\npublic class Buffer {\n    public static void main(String[] args) {\n        //缓存流读取\n        {\n            // 准备文件lol.txt其中的内容是\n            // garen kill teemo\n            // teemo revive after 1 minutes\n            // teemo try to garen, but killed again\n            File f = new File(&quot;log.txt&quot;);\n            // 创建文件字符流\n            // 缓存流必须建立在一个存在的流的基础上\n            try (\n                    FileReader fr = new FileReader(f);\n                    //BufferedReader的带参构造函数是一个流\n                    BufferedReader br = new BufferedReader(fr);\n                )\n            {\n                while (true) {\n                    // 一次读一行\n                    String line = br.readLine();\n                    if (null == line)\n                        break;\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        //缓存流写出\n        {\n            File f=new File(&quot;log1.txt&quot;);\n            try(\n                //创建文件字符流\n                FileWriter fw=new FileWriter(f);\n                //缓存流必须建立在一个存在的流的基础上\n                PrintWriter pw=new PrintWriter(fw);\n            ){\n                //直接pw.println\n                pw.println(&quot;garen kill teemo&quot;);\n                //如果想要在不是缓存满了才写入硬盘\n                //就需要使用pw.flush()\n                //pw.flush()\n                //否则会在缓存满了或者结束才写入到硬盘中\n                pw.println(&quot;teemo revive after 1 minutes&quot;);\n                pw.println(&quot;teemo try to garen, but killed again&quot;);\n            }catch(IOException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre><h3><span id=\"对象流\">对象流</span></h3><p>即常见的 Serializable 将对象流化方便传递. 必须实现Serializable接口 Hero类</p>\n<pre><code>package charactor;\n\nimport java.io.Serializable;\n\npublic class Hero implements Serializable {\n    //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号\n    private static final long serialVersionUID = 1L;\n    public String name;\n    public float hp;\n\n}</code></pre><p>应用:</p>\n<pre><code>package stream;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport charactor.Hero;\n\npublic class TestStream {\n\n    public static void main(String[] args) {\n        //创建一个Hero garen\n        //要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口\n        Hero h = new Hero();\n        h.name = &quot;garen&quot;;\n        h.hp = 616;\n\n        //准备一个文件用于保存该对象\n        File f =new File(&quot;d:/garen.lol&quot;);\n\n        try(\n            //创建对象输出流\n            FileOutputStream fos = new FileOutputStream(f);\n            ObjectOutputStream oos =new ObjectOutputStream(fos);\n            //创建对象输入流              \n            FileInputStream fis = new FileInputStream(f);\n            ObjectInputStream ois =new ObjectInputStream(fis);\n        ) {\n            oos.writeObject(h);\n            Hero h2 = (Hero) ois.readObject();\n            System.out.println(h2.name);\n            System.out.println(h2.hp);\n\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}</code></pre><h2><span id=\"常用的控制台输入systeminscanner\">常用的控制台输入System.in(Scanner)</span></h2><pre><code>package stream;\n\nimport java.util.Scanner;\n\npublic class TestStream {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int a = s.nextInt();\n        System.out.println(&quot;第一个整数：&quot;+a);\n        int b = s.nextInt();\n        System.out.println(&quot;第二个整数：&quot;+b);\n    }\n}</code></pre><h2><span id=\"流关系图\">流关系图</span></h2><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png\" alt></a></p>\n","categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]}