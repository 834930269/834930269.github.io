{"title":"HDU 5880","slug":"hdu-5880","date":"2018-03-11T03:46:16.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/hdu-5880.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"Type-AC自动机\"><a href=\"#Type-AC自动机\" class=\"headerlink\" title=\"Type: AC自动机\"></a>Type: AC自动机</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你N个子串,一个主串,让你过滤掉在主串中出现过的子串.被过滤掉的用*表示</p>\n<blockquote>\n<p>每个子串是由小写字母组成</p>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>AC自动机,一开始被两个样例卡住了</p>\n<blockquote>\n<p>1- 子串： abcd bc 主串: abcef 匹配不到 bc 2- 子串: a ab abc abcd 主串: aabcd 匹配不到 abcd</p>\n<blockquote>\n<p>第一种情况是因为当你遍历到abcd这条路径的c节点时,如果因为下一个是f就判断为失配并且不继续向下走,则就无法再匹配到bc.</p>\n<blockquote>\n<p>解决方法,在每次判断到失配的时候,新开一个函数从开始失配的节点 这里是 c ,从这个节点开始找他的失陪路径,知道找到 第一个尾节点 或 根节点 就停止,目标串即为最长被匹配串,不需要再去匹配他的子串了.</p>\n</blockquote>\n<p>第二种情况是因为一开始写代码每次循环时直接将u查找到了根节点,所以如果一个子串前面是另一个串的子串,那么将永远无法匹配到另一个子串.</p>\n<blockquote>\n<p>解决方法,不改动u,借助临时变量来更改u达到查找子串的目的.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            if(!isalpha(s[i])){\n                u=0;\n                continue;\n            }\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            /*\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                p=f[p];\n            }\n            */\n            add(u,i);\n        }\n    }\n\n    void print(){\n        for(int i=0;i&lt;tot_len;++i){\n            if(cle[i]) putchar(&apos;*&apos;);\n            else putchar(str[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str,i+1);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(str);\n        tot_len=strlen(str);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(str);\n        aho.print();\n    }\n    return 0;\n}</code></pre>","categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"HDU","slug":"AC自动机/HDU","count":2,"path":"api/categories/AC自动机/HDU.json"},{"name":"字符串处理","slug":"AC自动机/HDU/字符串处理","count":2,"path":"api/categories/AC自动机/HDU/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]}