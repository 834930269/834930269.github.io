{"title":"51NOD 1241 特殊的排序","slug":"51nod-1241-tsds","date":"2018-03-08T10:57:18.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1241-tsds.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"Type-动态规划-思维-最长等差数列-简化\"><a href=\"#Type-动态规划-思维-最长等差数列-简化\" class=\"headerlink\" title=\"Type:动态规划,思维,最长等差数列(简化)\"></a>Type:动态规划,思维,最长等差数列(简化)</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾部 =&gt; 1 2 3 4 5 这样就排好了，移动了2个元素。 给出一个1-N的排列，输出完成排序所需的最少移动次数。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：1个数N(2 &lt;= N &lt;= 50000)。 第2 - N + 1行：每行1个数，对应排列中的元素。</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出1个数，对应所需的最少移动次数。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>5 2 5 3 4 1</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>2</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>一开始会想到和逆序数有关,排序就是减少逆序数,所以会想到其中非逆序序列中最长的那个不用变化. 然后可以容易地证明剩余的数只需要移动一次即可到达正确的位置上</p>\n<blockquote>\n<p>比如 12346587 可以发现最长等差整数序列是 12345 而我们需要 12345678 第一次: 1234587 6 第二次: 1234586 7 第三次: 1234567 8 OK,往数列前面放的也一样</p>\n</blockquote>\n<p>那么我们的问题就是如何求最长等差数列(等差为1)了,</p>\n<blockquote>\n<p>因为等差为1,所以我们不难想到: dp[i] 为数字 i 的最长等差数列. 遍历Num[]数组的时候计算 dp 即可 dp[i]=dp[i-1]+1</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=50000+10;\n\nint dp[maxn],N,Num[maxn],max_;\n\nint main(){\n    while(cin&gt;&gt;N){\n        memset(dp,0,sizeof(dp));\n        dp[0]=0;\n        max_=1;\n        for(int i=1;i&lt;=N;++i){\n            cin&gt;&gt;Num[i];\n        }\n        for(int i=1;i&lt;=N;++i){\n            dp[Num[i]]=dp[Num[i]-1]+1;\n            max_=max(dp[Num[i]],max_);\n            //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;dp[Num[i]]&lt;&lt;endl;\n        }\n        cout&lt;&lt;N-max_&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"思维","slug":"51nod/动态规划/思维","count":1,"path":"api/categories/51nod/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}