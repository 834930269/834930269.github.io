{"title":"POJ 2262","slug":"poj-2262","date":"2017-04-02T09:45:52.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/poj-2262.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【生词】</strong> <strong>Goldbach 哥德巴赫</strong> <strong>Conjecture 推测,猜想</strong> <strong>Christian 基督教徒</strong> <strong>amateur 爱好者,业余爱好者</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=1000010;</strong> <strong>int N;</strong> <strong>int is_prime[maxn+1];</strong> <strong>int prime[maxn+1],p;</strong> <strong>void sieve(int t){</strong> **    memset(is_prime,1,sizeof(is_prime));** **    p=0;** **    is_prime[0]=is_prime[1]=0;** **    for(int i=2;i&lt;=t;++i){** **        if(is_prime[i]){** **            prime[p++]=i;** **            for(int j=2<em>i;j&lt;=t;j+=i)*</em> **                is_prime[j]=0;** **        }    ** **    }** <strong>}</strong> <strong>void solve(){</strong> <strong>//这个循环是 &lt;= 因为6=3+3,而不是&lt;</strong> **    for(int i=0;i&lt;p &amp;&amp; prime[i]&lt;=N/2 ;++i)** **        if(is_prime[N-prime[i]]){** **            printf(“%d = %d + %d\\n”,N,prime[i],N-prime[i]);** **            return;** **        }** **    printf(“Goldbach’s conjecture is wrong.\\n”);    ** <strong>}</strong> <strong>int main(){</strong> **    //1000000正解,而不是预处理到一半,这道题不同于上一道题** <strong>//可以出现大于N/2 的解.</strong> **    sieve(1000010);** **    while(~scanf(“%d”,&amp;N) &amp;&amp; N){** **        solve();** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]}