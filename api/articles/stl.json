{"title":"STL & 函数","slug":"stl","date":"2017-04-12T02:45:11.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/stl.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【fill】</strong> <strong>等同memset.</strong> <strong>fill(起始地址,终止地址,元素);</strong> <strong>【优先队列】</strong> <strong>priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数:</strong> <strong>priority_queue&lt;Type, Container, Functional&gt;</strong> <strong>其中Type 为数据类型， Container 为保存数据的容器，Functional 为元素比较方式。</strong> <strong>Container 必须是用数组实现的容器，比如 vector, deque 但不能用 list.</strong> <strong>STL里面默认用的是 vector. 比较方式默认用 operator&lt; , 所以如果你把后面俩个参数缺省的话，</strong> <strong>优先队列就是大顶堆，队头元素最大。</strong></p>\n<p><strong><code>#include &lt;iostream&gt;</code></strong></p>\n<p><strong><code>#include &lt;queue&gt;</code></strong></p>\n<p><strong><code>using</code> <code>namespace</code> <code>std;</code></strong></p>\n<p><strong><code>int</code> <code>main(){</code></strong></p>\n<p><strong><code>priority_queue&lt;``int``&gt; q;</code></strong></p>\n<p><strong><code>for``(</code> <code>int</code> <code>i= 0; i&lt; 10; ++i ) q.push(</code> <code>rand``() );</code></strong></p>\n<p><strong><code>while``( !q.empty() ){</code></strong></p>\n<p><strong><code>cout &lt;&lt; q.top() &lt;&lt; endl;</code></strong></p>\n<p><strong><code>q.pop();</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong><code>getchar``();</code></strong></p>\n<p><strong><code>return</code> <code>0;</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong>如果要用到小顶堆，则一般要把模板的三个参数都带进去。</strong> <strong>STL里面定义了一个仿函数 greater&lt;&gt;，对于基本类型可以用这个仿函数声明小顶堆</strong></p>\n<p><strong><code>#include &lt;iostream&gt;</code></strong></p>\n<p><strong><code>#include &lt;queue&gt;</code></strong></p>\n<p><strong><code>using</code> <code>namespace</code> <code>std;</code></strong></p>\n<p><strong><code>int</code> <code>main(){</code></strong></p>\n<p><strong><code>priority_queue&lt;``int``, vector&lt;``int``&gt;, greater&lt;``int``&gt; &gt; q;</code></strong></p>\n<p><strong><code>for``(</code> <code>int</code> <code>i= 0; i&lt; 10; ++i ) q.push(</code> <code>rand``() );</code></strong></p>\n<p><strong><code>while``( !q.empty() ){</code></strong></p>\n<p><strong><code>cout &lt;&lt; q.top() &lt;&lt; endl;</code></strong></p>\n<p><strong><code>q.pop();</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong><code>getchar``();</code></strong></p>\n<p><strong><code>return</code> <code>0;</code></strong></p>\n<p><strong><code>}</code></strong></p>\n<p><strong>ps:对于结构体Node,如果重载operator &gt; 可直接使用priority_queue&lt;Node,vector<node>,greater<node>&gt;.</node></node></strong></p>\n<p><strong>【set】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<set></set></strong> <strong>using namespace std;</strong> <strong>int main(){</strong> **    //声明** **    set<int> s;<strong>**    //插入元素</strong> **    s.insert(1);** **    s.insert(3);** **    s.insert(5);<strong>**    //查找元素</strong> **    set<int>::iterator ite;<strong>**    ite=s.find(1);</strong> **    if(ite==s.end()) puts(“not found”);** **    else puts(“found”);** **    //删除元素** **    s.erase(3);** **    //其他查找元素的方法** **    if(s.count(3)!=0)puts(“found”);** **    else puts(“not found”);** **    //遍历所有元素** **    for(ite=s.begin();ite!=s.end();++ite){** **        printf(“%d\\n”,<em>ite);*</em> **    }** **    return 0;** <strong>}</strong></int></int></p>\n</blockquote>\n<p><strong>【map】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<map></map></strong> <strong>#inlcude<string></string></strong> <strong>using namespace std;**</strong>int main(){<em>* **    //声明(int为键,const char<em>为值)*</em> **    map&lt;int,const char</em>&gt; m;<strong>**    //插入元素</strong> <em>*    //map里所有元素都是pair,pair是一个结构体** **    //有两个元素,第一个是first,第二个是second** **    m.insert(make_pair(1,”ONE”));** **    m.insert(make_pair(10,”TEN”));** **    m[100]=”HUNDREN”;  //其他的写法<strong>**    //查找元素</strong> **    map&lt;int,const char</em>&gt;::iterator ite;** **    ite=find(1);** **    puts(ite-&gt;second);    //输出ONE,so,这里为什么用second,懂了吧** **    ite=m.find(2);** **    if(ite==m.end()) puts(“not found”);** **    else puts(ite-&gt;second);** **    puts(m[10]);    //返回-&gt;second** **    //删除元素** **    m.erase();** **    //遍历等同于set,不过输出的是pair的first和second.** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","categories":[{"name":"未分类","slug":"未分类","count":16,"path":"api/categories/未分类.json"}],"tags":[]}