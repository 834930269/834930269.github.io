{"title":"LA 3882","slug":"la-3882","date":"2017-07-11T07:02:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3882.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3882\" target=\"_blank\" rel=\"noopener\">And Then There Was One</a></strong> <strong>【题解】</strong> <strong>假设问题是从n个人编号分别为0…n-1，取第k个，</strong> <strong>则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2…</strong> <strong>此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号</strong> <strong>把k号设置为0,则</strong> <strong>k 0</strong> <strong>k+1 1</strong> <strong>…</strong> <strong>0 n-k</strong> <strong>1 n-k+1</strong> <strong>假设已经求得了n-1个人情况下的最终胜利者保存在f[n-1]中，则毫无疑问，该胜利者还原到原来的真正编号即为 (f[n-1]+k)%n （因为第二轮重新编号的时候，相当于把每个人的编号都减了k，因此重新+k即可恢复到原来编号）。由此，我们可以想象，当最终只剩下一个人的时候，该人即为胜利者，此时重新编号，因为只有一个人，所以此时f[1]=0</strong> <strong>这样f[2]=(f[1]+k)%2,这样就可以求出最终胜利者在2个人的时候的情况下的编号，由递推公式f[n]=(f[n-1]+k)%n,可递推到最初编号序列中该胜利者的编号。</strong> <strong>因此用这个方法，只需一遍On的扫描，即可求出最终答案</strong> <strong>不过该题要求编号从1开始，只要把f[n]+1即可，同时，该题指定了第一个要删除的人必须为编号为m的人，其实也不难，求出f[n]之后，把原本编号为0的位置移到跟m只相距k的位置即可实现第一次删除的编号为m。所以最终 ans=(f[n]+1+m-k);</strong> <strong>当然因为m-k可能为负数，导致整个ans为负，这样其实最后+n即可解决。</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203882.cpp\" target=\"_blank\" rel=\"noopener\">LA 3882.cpp</a></strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=10000+10;<br>int f[maxn];<br>int main(){<br>    int n,k,m;<br>    while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n){<br>        ///最后一次变换只有一个点,所以最终点设为0<br>        ///每次去掉一个点以后重新编号,所以%i<br>        ///从底向上的方法<br>        f[1]=0;<br>        for(int i=2;i&lt;=n;++i)f[i]=(f[i-1]+k)%i;<br>        ///因为是从0编号,而题目要求从1编号,所以+1<br>        ///因为从0开始,而题目要求从m开始删除第k个<br>        ///所以第一次删除的下标应该是f[n]-k=第一次的起始下标<br>        ///0-k+m+1=真正的起始坐标,因为第一次需要将m设为0,从m开始重新编号<br>        int ans=(m-k+1+f[n])%n;<br>        ///因为m-k+1可能小于0,所以m-k+1+f[n]也可能小于0<br>        if(ans&lt;=0) ans+=n;<br>        printf(“%d\\n”,ans);<br>    }<br>    return 0;<br>}</strong></p>\n</blockquote>\n","categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"动态规划","slug":"LA/动态规划","count":1,"path":"api/categories/LA/动态规划.json"},{"name":"思维","slug":"LA/动态规划/思维","count":1,"path":"api/categories/LA/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]}