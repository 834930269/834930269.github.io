{"title":"51nod 1084 矩阵取数问题 V2","slug":"51nod-1084-jzqs-v2","date":"2018-03-05T15:06:34.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1084-jzqs-v2.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"Type-DP-多路-进程-DP\"><a href=\"#Type-DP-多路-进程-DP\" class=\"headerlink\" title=\"Type:DP,多路(进程)DP\"></a>Type:DP,多路(进程)DP</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>一个M*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，先从左上走到右下，再从右下走到左上。第1遍时只能向下和向右走，第2遍时只能向上和向左走。两次如果经过同一个格子，则该格子的奖励只计算一次，求能够获得的最大价值。 例如：3 * 3的方格。 1 3 3 2 1 3 2 2 1 能够获得的最大价值为：17。1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 2 -&gt; 1。其中起点和终点的奖励只计算1次。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：2个数M N，中间用空格分隔，为矩阵的大小。(2 &lt;= M, N &lt;= 200) 第2 - N + 1行：每行M个数，中间用空格隔开，对应格子中奖励的价值。(1 &lt;= A[i,j] &lt;= 10000)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出能够获得的最大价值。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>3 3 1 3 3 2 1 3 2 2 1</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>17</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>一开始的想法是先走一遍取最大值,然后回溯到起点,把走过的地方置为 0,然后WA= =,发现是行不通的,因为两次都是最有没办法保证全局最优.</p>\n<blockquote>\n<p>然后搜了题解</p>\n</blockquote>\n<p>这里用到多进程dp,即我们用 dp[step][j][k] 代表当前走了 step 步,第一个走的人在第 j行,第二个走的人在第 k行时最大的经过路径之和. 如果 j==k 时,即两个人当前路径点重合了.我们只需要随便选取一个加到记忆化数组中即可. 而当我们多路dp时,两个人来到当前状态的方向可能是</p>\n<blockquote>\n<p>(1) 第一个人往下走,第二个人往下走 (2) 第一个人往下走,第二个人往右走 (3) 第一个人往右走,第二个人往下走 (4) 第一个人往右走,第二个人往右走</p>\n</blockquote>\n<p>我们只需要在遍历到每个状态时,对以上四个状态找最大值加上两个人当前地点的数字即可 答案是dp[M+N][N][N]</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=210;\nint N,M,A;\nint mp[maxn][maxn],dp[2*maxn][maxn][maxn];\n\nint main(){\n    ///读题bug,N是行,第二个读入\n    scanf(&quot;%d%d&quot;,&amp;M,&amp;N);\n    for(int i=1;i&lt;=N;++i){\n        for(int j=1;j&lt;=M;++j){\n            scanf(&quot;%d&quot;,&amp;mp[i][j]);\n        }\n    }\n    ///枚举步数\n    for(int i=2;i&lt;=N+M;++i){\n        ///枚举位于行数 i-j or k即为当前所处列(因为总步数为i(行数加列数和))\n        for(int j=1;j&lt;=N&amp;&amp;i-j&gt;=0;++j){\n            for(int k=1;k&lt;=N&amp;&amp;i-k&gt;=0;++k){\n                ///分为四种情况,下下,下右,右下,右右\n                if(k==j){\n                    //下下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+mp[j][i-j]);\n                    //下右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+mp[j][i-j]);\n                    //右下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+mp[j][i-j]);\n                    //右右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]+mp[j][i-j]);\n                }else{\n                    //下下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+mp[j][i-j]+mp[k][i-k]);\n                    //下右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+mp[j][i-j]+mp[k][i-k]);\n                    //右下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+mp[j][i-j]+mp[k][i-k]);\n                    //右右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]+mp[j][i-j]+mp[k][i-k]);\n                }\n            }\n        }\n    }\n    printf(&quot;%d\\n&quot;,dp[N+M][N][N]);\n    return 0;\n}</code></pre>","categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"多进程dp","slug":"51nod/多进程dp","count":1,"path":"api/categories/51nod/多进程dp.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"多进程dp","slug":"多进程dp","count":1,"path":"api/tags/多进程dp.json"}]}