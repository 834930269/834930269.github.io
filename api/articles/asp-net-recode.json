{"title":"ASP.Net 记录贴","slug":"asp-net-recode","date":"2017-09-01T10:01:47.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/asp-net-recode.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>委派: 委托是方法的抽象，它存储的就是一系列具有相同签名和返回回类型的方法的地址。调用委托的时候，委托包含的所有方法将被执行。 1.委托类型的定义 委托是类型，就好像类是类型一样。与类一样，委托类型必须在被用来创建变量以及类型对象之前声明。</p>\n<pre><code>delegate void MyDel(int x);</code></pre><p>委托类型声明： （1） 以deleagate关键字开头。 （2）返回类型+委托类型名+参数列表。 2.声明委托变量</p>\n<pre><code>MyDel del1,del2;</code></pre><p>3.初始化委托变量</p>\n<pre><code>del1 = new MyDel( myInstObj.MyM1 );\ndel2 = new MyDel( SClass.OtherM2 );</code></pre><p>4.组合委托 委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表是两个操作数的委托调用列表的副本的连接。 委托是恒定的，操作数委托创建后不会被改变。委托组合拷贝的是操作数的副本。</p>\n<pre><code>MyDel del1 = myObj.MyMethod;\nMyDel del2 = SClass.OtherM2;\nMyDel del3 = del1 + del2;   //组合调用列表</code></pre><p>5.委托加减运算 可以使用+=运算符，为委托新增方法。 同样可以使用-=运算符，为委托移除方法。</p>\n<pre><code>MyDel del = myObj.MyMethod;\ndel += SClass.OtherM2; // 增加方法\ndel -= myObj.MyMethod; // 移除方法</code></pre><p>6.委托调用 委托调用跟方法调用类似。委托调用后，调用列表的每个方法将会被执行。 在调用委托前，应判断委托是否为空。调用空委托会抛出异常。</p>\n<pre><code>if(null != del)\n{\n     del();//委托调用\n}</code></pre><p>7.匿名方法 匿名方法是在初始化委托时内联声明的方法。 基本结构：</p>\n<pre><code>deleage( 参数 ) { 语句块 }</code></pre><p>例如：</p>\n<pre><code>delegate int MyDel (int x); //定义一个委托 \n\nMyDel del = delegate( int x){ return x; };</code></pre><p>8.Lambda表达式 Lambda运算符读作”goes to”。</p>\n<pre><code>MyDel del = delegate( int x) { return x; };//匿名方法\nMyDel del2 = (int x) =&gt; {return x;};//Lambda表达式\nMyDel del3 = x =&gt; {return x};//简写的Lambda表达式</code></pre>","categories":[{"name":"ASP.Net","slug":"ASP-Net","count":3,"path":"api/categories/ASP-Net.json"},{"name":"C#","slug":"ASP-Net/C","count":2,"path":"api/categories/ASP-Net/C.json"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]}