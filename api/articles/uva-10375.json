{"title":"UVa 10375","slug":"uva-10375","date":"2017-01-08T14:19:03.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10375.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>【类型】 唯一分解定理,素数筛法 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10375\" target=\"_blank\" rel=\"noopener\">UVa-10375-Choose and divide</a> 【唯一分解定理】 任何一个大于1的自然数<em>N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N</em>=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为素数，其中指数ai是正整数。这样的分解称为<em>N</em>的标准分解式. 【思路】 根据题意得: 给定p q r s 求 ①.(p!<em>s!</em>(r-s)!)/(r!<em>q!</em>(p-q)!) 暴力会炸,至于为啥.</p>\n<p>10000! 总位数：35660位,要不要试试？</p>\n<p>1.先筛10000以内的素数. 2.数组e表示当前结果的唯一分解式中各个素数的指数,prime数组第i位的指数是多少.如:e={1，0，2，0，0，0 …}表示pow(2,1)*pow(5,2)=50 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath></cmath></p>\n<p>#define MAXN 10000<br>using namespace std;</p>\n<p>int prime[MAXN];<br>bool is_prime[MAXN];<br>int primesize=0,p,q,r,s;</p>\n<p>int e[MAXN];</p>\n<p>void sieve(){<br>    memset(is_prime,1,sizeof(is_prime));<br>    is_prime[1]=is_prime[0]=false;<br>    for(int i=0;i&lt;MAXN;++i){<br>        if(is_prime[i]){<br>            prime[primesize++]=i;<br>            for(int j=i*2;j&lt;MAXN;j+=i)<br>                is_prime[j]=false;<br>        }<br>    }<br>}</p>\n<p>//乘以或除以n,d=1表示乘,d=-1表示除<br>void add_integer(int n,int d){<br>    for(int i=0;i&lt;primesize;++i){<br>        while(n%prime[i]==0){//必须是while<br>            n/=prime[i];<br>            e[i]+=d;<br>        }<br>        if(n==1)break;//提前终止循环,节约时间<br>    }<br>}</p>\n<p>void add_factorial(int n,int d){<br>    for(int i=1;i&lt;=n;++i)<br>        add_integer(i,d);<br>}</p>\n<p>int main(){<br>    sieve();<br>    while(cin&gt;&gt;p&gt;&gt;q&gt;&gt;r&gt;&gt;s){<br>        memset(e,0,sizeof(e));<br>        //以下一串表示上面的公式①的分子和分母.<br>        add_factorial(p,1);<br>        add_factorial(s,1);<br>        add_factorial(r-s,1);<br>        add_factorial(q,-1);<br>        add_factorial(r,-1);<br>        add_factorial(p-q,-1);<br>        double ans=1;<br>        for(int i=0;i&lt;primesize;++i)<br>            ans*=pow(prime[i],e[i]);<br>        printf(“%.5lf\\n”,ans);<br>    }<br>    return 0;<br>}</p>\n","categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}