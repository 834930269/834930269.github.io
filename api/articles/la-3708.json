{"title":"LA 3708","slug":"la-3708","date":"2017-03-31T15:25:38.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/la-3708.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【题解】</strong> <strong>蓝书P8</strong> <strong>题意是原本n个墓碑均匀分布在一个周长为10000的圆周上，现在加入m个，如果要使得n+m个墓碑都均匀分布的话，那么原来的墓碑最少的移动总距离是多少。</strong> <strong>因为加入m个之后m+n个墓碑的位置是固定的，要是移动距离最少必定会有一个墓碑不动，将圆周分成m+n段，分别标上0,1,2,3,4。。然后需要移动的墓碑坐标就是数轴上面的非整数点，两边的值靠近哪个就选哪个，之后再等比例扩大即可。</strong> <strong>放大倍数:10000/(M+N)</strong> <strong>原先N的坐标在放入M后的位置:</strong> <strong>//设距离L</strong> <strong>//i_(10000/N)=L_</strong> <em><strong>//L/(10000/(M+N))=pos</strong> <strong>//pos=i</strong></em><strong>(10000/N)/(10000/(M+N))</strong> <strong>//pos=i*(M+N)/N</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>int N,M;</strong> <strong>int main(){</strong> <em>*    while(scanf(“%d%d”,&amp;N,&amp;M)!=EOF) {** **        double ans=0.0;** **        for(int i=1;i&lt;N;++i){** **            double pos=(double)i/N</em>(N+M);<em>* **            //原先N的坐标在原来的位置是哪里** <strong>//设距离L</strong> **            //i</em>(10000/N)=L<em>* **            //L/(10000/(M+N))=pos** **//pos=i</em>(10000/N)/(10000/(M+N))<em>* **//pos=i</em>(M+N)/N** **            ans+=fabs(pos-floor(pos+0.5))/(N+M);** **            //floor()向下取整,这里等价于找两边距离最近** <strong>//的那个点.</strong> <strong>}</strong> **        printf(“%.4lf\\n”,ans<em>10000);  *</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>与上面题解同理(没那么奇葩的写法的Code)</strong></p>\n<blockquote>\n<p>**#include <cstdio></cstdio></p>\n<p>#include <cstring></cstring></p>\n<p>#include <algorithm></algorithm></p>\n<p>using namespace std;</p>\n<p>int main() {<br>    int n,m;<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)) {<br>        double ans = 0;<br>        for(int i = 1;i &lt; n;i++) {<br>            double pos = (double)i * (m + n) / n;<br>            ans += min(pos - (int)pos,(int)(pos + 1) - pos);<br>                        //取离两边距离最近的那个点<br>        }<br>        printf(“%.4lf\\n”,ans * 10000 / (m + n));<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"}],"tags":[{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]}