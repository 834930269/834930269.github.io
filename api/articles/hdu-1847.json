{"title":"HDU 1847","slug":"hdu-1847","date":"2018-01-24T09:54:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/hdu-1847.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"【博弈论-SG函数】\"><a href=\"#【博弈论-SG函数】\" class=\"headerlink\" title=\"【博弈论 - SG函数】\"></a>【博弈论 - SG函数】</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h2><h3 id=\"Good-Luck-in-CET-4-Everybody\"><a href=\"#Good-Luck-in-CET-4-Everybody\" class=\"headerlink\" title=\"Good Luck in CET-4 Everybody!\"></a>Good Luck in CET-4 Everybody!</h3><p>Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 11483 Accepted Submission(s): 7446 大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。 “升级”？“双扣”？“红五”？还是“斗地主”？ 当然都不是！那多俗啊~ 作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的： 1、 总共n张牌; 2、 双方轮流抓牌； 3、 每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…） 4、 抓完牌，胜负结果也出来了：最后抓完牌的人为胜者； 假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？ 当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。 Good luck in CET-4 everybody!</p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p>\n<h2 id=\"SampleInput\"><a href=\"#SampleInput\" class=\"headerlink\" title=\"SampleInput\"></a>SampleInput</h2><p>1 3</p>\n<h2 id=\"SampleOutput\"><a href=\"#SampleOutput\" class=\"headerlink\" title=\"SampleOutput\"></a>SampleOutput</h2><p>Kiki Cici</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>首先我们要知道SG函数代表的是当前状态的数值.如果是0,则为先手必败(SG函数值为可到达状态中未出现的最小的整数).然后我们从SG函数延伸一下– 1.我们假设当n=0时,先手必败. 2.当n=1时,因为S(0)=0，所以当前状态是非奇异局势.先手必胜,即,你可以通过拿走一定的牌使下一个拿牌的人的局势变成奇异局势(必败态). 即转移给下一个抽牌者状态为S(0). 3.当n=2是,因为S(0)=0，S(1)=1.所以当前状态是非奇异局势,先手必胜. 即你可以把下一个抽牌者状态转换成S(0). 4.当n=3时,可到达状态为S(3-1)=S(2)=1.S(3-2)=S(1)=1.因为无论往那个状态走,都会使对方先手必胜,所以该局势为奇异局势.先手必败. 故我们可以根据以上推理过程将全部的1000个状态是否必胜预处理处来.其预处理过程为<strong>检查可以到达的状态是否存在奇异局势,如果存在,则该局势为非奇异局势,即先手必胜态</strong>. 因为可拿牌数都是2^n.所以预处理复杂度为O(nlg(n)). PS…:其实预处理完以后你会发现.每当n%3==0时,为奇异局势. Code:</p>\n<pre><code>//SG函数\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nbool game[1001];\n\nvoid init(){\n    memset(game,false,sizeof(game));\n    for(int i=1;i&lt;=1000;++i){\n        int t=1;\n        while(i-t&gt;=0){\n            //如果i-t是奇异局势,则先手必胜\n            if(!game[i-t]){\n                game[i]=true;\n                break;\n            }\n            t&lt;&lt;=1;\n        }\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(game[n]){\n            printf(&quot;Kiki\\n&quot;);\n        }else{\n            printf(&quot;Cici\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"博弈论","slug":"HDU/博弈论","count":5,"path":"api/categories/HDU/博弈论.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]}