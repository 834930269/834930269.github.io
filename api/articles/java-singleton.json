{"title":"Java 单例模式","slug":"java-singleton","date":"2018-01-12T12:45:47.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-singleton.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1><span id=\"1饿汉式单例模式\">1.<code>饿汉式</code>单例模式</span></h1><h4><span id=\"giantdragon-应该只有一只通过私有化其构造方法使得外部无法通过new-得到新的实例\">GiantDragon 应该只有一只，通过<code>私有化其构造方法</code>，使得外部无法通过new 得到新的实例。</span></h4><h4><span id=\"giantdragon-提供了一个public-static的getinstance方法外部调用者通过该方法获取12行定义的对象而且每一次都是获取同一个对象-从而达到单例的目的\">GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 从而达到单例的目的。</span></h4><h4><span id=\"这种单例模式又叫做饿汉式单例模式无论如何都会创建一个实例\">这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例</span></h4><pre><code>package charactor;\n\npublic class GiantDragon {\n\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){\n\n    }\n\n    //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个\n\n    private static GiantDragon instance = new GiantDragon();\n\n    //public static 方法，提供给调用者获取12行定义的对象\n    public static GiantDragon getInstance(){\n        return instance;\n    }\n\n}</code></pre><p>测试:</p>\n<pre><code>package charactor;\n\npublic class TestGiantDragon {\n\n    public static void main(String[] args) {\n        //通过new实例化会报错\n//      GiantDragon g = new GiantDragon();\n\n        //只能通过getInstance得到对象\n\n        GiantDragon g1 = GiantDragon.getInstance();\n        GiantDragon g2 = GiantDragon.getInstance();\n        GiantDragon g3 = GiantDragon.getInstance();\n\n        //都是同一个对象\n        System.out.println(g1==g2);\n        System.out.println(g1==g3);\n    }\n}</code></pre><h1><span id=\"2懒汉式单例模式\">2.<code>懒汉式</code>单例模式</span></h1><h4><span id=\"懒汉式单例模式与饿汉式单例模式不同只有在调用getinstance的时候才会创建实例\">懒汉式单例模式与饿汉式单例模式不同，只有在调用getInstance的时候，才会创建实例</span></h4><pre><code>package charactor;\n\npublic class GiantDragon {\n\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){       \n    }\n\n    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null\n    private static GiantDragon instance;\n\n    //public static 方法，返回实例对象\n    public static GiantDragon getInstance(){\n        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象\n        if(null==instance){\n            instance = new GiantDragon();\n        }\n        //返回 instance指向的对象\n        return instance;\n    }\n\n}</code></pre><p>测试:</p>\n<pre><code>package charactor;\n\npublic class TestGiantDragon {\n\n    public static void main(String[] args) {\n        //通过new实例化会报错\n//      GiantDragon g = new GiantDragon();\n\n        //只能通过getInstance得到对象\n\n        GiantDragon g1 = GiantDragon.getInstance();\n        GiantDragon g2 = GiantDragon.getInstance();\n        GiantDragon g3 = GiantDragon.getInstance();\n\n        //都是同一个对象\n        System.out.println(g1==g2);\n        System.out.println(g1==g3);\n    }\n}</code></pre><h3><span id=\"单例模式三要素\">单例模式三要素:</span></h3><p>这个是面试的时候经常会考的点，面试题通常的问法是: 什么是单例模式？ 回答的时候，要答到三元素 1. 构造方法私有化 2. 静态属性指向实例 3. public static的 getInstance方法，返回第二步的静态属性</p>\n","categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]}