{"title":"python3学习 多态和继承","slug":"python3-inheritance-and-polymorphisn","date":"2017-07-15T16:44:40.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/python3-inheritance-and-polymorphisn.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Inheritance_and_polymorphisn.py\" target=\"_blank\" rel=\"noopener\">Inheritance_and_polymorphisn.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[5]:</p>\n<p>‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称为子类（Subclass），而被继<br>承的class称为基类、父类或超类（Base class、Super class）。<br>‘’’</p>\n<p>#比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：<br>class Animal(object):<br>    def run(self):<br>        print(‘Animal is running…’)</p>\n<p>#当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：<br>class Dog(Animal):<br>    pass<br>class Cat(Animal):<br>    pass<br>‘’’<br>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是<br>它的子类。Cat和Dog类似。</p>\n<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由<br>于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什<br>么事也没干，就自动拥有了run()方法：<br>‘’’<br>dog=Dog()<br>dog.run()<br>cat=Cat()<br>cat.run()</p>\n<p>#当子类和父类都存在相同的run()方法时，我们说，</p>\n<p>#子类的run()覆盖了父类的run()，在代码运行的时候，</p>\n<p>#总是会调用子类的run()。这样，我们就获得了继承的</p>\n<p>#另一个好处：多态。<br>class Puppy(Animal):<br>    def run(self):<br>        print(‘Puppy is running…’)<br>class Shark(Animal):<br>    def run(self):<br>        print(‘Shark is running…’)<br>puppy=Puppy()<br>puppy.run()</p>\n<p># In[7]:</p>\n<p>#判断一个变量是否是某个类型可以用isinstance()判断：</p>\n<p>#可以发现,puppy可以使Animal也可以是Puppy.<br>print(isinstance(puppy,Animal))<br>print(isinstance(puppy,Puppy))<br>b=Animal()<br>print(isinstance(b,Puppy))</p>\n<p>#所以，在继承关系中，如果一个实例的数据类型是某个子类</p>\n<p>#，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p>\n<p># In[12]:</p>\n<p>#要理解多态的好处，我们还需要再编写一个函数，这个函数接受</p>\n<p>#一个Animal类型的变量：<br>def run_twice(animal):<br>    animal.run()<br>    animal.run()<br>run_twice(Dog())<br>run_twice(Puppy())<br>run_twice(Shark())</p>\n<p># In[ ]:</p>\n<p>‘’’<br>多态的好处在于:</p>\n<p>新增一个Animal的子类，不必对  –run_twice()–<br>做任何修改，实际上，任何依赖Animal作为参数的函<br>数或者方法都可以不加修改地正常运行，原因就在于<br>多态。</p>\n<p>著名的“开闭”原则：</p>\n<p>对扩展开放：允许新增Animal子类；</p>\n<p>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则<br>传入的对象必须是Animal类型或者它的子类，否则，将无法调用<br>run()方法。</p>\n<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。<br>我们只需要保证传入的对象有一个run()方法就可以了：</p>\n<p>class Timer(object):<br>    def run(self):<br>        print(‘Start…’)</p>\n<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一<br>个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看<br>做是鸭子。<br>‘’’**</p>\n","categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]}