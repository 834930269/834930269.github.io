{"title":"Wannafly 挑战赛11","slug":"wannafly-cha-11","date":"2018-03-10T00:53:16.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/wannafly-cha-11.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>A. 水</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nint main(){\n    LL n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;n+1&lt;&lt;endl;\n    return 0;\n}</code></pre><p>B: 组合数学, 预处理阶乘逆元</p>\n<blockquote>\n<p>因为不可能暴力,所以我们想到是推式子 我们可以把前几项放在Excel表中推一下 然后我们会发现 关于m,n的式子为</p>\n<blockquote>\n<p>常数k*b^(m-1)*a^(n-m)</p>\n<blockquote>\n<p>该式子即为目标结果</p>\n</blockquote>\n<p>如何求常数k呢</p>\n<blockquote>\n<p>设k[n][m] 为n行m列的常数</p>\n<blockquote>\n<p>我们发现 k[n][m]=k[n-1][m]+k[n-1][m-1] 这个式子和组合数学里的 C(n,k)+C(n,k+1)=C(n+1,k+1) 相似</p>\n</blockquote>\n</blockquote>\n<p>所以 k[n][m]=C(n-1,m-1)</p>\n<blockquote>\n<p>但因为我们无法以O（N^2）解决这道题,所以不能用递推式求组合数</p>\n<blockquote>\n<p>那我们就直接用 组合数的公式求</p>\n<blockquote>\n<p>C(n,m)=n!/((n-m)!*m!)</p>\n</blockquote>\n</blockquote>\n<p>预处理n!和n!的逆元</p>\n<blockquote>\n<p>这里因为数组有限,无法使用递推式求逆元,</p>\n<blockquote>\n<p>所以我们用费马小定理求逆元</p>\n</blockquote>\n<p>a^(p-1)≡1(mod p)</p>\n</blockquote>\n<p>则 a^(p-2) 即为 a 对于 p 的逆元.</p>\n</blockquote>\n<p>预处理即可</p>\n</blockquote>\n<p>当n &lt; m时,ans=0</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 998244353;\nconst int maxn = 100000;\n\nint a,b,n,m;\nint T;\n\nll inv[maxn+10],fac[maxn+10];\n///预处理N!的逆元\n//费马小定理\n/*\n *假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡1（mod p）\n *根据这个性质我们可以知道 a的逆元为a^(p-2)\n */\nll fast_pow(ll a,ll b)\n{\n    ll ans=1;\n    while(b){\n        if(b&amp;1ll)ans=a*ans%MOD;\n        a=a*a%MOD;\n        b&gt;&gt;=1ll;\n    }\n    return ans;\n}\nvoid pre()\n{\n    inv[0]=1ll;\n    fac[0]=1ll;\n    for(int i=1;i&lt;=maxn;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=fast_pow(fac[i],MOD-2ll);\n    }\n}\nll C(ll a,ll b)\n{\n    return fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}\n\nint main(){\n    pre();\n    scanf(&quot;%d&quot;,&amp;T);\n    for(int k=0;k&lt;T;++k){\n        scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;n,&amp;m);\n        if(n&lt;m){\n            printf(&quot;0\\n&quot;);\n            continue;\n        }\n        int t=n-1,s=m-1;\n        ll ans=1;\n\n        ans=ans*C(n-1,m-1)%MOD*fast_pow(a,n-m)%MOD*fast_pow(b,m-1)%MOD;\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n/// C(N-1,M-1)*b^(M-1)*a^(N-M)\n/// N&lt;M 0</code></pre>","categories":[{"name":"牛客练习赛","slug":"牛客练习赛","count":2,"path":"api/categories/牛客练习赛.json"},{"name":"组合数学","slug":"牛客练习赛/组合数学","count":1,"path":"api/categories/牛客练习赛/组合数学.json"},{"name":"逆元","slug":"牛客练习赛/组合数学/逆元","count":1,"path":"api/categories/牛客练习赛/组合数学/逆元.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"}]}