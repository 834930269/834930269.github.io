{"name":"二分搜索","slug":"二分搜索","count":3,"postlist":[{"title":"山东省第七届省赛","slug":"acm-icpc-7","date":"2018-03-04T02:42:24.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/acm-icpc-7.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"A-水\"><a href=\"#A-水\" class=\"headerlink\" title=\"A:水\"></a>A:水</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int T,A,B;\n    while(~scanf(&quot;%d&quot;,&amp;T)){\n        for(int i=0;i&lt;T;++i){\n            cin&gt;&gt;A&gt;&gt;B;\n            if(A%B){\n                cout&lt;&lt;(A/B)+1&lt;&lt;endl;\n            }else{\n                cout&lt;&lt;(A/B)&lt;&lt;endl;\n            }\n        }\n    }\n    return 0;\n}</code></pre><h1 id=\"B-二分-或者可以暴力-只有45个FB-结论题-用到斐波那契博弈里的一个结论-任何数都可以被拆成不同斐波那契的和-进而猜测直接从最大的小于N的FB往下找即可\"><a href=\"#B-二分-或者可以暴力-只有45个FB-结论题-用到斐波那契博弈里的一个结论-任何数都可以被拆成不同斐波那契的和-进而猜测直接从最大的小于N的FB往下找即可\" class=\"headerlink\" title=\"B:二分(或者可以暴力,只有45个FB)结论题,用到斐波那契博弈里的一个结论:任何数都可以被拆成不同斐波那契的和,进而猜测直接从最大的小于N的FB往下找即可\"></a>B:二分(或者可以暴力,只有45个FB)结论题,用到斐波那契博弈里的一个结论:任何数都可以被拆成不同斐波那契的和,进而猜测直接从最大的小于N的FB往下找即可</h1><h2 id=\"我吐槽下SDUT的OJ…尼玛10-9能写成109-劳资找了大大大大大大半天错硬是不知道错哪里了艹\"><a href=\"#我吐槽下SDUT的OJ…尼玛10-9能写成109-劳资找了大大大大大大半天错硬是不知道错哪里了艹\" class=\"headerlink\" title=\"我吐槽下SDUT的OJ…尼玛10^9能写成109,劳资找了大大大大大大半天错硬是不知道错哪里了艹\"></a>我吐槽下SDUT的OJ…尼玛10^9能写成109,劳资找了大大大大大大半天错硬是不知道错哪里了艹</h2><h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=45;\nint Fb[maxn],M;\nint vis[maxn],has_ans;\n\nvoid init(){\n    Fb[0]=1;\n    Fb[1]=2;\n    for(int i=2;i&lt;maxn;++i){\n        Fb[i]=Fb[i-1]+Fb[i-2];\n        //printf(&quot;%d\\n&quot;,Fb[i]);\n    }\n\n}\n\nvoid solve(int N){\n    stack&lt;int&gt; ans;\n    int mx=maxn;\n    while(N!=0){\n        int ind=lower_bound(Fb,Fb+mx,N)-Fb;\n        if(Fb[ind]&gt;N)ind-=1;\n        N=N-Fb[ind];\n        ans.push(Fb[ind]);\n    }\n    printf(&quot;%d=&quot;,M);\n    int t=0;\n    while(!ans.empty()){\n        if(!t){\n            printf(&quot;%d&quot;,ans.top());t++;\n        }else printf(&quot;+%d&quot;,ans.top());\n        ans.pop();\n    }\n    printf(&quot;\\n&quot;);\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        memset(vis,0,sizeof(vis));\n        has_ans=0;\n        scanf(&quot;%d&quot;,&amp;M);\n        solve(M);\n    }\n    return 0;\n}\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 40ms\nTake Memory: 196KB\nSubmit time: 2018-03-04 13:39:50\n****************************************************/</code></pre><h1 id=\"E-简单枚举\"><a href=\"#E-简单枚举\" class=\"headerlink\" title=\"E:简单枚举\"></a>E:简单枚举</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=110;\n\nint T,N,M;\nchar mp[maxn][maxn];\nint dist[4][2]={ {1,0},{-1,0},{0,-1},{0,1}};\n\nbool check(int x,int y){\n    if(x&lt;1 || x&gt;M || y&lt;1 || y&gt;N) return false;\n    return true;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int ans=0;\n        scanf(&quot;%d%d&quot;,&amp;M,&amp;N);\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%s&quot;,mp[i]+1);\n        }\n        for(int i=1;i&lt;=M;++i){\n            for(int j=1;j&lt;=N;++j){\n                if(mp[i][j]==&apos;#&apos;){\n                    for(int k=0;k&lt;4;++k){\n                        int x=i+dist[k][0],y=j+dist[k][1];\n                        if(check(x,y)){\n                            if(mp[x][y]==&apos;#&apos;)continue;\n                            int room=0;\n                            for(int kk=0;kk&lt;4;++kk){\n                                int xx=x+dist[kk][0],yy=y+dist[kk][1];\n                                if(check(xx,yy)){\n                                    if(mp[xx][yy]==&apos;#&apos;)++room;\n                                }\n                            }\n                            if(room==1)ans++;\n                        }else ++ans;\n                    }\n                }\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n/***************************************************\nUser name: 奥术大师大所大\nResult: Accepted\nTake time: 228ms\nTake Memory: 212KB\nSubmit time: 2018-03-04 14:46:06\n****************************************************/</code></pre><h1 id=\"G-找规律-不像博弈-抱歉-会打表-但是规律想不出来-对不起\"><a href=\"#G-找规律-不像博弈-抱歉-会打表-但是规律想不出来-对不起\" class=\"headerlink\" title=\"G:找规律,不像博弈,抱歉,会打表,但是规律想不出来,对不起\"></a>G:找规律,不像博弈,抱歉,会打表,但是规律想不出来,对不起</h1><h2 id=\"打表\"><a href=\"#打表\" class=\"headerlink\" title=\"打表\"></a>打表</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint solve(int N){\n    int ans=0;\n    for(int i=1;i&lt;N;++i){\n        for(int j=i;j&lt;N-i;++j){\n            int k=N-i-j;\n            if((i^j^k)==0) ans++;\n        }\n    }\n    return ans;\n}\n\nint main(){\n    for(int i=1;i&lt;=200;++i){\n        printf(&quot;%d: %d\\n&quot;,i,solve(i)/3);\n    }\n    return 0;\n}</code></pre><h2 id=\"找的规律-知道规律了-直接粘的别人代码\"><a href=\"#找的规律-知道规律了-直接粘的别人代码\" class=\"headerlink\" title=\"找的规律,知道规律了,直接粘的别人代码\"></a>找的规律,知道规律了,直接粘的别人代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    int ans,pp;\n    int i;\n    long long int f[100];\n    f[2]=1;\n    f[1]=0;\n    f[0]=0;\n    for(i=3;i&lt;30;i++)\n        f[i]=f[i-1]*3+1;\n    long long int a;\n    int T;\n    cin&gt;&gt;T;\n    while(T--)\n    {\n        cin&gt;&gt;a;\n        ans=0;\n        if(a%2)\n        {\n            cout&lt;&lt;0&lt;&lt;endl;\n            continue;\n        }\n        while(a!=0)\n        {\n            pp=a%2;\n            if(pp)\n                ans++;\n            a/=2;\n        }\n        cout&lt;&lt;f[ans]&lt;&lt;endl;\n    }\n}</code></pre><h1 id=\"J-题目翻译-http-www-bubuko-com-infodetail-1612259-html-说实话-完全理解题意了基本就是水题-但对我不是\"><a href=\"#J-题目翻译-http-www-bubuko-com-infodetail-1612259-html-说实话-完全理解题意了基本就是水题-但对我不是\" class=\"headerlink\" title=\"J:题目翻译: http://www.bubuko.com/infodetail-1612259.html 说实话,完全理解题意了基本就是水题.但对我不是.\"></a>J:题目翻译: <a href=\"http://www.bubuko.com/infodetail-1612259.html\" target=\"_blank\" rel=\"noopener\">http://www.bubuko.com/infodetail-1612259.html</a> 说实话,完全理解题意了基本就是水题.但对我不是.</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint T;\nchar str[1000];\nint main(){\n    cin&gt;&gt;T;\n    while(T--){\n        int N,M;\n        cin&gt;&gt;N&gt;&gt;M;\n        int c=0,m=0,o=0,b=0;\n        getchar();\n        for(int i=0;i&lt;N;++i){\n            gets(str);\n            if(str[0]==&apos;C&apos;){\n                c++;\n            }else if(str[0]==&apos;M&apos;){\n                m++;\n            }else if(str[0]==&apos;O&apos;){\n                o++;\n            }else if(str[0]==&apos;B&apos;){\n                b++;\n            }\n        }\n        int ans=o*(2+(N-1)+m*2)+b*(2+m*2);\n        if(ans&gt;=M){\n            puts(&quot;Mrghllghghllghg!&quot;);\n        }else puts(&quot;Tell you a joke, the execution of Paladin.&quot;);\n    }\n    return 0;\n}</code></pre><h1 id=\"K-水\"><a href=\"#K-水\" class=\"headerlink\" title=\"K:水\"></a>K:水</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10010,maxm=5010;\nint N;\nstack&lt;char&gt; st;\nint main(){\n    while(~scanf(&quot;%d\\n&quot;,&amp;N)){\n        char qb;\n        while(N--){\n            int f=0;\n            do{\n                do{\n                    qb=getchar();\n                    if(isalpha(qb)) st.push(qb);\n                }while(qb!=&apos; &apos; &amp;&amp; qb!=&apos;\\n&apos;);\n                if(f==0)f++;\n                else printf(&quot; &quot;);\n                while(!st.empty()){\n                    printf(&quot;%c&quot;,st.top());\n                    st.pop();\n                }\n            }while(qb!=&apos;\\n&apos;);\n            printf(&quot;\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre>","text":"A:水#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int T,A,B;    while(~scanf(&quot;%d&quot;,&amp;T)){        for(int i=0;i&","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"二分搜索","slug":"Sdut/二分搜索","count":1,"path":"api/categories/Sdut/二分搜索.json"},{"name":"博弈论","slug":"Sdut/二分搜索/博弈论","count":1,"path":"api/categories/Sdut/二分搜索/博弈论.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/二分搜索/博弈论/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/二分搜索/博弈论/第七届ACM山东省赛.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"HDU 1431","slug":"hdu-1431","date":"2018-02-06T14:37:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1431.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1431\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>\n<h1 id=\"type-二分-线性素数筛\"><a href=\"#type-二分-线性素数筛\" class=\"headerlink\" title=\"type: 二分,线性素数筛\"></a>type: 二分,线性素数筛</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>先用线筛打1000W的表,然后二分查找a的下标,暴力a到b内素数是否是回文数即可.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000000+10;\nint a,b,tot=0;\n\nbool valid[maxn];\nint prime[maxn];\nvoid init(int n,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint query(int len,int key){\n    int left=1;\n    int right=len;\n    int mid;\n    while(left&lt;=right){\n        mid=(left+right)&gt;&gt;1;\n        if(key&lt;prime[mid]){\n            right=mid-1;\n        }else if(key&gt;prime[mid]){\n            left=mid+1;\n        }else return mid;\n    }\n    return -1;\n}\n\nbool check(int n){\n    if((n/10)==0) return true;\n    int str[20];\n    int len=0,l=n;\n    for(;l&gt;0;){\n        ++len;\n        str[len]=l%10;\n        l/=10;\n    }\n    for(int i=1;i&lt;=len;++i){\n        if(str[i]!=str[len-i+1]) return false;\n    }\n    return true;\n}\n\nint main(){\n    init(10000000,prime);\n    while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b)){\n        int id=query(tot,a);\n        for(int i=id;prime[i]&lt;=b &amp;&amp; prime[i];++i){\n            if(check(prime[i])){\n                printf(&quot;%d\\n&quot;,prime[i]);\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttp://acm.hdu.edu.cn/showproblem.php?pid=1431type: 二分,线性素数筛题意题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.题解先用线筛打1000W的表,然后二分","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"二分搜索","slug":"HDU/二分搜索","count":1,"path":"api/categories/HDU/二分搜索.json"},{"name":"数论","slug":"HDU/二分搜索/数论","count":1,"path":"api/categories/HDU/二分搜索/数论.json"},{"name":"线性素数筛法","slug":"HDU/二分搜索/数论/线性素数筛法","count":1,"path":"api/categories/HDU/二分搜索/数论/线性素数筛法.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"技巧论 QAQ","slug":"jql-qaq","date":"2018-02-25T15:49:18.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/jql-qaq.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>凡事要讲究技巧,无技不成巧,先将遇到的技巧记录下来..</p>\n<blockquote>\n<p>对的…这特么就是一个远古巨坑</p>\n</blockquote>\n</blockquote>\n<h1 id=\"中途相遇法-又称折半枚举-双向搜索\"><a href=\"#中途相遇法-又称折半枚举-双向搜索\" class=\"headerlink\" title=\"中途相遇法(又称折半枚举,双向搜索)\"></a>中途相遇法(又称折半枚举,双向搜索)</h1><h2 id=\"思想论\"><a href=\"#思想论\" class=\"headerlink\" title=\"思想论\"></a>思想论</h2><blockquote>\n<p>如果纬度特别高时,比如数据量为N,总情况数为N^4,全部遍历一遍是肯定不可以的,不过可以将它们折半成AB和CD再考虑,就可以快速解决了.</p>\n<blockquote>\n<p>从两个数列中考虑的话,就只剩下N^2种情况了,因此对两半枚举完以后排一下序,就可以用二分搜索了.</p>\n</blockquote>\n</blockquote>\n<h2 id=\"例题-山东第一届省赛-D\"><a href=\"#例题-山东第一届省赛-D\" class=\"headerlink\" title=\"例题:山东第一届省赛 D\"></a>例题:山东第一届省赛 D</h2><blockquote>\n<p>右侧标签云中找一下第一节山东省塞即可</p>\n</blockquote>\n<h1 id=\"爬梯法\"><a href=\"#爬梯法\" class=\"headerlink\" title=\"爬梯法\"></a>爬梯法</h1><h1 id=\"尺取法\"><a href=\"#尺取法\" class=\"headerlink\" title=\"尺取法\"></a>尺取法</h1><blockquote>\n<p>思想:</p>\n<blockquote>\n<p>规定那个两个点,先固定左端点,如果小于答案,则右端点向右走,否则左端点向左走 POJ 3061</p>\n</blockquote>\n</blockquote>\n<h1 id=\"分块法\"><a href=\"#分块法\" class=\"headerlink\" title=\"分块法\"></a>分块法</h1><blockquote>\n<p>51nod 1225</p>\n</blockquote>\n<h1 id=\"倍增算法\"><a href=\"#倍增算法\" class=\"headerlink\" title=\"倍增算法\"></a>倍增算法</h1><h1 id=\"康托展开\"><a href=\"#康托展开\" class=\"headerlink\" title=\"康托展开\"></a>康托展开</h1>","text":"凡事要讲究技巧,无技不成巧,先将遇到的技巧记录下来..对的…这特么就是一个远古巨坑中途相遇法(又称折半枚举,双向搜索)思想论如果纬度特别高时,比如数据量为N,总情况数为N^4,全部遍历一遍是肯定不可以的,不过可以将它们折半成AB和CD再考虑,就可以快速解决了.从两个数列中考虑的话","link":"","raw":null,"photos":[],"categories":[{"name":"中途相遇法","slug":"中途相遇法","count":1,"path":"api/categories/中途相遇法.json"},{"name":"二分搜索","slug":"中途相遇法/二分搜索","count":1,"path":"api/categories/中途相遇法/二分搜索.json"}],"tags":[{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"中途相遇法","slug":"中途相遇法","count":2,"path":"api/tags/中途相遇法.json"}]}]}