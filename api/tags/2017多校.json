{"name":"2017多校","slug":"2017多校","count":7,"postlist":[{"title":"2017多校训练1 HDU 6033 Add More Zero","slug":"2017-hdu-6033-add-more-zero","date":"2017-07-27T13:56:28.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6033-add-more-zero.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6033\" title=\"HDU: Problem-6033\" target=\"_blank\" rel=\"noopener\">HDU: Problem-6033</a> 题意/解: 求m*log10(2) github: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/1/A.cpp\" title=\"A.cpp\" target=\"_blank\" rel=\"noopener\">A.cpp</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int kase=0;\n    double t=log(2)/log(10),n;\n    while(~scanf(&quot;%lf&quot;,&amp;n)){\n        int a=n*t;\n        printf(&quot;Case #%d: %d\\n&quot;,++kase,a);\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:HDU: Problem-6033 题意/解: 求m*log10(2) github: :point_right:A.cpp#include&lt;bits/stdc++.h&gt;using namespace std;int main()","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"未分类","slug":"2017多校/未分类","count":1,"path":"api/categories/2017多校/未分类.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"}]},{"title":"2017多校训练1 HDU 6034 Balala Power!","slug":"2017-hdu-6034-balala-power","date":"2017-07-27T15:41:01.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6034-balala-power.json","excerpt":"","keywords":null,"cover":"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg","content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6034\" title=\"Balala Power!\" target=\"_blank\" rel=\"noopener\">Balala Power!</a> <a href=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" title=\"Balala\" target=\"_blank\" rel=\"noopener\"><img src=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" alt=\"Balala\" title=\"Balala\"></a> 题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可以有前导0,规则是为0的字符不能位于len&gt;1的字符串的开头. 题解: 统计每个字符的总结果,排序,最大的字符赋值25,然后依次往下赋值.然后判断前导0,找到第一个可以为0的存在的字符,将它赋值为0,之后其他的左移一位.(出现前导0的情况表示26个字符都已经出现了). github: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/1/1002.cpp\" title=\"1002.cpp\" target=\"_blank\" rel=\"noopener\">1002.cpp</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1e5+5;\nconst int mod=1e9+7;\nstruct star{\n    int reg[100005];\n    bool vi;\n    int c;\n    bool operator &lt; (const star &amp;A)const{\n        for(int i=maxn-1;i&gt;=0;--i){\n            if(reg[i]&gt;A.reg[i]) return 1;\n            else if(reg[i]&lt;A.reg[i]) return 0;\n            else continue;\n        }\n    }\n}ch[30];\nchar str[100005];\nint Hash[30];///字符-权值映射\nlong long ans,fac[100005];\ninline void init(){\n    for(int i=0;i&lt;27;++i){\n        memset(ch[i].reg,0,sizeof(ch[i].reg));\n        ch[i].vi=true;\n        ch[i].c=0;\n    }\n    ans=0;\n}\nint main(){\n    int n,len,p,kase=0;\n    fac[0]=1;///预先处理26^i;\n    for(int i=1;i&lt;maxn;++i)\n        fac[i]=fac[i-1]*26%mod;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        init();\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            len=strlen(str);\n            for(int j=0;j&lt;len;++j){\n                p=str[j]-&apos;a&apos;;\n                ch[p].reg[len-j-1]++;\n            }\n            if(len&gt;1)\n                ch[str[0]-&apos;a&apos;].vi=false;\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                if(ch[i].reg[j]&gt;=26){\n                    ch[i].reg[j+1]+=ch[i].reg[j]/26;\n                    ch[i].reg[j]%=26;\n                }\n            }\n            ch[i].c=i;\n        }\n        sort(ch,ch+26);\n        for(int i=0;i&lt;26;++i)\n            Hash[ch[i].c]=26-i-1;\n        for(int i=25;i&gt;=0;--i){///从最小的开始判断是否可以为0\n            if(ch[i].vi){\n                for(int j=25;j&gt;i;--j)\n                    Hash[ch[j].c]=Hash[ch[j-1].c];\n                Hash[ch[i].c]=0;\n                break;\n            }\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                ans=(ans+fac[j]*ch[i].reg[j]*Hash[ch[i].c]%mod)%mod;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:Balala Power!  [Figure]  题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]},{"title":"2017多校训练1 HDU 6043 KazaQ's Socks","slug":"2017-hdu-6043-kazaqs-socks","date":"2017-07-27T15:46:42.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6043-kazaqs-socks.json","excerpt":"","keywords":null,"cover":null,"content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6043\" title=\"KazaQ&#39;s Socks\" target=\"_blank\" rel=\"noopener\">KazaQ’s Socks</a> 题意:穿袜子,洗袜子,求洗了多少次袜子…:sweat_smile: 题解:无 github: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6043\" title=\"KazaQ&#39;s Socks\" target=\"_blank\" rel=\"noopener\">KazaQ’s Socks</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    long long a,b,ans,kase=0;\n    while(~scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b)){\n        if(b&lt;=a){\n            printf(&quot;Case #%lld: %lld\\n&quot;,++kase,b);\n            continue;\n        }else{\n            long long loop=(a-1)&lt;&lt;1,rg=b-a;\n            long long res=rg%loop;\n            if(res==a-1) ans=a-1;\n            else if(res==0) ans=a;\n            else\n                ans=res&gt;a-1?res-a+1:res;\n            printf(&quot;Case #%lld: %lld\\n&quot;,++kase,ans);\n        }\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:KazaQ’s Socks 题意:穿袜子,洗袜子,求洗了多少次袜子…:sweat_smile: 题解:无 github: :point_right:KazaQ’s Socks#include&lt;bits/stdc++.h&gt;using","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"}]},{"title":"2017多校训练2 HDU 6047 Maximum Sequence","slug":"2017-hdu-6047-maximum-sequence","date":"2017-07-29T04:51:07.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6047-maximum-sequence.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6047\" title=\"Maximum Sequence\" target=\"_blank\" rel=\"noopener\">Maximum Sequence</a> 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,记录每个i到maxindex(A)的最大值,然后动态更新. github: 1.线段树法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003_Range_Tree.cpp\" title=\"1003_Range_Tree.cpp\" target=\"_blank\" rel=\"noopener\">1003_Range_Tree.cpp</a> 2.暴力动态更新法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003.cpp\" title=\"1003.cpp\" target=\"_blank\" rel=\"noopener\">1003.cpp</a></p>\n<pre><code>///线段树法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst int maxnode=2000050;\n\nint b[maxnode],N;\nint maxv[maxnode];\n\nvoid build(int o,int l,int r){\n    if(l==r){\n        if(l&gt;N) return;///预先分配2*N个结点\n        scanf(&quot;%d&quot;,&amp;maxv[o]);maxv[o]-=l;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(o&lt;&lt;1,l,mid);\n    build(o&lt;&lt;1|1,mid+1,r);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint query(int o,int l,int r,int ll,int rr){\n    if(l&gt;=ll&amp;&amp;r&lt;=rr) return maxv[o];\n    int ma=-1,mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=ll) ma=max(ma,query(o&lt;&lt;1,l,mid,ll,rr));\n    if(rr&gt;mid) ma=max(ma,query(o&lt;&lt;1|1,mid+1,r,ll,rr));\n    return ma;\n}\n\nvoid update(int o,int l,int r,int p,int val){\n    if(l==r){\n        maxv[o]=val;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    if(p&lt;=mid)update(o&lt;&lt;1,l,mid,p,val);\n    else update(o&lt;&lt;1|1,mid+1,r,p,val);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        build(1,1,2*N);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        LL ans=0;\n        for(int i=N+1;i&lt;=2*N;++i){\n            int k=query(1,1,2*N,b[i-N],i-1);\n            update(1,1,2*N,i,k-i);\n            ans=(ans+k)%mod;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n\n///HDU 6047 暴力动态更新法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=500000+50;\nconst int mod=1e9+7;\nint N;\nint a[maxn],b[maxn],maxa[maxn];\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=1;i&lt;=N;++i){\n            int aa;\n            scanf(&quot;%d&quot;,&amp;aa);\n            a[i]=aa-i;\n        }\n        maxa[N]=a[N];\n        for(int i=N-1;i&gt;=1;--i) maxa[i]=max(maxa[i+1],a[i]);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        long long ans=0;\n        ans=(ans+maxa[b[1]])%mod;\n        int t=maxa[b[1]]-N-1;\n        for(int i=2;i&lt;=N;++i){\n            maxa[b[i]]=max(maxa[b[i]],t);\n            ans=(ans+maxa[b[i]])%mod;\n            t=max(t,maxa[b[i]]-N-1);\n        }\n        printf(&quot;%lld\\n&quot;,ans%mod);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: :point_right:Maximum Sequence 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"segmentTree","slug":"2017多校/segmentTree","count":1,"path":"api/categories/2017多校/segmentTree.json"},{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"path":"api/categories/2017多校/segmentTree/思维.json"},{"name":"线段树","slug":"2017多校/segmentTree/思维/线段树","count":1,"path":"api/categories/2017多校/segmentTree/思维/线段树.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"2017 Multi-University Training Contest - Team 9  1008","slug":"2017-multi-university-training-contest-team-9-1008","date":"2017-08-22T11:37:20.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/2017-multi-university-training-contest-team-9-1008.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6168\" title=\"HDU-6168 Numbers\" target=\"_blank\" rel=\"noopener\">HDU-6168 Numbers</a> github Code Link: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008.cpp\" title=\"1008.cpp\" target=\"_blank\" rel=\"noopener\">1008.cpp</a> Test Code: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008test.cpp\" title=\"1008test.cpp\" target=\"_blank\" rel=\"noopener\">1008test.cpp</a> 题解: 用map记录下每个数字出现的次数.然后对b进行排序,首先可以知道,排序后的数组,前两个数一定是a序列的前两个数.然后从这两个数开始拓展,a1+a2必在b中,所以在map中找到a1+a2的数量然后-1,之后把接下来的第一个数Push到a数组中,并且删除一个a1+a3和a2+a3,依次递推.知道a.size()到达sqrt(m/2)或者i&gt;=m为止,结束循环. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=200000;\n\nint c[maxn];\nint m,n;\nmap&lt;int,int&gt; d;\nvector&lt;int&gt; a;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;m)){\n        d.clear();a.clear();\n        n=sqrt(m&lt;&lt;1);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            d[c[i]]++;\n        }\n        sort(c,c+m);\n        a.push_back(c[0]);a.push_back(c[1]);\n        d[c[1]]--;d[c[0]]--;\n        for(int i=1;i&lt;m &amp;&amp; a.size()&lt;n;++i){\n            int si=a.size()-1;\n            for(int j=0;j&lt;si;++j){\n                if(d.find(a[si]+a[j])!=d.end() &amp;&amp; d[a[si]+a[j]]&gt;0){\n                    d[a[si]+a[j]]--;\n         //           printf(&quot;IDone %d\\n&quot;,a[si-1]+a[j]);\n                }\n            }\n            while(d[c[i]]==0){\n                int no=c[i];\n                while(c[i]==no){\n                    ++i;\n                    if(i&gt;=m)break;\n                }\n                if(i&gt;=m)break;\n    //            printf(&quot;Done %d\\n&quot;,c[i]);\n            }\n            if(i&lt;m){\n                a.push_back(c[i]);\n         //       printf(&quot;Push %d\\n&quot;,c[i]);\n                d[c[i]]--;\n            }\n            --i;\n        }\n        printf(&quot;%d\\n&quot;,a.size());\n        printf(&quot;%d&quot;,a[0]);\n        for(int i=1;i&lt;a.size();++i){\n            printf(&quot; %d&quot;,a[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>Test Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint t[5]={3,7,6,9,10};\nvector&lt;int&gt; ans;\nint main(){\n     freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n     freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n     for(int i=0;i&lt;5;++i) ans.push_back(t[i]);\n     for(int i=0;i&lt;5;++i){\n        for(int j=i+1;j&lt;5;++j){\n            ans.push_back(t[i]+t[j]);\n        }\n     }\n     printf(&quot;%d\\n&quot;,ans.size());\n     for(int i=0;i&lt;ans.size();++i) printf(&quot;%d &quot;,ans[i]);\n    return 0;\n}</code></pre>","text":"类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:HDU-6168 Numbers github Code Link: :earth_asia:1008.cpp Test Code: :earth_asia:1008","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]},{"title":"最近的多校和codeforce(未补题状态","slug":"current-multi-cf","date":"2017-08-15T14:20:45.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/current-multi-cf.json","excerpt":"","keywords":null,"cover":null,"content":"<p>codeforce: Round428 div2 A: 戳这里-&gt; :earth_americas:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/428DIV2%20A.cpp\" title=\"428DIV2 A.cpp\" target=\"_blank\" rel=\"noopener\">428DIV2 A.cpp</a> Round428 div2 B: 戳这里-&gt; :earth_americas:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/428DIV2B.cpp\" title=\"428DIV2 B.cpp\" target=\"_blank\" rel=\"noopener\">428DIV2 B.cpp</a> 多校: 戳这里-&gt; :earth_americas: <a href=\"https://github.com/834930269/Other_OJ/tree/master/Multi-University%20Training%20Contest\" title=\"水题集合φ(&gt;ω&lt;*) \" target=\"_blank\" rel=\"noopener\">水题集合φ(&gt;ω&lt;*)</a></p>\n","text":"codeforce: Round428 div2 A: 戳这里-&gt; :earth_americas:428DIV2 A.cpp Round428 div2 B: 戳这里-&gt; :earth_americas:428DIV2 B.cpp 多校: 戳这里-&gt; :ear","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"Codeforce","slug":"2017多校/Codeforce","count":1,"path":"api/categories/2017多校/Codeforce.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"}]},{"title":"2017 杭电多校训练赛 补题","slug":"2017-hdu-up","date":"2018-01-14T04:25:53.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/2017-hdu-up.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif","content":"<p>[toc]</p>\n<h1 id=\"第一场\"><a href=\"#第一场\" class=\"headerlink\" title=\"第一场\"></a><strong>第一场</strong></h1><h2 id=\"1003-Colorful-Tree-hdoj6035\"><a href=\"#1003-Colorful-Tree-hdoj6035\" class=\"headerlink\" title=\"1003 Colorful Tree hdoj6035\"></a><strong>1003 Colorful Tree hdoj6035</strong></h2><p>题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n<em>(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) *</em> //思路<strong>：Answer = 所有颜色种类 * 所有路径数量 - 每一种颜色有多少路径没有经过 . 一开始假设每条路径都经过了所有颜色，再把每种颜色没经过的路径数减去就行，这个应该很好理解。问题是怎么算没经过的路径数？操作是这样的，如果算颜色1没经过的路径数，我们先把图里所有颜色是1的节点遮起来（假设这个点不存在，图在这个点是断路），图就被分成了很多块，</strong>每块的值= 那一块里的顶点数<em>（那一块里的顶点数-1）/2*</em>。 所有块的值加起来就是不经过颜色1的所有路径数。 到这里是不是还是很好理解，那么问题来了，怎么实现？…题解里说用虚树什么的… 用一个DFS即可，复杂度O（n） 用Size数组储存以每个节点为根节点的子树大小（即子树里节点的个数），Sum数组…很难解释，大概是表示以每种颜色为根节点的子树的大小和，但不是非常准确，如果以颜色2为根节点的子树里还含有颜色为2的节点，那只要算根节点这个颜色为2的子树大小即可，若在以这个颜色为2的点为根节点的子树之外还有颜色为2的点，那还要加上这个点的值…不知道能不能理解…解释不清楚，大概就这个意思… 以下图颜色2为例，代码里最后的for里(即以根<strong>第一个节点</strong>计算中)减去的（n-sum[2]）*（n-sum[2]-1）/2的那部分减去的是下图橙色圈里的那块，dfs里<code>减去pp那部分</code>是下图里蓝色圈的那块。其他具体的按照自己的理解再思考思考。 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" alt></a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 200005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\n//c[]数组是每个节点的颜色\nint c[maxn],head[maxn],len,sum[maxn],size[maxn],vis[maxn];\nLL d;\n//边表\n//邻接表\nstruct node{\n    int v,next;\n}p[maxn&lt;&lt;1];\n\nvoid addedge(int u,int v){\n    //有向边指向点的编号\n    p[len].v=v;\n    //每条边的下一条边是上一次纪录的边的号码\n    p[len].next=head[u];\n    //邻接表的方法\n    //len为当前边的编号\n\n    //只记录当前节点的最后一个边的位置\n    head[u]=len++;\n}\n//对树进行dfs\nvoid dfs(int x,int fa){\n    //非这个点为根的所有该颜色的点\n    LL pre=sum[c[x]];\n    //size数组是当前节点的子节点总数目\n    size[x]=1;\n    int add=0;\n    //通过邻接表对当前节点x进行dfs\n    //等于0则退出\n    for(int i=head[x];~i;i=p[i].next){\n        //如果遇到反向边了,跳过,继续往其他边走\n        if(p[i].v==fa)\n            continue;\n        dfs(p[i].v,x);\n        size[x] += size[p[i].v];\n        //计算当前节点子树所有和当前节点颜色不同的点的个数\n        LL count = size[p[i].v] - sum[c[x]] + pre;\n        pre = sum[c[x]];\n        //当前子树的不同颜色点的个数\n        add += count;\n        //假设其他颜色都是白色,d即等于不同颜色所组成的边的总个数\n        d += count*(count-1)&gt;&gt;1;\n    }\n    //计算以x为根节点子树的所有与x不同颜色的点的个数\n    sum[c[x]] += add + 1;\n}\n\nint main(){\n    int n,tcase=1;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        memset(head,-1,sizeof(head));\n        memset(sum,0,sizeof(sum));\n        memset(vis,0,sizeof(vis));\n        d=len=0;\n        LL number = 0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            //记录颜色,颜色范围是[1,n]\n            if(!vis[c[i]]){\n                vis[c[i]]=1;\n                number++;\n            }\n        }\n        for(int i=1;i&lt;n;++i){\n            int u,v;\n            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);\n            addedge(u,v);\n            addedge(v,u);\n        }\n        dfs(1,0);\n        //ans初始等于(颜色个数)*(所有边的个数)-d(d为每个颜色在每个子树上被减去的不会经过那个颜色的路径的个数)\n        LL ans=(number*(n-1)*n&gt;&gt;1)-d;\n        for(int i=1;i&lt;=n;++i){\n            //不存在的颜色不需要计算,把已存在的颜色计算一下\n            if(vis[i]&amp;&amp;i!=c[1]){\n                //在根节点中与颜色i不同的颜色的个数\n                LL count=n-sum[i];\n                //每个颜色的路径数=(n*(n-1)&gt;&gt;1)-(count*(count-1)&gt;&gt;1)\n                //以根节点为中心减去不同于当前颜色的路径的个数\n                //最终得到的ans即为 每个颜色路径个数 的和\n                ans-=count*(count-1)&gt;&gt;1;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,tcase++,ans);\n    }\n    return 0;\n}</code></pre><h2 id=\"1006-Function-hdoj6038\"><a href=\"#1006-Function-hdoj6038\" class=\"headerlink\" title=\"1006 Function hdoj6038\"></a><strong>1006 Function hdoj6038</strong></h2><p>这道题似懂非懂的写了出来… 大体是寻找循环节. 我写的代码有点乱… 原式为: f[i]=b[f[a[i]]] A:{1,0,2} B{0,1} 可组成f: 000 111 110 001 A:{2,0,1} b{0,2,3,1} 可组成f: 000 231 312 123 以i -&gt; a[i] i -&gt; b[i] 为图的边进行Tarjan. 用Tarjan判断a和b各自有几个环(强连通分量),并且记录下每个环的大小. 然后AC代码如下(以后思路清楚了再重新看看…):</p>\n<pre><code>//HDU 6038\n#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\nconst int maxn=100000+100;\nconst int mod=1e9+7;\ntypedef long long int lli;\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint a[maxn],b[maxn];\n\nstack&lt;int&gt; S;\nmap&lt;int,int&gt; A,B;\n\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\ninline lli qp(lli aa,lli x){\n    if(aa == 0) return 0;\n    lli ans = 1;\n    for(;x;x&gt;&gt;=1){\n        if(x&amp;1) ans = ans*aa % mod;\n        aa = aa*aa % mod;\n    }\n    return ans % mod;\n}\n\nvoid dfs(int u,map&lt;int,int&gt;&amp; T){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v,T);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            //未回溯时计算low数组需要通过pre数组\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        int cnt=0;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            cnt++;\n            if(x==u)break;\n        }\n        T[cnt]++;\n    }\n}\n\nvoid Tarjan(int n,map&lt;int,int&gt;&amp; T){\n    while(!S.empty()){\n        S.pop();\n    }\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i,T);\n    }\n}\n\nint main(){\n    int n,m,kase=0;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;a[i]);\n        }\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;b[i]);\n        }\n        //对aTarjan\n        for(int i=0;i&lt;n;++i){\n            addAdge(i,a[i]);\n        }\n        Tarjan(n,A);\n        for(int i=0;i&lt;n;++i){\n            G[i].clear();\n        }\n        //对bTarjan\n        for(int i=0;i&lt;m;++i){\n            addAdge(i,b[i]);\n        }\n        Tarjan(m,B);\n        for(int i=0;i&lt;m;++i){\n            G[i].clear();\n        }\n\n        long long ans=1;\n        map&lt;int,int&gt;::iterator it1;\n        map&lt;int,int&gt;::iterator it2;\n        for(it1=A.begin();it1!=A.end();it1++){\n            long long tmp=0;\n            for(it2=B.begin();it2!=B.end();it2++){\n                if(it1-&gt;first%it2-&gt;first==0){\n                    tmp=tmp+it2-&gt;second*it2-&gt;first;\n                }\n                //printf(&quot;%d %d : %d %d\\n&quot;,it1-&gt;first,it2-&gt;first,it1-&gt;second,it2-&gt;second);\n            }\n            ans=ans*qp(tmp,it1-&gt;second)%mod;\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n        A.clear();\n        B.clear();\n    }\n    return 0;\n}</code></pre><h2 id=\"1008-Hints-of-sd0061-hdoj6040\"><a href=\"#1008-Hints-of-sd0061-hdoj6040\" class=\"headerlink\" title=\"1008 Hints of sd0061 hdoj6040\"></a><strong>1008 Hints of sd0061 hdoj6040</strong></h2><h1 id=\"第二场\"><a href=\"#第二场\" class=\"headerlink\" title=\"第二场\"></a><strong>第二场</strong></h1><h1 id=\"第三场\"><a href=\"#第三场\" class=\"headerlink\" title=\"第三场\"></a><strong>第三场</strong></h1>","text":"[toc]第一场1003 Colorful Tree hdoj6035题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) * //思路：Answer = 所有颜色种类 * 所有路径数量","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"dfs","slug":"2017多校/dfs","count":1,"path":"api/categories/2017多校/dfs.json"},{"name":"图论","slug":"2017多校/dfs/图论","count":1,"path":"api/categories/2017多校/dfs/图论.json"},{"name":"思维","slug":"2017多校/dfs/图论/思维","count":1,"path":"api/categories/2017多校/dfs/图论/思维.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]}]}