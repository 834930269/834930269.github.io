{"name":"逆序数","slug":"逆序数","count":2,"postlist":[{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） A 逆序数","slug":"2018-5-a","date":"2018-02-25T10:40:31.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/2018-5-a.json","excerpt":"","keywords":null,"cover":null,"content":"<p>链接：<a href=\"https://www.nowcoder.com/acm/contest/77/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/77/A</a> 来源：牛客网</p>\n<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。比如一个序列为4 5 1 3 2， 那么这个序列的逆序数为7，逆序对分别为(4, 1), (4, 3), (4, 2), (5, 1), (5, 3), (5, 2),(3, 2)。</p>\n<h1 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述:\"></a>输入描述:</h1><p>第一行有一个整数n(1 &lt;= n &lt;= 100000), 然后第二行跟着n个整数，对于第i个数a[i]，(0 &lt;= a[i] &lt;= 100000)。</p>\n<h1 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述:\"></a>输出描述:</h1><p>输出这个序列中的逆序数</p>\n<h1 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h1><h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><p>5 4 5 1 3 2</p>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p>7</p>\n<h1 id=\"两种方法求逆序数\"><a href=\"#两种方法求逆序数\" class=\"headerlink\" title=\"两种方法求逆序数\"></a>两种方法求逆序数</h1><h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100010;\n\nint seq[maxn],N;\nint temp[maxn];\nLL cnt;\n//归并排序求逆序数\nvoid merge_sort(int arr[],int l,int r){\n    if(l==r)return;\n    int mid=((l+r)&gt;&gt;1);\n    merge_sort(arr,l,mid);\n    merge_sort(arr,mid+1,r);\n    int i=l,j=mid+1;\n    for(int k=l;k&lt;=r;++k){\n        if(j&gt;r || (i&lt;=mid &amp;&amp; arr[i]&lt;arr[j]))temp[k]=arr[i++];\n        else temp[k]=arr[j++],cnt+=mid-i+1;\n        //如果a[i]&gt;a[j]则逆序数加上mid+1-i,即剩下的前面个数\n    }\n    for(i=l;i&lt;=r;++i)arr[i]=temp[i];\n}\n\nint main(){\n    cin&gt;&gt;N;\n    for(int i=0;i&lt;N;++i){\n        cin&gt;&gt;seq[i];\n    }\n    cnt=0;\n    merge_sort(seq,0,N-1);\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n}</code></pre><h2 id=\"树状数组\"><a href=\"#树状数组\" class=\"headerlink\" title=\"树状数组\"></a>树状数组</h2>","text":"链接：https://www.nowcoder.com/acm/contest/77/A 来源：牛客网题目描述在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。比如一个序列为4 5 1 3","link":"","raw":null,"photos":[],"categories":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/categories/树状数组.json"},{"name":"牛客练习赛","slug":"树状数组/牛客练习赛","count":2,"path":"api/categories/树状数组/牛客练习赛.json"},{"name":"逆序数","slug":"树状数组/牛客练习赛/逆序数","count":1,"path":"api/categories/树状数组/牛客练习赛/逆序数.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"逆序数","slug":"逆序数","count":2,"path":"api/tags/逆序数.json"}]},{"title":"51nod 1020 逆序排列","slug":"51nod-1020-reverse","date":"2018-03-05T04:50:19.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1020-reverse.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-DP-逆序数\"><a href=\"#Type-DP-逆序数\" class=\"headerlink\" title=\"Type:DP,逆序数\"></a>Type:DP,逆序数</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。 如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。 1-n的全排列中，逆序数最小为0（正序），最大为n*(n-1) / 2（倒序） 给出2个数n和k，求1-n的全排列中，逆序数为k的排列有多少种？ 例如：n = 4 k = 3。 1 2 3 4的排列中逆序为3的共有6个，分别是： 1 4 3 2 2 3 4 1 2 4 1 3 3 1 4 2 3 2 1 4 4 1 2 3 由于逆序排列的数量非常大，因此只需计算并输出该数 Mod 10^9 + 7的结果就可以了。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000) 第2 - T + 1行：每行2个数n，k。中间用空格分隔。（2 &lt;= n &lt;= 1000, 0 &lt;= k &lt;= 20000)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>共T行，对应逆序排列的数量 Mod (10^9 + 7)</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>1 4 3</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>6</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>考虑 dp[i][j] 表示 元素个数为 i 个时 逆序数为 j 的全排列个数为 dp[i][j] 个.</p>\n<blockquote>\n<p>设当前元素为 N ,则 N 可以放在原来 N-1 个元素的任意全排列的 N-i(i∈[0,N)) 上的位置.</p>\n<blockquote>\n<p>当 N 放在位置 N-i 上时,该排列的逆序数会增长 i (因为N最大,所以后面i个为逆序,前面为顺序),所以当我们想要找长度为 N ,逆序数为 k 的个数时,只需要找长度为 N-1 ,逆序数为 k-i 的全排列的个数即可.</p>\n<blockquote>\n<p>所以 dp[N][k] = lambda(dp[N-1][k-i] | i∈[0,N))</p>\n</blockquote>\n<p>复杂度为 O(k(N^2)) 会炸.</p>\n</blockquote>\n<p>考虑优化:</p>\n<blockquote>\n<p>① dp[N][k] = lambda(dp[N-1][k-i] | i∈[0,N)) ② dp[N][k-1] = lambda(dp[N-1][k-1-i] | i∈[0,N)) ①-②: dp[N][k]-dp[N][k-1] = dp[N-1][k]-dp[N-1][k-N] dp[N][k]=dp[N-1][k]-dp[N-1][k-N]+dp[N][k-1]</p>\n</blockquote>\n</blockquote>\n<p>得出递推公式:</p>\n<blockquote>\n<p>① dp[i][j]=1 j=0 ② dp[i][j]=dp[i-1][j]-dp[i-1][j-i]+dp[i][j-1]</p>\n</blockquote>\n<p>由题目的约束条件:</p>\n<blockquote>\n<p>逆序数最小为0（正序），最大为n*(n-1) / 2（倒序）</p>\n</blockquote>\n<p>故枚举逆序数只需要枚举到 i*(i-1)/2&amp;&amp;j\\&lt;20000即可 注意j-i不能&lt;0</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e9+7;\nint dp[1010][20010];\n\nvoid init(){\n    for(int i=1;i&lt;=1000;++i) dp[i][0]=1;\n    for(int i=2;i&lt;=1000;++i){\n        for(int j=1;j&lt;=i*(i-1)/2&amp;&amp;j&lt;=20000;++j){\n            dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n            if(j-i&gt;=0)dp[i][j]=(((dp[i][j]-dp[i-1][j-i])%mod)+mod)%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int n,k;\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n        printf(&quot;%d\\n&quot;,dp[n][k]);\n    }\n    return 0;\n}</code></pre>","text":"Type:DP,逆序数题目在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。 如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。 1-n的全排列中，逆序数最小为0（正序","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"全排列","slug":"51nod/全排列","count":1,"path":"api/categories/51nod/全排列.json"},{"name":"动态规划","slug":"51nod/全排列/动态规划","count":1,"path":"api/categories/51nod/全排列/动态规划.json"},{"name":"逆序数","slug":"51nod/全排列/动态规划/逆序数","count":1,"path":"api/categories/51nod/全排列/动态规划/逆序数.json"}],"tags":[{"name":"逆序数","slug":"逆序数","count":2,"path":"api/tags/逆序数.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"全排列","slug":"全排列","count":1,"path":"api/tags/全排列.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]}]}