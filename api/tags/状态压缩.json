{"name":"状态压缩","slug":"状态压缩","count":1,"postlist":[{"title":"UVa 11825","slug":"uva-11825","date":"2017-07-14T16:41:09.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-11825.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-11825\" target=\"_blank\" rel=\"noopener\">Hackers’ Crackdown</a></strong> <strong>【题意】</strong> <strong>有N台机器，每台机器上有N个服务</strong> <strong>你可以对每台机器选择关闭他以及和他相邻的机器的一种服务</strong> <strong>当所有机器不能运行一个服务时，就是摧毁了一种服务</strong> <strong>问你最多能摧毁多少个服务</strong> <strong>【题解】</strong> <strong>就是把n台电脑看成n个集合,每个集合的成员就是这台电脑,以及和这台电脑相邻的电脑;</strong> <strong>我们就是要求把这些集合合并成尽量多的大集合,使每个集合都等于全集;也就是因为最开始的小集合,我们可以让它里面全部电脑的某一项服务全部失误,那如果合并成一个大集合,则这个大集合的某一项服务可以全部失效;所以能合并成几个等于全集的大集合,就可以让几项服务失效;</strong> <strong>【Tip】</strong> <strong>状态压缩,异或操作是相同得0,不同得1.LRJ这道题的位运算用的好…</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2011825.cpp\" target=\"_blank\" rel=\"noopener\">Uva 11825.cpp</a></strong></p>\n<hr>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int N,T,P[1&lt;&lt;17],f[1&lt;&lt;17],cover[1&lt;&lt;17],ca=1;<br>int main(){<br>    while(~scanf(“%d”,&amp;N),N){<br>        ///初始化第i台计算机的相邻集合<br>        for(int i=0;i&lt;N;++i){<br>            int n,m;<br>            scanf(“%d”,&amp;n);<br>            P[i]=1&lt;&lt;i;<br>            for(int j=0;j&lt;n;++j){<br>                scanf(“%d”,&amp;m);<br>                P[i] |= 1&lt;&lt;m;<br>            }<br>        }<br>        ///S是N个计算机的所有组合的集合,二进制表示,cover[S]是集合的并<br>        for(int S=0;S&lt;(1&lt;&lt;N);++S){<br>            cover[S]=0;<br>            for(int i=0;i&lt;N;++i){<br>                if(S &amp; (1&lt;&lt;i)) cover[S] |= P[i];///第i台机器选/不选<br>            }<br>        }<br>        f[0]=0;<br>        int ALL=(1&lt;&lt;N)-1;///全集二进制表示<br>        for(int S=1;S&lt;(1&lt;&lt;N);++S){<br>            f[S]=0;<br>            ///筛出S的子集进行动态规划<br>            for(int S0=S;S0;S0=(S0-1)&amp;S){<br>                if(cover[S0]==ALL)///如果子集S的子集的并是全集<br>                    f[S]=max(f[S],f[S^S0]+1);<br>            }<br>        }<br>        printf(“Case %d: %d\\n”,ca++,f[ALL]);<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Hackers’ Crackdown 【题意】 有N台机器，每台机器上有N个服务 你可以对每台机器选择关闭他以及和他相邻的机器的一种服务 当所有机器不能运行一个服务时，就是摧毁了一种服务 问你最多能摧毁多少个服务 【题解】 就是把n台电脑看成n个集合,每","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"动态规划","slug":"UVa/位操作/动态规划","count":1,"path":"api/categories/UVa/位操作/动态规划.json"},{"name":"状态压缩","slug":"UVa/位操作/动态规划/状态压缩","count":1,"path":"api/categories/UVa/位操作/动态规划/状态压缩.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}]}]}