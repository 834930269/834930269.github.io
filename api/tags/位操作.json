{"name":"位操作","slug":"位操作","count":3,"postlist":[{"title":"UVa  11464","slug":"uva-11464","date":"2017-03-31T12:59:56.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-11464.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>gird 网格,格子</strong> <strong>so taht 以便</strong> <strong>The parity 奇偶校验</strong> <strong>even 有偶数意</strong> <strong>transformation 转化</strong> <strong>achieve 取得,获得,实现,成功</strong> <strong>requirement 要求</strong> <strong>indicates 表明</strong> <strong>character 性格,品质</strong> <strong>separated 分开,隔开</strong> <strong>instead 代替,反而,相反</strong> <strong>【题解】</strong> <strong>蓝书 P16</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<algorithm></algorithm></strong> <strong>using namespace std;</strong> <strong>const int INF=0x3f3f3f3f;</strong> <strong>const int maxn=20;</strong> <strong>int A[maxn][maxn],B[maxn][maxn],n,T,ca=1;</strong> <strong>int check(int s){</strong> **    memset(B,0,sizeof(B));** <strong>//先初始化第一行</strong> **    for(int i=0;i&lt;n;++i){** **        if(s &amp; (1&lt;&lt;i)) B[0][i]=1;//这句意思是判断每一位上是否是1** <strong>//即(1&lt;&lt;n)只有第n位是1,其他位都是0 为真即为1</strong> <strong>else if(A[0][i]==1) return INF;//1不能变成0</strong> **    }** **    for(int i=1;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            int sum=0;//元素B[i-1][0]的上,左,右元素之和** **            if(i&gt;1)sum+=B[i-2][j];** **            if(j&gt;0)sum+=B[i-1][j-1];** <strong>if(j&lt;n-1)sum+=B[i-1][j+1];</strong> **            B[i][j]=sum%2;//sum是偶数,=0,奇数,=1** **            if(A[i][j]==1 &amp;&amp; B[i][j]==0) return INF;** <strong>//不存在1-&gt;0的操作.</strong> <strong>}</strong> **    }** **    int cnt=0;** **    for(int i=0;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            if(A[i][j]!=B[i][j])** <strong>cnt++;</strong> <strong>}</strong> <strong>}</strong> <strong>return cnt;</strong> <strong>}</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        printf(“Case %d: “,ca++);** **        scanf(“%d”,&amp;n);** **        for(int i=0;i&lt;n;++i)** **            for(int j=0;j&lt;n;++j)** **                scanf(“%d”,&amp;A[i][j]);** <strong>int ans=INF;</strong> **        for(int i=0;i&lt;(1&lt;&lt;n);++i)** <strong>ans=min(ans,check(i));</strong> **        if(ans==INF) ans=-1;** <strong>printf(“%d\\n”,ans);</strong> <strong>}</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 gird 网格,格子 so taht 以便 The parity 奇偶校验 even 有偶数意 transformation 转化 achieve 取得,获得,实现,成功 requirement 要求 indicates 表明 character 性格,品质 separ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"枚举","slug":"UVa/位操作/枚举","count":1,"path":"api/categories/UVa/位操作/枚举.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"}]},{"title":"UVa 11825","slug":"uva-11825","date":"2017-07-14T16:41:09.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-11825.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-11825\" target=\"_blank\" rel=\"noopener\">Hackers’ Crackdown</a></strong> <strong>【题意】</strong> <strong>有N台机器，每台机器上有N个服务</strong> <strong>你可以对每台机器选择关闭他以及和他相邻的机器的一种服务</strong> <strong>当所有机器不能运行一个服务时，就是摧毁了一种服务</strong> <strong>问你最多能摧毁多少个服务</strong> <strong>【题解】</strong> <strong>就是把n台电脑看成n个集合,每个集合的成员就是这台电脑,以及和这台电脑相邻的电脑;</strong> <strong>我们就是要求把这些集合合并成尽量多的大集合,使每个集合都等于全集;也就是因为最开始的小集合,我们可以让它里面全部电脑的某一项服务全部失误,那如果合并成一个大集合,则这个大集合的某一项服务可以全部失效;所以能合并成几个等于全集的大集合,就可以让几项服务失效;</strong> <strong>【Tip】</strong> <strong>状态压缩,异或操作是相同得0,不同得1.LRJ这道题的位运算用的好…</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2011825.cpp\" target=\"_blank\" rel=\"noopener\">Uva 11825.cpp</a></strong></p>\n<hr>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int N,T,P[1&lt;&lt;17],f[1&lt;&lt;17],cover[1&lt;&lt;17],ca=1;<br>int main(){<br>    while(~scanf(“%d”,&amp;N),N){<br>        ///初始化第i台计算机的相邻集合<br>        for(int i=0;i&lt;N;++i){<br>            int n,m;<br>            scanf(“%d”,&amp;n);<br>            P[i]=1&lt;&lt;i;<br>            for(int j=0;j&lt;n;++j){<br>                scanf(“%d”,&amp;m);<br>                P[i] |= 1&lt;&lt;m;<br>            }<br>        }<br>        ///S是N个计算机的所有组合的集合,二进制表示,cover[S]是集合的并<br>        for(int S=0;S&lt;(1&lt;&lt;N);++S){<br>            cover[S]=0;<br>            for(int i=0;i&lt;N;++i){<br>                if(S &amp; (1&lt;&lt;i)) cover[S] |= P[i];///第i台机器选/不选<br>            }<br>        }<br>        f[0]=0;<br>        int ALL=(1&lt;&lt;N)-1;///全集二进制表示<br>        for(int S=1;S&lt;(1&lt;&lt;N);++S){<br>            f[S]=0;<br>            ///筛出S的子集进行动态规划<br>            for(int S0=S;S0;S0=(S0-1)&amp;S){<br>                if(cover[S0]==ALL)///如果子集S的子集的并是全集<br>                    f[S]=max(f[S],f[S^S0]+1);<br>            }<br>        }<br>        printf(“Case %d: %d\\n”,ca++,f[ALL]);<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Hackers’ Crackdown 【题意】 有N台机器，每台机器上有N个服务 你可以对每台机器选择关闭他以及和他相邻的机器的一种服务 当所有机器不能运行一个服务时，就是摧毁了一种服务 问你最多能摧毁多少个服务 【题解】 就是把n台电脑看成n个集合,每","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"动态规划","slug":"UVa/位操作/动态规划","count":1,"path":"api/categories/UVa/位操作/动态规划.json"},{"name":"状态压缩","slug":"UVa/位操作/动态规划/状态压缩","count":1,"path":"api/categories/UVa/位操作/动态规划/状态压缩.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}]},{"title":"第14届浙江省赛By Tusimple","slug":"14zojby-tusimple","date":"2017-04-22T11:57:29.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/14zojby-tusimple.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【网赛链接】</strong> <strong><a href=\"http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=364\" target=\"_blank\" rel=\"noopener\">第14届浙江省赛By Tusimple</a></strong> <strong>【A】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N,a1,T;</strong> <strong>int Kobayashi[4]={1,0,1,-1},Kscore;</strong> <strong>int Tohru[4]={0,1,1,-1},Tscore;</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        while(N–){** **            SI(T);** **            Kscore=0;** **            Tscore=0;** **            rep(i,T){** **                SI(a1);** **                Kscore+=Kobayashi[a1-1];** **                Tscore+=Tohru[a1-1];** **            }** **            if(Kscore&gt;Tscore)** **                puts(“Kobayashi”);** **            else if(Tscore&gt;Kscore)** **                puts(“Tohru”);** **            else** **                puts(“Draw”);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【B】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>const int maxn=20000+10;</strong> <strong>int T,N,fk,Orz,flag,cnt;</strong> <strong>int score[maxn],scomp[maxn];</strong> <strong>int main(){</strong> **    while(~SI(T)){** **        while(T–){** **            fill(score,score+4000,0);** **            Orz=flag=0;** **            SI(N);** **            if(N&gt;13 || N&lt;10){** **                rep(i,N){** **                    SI(fk);** **                }** **                puts(“No”);continue;** **            }** **            rep(i,N){** **                SI(fk);** **                if(fk&lt;=0){** **                    flag=1;** **                }else{** **                    score[fk]++;** **                }** **                scomp[i]=fk;** **            }** **            if(flag){** **                puts(“No”);** **            }else{** **                if(score[1]&lt;2){** **                    puts(“No”);** **                    continue;** **                }else{** **                    sort(scomp,scomp+N);** **                    rez(i,1,N-2){** **                        if(scomp[i]-scomp[i-1]&gt;2){** **                            puts(“No”);** **                            flag=1;** **                            break;** **                        }** **                    }** **                    if(!flag) puts(“Yes”);** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【C】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int T,n,q,c;</strong> <strong>map&lt;string,int&gt; mp;</strong> <strong>map&lt;string,int&gt;::iterator ite;</strong> <strong>map&lt;int,vector<string> &gt; res;</string></strong> <strong>string st;</strong> <strong>inline int readt(int N){</strong> **    int ans=0,tit;** **    rep(i,N){** **        SI(tit);** **        ans+=(1&lt;&lt;N-i-1) &amp; (tit&lt;&lt;N-i-1);** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        //测试数据可能出现重复的名字和情况,所以要初始化** **        mp.clear();** **        res.clear();** **        SII(n,q);** **        SI(c);** **        rep(i,c){** **            cin&gt;&gt;st;** **            mp[st]=0;** **        }** **        rep(i,q){** **            int nu;** **            SI(nu);** **            rep(j,nu){** **                cin&gt;&gt;st;** **                mp[st]+=(1&lt;&lt;q-i-1);** **            }** **        }** **        for(ite=mp.begin();ite!=mp.end();ite++){** **            res[ite-&gt;second].push_back(ite-&gt;first);** **        }** **        rep(i,n){** **            int index=readt(q);** **            if(res.find(index)==res.end()){** **                puts(“Let’s go to the library!!”);** **            }else{** **                vector<string>&amp; t=res[index];** **                if(t.size()&gt;1){** **                    puts(“Let’s go to the library!!”);** **                }else{** **                    cout&lt;&lt;t[0]&lt;&lt;”\\n”;** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></string></p>\n</blockquote>\n<p><strong>【D】</strong> <strong>因为样例用的是m=3…所以我就一直卡在z&gt;=3……然后比赛结束以后发现了…好亏啊</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct Star{</strong> **    int left,right;** **    bool operator&lt;(const Star MM) const{** **        return left&lt;MM.left;** **    }** <strong>}A[500],B[500];</strong> <strong>int n,m,x,y,T,s,e;</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        SII(n,m);SII(x,y);** **        rep(i,x){** **            SII(s,e);** **            A[i].left=s;** **            A[i].right=e;** **        }** **        rep(i,y){** **            SII(s,e);** **            B[i].left=s;** **            B[i].right=e;** **        }** **        sort(A,A+x);** **        sort(B,B+y);** **        int ans=0;** **        rep(i,x){** **            s=A[i].left;** **            e=A[i].right;** **            int z=0;** **            rep(j,y){** **                if(B[j].left&gt;A[i].right) break;** **                z+=(min(B[j].right,A[i].right)-max(A[i].left,B[j].left)+1);** **                    if(z&gt;=m){** **                        ans+=z-m+1;** **                        z=0;** **                    }else{** **                        z=0;** **                    }** **            }** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【网赛链接】 第14届浙江省赛By Tusimple 【A】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define ","link":"","raw":null,"photos":[],"categories":[{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/categories/ZOJ.json"},{"name":"位操作","slug":"ZOJ/位操作","count":1,"path":"api/categories/ZOJ/位操作.json"},{"name":"悬线法","slug":"ZOJ/位操作/悬线法","count":1,"path":"api/categories/ZOJ/位操作/悬线法.json"},{"name":"模拟","slug":"ZOJ/位操作/悬线法/模拟","count":1,"path":"api/categories/ZOJ/位操作/悬线法/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/tags/ZOJ.json"}]}]}