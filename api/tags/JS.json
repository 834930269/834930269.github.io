{"name":"JS","slug":"JS","count":5,"postlist":[{"title":"ASP.NET API2 设计 RESTful API","slug":"asp-net-api2-restful-api","date":"2017-11-26T04:12:55.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/asp-net-api2-restful-api.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171126121235.jpg","content":"<p>Copyright @ <a href=\"https://docs.microsoft.com/en-us/aspnet/web-api/overview/getting-started-with-aspnet-web-api/tutorial-your-first-web-api\" title=\"DocsASP.NETASP.NET Web API\" target=\"_blank\" rel=\"noopener\">DocsASP.NETASP.NET Web API</a> 微软的官方文档</p>\n<blockquote>\n<p>首先是新建ASP.NET api项目 然后是设计Model</p>\n<blockquote>\n<p>Product.cs</p>\n</blockquote>\n</blockquote>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace WAPI.Models\n{\n    public class Product\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public string Category { get; set; }\n        public decimal Price { get; set; }\n    }\n}</code></pre><blockquote>\n<p>编写Controller(路由)</p>\n<blockquote>\n<p>ProductsController.cs</p>\n</blockquote>\n</blockquote>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Web.Http;\n\nusing WAPI.Models;\n\nnamespace WAPI.Controllers\n{\n    public class ProductsController : ApiController\n    {\n        // XXM =&gt; decimal类型小数\n        Product[] products = new Product[]{\n            new Product{ Id=1,Name=&quot;Tomato Soup&quot;,Category=&quot;Groceries&quot;,Price=1},\n            new Product{ Id=2,Name=&quot;Yo-yo&quot;,Category=&quot;Toys&quot;,Price=3.75M},\n            new Product{ Id=3,Name=&quot;Hammer&quot;,Category=&quot;Hardware&quot;,Price=16.99M}\n        };\n\n        public IEnumerable&lt;Product&gt; GetAllProducts()\n        {\n            return products;\n        }\n\n        public IHttpActionResult GetProduct(int id)\n        {\n            //容器.FirstOrDefault(Boolean) 返回满足条件的第一个元素,如未找到,返回默认值\n            var product = products.FirstOrDefault((p) =&gt; p.Id == id);\n            if (product == null)\n            {\n                //ApiController.NotFound()\n                //即404界面\n                return NotFound();\n            }\n            //正常返回\n            return Ok(product);\n        }\n    }\n}</code></pre><blockquote>\n<p>最后通过编写前端界面,并使用JQuery来实现ajax传输,显示</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;\n    &lt;title&gt;Product App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;h2&gt;All Products&lt;/h2&gt;\n        &lt;ul id=&quot;products&quot;/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;h2&gt;Search by ID&lt;/h2&gt;\n        &lt;input type=&quot;text&quot; id=&quot;prodId&quot; size=&quot;5&quot;/&gt;\n        &lt;input type=&quot;button&quot; value=&quot;Search&quot; onclick=&quot;find();&quot;/&gt;\n        &lt;p id=&quot;product&quot;/&gt;\n    &lt;/div&gt;\n\n    &lt;script src=&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.0.3.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        var uri = &apos;api/products&apos;;\n\n        $(document).ready(function () {\n            //Send an AJAX request\n            $.getJSON(uri)\n                .done(function (data) {\n                    //On success,&apos;data&apos; contains a list of products.\n                    $.each(data, function (key, item) {\n                        //Add a list item for the product。\n                        $(&apos;&lt;li&gt;&apos;, { text: formatItem(item) }).appendTo($(&apos;#products&apos;));\n                    });\n                });\n        });\n\n\n        function formatItem(item) {\n            return item.Name + &apos;: $&apos; + item.Price;\n        }\n\n        function find() {\n            var id = $(&apos;#prodId&apos;).val();\n            $.getJSON(uri + &apos;/&apos; + id)\n                .done(function (data) {\n                    $(&apos;#product&apos;).text(formatItem(data));\n                })\n                .fail(function (jqXHR, textStatus, err) {\n                    $(&apos;#product&apos;).text(&apos;Error: &apos; + err);\n                });\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><blockquote>\n<p>结果如下所示</p>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ截图20171126121235.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171126121235.jpg\" alt></a></p>\n","text":"Copyright @ DocsASP.NETASP.NET Web API 微软的官方文档首先是新建ASP.NET api项目 然后是设计ModelProduct.csusing System;using System.Collections.Generic;using Sys","link":"","raw":null,"photos":[],"categories":[{"name":"ajax","slug":"ajax","count":4,"path":"api/categories/ajax.json"},{"name":"ASP.Net","slug":"ajax/ASP-Net","count":3,"path":"api/categories/ajax/ASP-Net.json"},{"name":"JS","slug":"ajax/ASP-Net/JS","count":1,"path":"api/categories/ajax/ASP-Net/JS.json"},{"name":"RestFul_API","slug":"ajax/ASP-Net/JS/RestFul-API","count":1,"path":"api/categories/ajax/ASP-Net/JS/RestFul-API.json"}],"tags":[{"name":"ajax","slug":"ajax","count":4,"path":"api/tags/ajax.json"},{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"RestFul_API","slug":"RestFul-API","count":2,"path":"api/tags/RestFul-API.json"},{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"javascript表单传送文件","slug":"javascrip-form-file","date":"2017-09-10T12:40:21.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/javascrip-form-file.json","excerpt":"","keywords":null,"cover":null,"content":"<p>专门把这次课给搞出来记一下笔记.. 在HTML中,唯一可以上传文件的就是</p>\n<pre><code>&lt;input type=&quot;file&quot;&gt;</code></pre><p>注意，当一个表单包含file时,表单的<em>enctype_必须是_multipart/form-data</em>,<em>method_必须指定为_post</em>,浏览器才能以正确编码并以_multipart/form-data_格式发送表单. Tip: enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。 出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径：</p>\n<pre><code>获取表单上传路径后结果总会是fakepath\n&lt;script&gt;\n$(function () {\n    var\n        fileInput = document.getElementById(&apos;test-file-upload&apos;),\n        filePath = document.getElementById(&apos;test-get-filename&apos;);\n    fileInput.addEventListener(&apos;change&apos;, function () {\n        filePath.innerText = fileInput.value;\n    });\n});\n&lt;/script&gt;\n\n&lt;form method=&quot;post&quot; action=&quot;http://localhost/test&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;p&gt;\n        &lt;input type=&quot;file&quot; id=&quot;test-file-upload&quot; name=&quot;test&quot;&gt;\n    &lt;/p&gt;\n    &lt;p&gt;待上传文件: &lt;span id=&quot;test-get-filename&quot; style=&quot;color:red&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/form&gt;</code></pre><p>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：</p>\n<pre><code>var f = document.getElementById(&apos;test-file-upload&apos;);\nvar filename = f.value; // &apos;C:\\fakepath\\test.png&apos;\nif (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) {\n    alert(&apos;Can only upload image file.&apos;);\n    return false;\n}</code></pre><h2><span id=\"file-api\">File API</span></h2><p>由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。 随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。 HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 下面的例子演示了如何读取用户选取的图片文件，并在一个 &lt; div&gt;中预览图像：</p>\n<pre><code>var\n    fileInput = document.getElementById(&apos;test-image-file&apos;),\n    info = document.getElementById(&apos;test-file-info&apos;),\n    preview = document.getElementById(&apos;test-image-preview&apos;);\n// 监听change事件:\nfileInput.addEventListener(&apos;change&apos;, function () {\n    // 清除背景图片:\n    preview.style.backgroundImage = &apos;&apos;;\n    // 检查文件是否选择:\n    if (!fileInput.value) {\n        info.innerHTML = &apos;没有选择文件&apos;;\n        return;\n    }\n    // 获取File引用:\n    var file = fileInput.files[0];\n    // 获取File信息:\n    info.innerHTML = &apos;文件: &apos; + file.name + &apos;&lt;br&gt;&apos; +\n                     &apos;大小: &apos; + file.size + &apos;&lt;br&gt;&apos; +\n                     &apos;修改: &apos; + file.lastModifiedDate;\n    if (file.type !== &apos;image/jpeg&apos; &amp;&amp; file.type !== &apos;image/png&apos; &amp;&amp; file.type !== &apos;image/gif&apos;) {\n        alert(&apos;不是有效的图片文件!&apos;);\n        return;\n    }\n    // 读取文件:\n    var reader = new FileReader();\n    reader.onload = function(e) {\n        var\n            data = e.target.result; // &apos;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&apos;            \n        preview.style.backgroundImage = &apos;url(&apos; + data + &apos;)&apos;;\n    };\n    // 以DataURL的形式读取文件:\n    reader.readAsDataURL(file);\n});</code></pre><p>上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk…(base64编码)…，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>\n<h2><span id=\"回调\">回调</span></h2><p>上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。 你可能会问，单线程模式执行的JavaScript，如何处理多任务？ 在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码： reader.readAsDataURL(file); 就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数： reader.onload = function(e) { // 当文件读取完成后，自动调用此函数: }; 当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>\n","text":"专门把这次课给搞出来记一下笔记.. 在HTML中,唯一可以上传文件的就是&lt;input type=&quot;file&quot;&gt;注意，当一个表单包含file时,表单的enctype_必须是_multipart/form-data,method_必须指定为_post,","link":"","raw":null,"photos":[],"categories":[{"name":"JS","slug":"JS","count":3,"path":"api/categories/JS.json"},{"name":"未分类","slug":"JS/未分类","count":1,"path":"api/categories/JS/未分类.json"}],"tags":[{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"JS事件","slug":"jsonmouseevent","date":"2017-09-13T04:57:42.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/jsonmouseevent.json","excerpt":"","keywords":null,"cover":null,"content":"<p>鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件仅作用在当前焦点的DOM上，通常是和。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当、或的内容改变时触发； submit：当 &lt; form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。</p>\n","text":"鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上","link":"","raw":null,"photos":[],"categories":[{"name":"JS","slug":"JS","count":3,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"Node.js-Koa-渲染","slug":"node-js-koa-render","date":"2017-10-02T07:30:56.000Z","updated":"2019-07-03T13:51:36.854Z","comments":true,"path":"api/articles/node-js-koa-render.json","excerpt":"","keywords":null,"cover":null,"content":"<p>模块依赖的是:</p>\n<pre><code>&quot;dependencies&quot;: {\n    &quot;nunjucks&quot;: &quot;2.4.2&quot;\n}</code></pre><p>nunjucks. 廖大说很像Jinja2,确实. 首先依然是目录结构,与其他无大差异. 然后是编写app.js中调用渲染的模块:</p>\n<pre><code>const nunjucks = require(&apos;nunjucks&apos;);\n\nfunction createEnv(path,opts){\n    var\n        autoescape=opts.autoescape===undefined?true:opts.autoescape,\n        noCache = opts.noCache || false,\n        watch = opts.watch || false,\n        throwOnUndefined = opts.throwOnUndefined || false,\n        env = new nunjucks.Environment(\n            new nunjucks.FileSystemLoader(&apos;views&apos;,{\n                noCache:noCache,\n                watch:watch,\n            }),{\n                autoescape: autoescape,\n                throwOnUndefined: throwOnUndefined\n            });\n    if(opts.filters){\n        for(var f in opts.filters){\n            env.addFilter(f,opts.filters[f]);\n        }\n    }\n    return env;\n}\n\nvar env=createEnv(&apos;views&apos;,{\n    watch:true,\n    filters:{\n        hex:function(n){\n            return &apos;0x&apos;+n.toString(16);\n        }\n    }\n});</code></pre><p>其中noCache是禁止缓冲,当程序发布时,这个必须是Cache,否则对性能的影响略大. 接下来就对模板html进行渲染了! 首先我们编写一个hello.html:</p>\n<pre><code> &lt;h1&gt;Hello { { name }}&lt;/h1&gt;\n&lt;!-- 循环输出名字 --&gt;\n&lt;body&gt;\n    &lt;h3&gt;Fruits List&lt;/h3&gt;\n    {% for f in fruits %}\n        <p>{ { f }}</p>\n        {% endfor %}\n&lt;/body&gt;</code></pre><p>对其中的 name 和 fruits(List)进行渲染: 代码位于app.js</p>\n<pre><code>var s=env.render(&apos;hello.html&apos;,{name:&apos;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&apos;,fruits:[123,456]});\nconsole.log(s);</code></pre><p>输出结果如下:</p>\n<pre><code>&lt;h1&gt;Hello &lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&lt;/h1&gt;\n&lt;!-- 循环输出名字 --&gt;\n&lt;body&gt;\n    &lt;h3&gt;Fruits List&lt;/h3&gt;\n\n    &lt;p&gt;123&lt;/p&gt;\n\n    &lt;p&gt;456&lt;/p&gt;\n\n&lt;/body&gt;</code></pre><p>可以看到,渲染成功.即简单的拼接字符串. 接下来我们进行网页模板页渲染: 首先我们写一个 base.html:</p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    {% block header %}<h3><span id=\"unnamed\">Unnamed</span></h3>{% endblock %}\n        {% block body %}<div>No body</div>{% endblock %}\n    {% block footer %}<div>copyright</div>{% endblock %}\n    \n    \n    \n\n可以看到确实很像jinja2~ 然后我们再写一个继承自base.html的 extend.html:\n\n    {% extends 'base.html' %}\n    \n    {% block header %}<h1><span id=\"header\">{ { header }}</span></h1>{% endblock %}\n\n{% block body %}<p>{ { body }}</p>{% endblock %}</code></pre><p>渲染:</p>\n<pre><code>console.log(env.render(&apos;extend.html&apos;,{\n    header: &apos;Hello&apos;,\n    body: &apos;bla bla bla...&apos;\n}));</code></pre><p>结果如下:</p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;p&gt;bla bla bla...&lt;/p&gt;\n    &lt;div&gt;copyright&lt;/div&gt;\n&lt;/body&gt;</code></pre><p>End</p>\n","text":"模块依赖的是:&quot;dependencies&quot;: {    &quot;nunjucks&quot;: &quot;2.4.2&quot;}nunjucks. 廖大说很像Jinja2,确实. 首先依然是目录结构,与其他无大差异. 然后是编写app.js中调用渲染的","link":"","raw":null,"photos":[],"categories":[{"name":"JS","slug":"JS","count":3,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"Python Flask 10 用户上传头像","slug":"python-flask-up-fil-to-app-2","date":"2017-10-18T03:54:20.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-up-fil-to-app-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B718.png","content":"<p>借助上节的基础==&gt; <a href=\"http://be-sunshine.cn/index.php/2017/10/17/python-flask-upfile/\" title=\"&lt;code&gt;点我啊!  Python Flask 上传文件&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啊! Python Flask 上传文件</code></a> 这节我们实现一下<code>修改用户头像</code>以及<code>默认头像</code>的功能. 截止目前的项目进度: <a href=\"https://github.com/834930269/Flask_Study/tree/master/flask-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%845-%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F\" title=\"&lt;code&gt;点我啊! Github:flask-大型网站架构5-新增上传头像&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啊! Github:flask-大型网站架构5-新增上传头像</code></a> 最终效果如图: <code>1.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获18.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B718.png\" alt></a> <code>2.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获19.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B719.png\" alt></a> <code>3.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获21.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B721.png\" alt></a> <code>4.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获22.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B722.png\" alt></a></p>\n<h1><span id=\"开始\">开始!</span></h1><h3><span id=\"1\">1:</span></h3><p>因为我们需要对每个用户<code>存下他的头像信息</code>. 这里我们选择<code>直接存储图片url</code>的形式进行存储. 所以我们需要对<code>model层</code>的<code>User</code>添加一个<code>gravatar</code>列,存储头像url. 主要代码如下:</p>\n<pre><code>class User(UserMixin,db.Model):\n    __tablename__ = &apos;users&apos;\n    gravatar = db.Column(db.String(200),default=&apos;/_uploads/photos/default.jpg&apos;)</code></pre><p>其中<code>gravatar</code>的默认值是<code>默认头像相对url</code>.</p>\n<h3><span id=\"2\">2:</span></h3><p>首先我们依然需要<code>先码出</code>上传头像界面的<code>表单(form)</code>. 先配置<code>所要上传的目标地址</code>变量<code>/config.py</code>:</p>\n<pre><code>import os\nUPLOADED_PHOTOS_DEST = os.path.abspath(os.path.join(os.getcwd(),&quot;app/static/Gravatar&quot;))</code></pre><p>我们需要对<code>上传文件</code>进行约束为图片格式,这里我们用一个<code>UploadSet</code>模块,编辑代码<code>/app/__init__.py</code>:</p>\n<pre><code>from flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\n\nphotos = UploadSet(&apos;photos&apos;,IMAGES)</code></pre><p>然后将创建好的<code>photo</code>对象加入已经创建好的<code>app</code>中:</p>\n<pre><code>configure_uploads(app,photos)\npatch_request_class(app)  </code></pre><p>然后编写<code>form表单</code>:</p>\n<pre><code>from flask_wtf.file import FileField, FileRequired, FileAllowed\nfrom flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\nfrom .. import photos\nfrom flask_wtf import FlaskForm\n\nclass UploadForm(FlaskForm):\n    photo = FileField(validators=[\n        FileAllowed(photos, u&apos;只能上传图片！&apos;), \n        FileRequired(u&apos;请选择一个头像吧！&apos;)])\n    submit = SubmitField(u&apos;确认上传&apos;,render_kw={&quot;class&quot;:&quot;btn btn-primary&quot;})</code></pre><p>其中<code>render_kw</code>是一个<code>dict</code>类型,作用是<code>渲染对应表单的css</code>. <code>FileAllowed</code>用来检测上传文件类型,不对的的话返回<code>第二个参数</code>. <code>FileRequired</code>和<code>Required</code>作用近似,即<code>非空判断</code>.</p>\n<h3><span id=\"3\">3:</span></h3><p>接下来我们就要开始编写<code>view层</code>了. 这里我们将编辑头像页面的<code>url</code>设为<code>/edit-gravatar</code> 所以我们需要码一个有<code>GET</code>和<code>POST</code>的视图函数.</p>\n<pre><code>from flask_login import  current_user\nfrom flask_login import login_user,login_required,logout_user\nfrom .forms import UploadForm\nfrom flask import render_template, session, redirect, url_for, current_app,abort,flash\nfrom .. import db,photos\n\n@main.route(&apos;/edit-gravatar&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\n@login_required\ndef edit_gravatar():\n    form = UploadForm()\n    if form.validate_on_submit():\n        filename = photos.save(form.photo.data)\n        file_url = photos.url(filename)\n        current_user.gravatar = file_url\n        db.session.add(current_user)\n        flash(&apos;修改成功!&apos;)\n        return redirect(url_for(&apos;.user&apos;,username=current_user.username,file_url=file_url))\n\n    return render_template(&apos;edit_gravatar.html&apos;,form=form,file_url=current_user.gravatar)</code></pre><p>注意我们所上传的头像文件<code>即使名字相同也不会覆盖掉之前的头像文件的</code>..(所以还是以二进制存到数据库中更好一点么).</p>\n<h3><span id=\"4\">4:</span></h3><p>接下来我们需要编写<code>前台界面</code>了: 首先,由于如果我们直接用<code>quick_form</code>创建表单的话,表单的<code>css</code>就不好改了.所以我们把每个表单分开放入<code>form type=file</code>中,并且通过<code>传参</code>或者<code>重叠覆盖</code>修改表单控件的<code>样式</code>. 其中,修改<code>input type=file</code>样式的通用方法是<code>将opacity设为0</code>,然后用一个<code>a</code>标签将<code>input和a组合</code>到一起,这样修改<code>a</code>的样式便相当于修改<code>input</code>的样式. 对应的几部分代码如下:</p>\n<pre><code>/*CSS*/\n.upload{\n    padding: 5px 10px;\n    height: 40px;\n    line-height: 30px;\n    position: relative;\n    border: 1px solid #999;\n    text-decoration: none;\n    text-align:center;\n    color: #fff;\n}\n.change{\n    position: absolute;\n    overflow: hidden;\n    right: 0;\n    top: 0;\n    opacity: 0;\n}\n\n\n&lt;a class=&quot;btn btn-success upload&quot; placeholder=&quot;上传头像&quot; &gt;\n    &lt;p id=&quot;show_gt&quot;&gt;选择您要上传的头像~&lt;/p&gt;\n    { { form.photo(class=&quot;change&quot;,placeholder=&quot;上传头像&quot;,onchange=&quot;c()&quot;) }}\n&lt;/a&gt;</code></pre><p>然后在<code>css</code>中修改<code>upload</code>样式即可. 其中<code>btn btn-xxx</code>是<code>bootstrap</code>样式. 但是到这里还需要考虑一个问题,就是当<code>选中图片以后,并不会显示到页面上,必选点击提交以后</code>才会修改,下次访问这个页面才会变成新图片. 所以我们需要一种方法使<code>选中图片的同时将图片显示在页面上</code>,并和之前的头像对比. 这里我们使用直接<code>通过JavaScript在本地显示</code>: 对应JS代码如下:</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function c () {\n        var gt=document.getElementById(&apos;show_gt&apos;);\n        gt.innerText = &apos;已选中图片~&apos;\n        var r= new FileReader();\n        f=document.getElementById(&apos;photo&apos;).files[0];\n        r.readAsDataURL(f);\n        r.onload=function  (e) {\n            document.getElementById(&apos;show&apos;).src=this.result;\n        };\n    }\n&lt;/script&gt;</code></pre><p>因为<code>FlaskForm</code>生成的表单的<code>id</code>和类中对应<code>表单实例的名字</code>是一样的,所以这里的<code>id</code>是photo. 获取<code>图片对象(object) f</code>. 把这个File对象传给FileReader对象的读取方法，就能读取文件了。 连接: <a href=\"http://blog.csdn.net/oscar999/article/details/37499743/\" title=\"&lt;code&gt;[JS进阶] HTML5 之文件操作(file)&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啦! [JS进阶] HTML5 之文件操作(file)</code></a> 最后的<code>r.result</code>即为对应图片的<code>二进制数据</code>. 然后就是修改一下排版即可:</p>\n<pre><code>&lt;!-- edit_gravatar.html --&gt;\n{% extends \"base.html\" %}\n{% import \"bootstrap/wtf.html\" as wtf %}\n{% block title %}编辑个人头像{% endblock %}\n    {% block page_content %}\n    <form method=\"POST\" enctype=\"multipart/form-data\">\n         { { form.hidden_tag() }}\n         <div class=\"page-header\"><h2><span id=\"展览板~\">展览板~</span></h2></div>\n         <a class=\"btn btn-success upload\" placeholder=\"上传头像\"><p id=\"show_gt\">选择您要上传的头像~</p>\n            { { form.photo(class=\"change\",placeholder=\"上传头像\",onchange=\"c()\") }}\n         </a><br>\n         {% for error in form.photo.errors %}\n             <span style=\"color: red;\">{ { error }}</span>\n         {% endfor %}\n         {% if file_url %}\n         <br><img src=\"{ { file_url }}\" width=\"256\" height=\"256\">\n         {% endif %}\n         <a class=\"btn btn-success\"><-之前 之后-></-之前></a>\n         <img src=\"{ { file_url }}\" id=\"show\" width=\"256\" height=\"256\"><br><br>\n         { { form.submit }}\n    </form>\n    <script type=\"text/javascript\">\n        function c () {\n            var gt=document.getElementById('show_gt');\n            gt.innerText = '已选中图片~'\n            var r= new FileReader();\n            f=document.getElementById('photo').files[0];\n            r.readAsDataURL(f);\n            r.onload=function  (e) {\n                document.getElementById('show').src=this.result;\n            };\n        }\n    </script>\n    {% endblock %}</code></pre><h3><span id=\"done\">Done</span></h3>","text":"借助上节的基础==&gt; 点我啊! Python Flask 上传文件 这节我们实现一下修改用户头像以及默认头像的功能. 截止目前的项目进度: 点我啊! Github:flask-大型网站架构5-新增上传头像 最终效果如图: 1.  [Figure]          { { ","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"JS","slug":"Flask/JS","count":1,"path":"api/categories/Flask/JS.json"},{"name":"Python","slug":"Flask/JS/Python","count":1,"path":"api/categories/Flask/JS/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]}]}