{"name":"Python","slug":"Python","count":65,"postlist":[{"title":"2017/10/24 更新了部分布局","slug":"20171024-as","date":"2017-10-24T04:27:00.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/20171024-as.json","excerpt":"","keywords":null,"cover":null,"content":"<p>基于Flask+Python+Bootstrap的个人小站. <a href=\"http://wolf.be-sunshine.cn\" title=\"wolf.be-sunshine.cn\" target=\"_blank\" rel=\"noopener\"><code>wolf.be-sunshine.cn</code></a> Stupid is stupid does.</p>\n","text":"基于Flask+Python+Bootstrap的个人小站. wolf.be-sunshine.cn Stupid is stupid does.","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"关于使用ajax(JavaScript)+Flask(Python)+Canvas 上传画布(Canvas)图片并存储","slug":"ajax-upload-canvas-to-server","date":"2017-10-26T14:31:36.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/ajax-upload-canvas-to-server.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171027191006.png","content":"<p>因为想要做一个todo list的记事本app.其中有一个模块是使用Canvas做涂鸦. <code>其中有两个操作</code>: <code>1.</code>然后上传canvas的画布图片并保存到本地. <code>2.</code>将对应画布的url传给画布,并绘制出来. 首先,Canvas画板的css和js是在Github上淘的一个,链接如下: <code>https://github.com/youknowznm/paint</code><a href=\"https://github.com/youknowznm/paint\" title=\"&lt;code&gt;点击这里&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点击这里</code></a> 首先是<code>index.html</code>的代码,大部分是样式,所以不用太在意,只需要注意<code>canvas的id</code>即可.</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;title&gt;paint&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./paint.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;canvas-wrapper&quot;&gt;\n        &lt;ul class=&quot;doodle-colors&quot;&gt;\n            &lt;li data-color=&quot;black&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;green&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;yellow&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;red&quot;&gt;&lt;/li&gt;\n            &lt;li data-color=&quot;white&quot;&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;ul class=&quot;doodle-controllers&quot;&gt;\n            &lt;li class=&quot;undo&quot;&gt;&lt;/li&gt;\n            &lt;li class=&quot;redo&quot;&gt;&lt;/li&gt;\n            &lt;li class=&quot;clear&quot;&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;canvas id=&quot;cv&quot; class=&quot;doodle-content&quot; width=&apos;500&apos; height=&apos;500&apos;&gt;&lt;/canvas&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./paint.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        window.onload = function() {\n            let canvasEle = $(&apos;.doodle-content&apos;)[0];\n            let colorsEle = $(&apos;.doodle-colors&apos;)[0];\n            let controllersEle = $(&apos;.doodle-controllers&apos;)[0];\n            initCanvas(canvasEle, colorsEle, controllersEle, null);\n        }\n        function oc(){\n            let cav=document.getElementById(&apos;cv&apos;);\n            console.log(cav);\n            let data=cav.toDataURL();\n            console.log(data);\n            let img = document.createElement(&apos;img&apos;);\n            img.src = data;\n            document.body.appendChild(img);\n            let image=cav.toDataURL(&apos;image/jpeg&apos;);\n            window.location=image;\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>注意,我在代码中添加了一个<code>JavaScript函数oc()</code>:</p>\n<pre><code>function oc(){\n    let cav=document.getElementById(&apos;cv&apos;);\n    console.log(cav);\n    let data=cav.toDataURL();\n    console.log(data);\n    let img = document.createElement(&apos;img&apos;);\n    img.src = data;\n    document.body.appendChild(img);\n    let image=cav.toDataURL(&apos;image/jpeg&apos;);\n    window.location=image;\n}</code></pre><p>其中<code>cav.toDataURL(&#39;type&#39;)</code>即可以实现提取当前Canvas中的图片流信息. 然后我们尝试向后台发送Canvas图片的<code>用base64加密的数据</code>. 使用一个<code>Button</code>来发送post信息. 添加<code>&lt;button id=&quot;btn&quot; &gt;123&lt;/button&gt;</code> 为<code>button</code>添加click事件:</p>\n<pre><code>$(function(){\n    $(&apos;#btn&apos;).click(function(){\n        let cav=document.getElementById(&apos;cv&apos;);\n        let image=cav.toDataURL(&apos;image/jpeg&apos;);\n        $.post(&apos;/upload&apos;,{&apos;data&apos;:image,&apos;idx&apos;:223},function(result){\n            let canvasEle = $(&apos;.doodle-content&apos;)[0];\n            let colorsEle = $(&apos;.doodle-colors&apos;)[0];\n            let controllersEle = $(&apos;.doodle-controllers&apos;)[0];\n            initCanvas(canvasEle, colorsEle, controllersEle, result);\n        })\n    })\n})</code></pre><p>其中表单中<code>data</code>为图片加密信息,<code>idx</code>为假想当前记事本的id. 实践.发送post内容如下: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ截图20171027191006.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171027191006.png\" alt></a> 注意这里只是介绍了前台代码,让大家看一下发送的表单数据,如果没编写后台接受<code>Post</code>的Route的话是会返回<code>404</code>的. 然后在后台的View视图中添加相应的Route:</p>\n<pre><code>from . import main\nfrom flask import Flask,render_template\nfrom flask import make_response,render_template, session, redirect, url_for, current_app,abort,flash,request\nimport json,os,base64  \n\n@main.route(&apos;/upload&apos;,methods=[&apos;POST&apos;])\ndef upLoad():\n    &quot;&quot;&quot;\n    disturbing by jq\n    this method cannot work\n    &quot;&quot;&quot;\n    files=request.values.get(&apos;data&apos;)\n    f=request.form[&apos;data&apos;][23:]\n    ind=request.form[&apos;idx&apos;]\n    imgdata=base64.b64decode(f)\n    file=open(&apos;app/static/&apos;+ind+&apos;.jpg&apos;,&apos;wb&apos;)\n    file.write(imgdata)\n    file.close()\n    return &apos;/static/&apos;+ind+&apos;.jpg&apos;\n\n@main.route(&apos;/show&apos;,methods=[&apos;GET&apos;])\ndef show():\n    return render_template(&apos;index.html&apos;)</code></pre><p>其中用<code>request.values.get(&#39;key&#39;)</code>来获取对应表单的数据.然后用base64算法对获取到的数据进行解码.之后创建一个空文件<code>idx.jpg</code>,将解码后的数据写进去.得到的即为图片. 我们可以看到<code>获取到的data的头有一段非编码部分</code>:</p>\n<pre><code>data:image/jpeg;base64,/9j/4A</code></pre><p>所以我们需要将前面不属于编码的部分去掉. 后台处理代码中:</p>\n<pre><code>f=request.form[&apos;data&apos;][23:]</code></pre><p>即完成了这一任务. 注意在JavaScript用这种方式获取Canvas的时候,开启管道时<code>背景如果是透明</code>,它会在转换成base64时自动补成<code>#fff</code>(纯黑色). 所以我们需要在创建Canvas时将背景染成纯白色<code>#000</code>. 我们在Paint.js中初始化context中加入下面两句:</p>\n<pre><code>// 初始化 context\nvar ctx = canvasEle.getContext(&apos;2d&apos;);\nctx.fillStyle=&quot;#fff&quot;;\nctx.fillRect(0, 0, 500, 500);</code></pre><p>OK,我们获取图片后即为原图了! 至于如何在Canvas中将图片画出来.直接用<code>paint.js</code>中的 <code>initCanvas(canvasEle, colorsEle, controllersEle, result);</code> 即可.result为对应图片的地址<code>一般是发布网站的相对地址</code>. 上传结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ截图20171027193747.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171027193747.png\" alt></a> 最后一个问题: <code>当我们试图读取图片的url时,浏览器多半会返回对应url的缓存图片文件,如何解决这个问题呢?</code> 我们只需要在<code>URL</code>中随便加入一个参数即可,保证每次的url不相同即可,比如:</p>\n<pre><code>URL=URL+&apos;?t=&apos;+Math.random();</code></pre><p>OK,日志本的第一个难题攻关!</p>\n","text":"因为想要做一个todo list的记事本app.其中有一个模块是使用Canvas做涂鸦. 其中有两个操作: 1.然后上传canvas的画布图片并保存到本地. 2.将对应画布的url传给画布,并绘制出来. 首先,Canvas画板的css和js是在Github上淘的一个,链接如下: ","link":"","raw":null,"photos":[],"categories":[{"name":"ajax","slug":"ajax","count":4,"path":"api/categories/ajax.json"},{"name":"Flask","slug":"ajax/Flask","count":1,"path":"api/categories/ajax/Flask.json"},{"name":"Python","slug":"ajax/Flask/Python","count":1,"path":"api/categories/ajax/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"ajax","slug":"ajax","count":4,"path":"api/tags/ajax.json"}]},{"title":"Flask 源码解读(一)","slug":"flask-sc1","date":"2017-11-04T08:53:02.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/flask-sc1.json","excerpt":"","keywords":null,"cover":null,"content":"<p>其中<code>Flask</code>用于处理Web应用的路由,request,response等模块的核心是<code>werkzeug</code>. <code>werkzeug</code> 提供了 python web WSGI 开发相关的功能：</p>\n<ul>\n<li>路由处理：怎么根据请求中的 url 找到它的处理函数</li>\n<li>request 和 response 封装：可以更好地读取 request 的数据，也容易生成响应</li>\n<li>一个自带的 WSGI server，可以用来测试环境运行自己的应用</li>\n</ul>\n<p>比如，我们可以使用 <code>werkzeug</code> 编写一个简单的 hello world 的 WSGI app：</p>\n<pre><code>from werkzeug.wrappers import Request,Response\n\ndef application(environ,start_response):\n    request = Request(environ)\n    text = &apos;Hello %s&apos; % request.args.get(&apos;name&apos;,&apos;World&apos;)\n    response = Response(text,mimetype=&apos;text/plain&apos;)\n    return response(environ,start_response)</code></pre><p>除了和 web WSGI 相关的功能，werkzeug 还实现了很多非常有用的数据结构和函数。比如用来处理一个 key 对应多个值的 MultiDict，不支持修改的字典 ImmutableDict ，可以缓存类属性的 cache_property 等等。</p>\n","text":"其中Flask用于处理Web应用的路由,request,response等模块的核心是werkzeug. werkzeug 提供了 python web WSGI 开发相关的功能：路由处理：怎么根据请求中的 url 找到它的处理函数request 和 response 封装：可以","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"flask源码学习","slug":"Flask/flask源码学习","count":1,"path":"api/categories/Flask/flask源码学习.json"},{"name":"Python","slug":"Flask/flask源码学习/Python","count":1,"path":"api/categories/Flask/flask源码学习/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Flask源码学习","slug":"Flask源码学习","count":1,"path":"api/tags/Flask源码学习.json"}]},{"title":"第一个开源到Github上的Web App cm-Todo","slug":"github-web-app-cm-todo","date":"2017-10-29T05:29:21.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/github-web-app-cm-todo.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"cm-Todo\"><a href=\"#cm-Todo\" class=\"headerlink\" title=\"cm-Todo\"></a>cm-Todo</h1><p>这是一款基于-Flask-Canvas-Mysql-Python3-Bootstrap-的TODO/记事本/交流 的Web App应用 Github地址: <code>点击=&gt;</code> <a href=\"https://github.com/834930269/cm-Todo\" title=\"https://github.com/834930269/cm-Todo\" target=\"_blank\" rel=\"noopener\">https://github.com/834930269/cm-Todo</a> 其中记事本框的CSS和部分JS来自于 <code>点击=&gt;</code> <a href=\"https://github.com/youknowznm/vue-memo\" title=\"youknowznm-vue-memo\" target=\"_blank\" rel=\"noopener\"><code>youknowznm-vue-memo</code></a> 本地使用方法: 先在<code>config.py</code>中的:</p>\n<blockquote>\n<p>DATABASE_USERNAME=<br>DATABASE_PASSWORD=</p>\n</blockquote>\n<p>中输入你Mysql数据库的用户名和密码,并自行创建一个名为notebook的数据库.<br>(这里数据库自行选择,不同数据库的接口配置在<code>config.py</code>中进行)  </p>\n<p>然后在当前目录下的命令行中执行以下命令:  </p>\n<p>python manage.py db init<br>python manage.py db migrate -m ‘first’ python manage.py db upgrade 最后在命令行中执行<code>manage.py</code>并通过<code>localhost:5000</code>进行访问即可. python manage.py runserver 注意,是python3.*,如果您是Linux用户,可能会需要修改以下Mysql数据库的所有编码方式为utf-8. 该App可以轻松集成到到您的Flask Web App中,至于如何集成,这里不再赘述. <code>Demo</code>: <code>点击</code>=&gt; <a href=\"http://be-sunshine.cn:5100/notebooks\" title=\"地平线上的一匹狼-日志\" target=\"_blank\" rel=\"noopener\"><code>地平线上的一匹狼-日志</code></a></p>\n","text":"cm-Todo这是一款基于-Flask-Canvas-Mysql-Python3-Bootstrap-的TODO/记事本/交流 的Web App应用 Github地址: 点击=&gt; https://github.com/834930269/cm-Todo 其中记事本框的CSS","link":"","raw":null,"photos":[],"categories":[{"name":"Bootstrap","slug":"Bootstrap","count":1,"path":"api/categories/Bootstrap.json"},{"name":"Flask","slug":"Bootstrap/Flask","count":1,"path":"api/categories/Bootstrap/Flask.json"},{"name":"Github","slug":"Bootstrap/Flask/Github","count":1,"path":"api/categories/Bootstrap/Flask/Github.json"},{"name":"Mysql","slug":"Bootstrap/Flask/Github/Mysql","count":1,"path":"api/categories/Bootstrap/Flask/Github/Mysql.json"},{"name":"Python","slug":"Bootstrap/Flask/Github/Mysql/Python","count":1,"path":"api/categories/Bootstrap/Flask/Github/Mysql/Python.json"},{"name":"SQL","slug":"Bootstrap/Flask/Github/Mysql/Python/SQL","count":1,"path":"api/categories/Bootstrap/Flask/Github/Mysql/Python/SQL.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Github","slug":"Github","count":2,"path":"api/tags/Github.json"},{"name":"Bootstrap","slug":"Bootstrap","count":1,"path":"api/tags/Bootstrap.json"},{"name":"Mysql","slug":"Mysql","count":2,"path":"api/tags/Mysql.json"},{"name":"SQL","slug":"SQL","count":2,"path":"api/tags/SQL.json"}]},{"title":"股票数据定向爬虫","slug":"gupiaodingxiangpachong","date":"2017-09-07T12:05:07.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/gupiaodingxiangpachong.json","excerpt":"","keywords":null,"cover":null,"content":"<p>累了…直接撩代码</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport traceback\nimport re\n\ndef getHTMLText(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef getStockList(lst,stockURL):\n    html=getHTMLText(stockURL)\n    soup=BeautifulSoup(html,&apos;html.parser&apos;)\n    a=soup.find_all(&apos;a&apos;)\n    for i in a:\n        try:\n            href=i.attrs[&apos;href&apos;]\n            lst.append(re.findall(r&apos;[s][hz]\\d{6}&apos;,href)[0])\n        except:\n            continue\n\ndef getStockInfo(lst,stockURL,fpath):\n    for stock in lst:\n        url=stockURL+stock+&quot;.html&quot;\n        html=getHTMLText(url)\n        try:\n            if html==&quot;&quot;:\n                continue\n            infoDict={}\n            soup=BeautifulSoup(html,&apos;html.parser&apos;)\n            stockInfo=soup.find(&apos;div&apos;,attrs={&apos;class&apos;:&apos;stock-bets&apos;})\n\n            name=stockInfo.find_all(attrs={&apos;class&apos;:&apos;bets-name&apos;})[0]\n            infoDict.update({&apos;股票名称&apos;:name.text.split()[0]})\n            keyList=stockInfo.find_all(&apos;dt&apos;)\n            valueList=stockInfo.find_all(&apos;dd&apos;)\n            for i in range(len(keyList)):\n                key=keyList[i].text\n                val=valueList[i].text\n                infoDict[key]=val\n\n            with open(fpath,&apos;a&apos;,encoding=&apos;utf-8&apos;) as f:\n                f.write(str(infoDict)+&apos;\\n&apos;)\n        except:\n            traceback.print_exc()\n            continue\n\nif __name__==&apos;__main__&apos;:\n    stock_list_url = &apos;http://quote.eastmoney.com/stocklist.html&apos;\n    stock_info_url = &apos;https://gupiao.baidu.com/stock/&apos;\n    output_file = &apos;E:\\学习相关\\廖雪峰\\python_study\\库\\第三章\\BaiduStockInfo.txt&apos;\n    slist=[]\n    getStockList(slist,stock_list_url)\n    getStockInfo(slist,stock_info_url,output_file)</code></pre><p>结果(超慢的得得得多多多多多多多,还没爬完…不过应该是解析全文默认编码的问题): 2017-09-07 20:08:30 星期四 :earth_asia:<a href=\"https://github.com/834930269/python_study/blob/master/%E5%BA%93/%E7%AC%AC%E4%B8%89%E7%AB%A0/BaiduStockInfo.txt\" title=\"github: 爬取结果.txt\" target=\"_blank\" rel=\"noopener\">github: 爬取结果.txt</a></p>\n","text":"累了…直接撩代码import requestsfrom bs4 import BeautifulSoupimport tracebackimport redef getHTMLText(url):    try:        r=requests.get(url)       ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"未分类","slug":"Python/未分类","count":3,"path":"api/categories/Python/未分类.json"},{"name":"爬虫","slug":"Python/未分类/爬虫","count":2,"path":"api/categories/Python/未分类/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"Pygame constants.py","slug":"pygame-constants-py","date":"2018-01-09T08:46:01.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/pygame-constants-py.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"一些按键相关-以及一些屏幕处理的常量\"><a href=\"#一些按键相关-以及一些屏幕处理的常量\" class=\"headerlink\" title=\"一些按键相关,以及一些屏幕处理的常量\"></a>一些按键相关,以及一些屏幕处理的常量</h1><pre><code># encoding: utf-8\n# module pygame.constants\n# from D:\\Software\\AnAconda\\lib\\site-packages\\pygame\\constants.cp36-win_amd64.pyd\n# by generator 1.145\n&quot;&quot;&quot; Constants defined by SDL and needed in Pygame. &quot;&quot;&quot;\n# no imports\n\n# Variables with simple values\n\nACTIVEEVENT = 1\n\nANYFORMAT = 268435456\n\nASYNCBLIT = 4\n\nAUDIO_S16 = 32784\nAUDIO_S16LSB = 32784\nAUDIO_S16MSB = 36880\nAUDIO_S16SYS = 32784\nAUDIO_S8 = 32776\nAUDIO_U16 = 16\nAUDIO_U16LSB = 16\nAUDIO_U16MSB = 4112\nAUDIO_U16SYS = 16\nAUDIO_U8 = 8\n\nBIG_ENDIAN = 4321\n\nBLEND_ADD = 1\nBLEND_MAX = 5\nBLEND_MIN = 4\nBLEND_MULT = 3\nBLEND_PREMULTIPLIED = 17\n\nBLEND_RGBA_ADD = 6\nBLEND_RGBA_MAX = 16\nBLEND_RGBA_MIN = 9\nBLEND_RGBA_MULT = 8\nBLEND_RGBA_SUB = 7\n\nBLEND_RGB_ADD = 1\nBLEND_RGB_MAX = 5\nBLEND_RGB_MIN = 4\nBLEND_RGB_MULT = 3\nBLEND_RGB_SUB = 2\n\nBLEND_SUB = 2\n\nBUTTON_X1 = 6\nBUTTON_X2 = 7\n\nDOUBLEBUF = 1073741824\n\nFULLSCREEN = -2147483648\n\nGL_ACCELERATED_VISUAL = 15\n\nGL_ACCUM_ALPHA_SIZE = 11\n\nGL_ACCUM_BLUE_SIZE = 10\n\nGL_ACCUM_GREEN_SIZE = 9\n\nGL_ACCUM_RED_SIZE = 8\n\nGL_ALPHA_SIZE = 3\n\nGL_BLUE_SIZE = 2\n\nGL_BUFFER_SIZE = 4\n\nGL_DEPTH_SIZE = 6\n\nGL_DOUBLEBUFFER = 5\n\nGL_GREEN_SIZE = 1\n\nGL_MULTISAMPLEBUFFERS = 13\nGL_MULTISAMPLESAMPLES = 14\n\nGL_RED_SIZE = 0\n\nGL_STENCIL_SIZE = 7\n\nGL_STEREO = 12\n\nGL_SWAP_CONTROL = 16\n\nHAT_CENTERED = 0\nHAT_DOWN = 4\nHAT_LEFT = 8\nHAT_LEFTDOWN = 12\nHAT_LEFTUP = 9\nHAT_RIGHT = 2\nHAT_RIGHTDOWN = 6\nHAT_RIGHTUP = 3\nHAT_UP = 1\n\nHWACCEL = 256\nHWPALETTE = 536870912\nHWSURFACE = 1\n\nIYUV_OVERLAY = 1448433993\n\nJOYAXISMOTION = 7\nJOYBALLMOTION = 8\nJOYBUTTONDOWN = 10\nJOYBUTTONUP = 11\nJOYHATMOTION = 9\n\nKEYDOWN = 2\nKEYUP = 3\n\nKMOD_ALT = 768\nKMOD_CAPS = 8192\nKMOD_CTRL = 192\nKMOD_LALT = 256\nKMOD_LCTRL = 64\nKMOD_LMETA = 1024\nKMOD_LSHIFT = 1\nKMOD_META = 3072\nKMOD_MODE = 16384\nKMOD_NONE = 0\nKMOD_NUM = 4096\nKMOD_RALT = 512\nKMOD_RCTRL = 128\nKMOD_RMETA = 2048\nKMOD_RSHIFT = 2\nKMOD_SHIFT = 3\n\nK_0 = 48\nK_1 = 49\nK_2 = 50\nK_3 = 51\nK_4 = 52\nK_5 = 53\nK_6 = 54\nK_7 = 55\nK_8 = 56\nK_9 = 57\nK_a = 97\nK_AMPERSAND = 38\nK_ASTERISK = 42\nK_AT = 64\nK_b = 98\nK_BACKQUOTE = 96\nK_BACKSLASH = 92\nK_BACKSPACE = 8\nK_BREAK = 318\nK_c = 99\nK_CAPSLOCK = 301\nK_CARET = 94\nK_CLEAR = 12\nK_COLON = 58\nK_COMMA = 44\nK_d = 100\nK_DELETE = 127\nK_DOLLAR = 36\nK_DOWN = 274\nK_e = 101\nK_END = 279\nK_EQUALS = 61\nK_ESCAPE = 27\nK_EURO = 321\nK_EXCLAIM = 33\nK_f = 102\nK_F1 = 282\nK_F10 = 291\nK_F11 = 292\nK_F12 = 293\nK_F13 = 294\nK_F14 = 295\nK_F15 = 296\nK_F2 = 283\nK_F3 = 284\nK_F4 = 285\nK_F5 = 286\nK_F6 = 287\nK_F7 = 288\nK_F8 = 289\nK_F9 = 290\nK_FIRST = 0\nK_g = 103\nK_GREATER = 62\nK_h = 104\nK_HASH = 35\nK_HELP = 315\nK_HOME = 278\nK_i = 105\nK_INSERT = 277\nK_j = 106\nK_k = 107\nK_KP0 = 256\nK_KP1 = 257\nK_KP2 = 258\nK_KP3 = 259\nK_KP4 = 260\nK_KP5 = 261\nK_KP6 = 262\nK_KP7 = 263\nK_KP8 = 264\nK_KP9 = 265\n\nK_KP_DIVIDE = 267\nK_KP_ENTER = 271\nK_KP_EQUALS = 272\nK_KP_MINUS = 269\nK_KP_MULTIPLY = 268\nK_KP_PERIOD = 266\nK_KP_PLUS = 270\n\nK_l = 108\nK_LALT = 308\nK_LAST = 323\nK_LCTRL = 306\nK_LEFT = 276\nK_LEFTBRACKET = 91\nK_LEFTPAREN = 40\nK_LESS = 60\nK_LMETA = 310\nK_LSHIFT = 304\nK_LSUPER = 311\nK_m = 109\nK_MENU = 319\nK_MINUS = 45\nK_MODE = 313\nK_n = 110\nK_NUMLOCK = 300\nK_o = 111\nK_p = 112\nK_PAGEDOWN = 281\nK_PAGEUP = 280\nK_PAUSE = 19\nK_PERIOD = 46\nK_PLUS = 43\nK_POWER = 320\nK_PRINT = 316\nK_q = 113\nK_QUESTION = 63\nK_QUOTE = 39\nK_QUOTEDBL = 34\nK_r = 114\nK_RALT = 307\nK_RCTRL = 305\nK_RETURN = 13\nK_RIGHT = 275\nK_RIGHTBRACKET = 93\nK_RIGHTPAREN = 41\nK_RMETA = 309\nK_RSHIFT = 303\nK_RSUPER = 312\nK_s = 115\nK_SCROLLOCK = 302\nK_SEMICOLON = 59\nK_SLASH = 47\nK_SPACE = 32\nK_SYSREQ = 317\nK_t = 116\nK_TAB = 9\nK_u = 117\nK_UNDERSCORE = 95\nK_UNKNOWN = 0\nK_UP = 273\nK_v = 118\nK_w = 119\nK_x = 120\nK_y = 121\nK_z = 122\n\nLIL_ENDIAN = 1234\n\nMOUSEBUTTONDOWN = 5\nMOUSEBUTTONUP = 6\nMOUSEMOTION = 4\n\nNOEVENT = 0\nNOFRAME = 32\n\nNUMEVENTS = 32\n\nOPENGL = 2\nOPENGLBLIT = 10\n\nPREALLOC = 16777216\n\nQUIT = 12\n\nRESIZABLE = 16\n\nRLEACCEL = 16384\nRLEACCELOK = 8192\n\nSCRAP_BMP = &apos;image/bmp&apos;\nSCRAP_CLIPBOARD = 0\nSCRAP_PBM = &apos;image/pbm&apos;\nSCRAP_PPM = &apos;image/ppm&apos;\nSCRAP_SELECTION = 1\nSCRAP_TEXT = &apos;text/plain&apos;\n\nSRCALPHA = 65536\nSRCCOLORKEY = 4096\n\nSWSURFACE = 0\n\nSYSWMEVENT = 13\n\nTIMER_RESOLUTION = 10\n\nUSEREVENT = 24\n\nUSEREVENT_DROPFILE = 4096\n\nUYVY_OVERLAY = 1498831189\n\nVIDEOEXPOSE = 17\nVIDEORESIZE = 16\n\nYUY2_OVERLAY = 844715353\n\nYV12_OVERLAY = 842094169\n\nYVYU_OVERLAY = 1431918169\n\n# no functions\n# no classes\n# variables with complex values\n\n__loader__ = None # (!) real value is &apos;&apos;\n\n__spec__ = None # (!) real value is &apos;&apos;</code></pre>","text":"一些按键相关,以及一些屏幕处理的常量# encoding: utf-8# module pygame.constants# from D:\\Software\\AnAconda\\lib\\site-packages\\pygame\\constants.cp36-win_amd64.py","link":"","raw":null,"photos":[],"categories":[{"name":"pygame","slug":"pygame","count":3,"path":"api/categories/pygame.json"},{"name":"Python","slug":"pygame/Python","count":3,"path":"api/categories/pygame/Python.json"},{"name":"游戏制作","slug":"pygame/Python/游戏制作","count":3,"path":"api/categories/pygame/Python/游戏制作.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"游戏制作","slug":"游戏制作","count":4,"path":"api/tags/游戏制作.json"},{"name":"pygame","slug":"pygame","count":3,"path":"api/tags/pygame.json"}]},{"title":"pygame sprite","slug":"pygame-sprite","date":"2017-12-30T09:20:40.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/pygame-sprite.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/12/mdm.png","content":"<p>自定义Sprite类: 让嗷大喵动起来! <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/12/mdm.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/12/mdm.png\" alt></a> 以上图片叫做帧图,背景为空,和二维数组一样的用法. 这个帧图的行为4,列为1. 对网上别人自定义的MySprite类做了修改,使其变成列行同时循环. 学习项目地址: <a href=\"https://github.com/834930269/Pygame-Learn/tree/master/second\" title=\"pygame-learn-sprite\" target=\"_blank\" rel=\"noopener\">pygame-learn-sprite</a> <code>class MySprite</code></p>\n<pre><code>class MySprite(pygame.sprite.Sprite):\n    def __init__(self,target):\n        pygame.sprite.Sprite.__init__(self)\n        self.target_surface = target\n        self.image = None\n        self.master_image = None\n        self.rect = None\n        self.topleft = 0,0\n        self.frame = 0\n        self.old_frame = -1\n        self.frame_width = 1\n        self.frame_height = 1\n        self.first_frame = 0\n        self.last_frame = 0\n        self.columns = 1\n        self.last_time = 0\n        self.row = 1\n\n    # filename 帧图宽度,帧图高度,帧图行,帧图列\n    def load(self,filename,width,height,columns,row):\n        self.master_image = pygame.image.load(filename).convert_alpha()\n        self.frame_width = width\n        self.frame_height = height\n        self.rect = 0,0,width,height\n        self.columns = columns\n        self.row = row\n        rect = self.master_image.get_rect()\n        self.last_frame = (rect.width // width)*(rect.height // height) - 1\n\n    def update(self,current_time,rate=60):\n        if current_time &gt; self.last_time +rate:\n            self.frame += 1\n            if self.frame &gt; self.last_frame:\n                self.frame = self.first_frame\n            self.last_frame = current_time\n\n        if self.frame != self.old_frame:\n            frame_x = (self.frame % self.columns) * self.frame_width\n            #添加了row以后每次计算对row取余即可计算出当前列数\n            frame_y = (self.frame // self.columns) % self.row * self.frame_height\n            #如果把frame_y置为0,则表示始终都是在位图的第一行\n            # 多行的话,可以通过frame_y来解决,但是要注意,y=0则返回\n            rect = (frame_x, frame_y, self.frame_width, self.frame_height)\n            self.image = self.master_image.subsurface(rect)\n            self.old_frame = self.frame</code></pre><p>让嗷大喵动起来吧!!</p>\n<pre><code>import pygame\nfrom pygame import *\n\nclass MySprite(pygame.sprite.Sprite):\n    def __init__(self,target):\n        pygame.sprite.Sprite.__init__(self)\n        self.target_surface = target\n        self.image = None\n        self.master_image = None\n        self.rect = None\n        self.topleft = 0,0\n        self.frame = 0\n        self.old_frame = -1\n        self.frame_width = 1\n        self.frame_height = 1\n        self.first_frame = 0\n        self.last_frame = 0\n        self.columns = 1\n        self.last_time = 0\n        self.row = 1\n\n    # filename 帧图宽度,帧图高度,帧图行,帧图列\n    def load(self,filename,width,height,columns,row):\n        self.master_image = pygame.image.load(filename).convert_alpha()\n        self.frame_width = width\n        self.frame_height = height\n        self.rect = 0,0,width,height\n        self.columns = columns\n        self.row = row\n        rect = self.master_image.get_rect()\n        self.last_frame = (rect.width // width)*(rect.height // height) - 1\n\n    def update(self,current_time,rate=60):\n        if current_time &gt; self.last_time +rate:\n            self.frame += 1\n            if self.frame &gt; self.last_frame:\n                self.frame = self.first_frame\n            self.last_frame = current_time\n\n        if self.frame != self.old_frame:\n            frame_x = (self.frame % self.columns) * self.frame_width\n            #添加了row以后每次计算对row取余即可计算出当前列数\n            frame_y = (self.frame // self.columns) % self.row * self.frame_height\n            #如果把frame_y置为0,则表示始终都是在位图的第一行\n            # 多行的话,可以通过frame_y来解决,但是要注意,y=0则返回\n            rect = (frame_x, frame_y, self.frame_width, self.frame_height)\n            self.image = self.master_image.subsurface(rect)\n            self.old_frame = self.frame\n\npygame.init()\nscreen = pygame.display.set_mode((800,600),0,32)\npygame.display.set_caption(&quot;精灵测试&quot;)\nfont = pygame.font.Font(None,18)\nframerate = pygame.time.Clock()\n\ncat = MySprite(screen)\ncat.load(&quot;mdm.png&quot;,100,100,4,1)\ngroup = pygame.sprite.Group()\ngroup.add(cat)\n\nwhile True:\n    framerate.tick(100)\n    ticks = pygame.time.get_ticks()\n\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            exit()\n    key = pygame.key.get_pressed()\n    if key[pygame.K_ESCAPE]:\n        exit()\n\n    screen.fill((0,0,100))\n\n    group.update(ticks)\n    group.draw(screen)\n    pygame.display.update()</code></pre>","text":"自定义Sprite类: 让嗷大喵动起来!  [Figure]  以上图片叫做帧图,背景为空,和二维数组一样的用法. 这个帧图的行为4,列为1. 对网上别人自定义的MySprite类做了修改,使其变成列行同时循环. 学习项目地址: pygame-learn-sprite class","link":"","raw":null,"photos":[],"categories":[{"name":"pygame","slug":"pygame","count":3,"path":"api/categories/pygame.json"},{"name":"Python","slug":"pygame/Python","count":3,"path":"api/categories/pygame/Python.json"},{"name":"游戏制作","slug":"pygame/Python/游戏制作","count":3,"path":"api/categories/pygame/Python/游戏制作.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"游戏制作","slug":"游戏制作","count":4,"path":"api/tags/游戏制作.json"},{"name":"pygame","slug":"pygame","count":3,"path":"api/tags/pygame.json"}]},{"title":"Python 爬虫 BeautifulSoup库基本操作","slug":"python-beautifulsoup","date":"2017-08-30T03:53:22.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/python-beautifulsoup.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Code:</p>\n<pre><code>import requests\nr=requests.get(&apos;http://python123.io/ws/demo.html&apos;)\n#print(r.text)\ndemo=r.text\nfrom bs4 import BeautifulSoup#后面的是类\nsoup=BeautifulSoup(demo,&apos;html.parser&apos;)#第一个参宿是信息,解释器html.parse\n#print(soup.prettify())\n1#BeautifulSoup库是解析、遍历、维护、&quot;标签树&quot;的功能库.\n#名称 Name 属性 Attributes\n#四种解释器\n&apos;&apos;&apos;\n1.html.parse\n2.lxml\n3.xml\n4.html5lib\n&apos;&apos;&apos;\n#元素\n&apos;&apos;&apos;\n1.Tag 标签&lt;&gt;\n2.Name 标签的名字&lt;p&gt;=p\n3.Attributes 标签的属性 字典形式组织,格式 &lt;tag&gt;.Attributes\n4.NavigableString 标签内费属性字符串 &lt;p&gt;...(中间这部分)...&lt;/p&gt;格式&lt;tag&gt;.string\n5.Comment 标签内字符串注释部分 一种特殊的Commnet类型\n&apos;&apos;&apos;\nprint(soup.title)\nprint(soup.a.name)\nprint(soup.a.parent.parent.name)#父亲的父亲\nprint(soup.a.attrs)\nprint(soup.a.attrs[&apos;class&apos;],type(soup.a.attrs))\nprint(soup.a.string),print(soup.p.string)\n&apos;&apos;&apos;\n标签树的下行遍历\n.contents 子节点的列表,将&lt;tag&gt;所有儿子节点存入列表\n.children 子节点的迭代类型,与.contents类似,用于循环遍历儿子节点\n.descendants 子孙节点的迭代类型,包含所有子孙节点,用于循环遍历\n&apos;&apos;&apos;\nprint(soup.head)\nprint(soup.head.contents)\nprint(soup.body.contents,&apos;\\n&apos;),print(&apos;len: &apos;,len(soup.body.contents))\n&apos;&apos;&apos;\n上行遍历\n.parent 节点的父亲标签\n.parents 返回节点的先辈标签\n&apos;&apos;&apos;\nfor parent in soup.a.parents:\n    if parent is None:\n        print(parent)\n    else:\n        print(parent.name)\n&apos;&apos;&apos;\n平行遍历\n.next_sibling 返回按照HTML文本顺序的下一个平行节点标签\n.previous_sibling 返回按照HTML文本顺序的上一个平行节点标签\n.next_siblings 迭代类型,返回按照HTML文本顺序的后续所有平行节点标签\n.previous_siblings 迭代类型,返回按照HTML文本顺序的前序所有平行结点标签\n&apos;&apos;&apos;</code></pre>","text":"Code:import requestsr=requests.get(&apos;http://python123.io/ws/demo.html&apos;)#print(r.text)demo=r.textfrom bs4 import BeautifulSoup#后面的是类","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python 爬虫学习记录","slug":"python-buglearning","date":"2017-05-27T05:27:34.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-buglearning.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>代码均上传至github</strong> <strong>【第一节课】</strong> <strong># urllib 的基本用法</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20first/uri.py\" target=\"_blank\" rel=\"noopener\">uri.py</a></strong> <strong>【第二节课】</strong> <strong># urllib 的urlretrieve方法</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20urlretrieve/test.py\" target=\"_blank\" rel=\"noopener\">test.py</a></strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/urllib%20-%20urlretrieve/test2.py\" target=\"_blank\" rel=\"noopener\">test2.py</a></strong></p>\n","text":"代码均上传至github 【第一节课】 # urllib 的基本用法 uri.py 【第二节课】 # urllib 的urlretrieve方法 test.py test2.py","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python 爬取中国大学排名","slug":"python-chut","date":"2017-08-30T10:19:46.000Z","updated":"2019-07-03T13:51:36.852Z","comments":true,"path":"api/articles/python-chut.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/08/17f778160b1fc4d8d2521e6846de2cbe.png","content":"<p>首先是爬取的目的地址: :zap:<a href=\"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html\" title=\"2016中国最好大学排名\" target=\"_blank\" rel=\"noopener\">=&gt;2016中国最好大学排名</a> 这里我们使用的是Python的request库和BeautifulSoup库,IDE用的是Anaconda的Spyder,Python version=3.6. 首先我们现在html中搜索清华大学(废话= =). 结果如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/17f778160b1fc4d8d2521e6846de2cbe.png\" alt=\"结果\"> 我们发现结果是在节点为’tbody’中,全部代码中也只有这一个地方有’tbody’.所以我们可以通过查找这个标签,然后再向下查找孩子来找到结果,但是我们知道,他的孩子可能会出现字符串类型,所以我们需要用isinstance(x,bs4.element.Tag),Tag–(标签)来过滤掉其它类型. 于是我们写出A程序:</p>\n<pre><code>#CrawUnivRankingA.py\nimport requests\nfrom bs4 import BeautifulSoup\nimport bs4\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef fillUnivList(ulist, html):\n    soup = BeautifulSoup(html, &quot;html.parser&quot;)\n    for tr in soup.find(&apos;tbody&apos;).children:\n        if isinstance(tr, bs4.element.Tag):\n            tds = tr(&apos;td&apos;)\n            ulist.append([tds[0].string, tds[1].string, tds[3].string])\n\ndef printUnivList(ulist, num):\n    print(&quot;{:^10}\\t{:^6}\\t{:^10}&quot;.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;))\n    for i in range(num):\n        u=ulist[i]\n        print(&quot;{:^10}\\t{:^6}\\t{:^10}&quot;.format(u[0],u[1],u[2]))\n\ndef main():\n    uinfo = []\n    url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos;\n    html = getHTMLText(url)\n    fillUnivList(uinfo, html)\n    printUnivList(uinfo, 20) # 20 univs\nmain()</code></pre><p>打印结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/807addc82e8f147efd10ff14afadcc03.png\" alt> 可以看出中间的学校缩进不规范,这是因为中文的问题,他是默认按照英文补充空格的. 改进一下,空格用chr(12288)补充:</p>\n<pre><code>#CrawUnivRankingB.py\nimport requests\nfrom bs4 import BeautifulSoup\nimport bs4\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        return &quot;&quot;\n\ndef fillUnivList(ulist, html):\n    soup = BeautifulSoup(html, &quot;html.parser&quot;)\n    for tr in soup.find(&apos;tbody&apos;).children:\n        if isinstance(tr, bs4.element.Tag):\n            tds = tr(&apos;td&apos;)\n            ulist.append([tds[0].string, tds[1].string, tds[3].string])\n\ndef printUnivList(ulist, num):\n    tplt = &quot;{0:^10}\\t{1:{3}^10}\\t{2:^10}&quot;\n    print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;,chr(12288)))\n    for i in range(num):\n        u=ulist[i]\n        print(tplt.format(u[0],u[1],u[2],chr(12288)))\n\ndef main():\n    uinfo = []\n    url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos;\n    html = getHTMLText(url)\n    fillUnivList(uinfo, html)\n    printUnivList(uinfo, 20) # 20 univs\nmain()</code></pre><p>打印结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/08/a8ee56c437ee19d41e7e53a863779b97.png\" alt> 结束.</p>\n","text":"首先是爬取的目的地址: :zap:=&gt;2016中国最好大学排名 这里我们使用的是Python的request库和BeautifulSoup库,IDE用的是Anaconda的Spyder,Python version=3.6. 首先我们现在html中搜索清华大学(废话= =)","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"爬虫","slug":"Python/爬虫","count":2,"path":"api/categories/Python/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"Python2 处理数据并绘制三维空间图","slug":"python-dwsg","date":"2017-06-01T05:12:37.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-dwsg.json","excerpt":"","keywords":null,"cover":"https://camo.githubusercontent.com/d4a677e900b6208428a00aab9b3d317064708124/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545352542392542332545382541372538362545352539422542452d312e6a7067","content":"<p><strong>【附件一.骑行数据】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/data1.txt\" target=\"_blank\" rel=\"noopener\">data1.txt</a></strong> <strong>【附件二.骑行数据处理】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/Deal-3D.py\" target=\"_blank\" rel=\"noopener\">Deal-3D.py</a></strong> <strong>处理结果:  <a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/in.txt\" target=\"_blank\" rel=\"noopener\">in.txt</a></strong> <strong>【附件三.数据分析,提取出时空分布信息】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/DealData.cpp\" target=\"_blank\" rel=\"noopener\">DealData.cpp</a></strong> <strong>提取结果:  <a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/out2.txt\" target=\"_blank\" rel=\"noopener\">out2.txt</a> (注:每行三个数据,第一个数据是时间区间编号,第二个数据是区域编号,第三个数据是单车数量)</strong> <strong>【将处理数据绘制成三维图】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/python2/matplotlib-3D-Image/3D-Image.py\" target=\"_blank\" rel=\"noopener\">3D-Image.py</a></strong> <strong>【绘制结果三视图】</strong> <strong>正视图:</strong> <strong><img src=\"https://camo.githubusercontent.com/d4a677e900b6208428a00aab9b3d317064708124/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545352542392542332545382541372538362545352539422542452d312e6a7067\" alt></strong>   <strong>侧视图:</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/06/%E4%BE%A7%E8%A7%86%E5%9B%BE.jpg\" alt></strong>   <strong>俯视图:</strong> <img src=\"https://camo.githubusercontent.com/9427753fa996288ba471a87588531c11a5a7fdc9/687474703a2f2f62652d73756e7368696e652e636e2f77702d636f6e74656e742f75706c6f6164732f323031372f30362f2545342542462541462545382541372538362545352539422542452e6a7067\" alt></p>\n","text":"【附件一.骑行数据】 data1.txt 【附件二.骑行数据处理】 Deal-3D.py 处理结果:  in.txt 【附件三.数据分析,提取出时空分布信息】 DealData.cpp 提取结果:  out2.txt (注:每行三个数据,第一个数据是时间区间编号,第二个数据是区域","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 番外 1 可以随鼠标移动的背景图片","slug":"python-flask-1-onmouse","date":"2017-10-18T13:32:57.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-1-onmouse.json","excerpt":"","keywords":null,"cover":null,"content":"<p>通过和大佬的交流学会了一点黑科技… <code>1.</code>因为<code>body的高度</code>和内容挂钩的,所以<code>鼠标可以到达</code>的body区域只有body的高度而已,如果<code>内容高度</code>没填满整个屏幕的话,就会出现下面有一部分无法响应鼠标移动事件,自然无法更新背景图片的<code>position</code>. 然后一个老司机告诉我:想要<code>简单粗暴一点</code>.可以用(<code>css3</code>):</p>\n<pre><code>height:100vh</code></pre><p>卧槽… <code>2.</code>响应函数:</p>\n<pre><code>// 一个小小的视觉效果\n$(&apos;body&apos;).on(&apos;mousemove&apos;, (evt) =&gt; {\n  $(&apos;body&apos;)\n    .css(&apos;background-position-x&apos;, Math.ceil(evt.pageX / 40))\n    .css(&apos;background-position-y&apos;, Math.ceil(evt.pageY / 40));\n});\nwindow.ondeviceorientation = (evt) =&gt; {\n  $(&apos;body&apos;)\n    .css(&apos;background-position-x&apos;, evt.gamma)\n    .css(&apos;background-position-y&apos;, evt.beta);\n};</code></pre>","text":"通过和大佬的交流学会了一点黑科技… 1.因为body的高度和内容挂钩的,所以鼠标可以到达的body区域只有body的高度而已,如果内容高度没填满整个屏幕的话,就会出现下面有一部分无法响应鼠标移动事件,自然无法更新背景图片的position. 然后一个老司机告诉我:想要简单粗暴一点","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 6.0.1 工厂函数","slug":"python-flask-6-0-1-factory-method","date":"2017-10-12T13:53:30.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-6-0-1-factory-method.json","excerpt":"","keywords":null,"cover":null,"content":"<p>开始大型网站架构的时候,有很多概念晦涩难懂,其中就有这个工厂函数. 以下是来自别人的博客: <a href=\"http://blog.csdn.net/qbw2010/article/details/45314541http://blog.csdn.net/qbw2010/article/details/45314541\" title=\"...Clicke Here...\" target=\"_blank\" rel=\"noopener\"><code>...Clicke Here...</code></a></p>\n<pre><code>def maker(N):  \n    def action(X):  \n        return X ** N  \n    return action  </code></pre><p>这个函数就是一个典型的<code>工厂函数</code>. 其中会牵扯到一个概念,<code>延迟执行</code>. 我们可以看到,这个函数是有<code>参数</code>的. 实例化对象:</p>\n<pre><code>f = maker(2)  </code></pre><p>然后我们在对象实例化后传入参数:</p>\n<pre><code>f(3)</code></pre><p>结果会输出9. 每次maker()的时候都会生成一个新的实例化对象. 而用实例化对象传入参数返回的就是返回的<code>调用函数返回的值</code>.</p>\n<pre><code> 1、Python中的def语句是一个可执行语句——函数并不存在，直到Python运行了def后才存在。当Python运行到def语句时，将创建一个函数对象，并将其赋值给某一变量名，这个变量名就是函数名。\n\n2、当函数被调用时，其调用者停止运行直到这个函数完成了工作，之后函数将控制权返回调用者。函数通过return语句将计算得到的值传递给调用者，返回值成为函数调用的结果，即return将一个函数结果发送给调用者。\n\n3、参数通过赋值传递给了函数。改变参数名并不会改变调用者中的变量名，但是改变传递的可变参数可以改变调用者共享的那个对象，即函数是通过赋值（对象引用）传递的。\n\n 4、函数maker里面嵌套了一个函数action，首先传给maker函数一个参数N，这个参数传给了action函数，action函数获得具体的参数形成具体的函数，此时，action(X)函数已经具体化了，也就是def action(X):return X**2，然后将action(X)返回给顶层，并赋值给f，即f是action(X)，然后再传递参数到f中，也就是传给了action(X)。</code></pre><p>在书中的:</p>\n<pre><code>def create_app(config_name):\n    app=Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)   \n\n    bootstrap.init_app(app)\n    mail.init_app(app)\n    moment.init_app(app)\n    db.init_app(app)\n    from .main import main as main_blueprint\n    app.register_blueprint(main_blueprint)\n\n    return app</code></pre><p>即为工厂函数,接受的参数是Config_name. 其返回的是实例化后的app对象,即可以对每种单元测试进行覆盖,而并非是对每种测试都重新运行一遍. 想对哪种单元测试进行测试时,只需调用其(工厂函数)返回的app实例化对象即可. 以下是我自己写的<code>工厂函数单元测试</code>样例:</p>\n<pre><code>class mq(object):\n    def __init__(self,string_c):\n        self.config_str=string_c\n    def print_str(self):\n        print(self.config_str)\n\ndef crete_factory_method(config_str):\n    tp=mq(config_str)\n    return tp\n\nfactory_test = crete_factory_method(&apos;这是第一个单元测试&apos;)\n\nfactory_test2 = crete_factory_method(&apos;这是第二个单元测试&apos;)\n\nfactory_test.print_str()\n#Out[]:这是第一个单元测试\n\nfactory_test2.print_str()\n#Out[]:这是第二个单元测试</code></pre><p>这样就明白了吧:)</p>\n","text":"开始大型网站架构的时候,有很多概念晦涩难懂,其中就有这个工厂函数. 以下是来自别人的博客: ...Clicke Here...def maker(N):      def action(X):          return X ** N      return action  ","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 6.0.2 相对路径","slug":"python-flask-6-0-2-path","date":"2017-10-13T04:17:13.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-6-0-2-path.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg","content":"<p>在Python引入包时,我们会发现有这样的一种引用方法: <code>from . import XX</code>,以及<code>from .. import xx</code>. 这就是相对路径引用. 其中有几点需要注意. <code>1.</code>在编译时,存在这种相对引用的<code>.py</code>是无法被<code>单独编译</code>的,只有在编译最高级的<code>.py</code>时,才不会报<code>编译级别错误</code>. <code>2.</code>存在<code>跨文件夹引用</code>时,需要在相应文件夹内创建一个<code>__init__.py</code>才可以引用成功,(<code>就算该文件是空的也没关系</code>)因为加了这个文件,编译器才会把该文件夹看做一个<code>package</code>,即可以用<code>from 文件夹名 import 类/文件</code>等方式进行引用. <code>3.</code>在主程序运行后,调用每个包时会先调用该包的<code>__init__.py</code>文件,然后再调用对应<code>import</code>的内容. 这里我结合上一节的<code>Factory method</code>编写了一个简单的测试程序:</p>\n<pre><code>具体目录结构如下:\n--工厂函数/\n    --tests/\n        --abc/\n            --__init__.py\n            --qb.py\n        --__init__.py\n        --test2.py\n    --test.py(主程)</code></pre><p>项目地址: <a href=\"https://github.com/834930269/python_study/tree/master/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0\" title=\"&lt;code&gt;Click Here: 工厂函数&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>Click Here: 工厂函数</code></a> 运行<code>test.py</code>,<code>Result:</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171013121052.jpg\" alt></a> <code>test.py</code>:</p>\n<pre><code>from tests.abc.qb import crete_factory_method\n\nfactory_test = crete_factory_method(&apos;这是第一个单元测试&apos;)\n\nfactory_test2 = crete_factory_method(&apos;这是第二个单元测试&apos;)\n\nfactory_test.print_str()\n\nfactory_test2.print_str()</code></pre><p><code>tests/__init__.py</code>:</p>\n<pre><code>print(&quot;I&apos;m Tom&apos;s __init__!&quot;)</code></pre><p><code>tests/test2.py</code>:</p>\n<pre><code>class mq(object):\n    def __init__(self,string_c):\n        self.config_str=string_c\n    def print_str(self):\n        print(self.config_str)</code></pre><p><code>tests/abc/__init__.py</code>:</p>\n<pre><code>print(&apos;由此可知,如果直接编译qb.py会报错,因为等级?错误,但是直接编译最顶层的test.py就不会报错了.&apos;)</code></pre><p><code>tests/abc/qb.py</code>:</p>\n<pre><code>from ..test2 import mq\n\ndef crete_factory_method(config_str):\n    tp=mq(config_str)\n    return tp</code></pre>","text":"在Python引入包时,我们会发现有这样的一种引用方法: from . import XX,以及from .. import xx. 这就是相对路径引用. 其中有几点需要注意. 1.在编译时,存在这种相对引用的.py是无法被单独编译的,只有在编译最高级的.py时,才不会报编译级别","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 7.1 @property","slug":"python-flask-7-1-property","date":"2017-10-14T12:54:20.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-7-1-property.json","excerpt":"","keywords":null,"cover":null,"content":"<p>见之前的文章===&gt; <a href=\"http://be-sunshine.cn/index.php/2017/07/16/python3-property/\" title=\"python3学习 @property\" target=\"_blank\" rel=\"noopener\"><code>Click Here: python3学习 @property</code></a></p>\n","text":"见之前的文章===&gt; Click Here: python3学习 @property","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 7 博客架构一: 登录注册模块","slug":"python-flask-7-blog-login-regist","date":"2017-10-14T14:53:28.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-7-blog-login-regist.json","excerpt":"","keywords":null,"cover":"http://img.blog.csdn.net/20160924183725708","content":"<p><code>1.</code>flask_login模块中,views层判断是否登录用<code>current_user.is_authenticated</code>,但是,<code>flask-login2.x</code>是current_user.is_authenticated<code>()</code>,<code>flask-login3.x</code>是current_user.is_authenticated 即:</p>\n<pre><code>&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;\n    {% if current_user.is_authenticated %}\n            <li><a href=\"{ { url_for('auth.logout') }}\">Sign Out</a></li>\n        {% else %}\n            <li><a href=\"{ { url_for('auth.login') }}\">Sign In</a></li>\n        {% endif %}\n&lt;/ul&gt;</code></pre><p><code>2.</code>在 <code>SQLAlchemy</code> 中， add() 操作之后数据成为<code>pending</code> 状态，此时数据<code>不会立即</code>写入到数据库中。 当你执行 <code>query()</code> 的时候，它会先把之前状态为 pending 的数据<code>写入到数据库</code>，并且<code>更新当前 session</code> 中存储的数据，然后再执行 <code>query()</code> <code>3.</code>如果出现<code>Can&#39;t locate revision identified by &#39;XXX&#39;</code>,要删除一下数据库中的<code>alembic_version</code>表,保证版本不会互相影响以完成更新.</p>\n<h1 id=\"项目地址-Github\"><a href=\"#项目地址-Github\" class=\"headerlink\" title=\"项目地址(Github):\"></a>项目地址(Github):</h1><p><a href=\"https://github.com/834930269/Flask_Study/tree/master/flask-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%842-%E6%B3%A8%E5%86%8C%E5%92%8C%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81\" title=\"flask-大型网站架构2-注册和邮箱验证\" target=\"_blank\" rel=\"noopener\"><code>Click Here: flask-大型网站架构2-注册和邮箱验证</code></a> <code>4.</code>看到了一个之前没太注意的地方: <a href=\"http://img.blog.csdn.net/20160924183725708\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.blog.csdn.net/20160924183725708\" alt></a> 这里是Flask-Login需要的自己实现的四个函数.可以用一个<code>UserMixin</code>解决.但需要自己实现一个<code>回调函数</code>。 <a href=\"http://img.blog.csdn.net/20160924183906725\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.blog.csdn.net/20160924183906725\" alt></a> <a href=\"http://img.blog.csdn.net/20160924183919554\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.blog.csdn.net/20160924183919554\" alt></a> 这就是代码里</p>\n<pre><code>@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))</code></pre><p>这段代码的意义. ..有点累..躺尸一会,先不更新了..<code>_(:3」∠)_我的床需要我</code></p>\n","text":"1.flask_login模块中,views层判断是否登录用current_user.is_authenticated,但是,flask-login2.x是current_user.is_authenticated(),flask-login3.x是current_user.is","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 富文本添加支持格式的以及Attributes的方法","slug":"python-flask-attribute","date":"2017-10-20T14:49:40.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-attribute.json","excerpt":"","keywords":null,"cover":null,"content":"<p>通过设置<code>attributes</code>和<code>tags</code>如:</p>\n<pre><code>#将Markdown转换为HTML\n@staticmethod\ndef on_change_body(target,value,oldvalue,initiator):\n    attrs = {\n        &apos;*&apos;: [&apos;class&apos;,&apos;style&apos;,&apos;width&apos;,&apos;height&apos;],\n        &apos;a&apos;: [&apos;href&apos;, &apos;rel&apos;],\n         &apos;img&apos;: [&apos;src&apos;, &apos;alt&apos;],\n    }\n    #允许的标签类型\n    allowed_tags = [&apos;a&apos;,&apos;abbr&apos;,&apos;acronym&apos;,&apos;b&apos;,&apos;blockquote&apos;,&apos;code&apos;,\n                    &apos;em&apos;,&apos;i&apos;,&apos;li&apos;,&apos;ol&apos;,&apos;pre&apos;,&apos;strong&apos;,&apos;ul&apos;,\n                    &apos;h1&apos;,&apos;h2&apos;,&apos;h3&apos;,&apos;p&apos;,&apos;img&apos;]\n    target.body_html = bleach.linkify(bleach.clean(\n        markdown(value,output_format=&apos;html&apos;),\n        tags=allowed_tags, attributes=attrs,strip=True))</code></pre><p>最近先把这个博客做好… 之后再看情况写部分重点= =. 最近眼有点难受.</p>\n","text":"通过设置attributes和tags如:#将Markdown转换为HTML@staticmethoddef on_change_body(target,value,oldvalue,initiator):    attrs = {        &apos;*&apos;: [","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask(一) --by Maxime Bouroumeau-Fuseau","slug":"python-flask-by-maxime-bouroumeau-fuseau","date":"2017-10-08T07:54:30.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-by-maxime-bouroumeau-fuseau.json","excerpt":"","keywords":null,"cover":null,"content":"<p>第一节的代码</p>\n<pre><code># -*- coding: utf-8 -*-\nimport sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for,abort, render_template, flash, jsonify\n\n# configuration\nDATABASE = &apos;/tmp/flaskr.db&apos;\nDEBUG = True\nSECRET_KEY = &apos;development key&apos;\nUSERNAME = &apos;admin&apos;\nPASSWORD = &apos;default&apos;\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_envvar(&apos;FLASKR_SETTINGS&apos;, silent=True)\napp.config[&apos;SECRET_KEY&apos;]=&apos;F34TF$($e34D&apos;;\n\n\n@app.route(&apos;/_add_numbers&apos;)\ndef add_numbers():\n    a=request.args.get(&apos;a&apos;,0,type=int)\n    b=request.args.get(&apos;b&apos;,0,type=int)\n    return jsonify(result=a+b)\n\n@app.route(&apos;/&apos;)\ndef home():\n    return render_template(&apos;index.html&apos;)\n\n@app.route(&apos;/signup&apos;,methods=[&apos;POST&apos;])\ndef signup():\n    session[&apos;username&apos;]=request.form[&apos;username&apos;]\n    session[&apos;message&apos;]=request.form[&apos;message&apos;]\n    return redirect(url_for(&apos;message&apos;))\n\n@app.route(&apos;/message&apos;)\ndef message():\n    if not &apos;username&apos; in session:\n        return abort(403)\n    return render_template(&apos;message.html&apos;,username=session[&apos;username&apos;],message=session[&apos;message&apos;])\n\ndef connect_db():\n    return sqlite3.connect(app.config[&apos;DATABASE&apos;])\n\nif __name__ == &apos;__main__&apos;:\n    app.run()</code></pre><p>在这个例子中,用户将输入想要说的信息到第一个页面,即用户和,message,这些数据将被存储在session中并且将被同步显示在/message页面下. Some observations: - <code>app.config</code> is a dict containing configuration parameters - <code>@app.route()</code> is by default limited to GET requests. Allowed HTTP methods of an action can be specified using the methods keyword arg. - <code>url_for(route_name, **kwargs)</code> should be used to generate urls for your handlers. It takes as first parameter the function name and as keyword args any needed parameters to generate the url. - <code>redirect(url)</code> creates an HTTP response with a redirect code and location - <code>abort(http_code)</code> is used to create error responses and stop the executing function. Flask is natively integrated with <code>jinja2</code>, a very good templating engine. Templates should be saved as .html files under the templates/ folder. The <code>render_template(filename, **kwargs)</code> function is a pretty straightforward method to render them. 即render_template()函数接受任意多个参数,第一个参数是位于templates/下的模板文件,之后的参数均是模板文件内定义的数据. 然后我们使用jinja渲染html.代码如下</p>\n<pre><code>index.html:\n\n{% extends \"layout.html\" %}\n{% block content %}\n        <h1>Say something</h1>\n        <form method=\"post\" action=\"{ { url_for('signup') }}\">\n            <p><label>Username:</label> <input type=\"text\" name=\"username\" required></p>\n            <p><label>Message:</label> <textarea name=\"message\"></textarea></p>\n            <p><button type=\"submit\">Send</button></p>\n        </form>\n    {% endblock %}\n\nmessage.html:\n\n{% extends \"layout.html\" %}\n{% block content %}\n        <h1>{ { username }} said:</h1>\n        <p>\n            { { message }}\n        </p>\n        <a href=\"{ { url_for('home') }}\">Say something else</a>\n    {% endblock %}\n\nlayout.html:\n\n&lt;!doctype html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;title&gt;Say somthing&lt;/title&gt;\n        &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n        &lt;link rel=&quot;shortcut icon&quot; href=&quot;{ { url_for(&apos;static&apos;, filename=&apos;favicon.ico&apos;) }}&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        {% block content %}{% endblock %}\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre><p>其中,模板中的url_for()是从 static/ 目录下get到当时路由定义函数渲染的页面.比如这里会转到<code>index.html</code></p>\n","text":"第一节的代码# -*- coding: utf-8 -*-import sqlite3from flask import Flask, request, session, g, redirect, url_for,abort, render_template, flash, js","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask(二) Custom Error Pages","slug":"python-flask-custom-error-pages","date":"2017-10-08T23:57:51.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-custom-error-pages.json","excerpt":"","keywords":null,"cover":null,"content":"<p>自定义错误界面: 直接上代码:</p>\n<pre><code>@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template(&apos;404.html&apos;), 404\n\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    return render_template(&apos;500.html&apos;), 500</code></pre><p>返回参数有两个,第一个是渲染模板,第二个是错误码,错误界面通过handler获取错误码然后重定向到错误界面.以上.</p>\n","text":"自定义错误界面: 直接上代码:@app.errorhandler(404)def page_not_found(e):    return render_template(&apos;404.html&apos;), 404@app.errorhandler(500)def in","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"},{"name":"未分类","slug":"Flask/Python/未分类","count":2,"path":"api/categories/Flask/Python/未分类.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask(四) Integration with the Python Shell","slug":"python-flask-integration-with-the-python-shell","date":"2017-10-10T02:14:17.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-integration-with-the-python-shell.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010101231.jpg","content":"<p>集成Python Shell,为了不每次启动都手动创建示例(比如from/import之类),所以调用这个. 但这个并不是给网站用的,是给开发者用的. 一开始我没太理解为什么要用这个包,后来看到了一个回答,很详细的:</p>\n<hr>\n<h3 id=\"Click-Here-Flask-script-内的Shell-类-使用\"><a href=\"#Click-Here-Flask-script-内的Shell-类-使用\" class=\"headerlink\" title=\"Click Here: Flask script 内的Shell 类 使用 ***\"></a><a href=\"https://segmentfault.com/q/1010000006219785/a-1020000006258581\" title=\"Click Here:  Flask script 内的Shell 类 使用 \" target=\"_blank\" rel=\"noopener\">Click Here: Flask script 内的Shell 类 使用</a> ***</h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010101231.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010101231.jpg\" alt></a></p>\n","text":"集成Python Shell,为了不每次启动都手动创建示例(比如from/import之类),所以调用这个. 但这个并不是给网站用的,是给开发者用的. 一开始我没太理解为什么要用这个包,后来看到了一个回答,很详细的:Click Here: Flask script 内的Shell","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask(三) Python Database Frameworks","slug":"python-flask-python-database-frameworks","date":"2017-10-09T14:07:40.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-python-database-frameworks.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B75.png","content":"<p>期间遇到两个错误,其一,因为<code>Python版本是3.*</code>,所以调用flask_sqlalchemy后执行时出错,因为<code>缺少了MySQLdb模块</code>. 在stackoverflow上面找到了解决办法. <a href=\"https://stackoverflow.com/questions/454854/no-module-named-mysqldb\" title=\"Click here: No module named MySQLdb\" target=\"_blank\" rel=\"noopener\">Click here: No module named MySQLdb</a> 然后这是大部分Python扩展库的集合: <a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python\" title=\"click here: Unofficial Windows Binaries for Python Extension Packages\" target=\"_blank\" rel=\"noopener\">click here: Unofficial Windows Binaries for Python Extension Packages</a> 解决办法: <code>pip install mysqlclient</code>/<code>conda install mysqlclient</code> 其二: <code>db.create_all</code>时会报<code>warning</code>,无视即可. 其三: 书上给的是用SQLite连接以及创建数据库,直接将连接地址改为Mysql的地址即可.具体代码如下:</p>\n<pre><code>#--*--coding:utf-8--*--\nfrom datetime import datetime\nfrom flask import Flask, render_template,session,redirect,url_for,flash\nfrom flask_script import Manager\nfrom flask_bootstrap import Bootstrap   \nfrom flask_moment import Moment\nfrom flask_wtf import Form\nfrom wtforms import StringField,SubmitField\nfrom wtforms.validators import Required\nfrom flask_sqlalchemy import SQLAlchemy\n\nclass NameForm(Form):\n    name=StringField(&apos;What is your name?&apos;,validators=[Required()])\n    submit=SubmitField(&apos;Submit&apos;)\n\napp = Flask(__name__)\n\n#Flask-WTF : secret_key\n#app.config dict used to save config message.\napp.config[&apos;SECRET_KEY&apos;]=&apos;hard to guess string&apos;\napp.config[&apos;SQLALCHEMY_DATABASE_URI&apos;]=\\\n    &apos;mysql://root:zwt~19970210@localhost/data&apos;\napp.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = True\napp.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = False\ndb=SQLAlchemy(app)\n\nmanager = Manager(app)\nbootstrap = Bootstrap(app)\nmoment = Moment(app)\n\nclass Role(db.Model):\n    __tablename__ = &apos;roles&apos;\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), unique=True)\n    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;, lazy=&apos;dynamic&apos;)\n\n    def __repr__(self):\n        return &apos;&lt;Role %r&gt;&apos; % self.name\n\n\nclass User(db.Model):\n    __tablename__ = &apos;users&apos;\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, index=True)\n    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;))\n\n    def __repr__(self):\n        return &apos;&lt;User %r&gt;&apos; % self.username\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template(&apos;404.html&apos;), 404\n\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    return render_template(&apos;500.html&apos;), 500\n\n\n@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef index():\n    form=NameForm()\n    if form.validate_on_submit():\n        old_name=session.get(&apos;name&apos;)\n        if old_name is not None and old_name!=form.name.data:\n            flash(&apos;Looks like you have changed your name!&apos;)\n        session[&apos;name&apos;]=form.name.data\n        return redirect(url_for(&apos;index&apos;))\n    return render_template(&apos;index.html&apos;,\n                           current_time=datetime.utcnow(),form=form,name=session.get(&apos;name&apos;))\n\n\n@app.route(&apos;/user/&lt;name&gt;&apos;)\ndef user(name):\n    return render_template(&apos;user.html&apos;, name=name)\n\n\nif __name__ == &apos;__main__&apos;:\n    db.create_all()\n    manager.run()</code></pre><p>其中,只需要修改<code>app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;]=&#39;mysql://root:zwt~19970210@localhost/data&#39;</code>即可修改连接的数据库. 其四: 想要提交操作事务,需要先将操作示例放置在全局db.session字典中. 其五: 一些操作 <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B75.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B75.png\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B76.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B76.png\" alt></a> Done</p>\n","text":"期间遇到两个错误,其一,因为Python版本是3.*,所以调用flask_sqlalchemy后执行时出错,因为缺少了MySQLdb模块. 在stackoverflow上面找到了解决办法. Click here: No module named MySQLdb 然后这是大部分Py","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 10.0.1上传文件","slug":"python-flask-upfile","date":"2017-10-17T13:55:17.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-upfile.json","excerpt":"","keywords":null,"cover":null,"content":"<p><code>1.</code> <code>os模块</code>:</p>\n<pre><code>#获取指定文件目录\nos.path.abspath(os.path.join(os.getcwd(),&quot;static/Gravatar&quot;))</code></pre><p><code>2.``Flask_wtf.file包</code>:里面放着各种处理文件上传的处理表单类. <code>3.</code>获取当前文件的<code>url</code>:</p>\n<pre><code>if filename is None:\n    fn=&apos;default.jpg&apos;\nelse:\n    fn=filename\nfn = os.path.abspath(os.path.join(app.config[&apos;UPLOADED_PHOTOS_DEST&apos;],fn))</code></pre><p><code>代码</code>:</p>\n<pre><code>#app.py\n# -*- coding: utf-8 -*-\nfrom flask import Flask, render_template\nfrom flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\nfrom flask_wtf import FlaskForm\nfrom flask_wtf.file import FileField, FileRequired, FileAllowed\nfrom wtforms import SubmitField\nimport os\n\napp = Flask(__name__)\napp.config[&apos;SECRET_KEY&apos;] = &apos;I have a dream&apos;\napp.config[&apos;UPLOADED_PHOTOS_DEST&apos;] = os.path.abspath(os.path.join(os.getcwd(),&quot;static/Gravatar&quot;))\n\nphotos = UploadSet(&apos;photos&apos;,IMAGES)\nconfigure_uploads(app,photos)\npatch_request_class(app)\n\n#创建Form\nclass UploadForm(FlaskForm):\n    photo = FileField(validators=[FileAllowed(photos,u&apos;只能上传图片哦!&apos;),\n                                  FileRequired(u&apos;文件为选择!&apos;)])\n    submit = SubmitField(u&apos;上传&apos;)\n\n@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef upload_file():\n    form = UploadForm()\n    if form.validate_on_submit():\n        filename = photos.save(form.photo.data)\n        file_url = photos.url(filename)\n    else:\n        file_url = None\n        filename = None\n    if filename is None:\n        fn=&apos;default.jpg&apos;\n    else:\n        fn=filename\n    fn = os.path.abspath(os.path.join(app.config[&apos;UPLOADED_PHOTOS_DEST&apos;],fn))\n    return render_template(&apos;index.html&apos;,form=form,file_url=file_url,filename=fn)\n\nif __name__ == &apos;__main__&apos;:\n    app.run()</code></pre><p><code>前台-app/templates</code>:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;title&gt;Upload File&lt;/title&gt;\n&lt;h1&gt;图片上传&lt;/h1&gt;\n&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;\n     { { form.hidden_tag() }}\n     { { form.photo }}\n     {% for error in form.photo.errors %}\n             <span style=\"color: red;\">{ { error }}</span>\n         {% endfor %}\n     { { form.submit }}\n&lt;/form&gt;\n{ { filename }}\n{% if file_url %}\n    <br><img src=\"{ { file_url }}\">\n    {% endif %}</code></pre>","text":"1. os模块:#获取指定文件目录os.path.abspath(os.path.join(os.getcwd(),&quot;static/Gravatar&quot;))2.``Flask_wtf.file包:里面放着各种处理文件上传的处理表单类. 3.获取当前文件的url:","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask(3.1) Flask_wtf.Form rename to Flask_wtf.FlaskForm","slug":"python-flask3-1-flask-wtf-form-rename-to-flask-wtf-flaskform","date":"2017-10-10T01:53:01.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask3-1-flask-wtf-form-rename-to-flask-wtf-flaskform.json","excerpt":"","keywords":null,"cover":null,"content":"<p>如题,Flask_wtf.Form将在1.0被删除,所以以后引用模块名应该是FlaskForm.</p>\n","text":"如题,Flask_wtf.Form将在1.0被删除,所以以后引用模块名应该是FlaskForm.","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask5.1 Context(上下文=>跟随变量)","slug":"python-flask5-1-context","date":"2017-10-11T07:29:31.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask5-1-context.json","excerpt":"","keywords":null,"cover":null,"content":"<p>这是一个概念性的东西. 这里贴几个地址(有些我没看懂): <code>1.</code>轮子哥:</p>\n<pre><code>vczh\n    vczh: 《C++Primer 5th》强势审校\n\n每一段程序都有很多外部变量。只有像Add这种简单的函数才是\n没有外部变量的。一旦你的一段程序有了外部变量，这段程序就\n不完整，不能独立运行。你为了使他们运行，就要给所有的外部\n变量一个一个写一些值进去。这些值的集合就叫上下文。\n\n譬如说在C++的lambda表达是里面，[写在这里的就是上下文](int a, int b){ ... }。</code></pre><p>似懂非懂. <code>2.</code>: 最近在学Python + Flask，搜到了这个问题，也来回答一下吧。既然题主也在学Flask，就用Flask来举例：Flask从客户端收到请求的时候，视图函数如果要处理请求的话，可能就要访问一些对象。那么这些对象可以通过参数的形式传递进来，或者是在函数中访问外部变量。所以这个外部变量要有特定的值才会有意义，也即所谓的上下文。譬如Flask中的request变量，这是一个请求上下文，也就是当请求被推送之后，request才会有意义，接下来才可以使用request，否则就会报错，因为缺少上下文。引用一段《Flask Web开发》中的代码：</p>\n<pre><code>from flask import request\n\n@app.route(&apos;/&apos;)\ndef index():\n    user_agent = request.headers.get(&apos;User-Agent&apos;)\n    return &apos;&lt;p&gt;Your browser is %s&lt;/p&gt;&apos; % user_agent  </code></pre><p>就像前面说的，函数index()访问了request这个外部变量，但request必须在请求推送之后才可以使用，这就是一个请求上下文全局变量。 <strong>作者：Blackbelly 链接：<a href=\"https://www.zhihu.com/question/26387327/answer/128743651\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/26387327/answer/128743651</a> 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong> <code>3.</code>转自简书: <a href=\"http://www.jianshu.com/p/7a7efbb7205f\" title=\"Click Here: Flask的Context(上下文)学习笔记\" target=\"_blank\" rel=\"noopener\">Click Here: Flask的Context(上下文)学习笔记</a></p>\n","text":"这是一个概念性的东西. 这里贴几个地址(有些我没看懂): 1.轮子哥:vczh    vczh: 《C++Primer 5th》强势审校每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python  Flask(六) 大型网站架构","slug":"python-flasksix-large-application-structure","date":"2017-10-13T05:35:46.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flasksix-large-application-structure.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B711.png","content":"<h1 id=\"Large-Application-Structure\"><a href=\"#Large-Application-Structure\" class=\"headerlink\" title=\"Large Application Structure\"></a>Large Application Structure</h1><hr>\n<p>有了之前的基础后我们再来看第六章就轻松多了. 首先贴上<code>稍加修改</code>的后项目地址: <a href=\"https://github.com/834930269/Flask_Study/tree/master/flask-%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%84\" title=\"&lt;code&gt;Click Here: flask-转换结构&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>Click Here: flask-转换结构</code></a> 我们可以看到项目目录下有两个<code>Config</code>文件,其中<code>副本</code>是同书上一样的使用<code>SQLite</code>作为数据库文件来使用的,而且email的<code>smtp</code>服务器地址为<code>smtp.gmail.com</code>(文件中不是这个地址,需要改一下). 而修改后的<code>config.py</code>使用<code>mysql</code>作为基数据库,<code>smtp.qq.com</code>作为email的发送地址的. 这里说我在<code>config.py</code>的项目中设的各个环境变量即相应的意义.</p>\n<pre><code>1.MAIL_SENDER: 发送email的用户(abc@qq.com)=&gt;\n               在qq邮箱中这一项必须和发送者的邮箱一样\n2.MAIL_USERNAME: 发送者的用户名\n3.MAIL_PASSWORD: 发送者的密码=&gt;这里因为QQ邮箱使用的\n                 是授权码作为密码,所以需要申请一下授权码\n                 正常的密码是无法登录的\n4.FLASKY_ADMIN: 同是发送者的用户名,但是如果不填写的话,\n                则默认不发送邮件,所以可以不用设置.\n                不设置这项的话上面三项均可以忽略.\n5.DATABASE_USERNAME: 你在mysql中创建data_dev数据库时\n                     指定授权可操作该数据库的用户名\n6.DATABASE_PASSWORD: 同5的密码</code></pre><p>因为在<code>mysql</code>的数据库<code>命名规范</code>中,<code>data-dev</code>是不被允许的. 所以我将它改为了<code>data_dev</code>. 在运行项目前,需要先创建<code>data_dev</code>数据库,并创建一个可以操作该数据库的用户,假设我们创建的用户是: <code>USER: ABC</code> <code>USER_PASSWORD: ABC</code> 我们在数据库和用户创建好了以后将<code>相应的环境变量</code>放进环境中: <code>set DATABASE_USERNAME=ABC</code> <code>set DATABASE_PASSWORD=ABC</code> 这里我们不对上面4项进行设置,这样就默认不发送邮件. 然后我们需要建立<code>迁移数据库</code>,以便完成对数据库表项的<code>初始化</code>. <code>python manage.py db init</code> <code>python manage.py db migrate -m &#39;commit&#39;</code> <code>python manage.py db upgrade</code> 然后我们就可以运行项目了! <code>manage.py runserver</code> 结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B711.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B711.png\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B712.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B712.png\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B713.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B713.png\" alt></a></p>\n","text":"Large Application Structure有了之前的基础后我们再来看第六章就轻松多了. 首先贴上稍加修改的后项目地址: Click Here: flask-转换结构 我们可以看到项目目录下有两个Config文件,其中副本是同书上一样的使用SQLite作为数据库文件来使","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python list 学习笔记","slug":"python-list-di","date":"2017-05-24T09:46:46.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-list-di.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong>跟随廖雪峰老师学习:</strong> <strong><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316724772904521142196b74a3f8abf93d8e97c6ee6000\" target=\"_blank\" rel=\"noopener\">廖雪峰python-使用list</a></strong> <strong>【Code】</strong> <strong>已上传至github.</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/list/list.py\" target=\"_blank\" rel=\"noopener\">list.py</a></strong> <strong>【总结】</strong> <strong>比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…</strong></p>\n","text":"【Link】 跟随廖雪峰老师学习: 廖雪峰python-使用list 【Code】 已上传至github. list.py 【总结】 比c++的数组好用多了,这样直接就是不等长数组了,而且元素可以是任意类型,方便倒是,但是估计慢的一匹= =…","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python os模块+flask实现文件上传","slug":"python-os-flask-upload","date":"2017-10-08T00:28:45.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-os-flask-upload.json","excerpt":"","keywords":null,"cover":null,"content":"<p>首先是os模块选择上传目录: os.path为初始画一个path对象,他可以将路径转换为标准路径.</p>\n<pre><code>os.path.dirname()</code></pre><p>转到相应文件目录</p>\n<pre><code>os.getcwd()</code></pre><p>获取当前目录</p>\n<pre><code>os.path.join(path1,path2,path3...)</code></pre><p>将所有目录组合起来 实现代码如下:</p>\n<pre><code># -*- coding: utf-8 -*-\nimport os\nfrom flask import Flask, request, url_for, send_from_directory\nfrom werkzeug import secure_filename\nimport logging; logging.basicConfig(level=logging.INFO)\n\nALLOWED_EXTENSIONS = set([&apos;png&apos;, &apos;jpg&apos;, &apos;jpeg&apos;, &apos;gif&apos;])\n\napp = Flask(__name__)\napp.config[&apos;UPLOAD_FOLDER&apos;] = os.path.join(os.path.dirname(os.getcwd()),&apos;static&apos;,&apos;cav&apos;)\napp.config[&apos;MAX_CONTENT_LENGTH&apos;] = 16 * 1024 * 1024\n\n\nhtml = &apos;&apos;&apos;\n    &lt;!DOCTYPE html&gt;\n    &lt;title&gt;Upload File&lt;/title&gt;\n    &lt;h1&gt;图片上传&lt;/h1&gt;\n    &lt;form method=post enctype=multipart/form-data&gt;\n         &lt;input type=file name=file&gt;\n         &lt;input type=submit value=上传&gt;\n    &lt;/form&gt;\n    &apos;&apos;&apos;\n\n\ndef allowed_file(filename):\n    return &apos;.&apos; in filename and \\\n           filename.rsplit(&apos;.&apos;, 1)[1] in ALLOWED_EXTENSIONS\n\n\n@app.route(&apos;/uploads/&lt;filename&gt;&apos;)\ndef uploaded_file(filename):\n\n    return send_from_directory(app.config[&apos;UPLOAD_FOLDER&apos;],\n                               filename)\n\n\n@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])\ndef upload_file():\n    if request.method == &apos;POST&apos;:\n        file = request.files[&apos;file&apos;]\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            logging.info(&apos;Upload path with : &apos;,os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename))\n            logging.info(app.config[&apos;UPLOAD_FOLDER&apos;])\n            file.save(os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename))\n            file_url = url_for(&apos;uploaded_file&apos;, filename=filename)\n            return html + &apos;&lt;br&gt;&lt;img src=&apos; + file_url + &apos;&gt;&apos;\n    return html\n\n\nif __name__ == &apos;__main__&apos;:\n    app.run()</code></pre>","text":"首先是os模块选择上传目录: os.path为初始画一个path对象,他可以将路径转换为标准路径.os.path.dirname()转到相应文件目录os.getcwd()获取当前目录os.path.join(path1,path2,path3...)将所有目录组合起来 实现代码如","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python 机器学习 科学计算库","slug":"python-sklearn-moudle","date":"2018-01-08T08:34:43.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/python-sklearn-moudle.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Jupyter-Notebook\"><a href=\"#Jupyter-Notebook\" class=\"headerlink\" title=\"Jupyter Notebook\"></a>Jupyter Notebook</h1><p><strong>math Last Checkpoint: a few seconds ago (autosaved) [Python 3]</strong> <strong>Python 3</strong> <strong>Code:</strong></p>\n<pre><code>import numpy as np\n\nnp.arange(10)\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\na=np.arange(10)\n\n#可以直接对数组进行运算\n\na = a ** 2\n\na\n\narray([ 0,  1,  4,  9, 16, 25, 36, 49, 64, 81], dtype=int32)\n\n​\n\n#Scipy\n\n#用来做高等数学等计算的包\n\nfrom scipy import linalg\n\n#生成一个二维数组\n\nA = np.array([[1,2],[3,4]])\n\nA\n\narray([[1, 2],\n       [3, 4]])\n\n#计算行列式的值\n\n#1*4-2*3\n\nlinalg.det(A)\n\n​\n\n-2.0\n\n#Pandas\n\n#是一种构建于Numpy的高级数据结构和精巧工具,快速简单的处理数据\n\nimport pandas as pd\n\n#序列\n\ns = pd.Series([1,3,5,np.nan,6,8])\n\ns\n\n0    1.0\n1    3.0\n2    5.0\n3    NaN\n4    6.0\n5    8.0\ndtype: float64\n\n#时间数组,起始时间到六天\n\ndates = pd.date_range(&apos;20130101&apos;,periods=6)\n\ndates\n\nDatetimeIndex([&apos;2013-01-01&apos;, &apos;2013-01-02&apos;, &apos;2013-01-03&apos;, &apos;2013-01-04&apos;,\n               &apos;2013-01-05&apos;, &apos;2013-01-06&apos;],\n              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)\n\n#生成表格\n\n#index:行标识\n\n#columns:列标识\n\n#rand是0-1的均匀分布，randn是均值为0方差为1的正态分布；\n\n#rand(n)或randn(n)生成n*n的随机数矩阵。\n\n#rand(n,m)或randn(m,n)生成m*n的随机数矩阵。\n\ndf = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list(&apos;ABCD&apos;))\n\ndf\n\n    A   B   C   D\n2013-01-01  1.210884    0.616424    0.961066    0.173936\n2013-01-02  0.358245    0.506724    -0.047834   0.587061\n2013-01-03  -0.508396   0.012049    -0.114224   -1.195929\n2013-01-04  2.303441    0.536666    -1.013810   -0.574154\n2013-01-05  -1.327828   -0.003089   0.662432    0.038886\n2013-01-06  1.379826    1.554135    -0.681174   -0.816094\n\n#通过B列降序排序\n\ndf.sort_values(by=&apos;B&apos;)\n\n#从上到下多少行\n\n#df.head()\n\n#从下到上多少行\n\n#df.tail()\n\n#所有值和描述\n\n#df.describe()\n\n#转置\n\n#df.T\n\n​\n\n    A   B   C   D\n2013-01-01  1.210884    0.616424    0.961066    0.173936\n2013-01-02  0.358245    0.506724    -0.047834   0.587061\n2013-01-03  -0.508396   0.012049    -0.114224   -1.195929\n2013-01-04  2.303441    0.536666    -1.013810   -0.574154\n2013-01-05  -1.327828   -0.003089   0.662432    0.038886\n\n#绘图\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1,2,3])\n\nplt.ylabel(&apos;some numbers&apos;)\n\nplt.show()\n\n​</code></pre>","text":"Jupyter Notebookmath Last Checkpoint: a few seconds ago (autosaved) [Python 3] Python 3 Code:import numpy as npnp.arange(10)array([0, 1, 2, ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"机器学习","slug":"Python/机器学习","count":2,"path":"api/categories/Python/机器学习.json"},{"name":"相关库","slug":"Python/机器学习/相关库","count":1,"path":"api/categories/Python/机器学习/相关库.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"}]},{"title":"python web django","slug":"python-web-django","date":"2018-01-07T13:39:23.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/python-web-django.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Django的模板语法，如下:</p>\n<pre><code>{ {}} :用于变量替换。\n{%for i in content%}{ {i}}{%endfor%} : for 循环\n{%extends \"base.html\"%} : 用于指定父模板文件\n{%block name %} ··· {%endblock%} :用于指定被替换的内容,内容名称为 name.\n{%if 条件%} .....{% elif 条件%} ....{%else%}... {%endif%} :用于 if 语句</code></pre><p>常用的 ORM 查询操作:</p>\n<pre><code>ModelName.object.all() #返回 model 的所有数据集\n\nModelName.object.filter(**kwargs) #返回符合筛选条件的数据集\n\nModelName.object.exclude(**kwargs) #返回不符合筛选条件的数据集\n\nModelName.object.get(**kwargs) #用于查询单条记录</code></pre><h1 id=\"创建数据\"><a href=\"#创建数据\" class=\"headerlink\" title=\"创建数据\"></a>创建数据</h1><pre><code># 第一种方式\n# models.UserInfo.objects.create(username=&quot;root&quot;,password=&quot;123&quot;)\n# 第二种方式\n# obj = models.UserInfo(username=&apos;fzh&apos;, password=&quot;iajtag&quot;)\n# obj.save()\n# 第三种方式\n# dic = {&apos;username&apos;:&apos;fgf&apos;, &apos;password&apos;:&apos;666&apos;}\n# models.UserInfo.objects.create(**dic)</code></pre><h1 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h1><pre><code># result = models.UserInfo.objects.all()  # 查询所有，为QuerySet类型，可理解成列表\n# result = models.UserInfo.objects.filter(username=&quot;fgf&quot;,password=&quot;666&quot;)  # 列表\n# result = models.UserInfo.objects.filter(username=&quot;fgf&quot;).first()  # 对象\n# 条件查询。filter 相当于where查询条件，里面的&quot;，&quot;会组成and条件\n# for row in result:  # 打印查询到数据。\n#     print(row.id,row.username,row.password)\n\n# 查看QuerySet类型具体做了什么事情，可以： print(result.query)</code></pre><h1 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h1><pre><code># models.UserInfo.objects.all().delete()  # 删除所有\n# models.UserInfo.objects.filter(id=4).delete()  # 删除所有</code></pre><h1 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h1><pre><code># models.UserInfo.objects.all().update(password=8888)\n# models.UserInfo.objects.filter(id=3).update(password=888888)</code></pre><p>数据库(ORM)操作相关: 如果想要完全删除migrations(使用sqllite时),需要将所有缓存文件/夹都删掉 然后新建一个空的migrations</p>\n<blockquote>\n<p>python manage.py makemigrations –empty (你的app名字) python manage.py makemigrations python manage.py migrate 解决!</p>\n</blockquote>\n","text":"Django的模板语法，如下:{ {}} :用于变量替换。{%for i in content%}{ {i}}{%endfor%} : for 循环{%extends \"base.html\"%} : 用于指定父模板文件{%block name %} ··· {%endblock%","link":"","raw":null,"photos":[],"categories":[{"name":"django","slug":"django","count":2,"path":"api/categories/django.json"},{"name":"Python","slug":"django/Python","count":2,"path":"api/categories/django/Python.json"},{"name":"Web","slug":"django/Python/Web","count":2,"path":"api/categories/django/Python/Web.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"},{"name":"django","slug":"django","count":2,"path":"api/tags/django.json"}]},{"title":"python3学习 Class私有成员访问限制","slug":"python3-class-vt","date":"2017-07-15T16:20:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-class-vt.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Visit_limit.py\" target=\"_blank\" rel=\"noopener\">Visit_limit.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[3]:</p>\n<p>‘’’<br>如果要让内部属性不被外部访问，可以把属性的名称前加上<br>两个下划线<strong>，在Python中，实例的变量名如果以</strong>开头，<br>就变成了一个私有变量（private），只有内部可以访问，外<br>部不能访问，<br>‘’’<br>class student(object):<br>    def __init__(self,name,score):<br>        self.<strong>name=name<br>        self.</strong>score=score<br>    def print_score(self):<br>        print(‘%s: %s’ %(self.__name,self.__score))<br>‘’’<br>改完后，对于外部代码来说，没什么变动，但是已经无法从外部<br>访问实例变量.__name和实例变量.__score了:只能通过类内的方法<br>才可以调用这些私有变量<br>‘’’<br>bart = student(‘Bart Simpson’, 98)<br>bart.print_score()<br>print(bart.__name)</p>\n<p># In[4]:</p>\n<p>‘’’<br>如果外部想要获取name和score怎么办,<br>给student类添加get_name和get_score<br>外部想要修改怎么办,set_score</p>\n<p>需要注意的是，在Python中，变量名类似__xxx__的，<br>也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，<br>特殊变量是可以直接访问的，不是private变量，所以，不能用<br>__name__、__score__这样的变量名。</p>\n<p>有些时候，你会看到以一个下划线开头的实例变量名，比如_name<br>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，<br>当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，<br>请把我视为私有变量，不要随意访问”。</p>\n<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。<br>不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，<br>所以，仍然可以通过_Student__name来访问__name变量：<br>‘’’<br>print(bart._student__name)#好神奇</p>\n<p>#但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。</p>\n<p># In[5]:</p>\n<p>#所以如果外界对实例化对象设置私有变量的值,因为上面说了</p>\n<p>#私有变量会被改名为 _student__name这样,所以如果使用</p>\n<p>#bart.__name=’New Name’,则表示在该对象内新建一个变量</p>\n<p>#不影响本来的<strong>name<br>bart.</strong>name=’New name’<br>bart.print_score()</p>\n<p>#out[]: Bart Simpson: 98</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: Visit_limit.py **# coding: utf-8# In[3]:‘’’<br>如果要让内部属性不被外部访问，可以把属性的名称前加上<br>两个下划线，在Python中，实例的变量名如果以开头，<br>就变成了一个私有变量","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 class","slug":"python3-class","date":"2017-07-15T03:52:34.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-class.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/class_.py\" target=\"_blank\" rel=\"noopener\">class_.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[13]:</p>\n<p>class student(object):<br>    #绑定实例属性<br>    #__init__方法的第一个参数永远是self,即实例本身<br>    def __init__(self,name,score):<br>        self.name = name<br>        self.score = score<br>    def print_score(self):<br>        print(“%s: %s” % (self.name,self.score))<br>    def get_grade(self):<br>        if self.score &gt;= 90:<br>            return ‘A’<br>        elif self.score &gt;= 60:<br>            return ‘B’<br>        else:<br>            return ‘C’</p>\n<p>bart=student(‘Bart Simpson’,59)<br>print(bart.name,bart.score,bart)<br>bart.print_score()<br>print(bart.get_grade())</p>\n<p># In[14]:</p>\n<p>#另一种访问方式<br>def pt_score(std):<br>    print(‘%s: %s’ % (std.name,std.score))<br>pt_score(bart)</p>\n<p># In[19]:</p>\n<p>‘’’<br>要定义一个方法，除了第一个参数是self外，其他<br>和普通函数一样。要调用一个方法，只需要在实例<br>变量上直接调用，除了self不用传递，其他参数正常传入：<br>‘’’</p>\n<p>‘’’<br>和静态语言不同，Python允许对实例变量绑定任何数据，也就<br>是说，对于两个实例变量，虽然它们都是同一个类的不同实例，<br>但拥有的变量名称都可能不同：<br>‘’’<br>bart = student(‘Bart Simpson’, 59)<br>lisa = student(‘Lisa Simpson’, 87)<br>bart.age = 8<br>print(bart.age)<br>print(lisa.age)#抛异常</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: class_.py **# coding: utf-8# In[13]:class student(object):<br>    #绑定实例属性<br>    #__init__方法的第一个参数永远是self,即实例本身<br>   ","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 数据库","slug":"python3-database","date":"2017-07-29T01:32:25.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-database.json","excerpt":"","keywords":null,"cover":null,"content":"<p>文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Database\" title=\"Database仓库\" target=\"_blank\" rel=\"noopener\">Database仓库</a></p>\n","text":"文件比较多,主要知识点分为三个方面. 1.Mysql的操作 2.轻型数据库SQLite 3.ORM相关类sqlalchemy github仓库: :point_right:Database仓库","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 装饰器Decorator+log(日志输出)+functools+args","slug":"python3-decoratorlog-functoolsargs","date":"2017-07-14T03:08:37.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-decoratorlog-functoolsargs.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Record】</strong> <strong>函数是对象,也有其属性,比如 f.</strong>name** 获取f控制的函数的名字.** <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/Decorator/Decorator.py\" target=\"_blank\" rel=\"noopener\">Decorator.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#函数也是一个对象,所以可以赋值给变量<br>def now():<br>    print(‘1997-02-10’)<br>f=now<br>f()</p>\n<p># In[3]:</p>\n<p>#函数对象有一个__name__属性,可以拿到其名字<br>print(f.__name__)</p>\n<p># In[5]:</p>\n<p>‘’’<br>现在，假设我们要增强now()函数的功能，比如，<br>在函数调用前后自动打印日志，但又不希望修改<br>now()函数的定义，这种在代码运行期间动态增<br>加功能的方式，称之为“装饰器”（Decorator）。<br>‘’’</p>\n<p>#本质上，decorator就是一个返回函数的高阶函数</p>\n<p>#。所以，我们要定义一个能打印日志的decorator，可以定义如下：<br>def log(func):<br>    def wrapper(*args,**kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args,**kw)<br>    return wrapper<br>‘’’<br>观察上面的log，因为它是一个decorator，所以接受<br>一个函数作为参数，并返回一个函数。我们要借助<br>Python的@语法，把decorator置于函数的定义处：</p>\n<p>调用now()函数，不仅会运行now()函数本身，还会在<br>运行now()函数前打印一行日志：<br>‘’’<br>@log<br>def now2():<br>    print(‘1997-12-11’)<br>now2() </p>\n<p># In[16]:</p>\n<p>#把@log放到now()函数的定义处，相当于执行了语句：</p>\n<p>#now=log(now)<br>‘’’<br>1.wrapper()函数的参数定义是(*args, **kw)，因此，<br>wrapper()函数可以接受任意参数的调用。在wrapper()<br>函数内，首先打印日志，再紧接着调用原始函数。</p>\n<p>2.如果decorator本身需要传入参数，那就需要编写一个返<br>回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>\n<p>‘’’<br>def log2(text):<br>    def decorator(func):<br>        def wrapper(*args,**kw):<br>            print(‘%s %s():’ %(text,func.__name__))<br>            return func(*args,**kw)<br>        return wrapper<br>    return decorator</p>\n<p>#这个3层嵌套的decorator用法如下：<br>@log2(‘execute’)<br>def now3():<br>    print(‘2015-3-25’)<br>now3()</p>\n<p>#三层嵌套是这样的:now = log(‘execute’)(now)</p>\n<p># In[17]:</p>\n<p>‘’’<br>我们来剖析上面的语句，首先执行log(‘execute’)，<br>返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>\n<p>以上两种decorator的定义都没有问题，但还差最后一步。<br>因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数<br>，它们的__name__已经从原来的’now’变成了’wrapper’：<br>‘’’<br>print(now.__name__)</p>\n<p># In[20]:</p>\n<p>‘’’<br>因为返回的那个wrapper()函数名字就是’wrapper’，所以，<br>需要把原始函数的__name__等属性复制到wrapper()函数中，<br>否则，有些依赖函数签名的代码执行就会出错。</p>\n<p>不需要编写wrapper.__name__ = func.__name__这样的代码，<br>Python内置的functools.wraps就是干这个事的，所以，一个<br>完整的decorator的写法如下：<br>‘’’<br>import functools</p>\n<p>def log3(func):<br>    @functools.wraps(func)<br>    def wrapper(*args, **kw):<br>        print(‘call %s():’ % func.__name__)<br>        return func(*args, **kw)<br>    return wrapper</p>\n<p>#或者针对带参数的decorator：<br>def log4(text):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(*args, **kw):<br>            print(‘%s %s():’ % (text, func.__name__))<br>            return func(*args, **kw)<br>        return wrapper<br>    return decorator</p>\n<p># In[22]:</p>\n<p>#题目<br>‘’’<br>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。<br>OOP的装饰模式需要通过继承和组合来实现，而Python除了能支<br>持OOP的decorator外，直接从语法层次支持decorator。Python<br>的decorator可以用函数实现，也可以用类实现。</p>\n<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使<br>用起来非常灵活和方便。</p>\n<p>请编写一个decorator，能在函数调用的前后打印出’begin call’<br>和’end call’的日志。</p>\n<p>再思考一下能否写出一个@log的decorator，使它既支持：</p>\n<p>@log<br>def f():<br>    pass</p>\n<p>又支持：</p>\n<p>@log(‘execute’)<br>def f():<br>    pass<br>‘’’<br>def log5(<em>args1):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(\\</em>args,**kw):<br>            print(‘args1 num =%d’ %len(args1))<br>            print(‘begin %s():’ % func.__name__)<br>            func()<br>            print(‘end %s().\\n’ % func.__name__)<br>        return wrapper<br>    return decorator</p>\n<p>@log5(‘123’,’a’)<br>def dream():<br>    print(‘My Dream.’)</p>\n<p>@log5()<br>def future():<br>    print(‘Must..’)</p>\n<p>dream()<br>future()</p>\n<p>‘’’<br>Out:<br>args1 num =2<br>begin dream():<br>My Dream.<br>end dream().</p>\n<p>args1 num =0<br>begin future():<br>Must..<br>end future().<br>‘’’</p>\n<p># In[ ]:**</p>\n","text":"【Record】 函数是对象,也有其属性,比如 f.name** 获取f控制的函数的名字.** 【Source Code】 github: Decorator.py**# coding: utf-8# In[1]:#函数也是一个对象,所以可以赋值给变量<br>def now():","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"基于python3+mysql+nginx的个人博客","slug":"python3-end-blog-2","date":"2017-08-03T02:11:46.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/python3-end-blog-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg","content":"<p>一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而第三个博客是用nginx,所以使用了不同的端口号,以防冲突): 点击这里=&gt; :octocat:<a href=\"http://be-sunshine.cn:81\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn:81</a> 开源: (github上,暂时还未和python学习篇分开,回头分开再贴,Orz =3 )<del>~</del> 愿我永远有一颗不变的心! <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/07/6afc8b139a04958b4952839b174f6c7c-e1501291934310.jpg\" alt></p>\n","text":"一个月,总算大概跟着廖大的博客搭完了第三个博客.不过这次是用代码写出来的,也搞懂了MVC以及线程池,异步,线程,进程等一系列知识点,但是还是有很多逻辑都没搞懂.下一步就是巩固,以及完善第三个博客,等待各种模块都搭建完毕,正式迁移. 下面是连接咯(因为这个博客是用Apache2,而","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"全栈","slug":"Python/全栈","count":1,"path":"api/categories/Python/全栈.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"全栈","slug":"全栈","count":1,"path":"api/tags/全栈.json"}]},{"title":"python3学习 enumerate","slug":"python3-enumerate","date":"2017-07-16T09:01:37.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-enumerate.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/enumerate.py\" target=\"_blank\" rel=\"noopener\">enumerate.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[15]:</p>\n<p>from enum import Enum<br>Month=Enum(‘Months’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘Jun’, ‘Jul’, ‘Aug’, ‘Sep’, ‘Oct’, ‘Nov’, ‘Dec’))<br>for name,member in Month.__members__.items():<br>    print(name,’=&gt;’,member,’,’,member.value)</p>\n<p># In[17]:</p>\n<p>#如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：<br>from enum import unique<br>@unique<br>class WeekDay(Enum):<br>    Sun = 0 # Sun的value被设定为0<br>    Mon = 1<br>    Tue = 2<br>    Wed = 3<br>    Thu = 4<br>    Fri = 5<br>    Sat = 6</p>\n<p>#@unique装饰器可以帮助我们检查保证没有重复值。<br>day1=WeekDay.Mon<br>print(day1)<br>print(WeekDay[‘Tue’])<br>print(WeekDay.Tue.value)<br>print(day1 == WeekDay.Mon)<br>print(day1 == WeekDay.Tue)<br>print(WeekDay(1))</p>\n<p>for name,member in WeekDay.__members__.items():<br>    print(name,’=&gt;’,member,member.value)</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: enumerate.py **# coding: utf-8# In[15]:from enum import Enum<br>Month=Enum(‘Months’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 筛选器filter+筛回文数+艾氏筛法filter写法","slug":"python3-filter","date":"2017-07-13T08:47:07.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-filter.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/filter/filter.py\" target=\"_blank\" rel=\"noopener\">filter.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>‘’’<br>Python内建的filter()函数用于过滤序列。</p>\n<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>\n<p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：<br>‘’’<br>def is_odd(x):<br>    return x&amp;1==1<br>print(list(filter(is_odd,[1,2,4,5,6,9,10,15])))</p>\n<p># In[2]:</p>\n<p>#把一个序列中的空字符串删掉，可以这么写：<br>def not_empty(s):<br>    return s and s.strip()<br>print(list(filter(not_empty, [‘A’, ‘’, ‘B’, None, ‘C’, ‘  ‘])))</p>\n<p># In[8]:</p>\n<p>#filter实现无穷数的艾筛</p>\n<p>#暂未明白多个filter是怎么筛的<br>def _odd_iter():<br>    n = 1<br>    while True:<br>        n = n + 2<br>        yield n<br>def _not_divisible(n):<br>    return lambda x: x % n &gt; 0<br>def primes():<br>    yield 2<br>    it = _odd_iter() # 初始序列<br>    while True:<br>        n = next(it) # 返回序列的第一个数<br>        yield n<br>        it = filter(_not_divisible(n), it) # 构造新序列<br># 打印1000以内的素数:<br>for n in primes():<br>    if n &lt; 10:<br>        print(n)<br>    else:<br>        break</p>\n<p># In[9]:</p>\n<p>#去除非回文数<br>def is_palindrome(n):<br>    return str(n)==str(n)[::-1]<br># 测试:<br>output = filter(is_palindrome, range(1, 1000))<br>print(list(output))</p>\n<p># In[ ]:</p>\n<p>【前面的问题】<br>果然是嵌套<br>形同:it = filter(_not_divisible(n), it)只是给“奇数生成器”嵌套了一个过滤规则。执行了几次循环之后，这个生成器就成了：<br>(剔除能被7整除的(剔除能被5整除的(剔除能被3整除的(剔除能被2整除的(奇数生成器)))))<br>效率特别差= =**</p>\n","text":"【Source Code】 filter.py **# coding: utf-8# In[1]:‘’’<br>Python内建的filter()函数用于过滤序列。和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 GUI","slug":"python3-gui","date":"2017-07-24T15:35:45.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-gui.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 Tkinter library is this demo’s library. github: :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/GUI/GUI-tk.py\" title=\"GUI-tk.py\" target=\"_blank\" rel=\"noopener\">GUI-tk.py</a></p>\n<pre><code>from tkinter import *\nimport tkinter.messagebox as messagebox\n\nclass Application(Frame):\n    def __init__(self,master=None):\n        Frame.__init__(self,master)\n        self.pack()\n        self.createWidgets()\n\n    def createWidgets(self):\n        self.nameInput=Entry(self)\n        self.nameInput.pack()\n        self.alertButton=Button(self,text=&apos;Hello&apos;,command=self.hello)\n        self.alertButton.pack()\n        self.helloLabel=Label(self,text=&apos;Hello,world!&apos;)\n        self.helloLabel.pack()\n        self.quitButton=Button(self,text=&apos;Quit&apos;,command=self.quit)\n        self.quitButton.pack()\n    def hello(self):\n        name=self.nameInput.get() or &apos;world&apos;\n        messagebox.showinfo(&apos;Message&apos;,&apos;Hello, %s&apos; % name)\napp=Application()\n#设置窗口标题\napp.master.title(&apos;Hello World&apos;)\n#启动消息循环\napp.mainloop()</code></pre>","text":"【Source Code】 Tkinter library is this demo’s library. github: :point_right:GUI-tk.pyfrom tkinter import *import tkinter.messagebox as messag","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 多态和继承","slug":"python3-inheritance-and-polymorphisn","date":"2017-07-15T16:44:40.000Z","updated":"2019-07-03T13:51:36.853Z","comments":true,"path":"api/articles/python3-inheritance-and-polymorphisn.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/class/Inheritance_and_polymorphisn.py\" target=\"_blank\" rel=\"noopener\">Inheritance_and_polymorphisn.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[5]:</p>\n<p>‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称为子类（Subclass），而被继<br>承的class称为基类、父类或超类（Base class、Super class）。<br>‘’’</p>\n<p>#比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：<br>class Animal(object):<br>    def run(self):<br>        print(‘Animal is running…’)</p>\n<p>#当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：<br>class Dog(Animal):<br>    pass<br>class Cat(Animal):<br>    pass<br>‘’’<br>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是<br>它的子类。Cat和Dog类似。</p>\n<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由<br>于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什<br>么事也没干，就自动拥有了run()方法：<br>‘’’<br>dog=Dog()<br>dog.run()<br>cat=Cat()<br>cat.run()</p>\n<p>#当子类和父类都存在相同的run()方法时，我们说，</p>\n<p>#子类的run()覆盖了父类的run()，在代码运行的时候，</p>\n<p>#总是会调用子类的run()。这样，我们就获得了继承的</p>\n<p>#另一个好处：多态。<br>class Puppy(Animal):<br>    def run(self):<br>        print(‘Puppy is running…’)<br>class Shark(Animal):<br>    def run(self):<br>        print(‘Shark is running…’)<br>puppy=Puppy()<br>puppy.run()</p>\n<p># In[7]:</p>\n<p>#判断一个变量是否是某个类型可以用isinstance()判断：</p>\n<p>#可以发现,puppy可以使Animal也可以是Puppy.<br>print(isinstance(puppy,Animal))<br>print(isinstance(puppy,Puppy))<br>b=Animal()<br>print(isinstance(b,Puppy))</p>\n<p>#所以，在继承关系中，如果一个实例的数据类型是某个子类</p>\n<p>#，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p>\n<p># In[12]:</p>\n<p>#要理解多态的好处，我们还需要再编写一个函数，这个函数接受</p>\n<p>#一个Animal类型的变量：<br>def run_twice(animal):<br>    animal.run()<br>    animal.run()<br>run_twice(Dog())<br>run_twice(Puppy())<br>run_twice(Shark())</p>\n<p># In[ ]:</p>\n<p>‘’’<br>多态的好处在于:</p>\n<p>新增一个Animal的子类，不必对  –run_twice()–<br>做任何修改，实际上，任何依赖Animal作为参数的函<br>数或者方法都可以不加修改地正常运行，原因就在于<br>多态。</p>\n<p>著名的“开闭”原则：</p>\n<p>对扩展开放：允许新增Animal子类；</p>\n<p>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则<br>传入的对象必须是Animal类型或者它的子类，否则，将无法调用<br>run()方法。</p>\n<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。<br>我们只需要保证传入的对象有一个run()方法就可以了：</p>\n<p>class Timer(object):<br>    def run(self):<br>        print(‘Start…’)</p>\n<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一<br>个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看<br>做是鸭子。<br>‘’’**</p>\n","text":"【Source Code】 github: Inheritance_and_polymorphisn.py **# coding: utf-8# In[5]:‘’’<br>在OOP程序设计中，当我们定义一个class的时候，可以从某个<br>现有的class继承，新的class称","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 迭代+enumrate","slug":"python3-iterations-enumrate","date":"2017-07-12T01:26:17.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python3-iterations-enumrate.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/iteration/%E8%BF%AD%E4%BB%A3.py\" target=\"_blank\" rel=\"noopener\">迭代.py</a></strong></p>\n<blockquote>\n<p>**# coding: utf-8</p>\n<p># In[2]:</p>\n<p>d={‘a’:1,’b’:2,’c’:3}<br>for key in d:<br>    print(key)</p>\n<p># In[5]:</p>\n<p>for ch in ‘ABC’:<br>    print(ch)</p>\n<p># In[1]:</p>\n<p>#判断是否可迭代<br>from collections import Iterable<br>print(isinstance(‘abc’,Iterable))<br>print(isinstance([1,2,3],Iterable))<br>print(isinstance(123,Iterable))</p>\n<p># In[8]:</p>\n<p>for i,value in enumerate([‘A’,’B’,’C’]):<br>    print(i,value)<br>print(enumerate([‘A’,’B’,’C’]))</p>\n<p>#enumerate是枚举,列举的意思</p>\n<p>#如果对于一个列表,既要遍历索引又要遍历元素时,首先可以这样写<br>list1 = [“这”, “是”, “一个”, “测试”]<br>for i in range (len(list1)):<br>    print(i ,list1[i])<br>print(‘\\n’)</p>\n<p>#但这样很麻烦,所以可以用enumrate这样写<br>for i,value in enumerate(list1):<br>    print(i,value)<br>print(‘\\n’)</p>\n<p>#enumerate还可以接受第二个参数,用于指定初始索引<br>for i,value in enumerate(list1,1):<br>    print(i,value)<br>print(‘\\n’)</p>\n<p># In[9]:</p>\n<p>#在for循环里,同时引用两个变量<br>for x,y in [(1,1),(2,2),(3,3)]:<br>    print(x,y)</p>\n<p># In[ ]:</p>\n<p>#end**</p>\n</blockquote>\n","text":"【Source Code】 迭代.py**# coding: utf-8# In[2]:d={‘a’:1,’b’:2,’c’:3}<br>for key in d:<br>    print(key)# In[5]:for ch in ‘ABC’:<br>    print(ch","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 列表生成式+isinstance","slug":"python3-listcomprehension","date":"2017-07-12T05:44:56.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python3-listcomprehension.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/List_Comprehensions/%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F.py\" target=\"_blank\" rel=\"noopener\">列表生成式.py</a></strong></p>\n<blockquote>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br>li=list(range(1,11))<br>print(li)</p>\n<p># In[2]:</p>\n<p>#但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：<br>L=[]<br>for x in range(1,11):<br>    L.append(x*x)<br>print(L)</p>\n<p># In[3]:</p>\n<p>#但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：<br>R=[x*x for x in range(1,11)]<br>print(R)</p>\n<p># In[12]:</p>\n<p>#for循环后还可以加上if这样我们就可以筛出仅偶数的平方</p>\n<p>#x&amp;x-1是判断x是否是2的幂，x&amp;1为1为奇<br>R=[x*x for x in range(1,11) if not(x&amp;1)]<br>print(R)</p>\n<p># In[14]:</p>\n<p>#还可以使用两层循环，可以生成全排列：<br>T=[m+n for m in ‘ABC’ for n in ‘XYZ’]<br>print(T)</p>\n<p># In[2]:</p>\n<p>#运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：<br>import os # 导入os模块，模块的概念后面讲到<br>OS=[d for d in os.listdir(‘.’)]# os.listdir可以列出文件目录<br>print(OS)<br># Out [1]: [‘.anaconda’, ‘.android’, ‘.bash_history’, ‘.conda’, ‘.condarc’, ‘.gem’, ‘.gemrc’, ‘.gitconfig’, ‘.idlerc’, ‘.ipynb_checkpoints’, ‘.ipython’, ‘.jupyter’, ‘.oracle_jre_usage’, ‘.packettracer’, ‘.ssh’, ‘.viminfo’, ‘360驱动大师.lnk’, ‘ACDSee5.lnk’, ‘AppData’, ‘Application Data’, ‘Cisco Packet Tracer 6.2sv’, ‘Contacts’, ‘Cookies’, ‘Desktop’, ‘Documents’, ‘Downloads’, ‘fancy_deboss.png’, ‘Favorites’, ‘fontawesome-webfont.svg’, ‘IntelGraphicsProfiles’, ‘Links’, ‘Local Settings’, ‘Music’, ‘My Documents’, ‘NetHood’, ‘NTUSER.DAT’, ‘ntuser.dat.LOG1’, ‘ntuser.dat.LOG2’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TM.blf’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000001.regtrans-ms’, ‘NTUSER.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000002.regtrans-ms’, ‘ntuser.ini’, ‘ntuser.pol’, ‘Pictures’, ‘PrintHood’, ‘Recent’, ‘Saved Games’, ‘Searches’, ‘SendTo’, ‘Templates’, ‘Test.ipynb’, ‘Videos’, ‘wc’, ‘WebpageIcons.db’, ‘WIN7激活工具’, ‘XT.DAT.LOG1’, ‘XT.DAT.LOG2’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TM.blf’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000001.regtrans-ms’, ‘xt.DAT{016888bd-6c6f-11de-8d1d-001e0bcde3ec}.TMContainer00000000000000000002.regtrans-ms’, ‘「开始」菜单’, ‘列表生成式.ipynb’, ‘宽带连接.lnk’, ‘迭代.ipynb’, ‘迭代.py’]</p>\n<p># In[3]:</p>\n<p>#for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：<br>d={‘x’:’A’,’y’:’B’,’z’:’C’}<br>for k,v in d.items():<br>    print(k,’=’,v)</p>\n<p># In[5]:</p>\n<p>#因此,列表生成式也可以用两个变量生成list:<br>dp=[k+’=’+v for k,v in d.items()]<br>print(dp)</p>\n<p># In[6]:</p>\n<p>#最后把一个list中的字母全变成小写:<br>L=[‘Hello’,’World’,’IBM’,’Apple’]<br>Lp=[s.lower() for s in L]<br>print(Lp)</p>\n<p># In[7]:</p>\n<p>#使用内建的isinstance(key,type)可以判断key是否是type</p>\n<p>#例:<br>L1 = [‘Hello’, ‘World’, 18, ‘Apple’, None]<br>L2=[k.lower() for k in L1 if isinstance(k,str)]<br>print(L2)</p>\n<p># In[ ]:**</p>\n</blockquote>\n","text":"【Source Code】 列表生成式.py **# coding: utf-8# In[1]:#举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br>li=list(range(1,11))<","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 map&reduce+浮点字符串转换浮点数+英文姓名规范+一点点lambda","slug":"python3-map-reduce","date":"2017-07-13T08:03:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-map-reduce.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/map%26reduce/map_reduce.py\" target=\"_blank\" rel=\"noopener\">map_reduce.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[2]:</p>\n<p>#我们先看map。map()函数接收两个参数，一个是函数，</p>\n<p>#一个是Iterable，map将传入的函数依次作用到序列的</p>\n<p>#每个元素，并把结果作为新的Iterator返回。</p>\n<p>#现在,我们用python代码实现1-9映射到x^2<br>def f(x):<br>    return x*x<br>r=map(f,[x for x in range(10)])<br>print(list(r))</p>\n<p>#map()传入的第一个参数是f，即函数对象本身。由于结</p>\n<p>#果r是一个Iterator，Iterator是惰性序列，因此通过</p>\n<p>#list()函数让它把整个序列都计算出来并返回一个list。</p>\n<p># In[3]:</p>\n<p>#将数字转换成字符<br>print(list(map(str,[x for x in range(1,10)])))</p>\n<p># In[4]:</p>\n<p>#reduce<br>‘’’<br>再看reduce的用法。reduce把一个函数作用在一个序列<br>[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce<br>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>\n<p>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>当然,可以直接用sum()<br>‘’’<br>from functools import reduce<br>def add(x,y):<br>    return x+y<br>print(reduce(add,[x for x in range(1,10)]))</p>\n<p># In[5]:</p>\n<p>#如果将[1，3，5，7，9]变成13579<br>def fn(x,y):<br>    return x*10+y<br>print(reduce(fn,[x for x in range(1,10,2)]))</p>\n<p># In[6]:</p>\n<p>‘’’<br>这个例子本身没多大用处，但是，如果考虑到字符串<br>str也是一个序列，对上面的例子稍加改动，配合map()，<br>我们就可以写出把str转换为int的函数：<br>‘’’<br>def char2num(s):<br>    return {‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9}[s]<br>print(reduce(fn, map(char2num, ‘13579’)))</p>\n<p># In[7]:</p>\n<p>#也可以直接返回转换结果<br>def str2int(s):<br>    return reduce(fn, map(char2num, s))<br>print(str2int(‘98661’))</p>\n<p># In[9]:</p>\n<p>#还可以用lambda函数进一步转化，事实证明Python的整数运算是大数= =</p>\n<p>#当然,可以直接用int()<br>def str2int(s):<br>    return reduce(lambda x,y:x*10+y,map(char2num,s))<br>print(str2int(‘46131346431311616131’))</p>\n<p># In[10]:</p>\n<p>#利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，</p>\n<p>#其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：</p>\n<p>#[‘Adam’, ‘Lisa’, ‘Bart’]：<br>def normalize(name):<br>    return name[0].upper()+name[1:].lower()<br># 测试:<br>L1 = [‘adam’, ‘LISA’, ‘barT’]<br>L2 = list(map(normalize, L1))<br>print(L2)</p>\n<p># In[11]:</p>\n<p>#Python提供的sum()函数可以接受一个list并求和，请编写一个prod()</p>\n<p>#函数，可以接受一个list并利用reduce()求积：<br>def prod(L):<br>    return reduce(lambda x,y:x*y,L)<br>print(‘3 * 5 * 7 * 9 =’, prod([3, 5, 7, 9]))</p>\n<p># In[20]:</p>\n<p>#利用map和reduce编写一个str2float函数，把字符串’123.456’转换成浮点数123.456：<br>def str2float(s):<br>    n,l=s.find(‘.’),len(s)<br>    if n!=-1:<br>        return reduce(lambda x,y:x<em>10+y,map(lambda x:int(x),s[:n]))+reduce(lambda x,y:x/10+y,map(lambda x:int(x)/10,s[l-1:n:-1]))<br>    else:<br>        return reduce(lambda x,y:x</em>10+y,map(lambda x:int(x),s))<br>print(‘str2float(\\‘166516516.1133165\\‘) =’, str2float(‘166516516.1133165’))</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: map_reduce.py **# coding: utf-8# In[2]:#我们先看map。map()函数接收两个参数，一个是函数，#一个是Iterable，map将传入的函数依次作用到序列的#每个元素，并把结果作为新的Iterat","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 多进程+进程池+进程间通信+子进程","slug":"python3-multiprocess","date":"2017-07-19T06:29:28.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-multiprocess.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:</strong></p>\n<ol>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/multiprocessing_test.py\" target=\"_blank\" rel=\"noopener\">multiprocessing_test.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E5%AD%90%E8%BF%9B%E7%A8%8B.py\" target=\"_blank\" rel=\"noopener\">子进程.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E8%BF%9B%E7%A8%8B%E6%B1%A0.py\" target=\"_blank\" rel=\"noopener\">进程池.py</a></strong></li>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.py\" target=\"_blank\" rel=\"noopener\">进程间通信.py</a></strong></li>\n</ol>\n<p><strong>不贴代码了..略多.点上面得超链接进github↑↑</strong></p>\n","text":"【Source Code】 github:multiprocessing_test.py子进程.py进程池.py进程间通信.py不贴代码了..略多.点上面得超链接进github↑↑","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 多-线-程","slug":"python3-multilwp","date":"2017-07-19T06:40:14.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-multilwp.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:</strong></p>\n<ol>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/%E5%A4%9A%E7%BA%BF%E7%A8%8B.py\" target=\"_blank\" rel=\"noopener\">多线程.py</a></strong></li>\n</ol>\n<p>**import time,threading</p>\n<p>#新线程执行的代码:<br>def loop():<br>    print(‘thread %s is running…’ % threading.current_thread().name)<br>    n=0<br>    while n&lt;5: n=n+1 print(‘thread %s &gt;&gt;&gt; %s’ % (threading.current_thread().name,n))<br>        time.sleep(1)<br>    print(‘thread %s ended.’ % threading.current_thread().name)</p>\n<p>print(‘thread %s is running…’ % threading.current_thread().name)<br>t=threading.Thread(target=loop,name=’LoopThread’)<br>t.start()<br>t.join()<br>print(‘thread %s ended.’ % threading.current_thread().name)</p>\n<p>‘’’<br>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷<br>贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共<br>享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共<br>享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br>‘’’</p>\n<p>#高级语言计算顺序<br>‘’’<br>    balance = balance + n</p>\n<p>分两步：</p>\n<pre><code>计算balance + n，存入临时变量中；\n将临时变量的值赋给balance。</code></pre><p>你也不希望你的存款莫名其妙变成负数吧.<br>所以如果想要计算正确,就要给change_it()上一把锁当某个线程开始执行<br>change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时<br>执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。由<br>于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以<br>，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现：<br>‘’’</p>\n<p>#但可能因为锁阻止了多线程并发执行，包含锁的代码只能单线程模式执行</p>\n<p>#另外,由于多个所由于可以存在多个锁，不同的线程持有不同的锁，并试图</p>\n<p>#获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执</p>\n<p>#行，也无法结束，只能靠操作系统强制终止。</p>\n<p>#–示例<br>import time, threading</p>\n<p># 假定这是你的银行存款:<br>balance = 0</p>\n<p>def change_it(n):<br>    # 先存后取，结果应该为0:<br>    global balance<br>    balance = balance + n<br>    balance = balance - n</p>\n<p>lock = threading.Lock()</p>\n<p>def run_thread(n):<br>    for i in range(100000):<br>        # 先要获取锁:<br>        lock.acquire()<br>        try:<br>            # 放心地改吧:<br>            change_it(n)<br>        finally:<br>            # 改完了一定要释放锁:<br>            lock.release()</p>\n<p>t1 = threading.Thread(target=run_thread, args=(5,))<br>t2 = threading.Thread(target=run_thread, args=(8,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)</p>\n<p>#由于Python历史遗留的GIL问题,如果一个线程满CPU</p>\n<p>#基本上只能以单核来执行线程,如果想要实现彻底的多核线程</p>\n<p>#要用C扩展**</p>\n","text":"【Source Code】 github:多线程.py**import time,threading#新线程执行的代码:<br>def loop():<br>    print(‘thread %s is running…’ % threading.current_thread(","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 oop-多重继承+MixIn","slug":"python3-oop-mixin","date":"2017-07-16T05:56:37.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-oop-mixin.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/Multi%20inheritance.py\" target=\"_blank\" rel=\"noopener\">Multi inheritance.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>#采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：<br>class Animal(object):<br>    pass</p>\n<p># 大类:<br>class Mammal(Animal):<br>    pass</p>\n<p>class Bird(Animal):<br>    pass</p>\n<p># 各种动物:<br>class Dog(Mammal):<br>    pass</p>\n<p>class Bat(Mammal):<br>    pass</p>\n<p>class Parrot(Bird):<br>    pass</p>\n<p>class Ostrich(Bird):<br>    pass</p>\n<p>#现在，我们要给动物再加上Runnable和Flyable的功能，</p>\n<p>#只需要先定义好Runnable和Flyable的类：<br>class Runnable(object):<br>    def run(self):<br>        print(‘Running…’)</p>\n<p>class Flyable(object):<br>    def fly(self):<br>        print(‘Flying…’)</p>\n<p>#对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：<br>class Dog(Mammal, Runnable):<br>    pass</p>\n<p>#对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：<br>class Bat(Mammal, Flyable):<br>    pass</p>\n<p>#通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>\n<p># In[4]:</p>\n<p>‘’’<br>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<br>Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多<br>重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继<br>承Runnable。这种设计通常称之为MixIn。</p>\n<p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn<br>和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和<br>植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>\n<p>class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):<br>    pass<br>‘’’</p>\n<p>‘’’<br>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>\n<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>\n<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>\n<p>class MyTCPServer(TCPServer, ForkingMixIn):<br>    pass</p>\n<p>编写一个多线程模式的UDP服务，定义如下：</p>\n<p>class MyUDPServer(UDPServer, ThreadingMixIn):<br>    pass</p>\n<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>\n<p>class MyTCPServer(TCPServer, CoroutineMixIn):<br>    pass</p>\n<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>\n<p>‘’’</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: Multi inheritance.py **# coding: utf-8# In[1]:#采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：<br>class Animal(object):<br>    pass# 大类:<","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 偏函数Partial_function+args+kw","slug":"python3-partial-functionargskw","date":"2017-07-14T07:20:06.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-partial-functionargskw.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/Partial_function/Partial_function.py\" target=\"_blank\" rel=\"noopener\">github: Partial_Function.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[2]:</p>\n<p>#Partial function包含在functools中</p>\n<p>#int可以将字符串转换成整形<br>print(‘十进制: ‘,int(‘123456’),’\\n’)</p>\n<p># In[12]:</p>\n<p>#但int()函数还提供额外的base参数，默认值为10。</p>\n<p>#如果传入base参数，就可以做N进制的转换：<br>print(‘十六进制转十进制: ‘,int(‘E123456’,16),’\\n’)</p>\n<p># In[13]:</p>\n<p>#假设要转换大量的二进制字符串，每次都传入int(x, base=2)</p>\n<p>#非常麻烦，于是，我们想到，可以定义一个int2()的函数，默</p>\n<p>#认把base=2传进去：<br>def int2(x, base=2):<br>    return int(x, base)<br>print(‘二进制转十进制: ‘,int2(‘1000000’))<br>print(‘二进制转十进制: ‘,int2(‘1010101’))</p>\n<p># In[14]:</p>\n<p>#functools.partial就是帮助我们创建一个偏函数的，不需要我</p>\n<p>#们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：<br>import functools<br>int3=functools.partial(int,base=2)<br>print(‘二进制转十进制: ‘,int3(‘1000000’))<br>print(‘二进制转十进制: ‘,int3(‘1010101’))</p>\n<p># In[22]:</p>\n<p>‘’’<br>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：</p>\n<p>int2 = functools.partial(int, base=2)</p>\n<p>实际上固定了int()函数的关键字参数base，也就是：</p>\n<p>int2(‘10010’)</p>\n<p>相当于：</p>\n<p>kw = { ‘base’: 2 }<br>int(‘10010’, **kw)</p>\n<p>当传入：</p>\n<p>max2 = functools.partial(max, 10)</p>\n<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>\n<p>max2(5, 6, 7)</p>\n<p>相当于：</p>\n<p>args = (10, 5, 6, 7)<br>max(*args)</p>\n<p>‘’’</p>\n<p>max2 = functools.partial(max)<br>args = (10, 5, 6, 7)<br>print(max2(*args))</p>\n<p>#out:10<br>max3 = functools.partial(max,102)<br>args = (10, 5, 6, 7)<br>print(max3(*args))</p>\n<p>#OUT:102**</p>\n","text":"【Source Code】 github: Partial_Function.py **# coding: utf-8# In[2]:#Partial function包含在functools中#int可以将字符串转换成整形<br>print(‘十进制: ‘,int(‘12345","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 @property","slug":"python3-property","date":"2017-07-16T05:36:11.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-property.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/property.py\" target=\"_blank\" rel=\"noopener\">property.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[2]:</p>\n<p>‘’’<br>还记得装饰器（decorator）可以给函数动态加上功能吗？<br>对于类的方法，装饰器一样起作用。Python内置的@property<br>装饰器就是负责把一个方法变成属性调用的：<br>‘’’<br>class Student(object):<br>    @property<br>    def score(self):<br>        return self._score<br>    @score.setter<br>    def score(self,value):<br>        if not isinstance(value,int):<br>            raise ValueError(‘score must be an integer!’)<br>        if value &lt; 0 or value &gt; 100:<br>            raise ValueError(‘score must between 0 ~ 100!’)<br>        self._score = value<br>‘’’<br>@property的实现比较复杂，我们先考察如何使用。把一个getter方<br>法变成属性，只需要加上@property就可以了，此时，@property本身<br>又创建了另一个装饰器@score.setter，负责把一个setter方法变成属<br>性赋值，于是，我们就拥有一个可控的属性操作：</p>\n<p>相当于 Get Set<br>‘’’<br>a=Student()<br>a.score = 60 # OK，实际转化为a.set_score(60)<br>print(a.score)# OK，实际转化为s.get_score()</p>\n<p># In[3]:</p>\n<p>#a.score=9999  ValueError(‘score must between 0 ~ 100!’)</p>\n<p>#还可以定义只读属性，只定义getter方法，不定义setter方法</p>\n<p>#就是一个只读属性：<br>class Student(object):</p>\n<pre><code>@property\ndef birth(self):\n    return self._birth\n\n@birth.setter\ndef birth(self, value):\n    self._birth = value\n\n@property\ndef age(self):\n    return 2015 - self._birth</code></pre><p>#上面的birth是可读写属性，而age就是一个只读属性，因为age</p>\n<p>#可以根据birth和当前时间计算出来。</p>\n<p>‘’’<br>练习</p>\n<p>请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：<br>‘’’<br>class Screen(object):<br>    @property<br>    def width(self):<br>        return self._width<br>    @width.setter<br>    def width(self,value):<br>        self._width=value<br>    @property<br>    def height(self):<br>        return self._height<br>    @height.setter<br>    def height(self,value):<br>        self._height=value<br>    @property<br>    def resolution(self):<br>        return self.width*self.height<br># test:<br>s = Screen()<br>s.width = 1024<br>s.height = 768<br>print(s.resolution)<br>assert s.resolution == 786432, ‘1024 * 768 = %d ?’ % s.resolution</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: property.py**# coding: utf-8# In[2]:‘’’<br>还记得装饰器（decorator）可以给函数动态加上功能吗？<br>对于类的方法，装饰器一样起作用。Python内置的@property<br>装饰器","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 PIL图像处理库","slug":"python3-pillow","date":"2017-07-24T10:42:57.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-pillow.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi.py\" title=\"pi.py\" target=\"_blank\" rel=\"noopener\">pi.py</a></p>\n<pre><code>from PIL import Image\n\n#打开一个jpg文件,是当前路径\nim=Image.open(&apos;test.jpg&apos;)\n#获得图像尺寸\nw,h=im.size\nprint(&apos;Original Image size: %sx%s&apos; % (w,h))\n#缩放到50%\nim.thumbnail((w//2,h//2))\nprint(&apos;Resize image to: %sx%s&apos; %(w//2,h//2))\n#把缩放后的图像用jpeg保存\nim.save(&apos;thumbnail.jpg&apos;,&apos;jpeg&apos;)</code></pre><p>2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi2.py\" title=\"pi2.py\" target=\"_blank\" rel=\"noopener\">pi2.py</a></p>\n<pre><code>from PIL import Image,ImageFilter\n#打开一个文件,当前路径\nim=Image.open(&apos;test.jpg&apos;)\n#应用模糊滤镜\nim2=im.filter(ImageFilter.BLUR)\nim2.save(&apos;blur.jpg&apos;,&apos;jpeg&apos;)</code></pre><p>3.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/PIL/pi3.py\" title=\"pi3.py\" target=\"_blank\" rel=\"noopener\">pi3.py</a></p>\n<pre><code>from PIL import Image,ImageDraw,ImageFont,ImageFilter\n\nimport random\n\n#随机字母\ndef rndChar():\n    return chr(random.randint(65,90))\n#随机颜色1;\ndef rndColor():\n    return (random.randint(64,255),random.randint(64,255),random.randint(64,255))\n#随机颜色2\ndef rndColor2():\n    return (random.randint(32,255),random.randint(32,255),random.randint(32,255))\n\n#240*60\nwidth=240\nheight=60\nimage=Image.new(&apos;RGB&apos;,(width,height),(255,255,255))\n#穿件Font对象\nfont=ImageFont.truetype(&apos;Arial.ttf&apos;,36)\n#创建Draw对象\ndraw=ImageDraw.Draw(image)\n#填充每个像素\nfor x in range(width):\n    for y in range(height):\n        draw.point((x,y),fill=rndColor())\n#输出文字\nfor t in range(4):\n    draw.text((60*t+10,10),rndChar(),font=font,fill=rndColor2())\n#模糊:\nimage=image.filter(ImageFilter.BLUR)\nimage.save(&apos;code.jpg&apos;,&apos;jpeg&apos;)</code></pre>","text":"【Source Code】 github: 1.:point_right:pi.pyfrom PIL import Image#打开一个jpg文件,是当前路径im=Image.open(&apos;test.jpg&apos;)#获得图像尺寸w,h=im.sizeprint(&a","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 正则表达式","slug":"python3-regular-expression","date":"2017-07-20T12:42:52.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-regular-expression.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】</p>\n<ul>\n<li><p>:point_right:<a href=\"https://github.com/834930269/python_study/tree/master/Regular%20Expression\" title=\"Regular Expression模块\" target=\"_blank\" rel=\"noopener\">Regular Expression模块</a></p>\n<p>s=’ABC\\-001’#对应正则表达式字符串为’ABC-001’<br>#因为python本身需要转义,但用 r 前缀的话,就可以忽略转义字符了<br>s=r’ABC-001’<br>import re<br>print(‘成功的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010-12345’))<br>print(‘失败的匹配:’)<br>print(re.match(r’^\\d{3}-\\d{3,8}$’,’010 12345’))</p>\n<p>test=’用户输入的字符串’<br>if re.match(r’正则表达式’,test):</p>\n<pre><code>print(&apos;ok&apos;)</code></pre><p>else:</p>\n<pre><code>print(&apos;failed&apos;)</code></pre><p>#切分字符串<br>#用正则表达式切分字符串比用固定的字符更灵活,<br>print(‘a b   c’.split(‘ ‘))<br>#[‘a’, ‘b’, ‘’, ‘’, ‘c’],无法识别连续的空格<br>#用正则表达式试试<br>print(re.split(r’\\s+’,’a b   c’))<br>#[‘a’, ‘b’, ‘c’]<br>print(re.split(r’[\\s,;]+’, ‘a,b;; c  d’))<br>#[‘a’, ‘b’, ‘c’, ‘d’]</p>\n<p>#分组<br>m=re.match(r’^(\\d{3})-(\\d{3,8})$’,’010-12345’)<br>print(m)<br>print(‘m.group(0): ‘,m.group(0),’\\nm.group(1): ‘,m.group(1),’\\nm.group(2): ‘,m.group(2))</p>\n<p>‘’’<br>^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从<br>匹配的字符串中提取出区号和本地号码</p>\n<p>如果正则表达式中定义了组，就可以在Match对象上用<br>group()方法提取出子串来。<br>‘’’<br>#提取时间<br>t=’19:05:30’<br>m=re.match(r’^(0[0-9]|1[0-9]|2[0-3]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$’,t)<br>print(m.groups())</p>\n<p>#这样可以直接匹配出合法时间,但有些时候,正则也无法完全验证,这时候就要配合程序了</p>\n<p>#贪婪匹配<br>#正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符<br>print(re.match(r’^(\\d+)(0<em>)$’, ‘102300’).groups())<br>#Out[]:(‘102300’, ‘’)<br>#由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0</em>只能匹配空字符串了。</p>\n<p>#必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，<br>#加个?就可以让\\d+采用非贪婪匹配：</p>\n<p>#尽可能少 匹配<br>print(re.match(r’^(\\d+?)(0*)$’, ‘102300’).groups())<br>#out[]:(‘1023’, ‘00’)</p>\n<p>#编译<br>‘’’<br>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>\n<pre><code>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；\n\n用编译后的正则表达式去匹配字符串。</code></pre><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预<br>编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br>‘’’<br>re_telephone = re.compile(r’^(\\d{3})-(\\d{3,8})$’)<br>print(re_telephone.match(‘010-12345’).groups())<br>print(re_telephone.match(‘010-8086’).groups())</p>\n</li>\n</ul>\n<pre><code>#邮箱匹配1\nimport re\nEmail=input(&apos;please enter the Email:&apos;)\nre_mode=re.compile(r&apos;&lt;([a-zA-Z]* [a-zA-Z]*)&gt; [\\w.]*@\\w+.[a-z]*&apos;)\nwe=re_mode.match(Email)\nif we:\n    print(we.groups())\nelse:\n    print(&apos;failed!&apos;)\n\n#邮箱匹配2\nimport re\n&apos;&apos;&apos;\n&gt;&gt;&gt; 834930269@qq.com\nok!\n&apos;&apos;&apos;\ntest=input(&apos;please enter:&apos;)\nre_mode=re.compile(r&apos;[0-9a-zA-Z._]*@\\w+.com&apos;)\nif re_mode.match(test):\n    print(&apos;ok!&apos;)\nelse:\n    print(&apos;failed!&apos;)</code></pre>","text":"【Source Code】:point_right:Regular Expression模块s=’ABC\\-001’#对应正则表达式字符串为’ABC-001’<br>#因为python本身需要转义,但用 r 前缀的话,就可以忽略转义字符了<br>s=r’ABC-001’<br>i","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 __slots__","slug":"python3-slots","date":"2017-07-16T04:40:11.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-slots.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/oop/slots.py\" target=\"_blank\" rel=\"noopener\">slots.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[6]:</p>\n<p>class Student(object):<br>    pass<br>s=Student()<br>s.name=’Michael’<br>print(s.name)</p>\n<p>#还可以尝试给实例绑定一个方法：<br>def set_age(self,age):<br>    self.age=age<br>from types import MethodType<br>s.set_age=MethodType(set_age,s)#绑定方法<br>s.set_age(25)<br>print(s.age)</p>\n<p>#但是，给一个实例绑定的方法，对另一个实例是不起作用的：<br>s2=Student()</p>\n<p>#s2.set_age(25)</p>\n<p># In[8]:</p>\n<p>#为了给所有实例都绑定方法，可以给class绑定方法：<br>def set_score(self,score):<br>    self.score=score<br>Student.set_score=set_score</p>\n<p>#给class绑定方法后，所有实例均可调用：<br>s.set_score(20)<br>s2.set_score(30)<br>print(s.score,s2.score)</p>\n<p># In[9]:</p>\n<p>#使用__slots__</p>\n<p>#但是，如果我们想要限制实例的属性怎么办？比如，</p>\n<p>#只允许对Student实例添加name和age属性。</p>\n<p>#为了达到限制的目的，Python允许在定义class的时候，</p>\n<p>#定义一个特殊的__slots__变量，来限制该class实例能添加的属性：<br>class student(object):<br>    __slots__ = (‘name’, ‘age’) # 用tuple定义允许绑定的属性名称<br>s=student()<br>s.name=’Michael’<br>s.age=8</p>\n<p>#s.score=20#AttributeError</p>\n<p># In[10]:</p>\n<p>#使用__slots__要注意，__slots__定义的属性仅</p>\n<p>#对当前类实例起作用，对继承的子类是不起作用的：<br>class GraduateStudent(student):<br>    pass<br>g = GraduateStudent()<br>g.score=9999#没抛异常</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: slots.py **# coding: utf-8# In[6]:class Student(object):<br>    pass<br>s=Student()<br>s.name=’Michael’<br>print(s.nam","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 ThreadLocal线程局部变量","slug":"python3-threadloca","date":"2017-07-19T07:43:31.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-threadloca.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>局部变量传递,避免使用线程锁</strong> <strong>github:</strong></p>\n<ul>\n<li><strong><a href=\"https://github.com/834930269/python_study/blob/master/multiprocessing/ThreadLocal.py\" target=\"_blank\" rel=\"noopener\">ThreadLocal.py</a></strong></li>\n</ul>\n<p>**#Thread-较量级线程</p>\n<p>#建议在多线程环境下用局部变量,但传递变量传递很麻烦</p>\n<p>‘’’<br>def process_student(name):<br>    std=Student(name)<br>    #std是局部变量,但是每个函数都要用它,因此必须传过去<br>    #一层一层的传<br>    do_task_1(std)<br>    do_task_2(std)</p>\n<p>def do_task_1(std):<br>    do_subtask_1(std)<br>    do_subtask_1(std)</p>\n<p>def do_task_2(std):<br>    do_subtask_2(std)<br>    do_subtask_2(std)<br>‘’’</p>\n<p>#考虑,以每层的thread对象作为key,值为操作对象</p>\n<p>class Student:<br>    def __init__(self,name):<br>        self.name=name</p>\n<p>global_dict = {}<br>def std_thread(name):<br>    std=Student(name)<br>    #吧std放到全局变量中dict中<br>    global_dict[threading.current_thread()]=std<br>    do_task_1()<br>    do_task_2()</p>\n<p>def do_task_1():<br>    #不传入std,而是根据当前线程查找<br>    std=global_dict[threading,current_thread()]<br>    #…</p>\n<p>def do_task_2():<br>    #任何函数都可以根据当前线程查找<br>    std=global_dict[threading,current_thread()]<br>    #…</p>\n<p>#ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事<br>import threading</p>\n<p>#创建全局ThreadLocal对象:<br>local_school=threading.local()<br>def process_student():<br>    #获取当前县城关联的student<br>    std=local_school.student<br>    print(‘Hello,%s (in %s)\\n’ % (std,threading.current_thread().name))</p>\n<p>def process_thread(name):<br>    #绑定ThreadLocal的student:<br>    local_school.student=name<br>    process_student()</p>\n<p>t1=threading.Thread(target=process_thread,args=(‘Alice’,),name=’Thread_A’)<br>t2=threading.Thread(target=process_thread,args=(‘Bob’,),name=’Thread_B’)<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()</p>\n<p>#ThreadLocal解决了线程锁的问题,把所有的变量都处理成局部变量,互不影响**</p>\n","text":"【Source Code】 局部变量传递,避免使用线程锁 github:ThreadLocal.py**#Thread-较量级线程#建议在多线程环境下用局部变量,但传递变量传递很麻烦‘’’<br>def process_student(name):<br>    std=Stud","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 sorted","slug":"python3-sorted","date":"2017-07-13T09:03:34.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-sorted.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/python_study/blob/master/sorted/sorted.py\" target=\"_blank\" rel=\"noopener\">sorted.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[1]:</p>\n<p>print(sorted([36, 5, -12, 9, -21]))</p>\n<p>#此外，sorted()函数也是一个高阶函数，它还可</p>\n<p>#以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：<br>print(sorted([36, 5, -12, 9, -21], key=abs))</p>\n<p>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’]))</p>\n<p>#我们给sorted传入key–函数–，即可实现忽略大小写的排序：<br>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower))</p>\n<p>#要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：<br>print(sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower, reverse=True))</p>\n<p># In[5]:</p>\n<p>L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]</p>\n<p>#key是排序规则函数</p>\n<p># In[6]:</p>\n<p>#按名字排序<br>def by_name(t):<br>    return t[0]<br>L2 = sorted(L, key=by_name)<br>print(L2)</p>\n<p>#按成绩从高到低排序<br>def by_score(t):<br>    return -t[1]<br>L2 = sorted(L, key=by_score)<br>print(L2)</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github: sorted.py **# coding: utf-8# In[1]:print(sorted([36, 5, -12, 9, -21]))#此外，sorted()函数也是一个高阶函数，它还可#以接收一个key函数来实现自定义的排序，例","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 定制类","slug":"python3-str-getatr","date":"2017-07-16T08:33:50.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-str-getatr.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong>github:<a href=\"https://github.com/834930269/python_study/blob/master/oop/%E5%AE%9A%E5%88%B6%E7%B1%BB.py\" target=\"_blank\" rel=\"noopener\">定制类.py</a></strong></p>\n<hr>\n<p> **# coding: utf-8</p>\n<p># In[3]:</p>\n<p>#__str__<br>class student(object):<br>    def __init__(self,name):<br>        self.name=name<br>    def __str__(self):<br>        return ‘Student object (name: %s)’ % self.name<br>    __repr__=__str__<br>s=student(‘Michael’)</p>\n<p>#__str__是控制打印时输出类型,__repr__是控制台直接s输出的类型</p>\n<p>#如果不重写,那会输出&lt;__main__.Student object at 地址&gt;<br>s<br>print(s)</p>\n<p># In[10]:</p>\n<p>#__iter__<br>‘’’<br>如果一个类想被用于for … in循环，类似list或tuple那样，就必<br>须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python<br>的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个<br>值，直到遇到StopIteration错误时退出循环。</p>\n<p>斐波那契:<br>‘’’<br>class Fib(object):<br>    def __init__(self):<br>        self.a, self.b = 0, 1 # 初始化两个计数器a，b</p>\n<pre><code>def \\_\\_iter\\_\\_(self):\n    return self # 实例本身就是迭代对象，故返回自己\n\ndef \\_\\_next\\_\\_(self):\n    self.a, self.b = self.b, self.a + self.b # 计算下一个值\n    if self.a &gt; 100000: # 退出循环的条件\n        raise StopIteration()\n    return self.a # 返回下一个值\ndef \\_\\_getitem\\_\\_(self, n):\n    if isinstance(n, int): # n是索引\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n    if isinstance(n, slice): # n是切片\n        start = n.start\n        stop = n.stop\n        if start is None:\n            start = 0\n        a, b = 1, 1\n        L = \\[\\]\n        for x in range(stop):\n            if x &gt;= start:\n                L.append(a)\n            a, b = b, a + b\n        return L</code></pre><p>for i in Fib():<br>    print(i)</p>\n<p># In[14]:</p>\n<p>#__getitem__</p>\n<p>#Fib实例虽然能作用于for循环，看起来和list有点像，</p>\n<p>#但是，把它当成list来使用还是不行</p>\n<p>#要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：<br>f=Fib()<br>print(f[0],f[1],f[2],f[100])<br>‘’’<br>但是list有个神奇的切片方法：</p>\n<blockquote>\n<blockquote>\n<p>&gt; list(range(100))[5:10]<br>[5, 6, 7, 8, 9]</p>\n</blockquote>\n</blockquote>\n<p>对于Fib却报错。原因是__getitem__()传入的参数<br>可能是一个int，也可能是一个 切片对象slice ，所以要做判断：</p>\n<p>class Fib(object):<br>    def __getitem__(self, n):<br>        if isinstance(n, int): # n是索引<br>        if isinstance(n, slice): # n是切片<br>‘’’<br>print(f[:20])#但是没有判断倒序切片以及没有对step参数作处理：</p>\n<p>‘’’<br>此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以<br>作key的object，例如str。</p>\n<p>与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋<br>值。最后，还有一个__delitem__()方法，用于删除某个元素。</p>\n<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的<br>list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”<br>，不需要强制继承某个接口。<br>‘’’</p>\n<p># In[18]:</p>\n<p>#__getattr__</p>\n<p>#正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：<br>class Student(object):<br>    def __init__(self):<br>        self.name = ‘Michael’<br>    def __getattr__(self, attr):<br>        if attr==’score’:<br>            return 99<br>        if attr==’age’:<br>            return lambda: 25<br>        raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)</p>\n<p>#调用name属性，没问题，但是，调用不存在的score属性，就有问题了<br>‘’’</p>\n<blockquote>\n<blockquote>\n<p>&gt; s = Student()<br>&gt; print(s.name)<br>Michael<br>&gt; print(s.score)<br>Traceback (most recent call last):<br>  …<br>AttributeError: ‘Student’ object has no attribute ‘score’<br>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>\n</blockquote>\n</blockquote>\n<p>要避免这个错误，除了可以加上一个score属性外，Python还有另<br>一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：<br>class Student(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self):\n    self.name = &apos;Michael&apos;\n\ndef \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;score&apos;:\n        return 99</code></pre><p>返回函数也是完全可以的：<br>class Student(object):</p>\n<pre><code>def \\_\\_getattr\\_\\_(self, attr):\n    if attr==&apos;age&apos;:\n        return lambda: 25</code></pre><p>只是调用方式要变为：</p>\n<blockquote>\n<blockquote>\n<p>&gt; s.age()<br>25<br>注意，只有在没有找到属性的情况下，才调用__getattr__，<br>已有的属性，比如name，不会在__getattr__中查找。</p>\n</blockquote>\n</blockquote>\n<p>此外，注意到任意调用如s.abc都会返回None，这是因为我们<br>定义的__getattr__默认返回就是None。要让class只响应特定<br>的几个属性，我们就要按照约定，抛出AttributeError的错误：<br>raise AttributeError(‘\\‘Student\\‘ object has no attribute \\‘%s\\‘’ % attr)<br>‘’’<br>s=Student()<br>print(s.name,s.score,s.age())</p>\n<p># In[19]:</p>\n<p>‘’’<br>举个例子：</p>\n<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>\n<pre><code>http://api.server/user/friends\nhttp://api.server/user/timeline/list</code></pre><p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>\n<p>利用完全动态的__getattr__，我们可以写出一个链式调用：<br>‘’’<br>class Chain(object):</p>\n<pre><code>def \\_\\_init\\_\\_(self, path=&apos;&apos;):\n    self._path = path\n\ndef \\_\\_getattr\\_\\_(self, path):\n    return Chain(&apos;%s/%s&apos; % (self._path, path))\n\ndef \\_\\_str\\_\\_(self):\n    return self._path\n\n\\_\\_repr\\_\\_ = \\_\\_str\\_\\_</code></pre><p>#try<br>print(Chain().status.user.timeline.list)</p>\n<p>#out[]: /status/user/timeline/list</p>\n<p>#这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，</p>\n<p>#而且，不随API的增加而改变！</p>\n<p>#还有些REST API会把参数放到URL中，比如GitHub的API：</p>\n<p>#GET /users/:user/repos</p>\n<p>#调用时，需要把:user替换为实际用户名。</p>\n<p># In[21]:</p>\n<p>#__call__<br>class Student(object):<br>    def __init__(self, name):<br>        self.name = name</p>\n<pre><code>def \\_\\_call\\_\\_(self):\n    print(&apos;My name is %s.&apos; % self.name)</code></pre><p>s = Student(‘Michael’)<br>s()</p>\n<p># In[29]:</p>\n<p>print(callable(max),callable(map),callable(str),callable(‘123’))</p>\n<p># In[ ]:**</p>\n","text":"【Source Code】 github:定制类.py **# coding: utf-8# In[3]:#__str__<br>class student(object):<br>    def __init__(self,name):<br>        self.name","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 UDP+TCP-IP编程","slug":"python3-udptcp-ip","date":"2017-07-26T14:19:14.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-udptcp-ip.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: —-TCP: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/TCP-IP/echo-server.py\" title=\"服务端: echo-server.py\" target=\"_blank\" rel=\"noopener\">服务端: echo-server.py</a> 2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/TCP-IP/echo-client.py\" title=\"客户端: echo-client.py\" target=\"_blank\" rel=\"noopener\">客户端: echo-client.py</a> —-UDP: 1.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/UDP/echo-server.py\" title=\"服务端: echo-server.py\" target=\"_blank\" rel=\"noopener\">服务端: echo-server.py</a> 2.:point_right:<a href=\"https://github.com/834930269/python_study/blob/master/UDP/echo-client.py\" title=\"客户端: echo-client.py\" target=\"_blank\" rel=\"noopener\">客户端: echo-client.py</a> 【TCP】 服务端:</p>\n<pre><code>import socket,threading,time\n\n#协议IPV4 后者是基于流的TCP\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n\n#绑定,监听端口\ns.bind((&apos;127.0.0.1&apos;,9999))\n\n#最大连接数为5\ns.listen(5)\nprint(&apos;Watting for connection...&apos;)\n\ndef tcplink(sock,addr):\n    print(&apos;Accpet new connection from %s:%s...&apos; % addr)\n    sock.send(b&apos;Welcome!&apos;)\n    while True:\n        data=sock.recv(1024)\n        time.sleep(1)\n        if not data or data.decode(&apos;utf-8&apos;)==&apos;exit&apos;:\n            break\n        sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;))\n    sock.close()\n    print(&apos;Connection from %s:%s closed.&apos; % addr)\n\nwhile True:\n    #接受一个连接\n    sock,addr=s.accept()\n    #创建新线程来处理TCP连接\n    t=threading.Thread(target=tcplink,args=(sock,addr))\n    t.start()</code></pre><p>客户端:</p>\n<pre><code>import socket\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n#建立连接\ns.connect((&apos;127.0.0.1&apos;,9999))\n#接受欢迎消息\nprint(s.recv(1024).decode(&apos;utf-8&apos;))\nfor data in [b&apos;Michael&apos;,b&apos;Tracy&apos;,b&apos;Sarah&apos;]:\n    #发送数据:\n    s.send(data)\n    print(s.recv(1024).decode(&apos;utf-8&apos;))\ns.send(b&apos;exit&apos;)\ns.close</code></pre><p>【UDP】 服务端:</p>\n<pre><code>import socket,threading,time\n\n#IPV4,UDP\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n#绑定端口\ns.bind((&apos;127.0.0.1&apos;,9999))\nprint(&apos;Bind UDP on 9999...&apos;)\n\ndef udplink(data,addr):\n    s.sendto(b&apos;Hello, %s!&apos; % data,addr)\n\nwhile True:\n    #接收数据\n    #recvfrom()方法返回数据和客户端的地址与端口\n    data,addr=s.recvfrom(1024)\n    t=threading.Thread(target=udplink,args=(data,addr))\n    time.sleep(1)\n    t.start()</code></pre><p>客户端:</p>\n<pre><code>import socket\n\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n\nfor data in [b&apos;Michael&apos;,b&apos;Tracy&apos;,b&apos;Sarah&apos;]:\n    #发送数据\n    s.sendto(data,(&apos;127.0.0.1&apos;,9999))\n    #接收数据\n    print(s.recv(1024).decode(&apos;utf-8&apos;))\ns.close()</code></pre>","text":"【Source Code】 github: —-TCP: 1.:point_right:服务端: echo-server.py 2.:point_right:客户端: echo-client.py —-UDP: 1.:point_right:服务端: echo-server.py","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 生成器+杨辉三角+yield+异常StopIteration","slug":"python3-yield-stopiteration","date":"2017-07-12T08:04:07.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/python3-yield-stopiteration.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Source Code】</strong> <strong><a href=\"https://github.com/834930269/python_study/blob/master/generator/%E7%94%9F%E6%88%90%E5%99%A8.py\" target=\"_blank\" rel=\"noopener\">github: 生成器.py</a></strong></p>\n<hr>\n<p>**# coding: utf-8</p>\n<p># In[1]:</p>\n<p>‘’’<br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，<br>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，<br>那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元<br>素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制<br>，称为生成器：generator。<br>‘’’</p>\n<p>#要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：<br>L=[x<em>x for x in range(10)]<br>print(L)<br>g=(x</em>x for x in range(10))<br>print(g)</p>\n<p>#out[1]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</p>\n<p>#out[2]:  at 0x0000000004C2FB48&gt;</p>\n<p># In[3]:</p>\n<p>‘’’<br>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>\n<p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？</p>\n<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：<br>generator必须紧跟着输入,否则用next()只能输出一次循环</p>\n<p>‘’’<br>g=(x*x for x in range(10))<br>i=0<br>while i&lt;10:<br>    print(next(g))<br>    i+=1</p>\n<p># In[10]:</p>\n<p>#用for<br>g=(x*x for x in range(10))<br>for n in g:<br>    print(n)</p>\n<p># In[6]:</p>\n<p>#斐波那契</p>\n<p>#注意,赋值语句 a,b=b,a+b</p>\n<p>#相当于<br>‘’’<br>t = (b, a + b) # t是一个tuple<br>a = t[0]<br>b = t[1]</p>\n<p>‘’’<br>def fib(max):<br>    n,a,b=0,0,1<br>    while n</p>\n<p>#想要在循环中得到fib2的return值,必须捕获StopIteration错误返回值包括在</p>\n<p>#其中的value中<br>while True:<br>    try:<br>        x=next(f)<br>        print(‘f:’,x)<br>    except StopIteration as ev:<br>        print(‘Generator return value:’,ev.value)<br>        break</p>\n<p># In[17]:</p>\n<p>#yield举例<br>def odd():<br>    print(‘step 1’)<br>    yield 1<br>    print(‘step 2’)<br>    yield(3)<br>    print(‘step 3’)<br>    yield(5)<br>o=odd()<br>print(‘之前没输出’)<br>for n in o:<br>    print(n)</p>\n<p># In[ ]:</p>\n<p>#test<br>‘’’<br>杨辉三角定义如下：</p>\n<pre><code>      1\n    1   1\n  1   2   1\n1   3   3   1</code></pre><p>  1   4   6   4   1<br>1   5   10  10  5   1<br>‘’’<br>def triangles():<br>    L=[1]<br>    while True:<br>        yield L<br>        l=len(L)<br>        R=[1]<br>        for i in range(1,l):<br>            R.append(L[i-1]+L[i])<br>        R.append(1)<br>        L=R[:]<br>‘’’<br>第二种解法,中间为中间列表,和上面一样,只不过直接加起来了,避免了中间变量<br>def triangles():<br>l = [1]<br>while True:<br>    yield l<br>    l = [1] + [l[i]+l[i+1] for i in range(len(l)-1)] + [1]<br>‘’’<br># 期待输出:<br># [1]<br># [1, 1]<br># [1, 2, 1]<br># [1, 3, 3, 1]<br># [1, 4, 6, 4, 1]<br># [1, 5, 10, 10, 5, 1]<br># [1, 6, 15, 20, 15, 6, 1]<br># [1, 7, 21, 35, 35, 21, 7, 1]<br># [1, 8, 28, 56, 70, 56, 28, 8, 1]<br># [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]<br>n = 0<br>for t in triangles():<br>    print(t)<br>    n = n + 1<br>    if n == 10:<br>        break**</p>\n","text":"【Source Code】 github: 生成器.py**# coding: utf-8# In[1]:‘’’<br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，<br>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"python3学习 常用模块","slug":"python3-useful-moudle","date":"2017-07-21T16:06:17.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/python3-useful-moudle.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Source Code】 github: 1. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/Base64.py\" title=\"Base64.py\" target=\"_blank\" rel=\"noopener\">Base64</a> 2. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/MD5%E5%8A%A0%E5%AF%86%E5%AF%86%E7%A0%81.py\" title=\"MD5加密密码.py\" target=\"_blank\" rel=\"noopener\">MD5加密密码.py</a> 3. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/SAX%E8%A7%A3%E6%9E%90XML.py\" title=\"SAX解析XML.py\" target=\"_blank\" rel=\"noopener\">SAX解析XML.py</a> 4. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/With%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86.py\" title=\"with语法实现模块管理.py\" target=\"_blank\" rel=\"noopener\">with语法实现模块管理.py</a> 5. :point_right:<a href=\"https://github.com/834930269/python_study/blob/master/Useful_module/datetime_M.py\" title=\"datetime.py\" target=\"_blank\" rel=\"noopener\">datetime.py</a></p>\n","text":"【Source Code】 github: 1. :point_right:Base64 2. :point_right:MD5加密密码.py 3. :point_right:SAX解析XML.py 4. :point_right:with语法实现模块管理.py 5. :poin","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"聊天室内核从0开始 – 3 Seq2Seq","slug":"seq2seq","date":"2019-01-06T14:32:09.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/seq2seq.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Seq2Seq\"><a href=\"#Seq2Seq\" class=\"headerlink\" title=\"Seq2Seq\"></a>Seq2Seq</h1><p>关于Seq2Seq模型,看如下博客即可,针对的视频讲解可以去BliBli搜相关视频,基本一致. <a href=\"https://blog.csdn.net/wangyangzhizhou/article/details/77883152\" title=\"深度学习的seq2seq模型\" target=\"_blank\" rel=\"noopener\">深度学习的seq2seq模型</a></p>\n<blockquote>\n<p>注意要看下注意力机制</p>\n</blockquote>\n<h1 id=\"tensorflow-基础\"><a href=\"#tensorflow-基础\" class=\"headerlink\" title=\"tensorflow 基础\"></a>tensorflow 基础</h1><h1 id=\"项目完整代码-有空写其他的\"><a href=\"#项目完整代码-有空写其他的\" class=\"headerlink\" title=\"项目完整代码(有空写其他的)\"></a>项目完整代码(有空写其他的)</h1><blockquote>\n<p>这个项目中仅有一个训练一轮的模型(所以仅供看看).如果有需要还是要训练多点,但是前提当然是你有一个好的机器或者服务器,如果有信用卡也可以选择取Github Cloud 或者AWS上选择免费的服务器来帮你训练(时间会很长)</p>\n</blockquote>\n<p><a href=\"https://pan.baidu.com/s/1D18ZwROdqyilBuy6EU4xLA\" title=\"chatbot2\" target=\"_blank\" rel=\"noopener\">chatbot2</a></p>\n","text":"Seq2Seq关于Seq2Seq模型,看如下博客即可,针对的视频讲解可以去BliBli搜相关视频,基本一致. 深度学习的seq2seq模型注意要看下注意力机制tensorflow 基础项目完整代码(有空写其他的)这个项目中仅有一个训练一轮的模型(所以仅供看看).如果有需要还是要训","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"机器学习","slug":"Python/机器学习","count":2,"path":"api/categories/Python/机器学习.json"},{"name":"聊天机器人内核","slug":"Python/机器学习/聊天机器人内核","count":1,"path":"api/categories/Python/机器学习/聊天机器人内核.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"},{"name":"聊天机器人内核","slug":"聊天机器人内核","count":3,"path":"api/tags/聊天机器人内核.json"}]},{"title":"使用django搭建的文件上传系统","slug":"use-django-fileshare","date":"2018-01-08T02:17:42.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/use-django-fileshare.json","excerpt":"","keywords":null,"cover":null,"content":"<p>link -&gt; <a href=\"http://be-sunshine.cn:9011\" title=\"http://be-sunshine.cn:9011\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn:9011</a></p>\n<h1 id=\"关于-这个仓库…\"><a href=\"#关于-这个仓库…\" class=\"headerlink\" title=\"关于 这个仓库…\"></a><strong>关于</strong> 这个仓库…</h1><ol>\n<li><p>上传文件大小最大不能超过… 5M</p>\n</li>\n<li><p>请妥善保存文件的备份连接.</p>\n</li>\n</ol>\n","text":"link -&gt; http://be-sunshine.cn:9011关于 这个仓库…上传文件大小最大不能超过… 5M请妥善保存文件的备份连接.","link":"","raw":null,"photos":[],"categories":[{"name":"django","slug":"django","count":2,"path":"api/categories/django.json"},{"name":"Python","slug":"django/Python","count":2,"path":"api/categories/django/Python.json"},{"name":"Web","slug":"django/Python/Web","count":2,"path":"api/categories/django/Python/Web.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"},{"name":"django","slug":"django","count":2,"path":"api/tags/django.json"}]},{"title":"Web Application","slug":"web-application","date":"2017-11-04T08:32:16.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/web-application.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Link <a href=\"http://cizixs.com/2015/09/21/what-is-a-web-framework\" target=\"_blank\" rel=\"noopener\">什么是Web框架</a> 一个简单的可以处理get和post的Web Application, 其中如果80端口不能访问就换成其他端口即可.</p>\n<pre><code>import socket\n\nHOST = &apos;&apos; #localhost\nPORT = 80 #监听80端口,如果不行就换成其他端口\nlisten_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#协议部分\nlisten_socket.bind((HOST,PORT))#只允许迭代类型么？\nlisten_socket.listen(1)\nconnection,address = listen_socket.accept()\nrequest = connection.recv(1024)\nconnection.sendall(b&quot;&quot;&quot;HTTP/1.1 200 OK\nContent-type: text/html\n\n\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;&quot;&quot;)#返回的响应以及data,但必须转一下bytes类型\nconnection.close()</code></pre><p>（如果上面的程序报端口错误，可以把 PORT 的值修改成其他值，比如 8080。） 上面的代码只会接收一个连接和一个请求，不管请求的 URL 是什么，都会返回同样的 HTTP 内容，response code 是 200。（很明显，这不算真正的 web server）。在这个例子，我们告诉客户端，返回的数据格式为 HTML，而不是其他的格式，比如 JSON。</p>\n","text":"Link 什么是Web框架 一个简单的可以处理get和post的Web Application, 其中如果80端口不能访问就换成其他端口即可.import socketHOST = &apos;&apos; #localhostPORT = 80 #监听80端口,如果不行就换成其","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"Web_Application","slug":"Python/Web-Application","count":1,"path":"api/categories/Python/Web-Application.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"Web_Application","slug":"Web-Application","count":1,"path":"api/tags/Web-Application.json"}]},{"title":"词云: Python爬取国际时事","slug":"wordcloud-python","date":"2018-04-01T11:30:24.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/wordcloud-python.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190628.jpg","content":"<h1 id=\"前置工具\"><a href=\"#前置工具\" class=\"headerlink\" title=\"前置工具\"></a>前置工具</h1><blockquote>\n<p>python wordcloud jieba BeautifulSoup matplotlib scipy</p>\n</blockquote>\n<h1 id=\"第一步-爬取国际时事列表\"><a href=\"#第一步-爬取国际时事列表\" class=\"headerlink\" title=\"第一步: 爬取国际时事列表\"></a>第一步: 爬取国际时事列表</h1><h2 id=\"待爬地址-http-m-sohu-com-cr-57-page-1-amp-v-2\"><a href=\"#待爬地址-http-m-sohu-com-cr-57-page-1-amp-v-2\" class=\"headerlink\" title=\"待爬地址: http://m.sohu.com/cr/57/?page=1&amp;v=2\"></a>待爬地址: <a href=\"http://m.sohu.com/cr/57/?page=1&amp;v=2\" target=\"_blank\" rel=\"noopener\">http://m.sohu.com/cr/57/?page=1&amp;v=2</a></h2><blockquote>\n<p>首先我们可以观察到,每点击列表中的下一页时, page 会加一</p>\n<blockquote>\n<p>然后我们就可以确认,想获取多少条信息,直接替换page属性的值即可</p>\n</blockquote>\n<p>然后我们观察想要爬取的内容:</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190628.jpg\" alt></p>\n<h2 id=\"审查元素\"><a href=\"#审查元素\" class=\"headerlink\" title=\"审查元素:\"></a>审查元素:</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401190805.jpg\" alt></p>\n<blockquote>\n<p>我们发现文本都是在 div(class=”bd3 pb1”) -&gt; div -&gt; p -&gt; a 标签下的:</p>\n</blockquote>\n<h2 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h2><blockquote>\n<p>爬取数据并保存在<strong>data.txt</strong>中:</p>\n</blockquote>\n<pre><code># coding: utf-8\n\nfrom wordcloud import WordCloud\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\n\ndef getHTMLText(url):\n    try:\n        r = requests.get(url)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        pass\n\ndef has_p_a(tag):\n    pass\n\ndef getWannaData(stockURL,res):\n    html = getHTMLText(stockURL)\n    soup = BeautifulSoup(html,&apos;html.parser&apos;)\n    p = soup.find(&apos;div&apos;,class_=&quot;bd3 pb1&quot;).find_all(&apos;a&apos;)\n    for q in p:\n        res.append(q.text)\n\nres = []\nmaxn = 100\nfor i in range(1,maxn):\n    getWannaData(&apos;http://m.sohu.com/cr/57/?page=&apos;+str(i)+&apos;&amp;v=2&apos;,res)\n\nfile = open(&apos;data.txt&apos;,&apos;a+&apos;)\nfor q in res:\n    file.write(q+&apos;\\n&apos;)</code></pre><blockquote>\n<p>其中maxn是控制爬取多少页的</p>\n</blockquote>\n<h2 id=\"data-txt-部分内容\"><a href=\"#data-txt-部分内容\" class=\"headerlink\" title=\"data.txt 部分内容:\"></a>data.txt 部分内容:</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/QQ%E6%88%AA%E5%9B%BE20180401191238.jpg\" alt></p>\n<h1 id=\"第二步-生成词云\"><a href=\"#第二步-生成词云\" class=\"headerlink\" title=\"第二步: 生成词云\"></a>第二步: 生成词云</h1><h2 id=\"前置\"><a href=\"#前置\" class=\"headerlink\" title=\"前置\"></a>前置</h2><blockquote>\n<p>因为要进行中文分词,所以要用jieba 注意再打开<strong>data.txt</strong>时<strong>编码</strong>问题 还有ttf不能保存在有中文的路径下</p>\n</blockquote>\n<h2 id=\"背景图片\"><a href=\"#背景图片\" class=\"headerlink\" title=\"背景图片\"></a>背景图片</h2><blockquote>\n<p>我们选择 <strong>水伊布.png</strong></p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/timg.jpg\" alt></p>\n<h2 id=\"生成词云\"><a href=\"#生成词云\" class=\"headerlink\" title=\"生成词云\"></a>生成词云</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/yb.png\" alt> <strong>容我说一句,在中国相对封闭的网络环境中,已经可以看到世界如此的乱了,全部的词条大部分是消极的…看起来大规模战争结束的时间太久了…(还是说,世界就没有安宁过)</strong></p>\n<blockquote>\n<p>这张图可以找到安倍</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/04/yb2.png\" alt></p>\n","text":"前置工具python wordcloud jieba BeautifulSoup matplotlib scipy第一步: 爬取国际时事列表待爬地址: http://m.sohu.com/cr/57/?page=1&amp;v=2首先我们可以观察到,每点击列表中的下一页时, pa","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"爬虫","slug":"Python/爬虫","count":2,"path":"api/categories/Python/爬虫.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"爬虫","slug":"爬虫","count":4,"path":"api/tags/爬虫.json"}]},{"title":"机器学习实战(一) K-近邻","slug":"machine-learning-knn","date":"2018-01-27T14:04:15.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/machine-learning-knn.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180127214341.jpg","content":"<h1 id=\"K临近算法概述\"><a href=\"#K临近算法概述\" class=\"headerlink\" title=\"K临近算法概述\"></a>K临近算法概述</h1><p>简单地说,k临近算法就是采用不同的特征值之间的距离方法进行分类. 通过数据与数据集间的距离进行分类,以及断定新数据的类别. 这里我们选择使用欧氏距离来当做两点间的距离.</p>\n<h2 id=\"实现KNN算法\"><a href=\"#实现KNN算法\" class=\"headerlink\" title=\"实现KNN算法\"></a>实现KNN算法</h2><h3 id=\"伪码\"><a href=\"#伪码\" class=\"headerlink\" title=\"伪码\"></a>伪码</h3><blockquote>\n<p>对未知类别属性的数据集中的每个点依次执行以下操作</p>\n<blockquote>\n<p>计算已知类别数据集中的点 按照距离递增次序排序 选取与当前点距离最小的k个点 确定前k个点所在的类别的出现频率 返回前k个点出现频率最高的类别作为当前点的预测分类</p>\n</blockquote>\n</blockquote>\n<h3 id=\"实现算法前\"><a href=\"#实现算法前\" class=\"headerlink\" title=\"实现算法前\"></a>实现算法前</h3><p>我们来学习一下需要用到的一些库函数.</p>\n<h4 id=\"numpy\"><a href=\"#numpy\" class=\"headerlink\" title=\"numpy\"></a>numpy</h4><p>1.list转array</p>\n<pre><code>from numpy import *\narray([1,1])</code></pre><p>2.zeros()初始化向量</p>\n<pre><code>import numpy\nfrom numpy import *\na=(3,4)\nzeros(a)\n# 初始化一个3行四列的0矩阵</code></pre><p>3.矩阵操作</p>\n<pre><code>import numpy\nfrom numpy import *\n\nMat = array([[1,2],[3,4]])\n\n# 每行最小\nMat.min(0)\n# 每列最小\nMat.min(1)\n# 每行和\nMat.sum(0)\n# 上面传递的参数都是axis=1 or 0,0代表行,1代表列\n\n# shape返回一个tuple,代表矩阵的行数和列数\nMat.shape</code></pre><p>3.1矩阵排序argsort()</p>\n<pre><code>import numpy\nfrom numpy import *\n\nk = array([1,2,8.5,-1,0])\nt = k.argsort()\n# 输出升序排序后每位数字的下标数组</code></pre><p>输出升序排序后每位数字的下标数组,比如上面那个输出是:</p>\n<pre><code>array([3,4,0,1,2],dtype=int64)\n# 第一个是k[3],第二个是k[4]</code></pre><p>4.tile</p>\n<pre><code>import numpy\nfrom numpy import *\n\n# 有两个参数,第一个参数是初始矩阵,第二个参数是一个tuple,代表\n# 向行拓展次数,以及向列拓展次数,具体调用一下就知道了\ntile([1,2],(1))# 原矩阵\ntile([1,2],(2,2))# 行两倍,列两倍</code></pre><p>5.运算 直接使用运算符号,是相当于每行与每列进行运算. 真正的矩阵运算需要通过库来实现.</p>\n<h4 id=\"数据读取\"><a href=\"#数据读取\" class=\"headerlink\" title=\"数据读取\"></a>数据读取</h4><p>与本例相关的数据集地址: <a href=\"http://be-sunshine.cn:9011/static/file/datingTestSet2.txt\" title=\"datingTestSet2.txt\" target=\"_blank\" rel=\"noopener\">datingTestSet2.txt</a></p>\n<pre><code># 打开数据文件\nfr = open(&apos;datingTestSet2.txt&apos;)\n# 按行读取\narrayOfLines = fr.readlines()\narrayOfLines\n\nfrom numpy import *\nnumberOfLines = len(arrayOfLines)\n# 生成与数据集相同列数的矩阵\nreturnMat = zeros((numberOfLines,3))\nreturnMat\n# 格式化读入,存储到矩阵中\nfor line in arrayOfLines:\n    line = line.strip()\n    print(line.split(&apos;\\t&apos;))\n    print(int(line.split(&apos;\\t&apos;)[-1]))</code></pre><h4 id=\"matplotlib散点图\"><a href=\"#matplotlib散点图\" class=\"headerlink\" title=\"matplotlib散点图\"></a>matplotlib散点图</h4><pre><code>import matplotlib\nimport matplotlib.pyplot as plt\nimport numpy\nfrom numpy import *\n# 生成plt\nfig = plt.figure()\n# 规定最多111个点\nax = fig.add_subplot(111)\n# 创建一个矩阵,第三个代表类别\nMat = array([[1,123,2],[10,256,1],[7,321,3]])\n# 获取类别矩阵\nLabel = Mat[:,2]\n# 第一个参数横坐标,第二个参数纵坐标,第三个参数,颜色矩阵,第三个参数,大小矩阵\nax.scatter(Mat[:,0],Mat[:,1],15.0*Label,15.0*Label)\n# 绘制\nplt.show()</code></pre><h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"对于代码的解释我都注释在代码中了\"><a href=\"#对于代码的解释我都注释在代码中了\" class=\"headerlink\" title=\"对于代码的解释我都注释在代码中了\"></a>对于代码的解释我都注释在代码中了</h4><pre><code># K-近邻\n&apos;&apos;&apos;\n算法思想:\n\n计算已知类别数据集中的点\n\n按照距离递增次序排序\n\n选取与当前点距离最小的k个点\n\n确定前k个点所在的类别的出现频率\n\n返回前k个点出现频率最高的类别作为当前点的预测分类\n&apos;&apos;&apos;\n\ndef classify0(inX,dataSet,labels,k):\n    &apos;&apos;&apos;\n    k-邻近算法\n    inX:测试数据 - array\n    dataSet:样本数据集 - array\n    labels:标签向量 - array\n    k: 选举前k个 - int\n    &apos;&apos;&apos;\n    # 获取数据集的列数\n    dataSetSize = dataSet.shape[0]\n    # 新建一个矩阵,将测试数据inX复制到每列上,以便计算距离\n    diffMat = tile(inX,(dataSetSize,1)) - dataSet\n    # 对每个指标的距离进行平方\n    sqDiffMat = diffMat**2\n    # 把每个指标的差方相加\n    sqDistance = sqDiffMat.sum(0)\n    # 计算inX与每个点的距离\n    distance = sqDistance**0.5\n    # 升序排序,返回排序后的下标矩阵\n    sortedDistIndicies = distance.argsort()\n\n    # 选择距离最小的k个点\n    classCount = {}\n    for i in range(k):\n        # 选取前k个距离最近的点中的第i个\n        voteIlabel = labels[sortedDistIndicies[i]]\n        # 映射到dict中,其中get的第二个参数是如果不存在的默认值\n        classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1\n    # dict.items()返回一个字典列表(dict_items)类型,即dict的原始插入顺序的list\n    # 可以直接用sorted排序\n    # 升序,其中operator.itemgetter(index)代表按照待排列表的第几个元素排序.\n    # reverse=True即变成了降序\n    sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True)\n    # 返回分类中频率最高的那个的标签\n    return sortedClassCount[0][0]</code></pre><h3 id=\"可视化分析\"><a href=\"#可视化分析\" class=\"headerlink\" title=\"可视化分析\"></a>可视化分析</h3><pre><code>import numpy\nfrom numpy import *\n# 将测试数据转换为需要的类型\ndef file2matrix(filename):\n    &apos;&apos;&apos;\n    对于datingTestSet2.txt返回值类型\n    returnMat: [里程数,百分比,公升数]\n    --每年获得的飞行常客里程数\n    --玩视频游戏所耗时间百分比\n    --每周消耗的冰淇淋公升数\n    classLabelVector: [标签]\n    --1,2,3分别代表最好,其次,最次\n    &apos;&apos;&apos;\n    fr = open(filename)\n    arrayOLines = fr.readlines()\n    # 得到文件行数\n    numberOfLines = len(arrayOLines)\n    # 新建(文件行数,3列)的0 array\n    returnMat = zeros((numberOfLines,3))\n    classLabelVector = []\n    index = 0\n    # 处理数据\n    for line in arrayOLines:\n        line = line.strip()\n        listFromLine = line.split(&apos;\\t&apos;)\n        # 将数据加入返回的列表中\n        returnMat[index,:] = listFromLine[:3]\n        # 标签列表\n        classLabelVector.append(int(listFromLine[-1]))\n        index+=1\n    return returnMat,classLabelVector\n\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndatingDataMat,datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)\n\nfig = plt.figure()\nax = fig.add_subplot(111)\nax.scatter(datingDataMat[:,0],datingDataMat[:,1],15.0*array(datingLabels),15.0*array(datingLabels))\nplt.show()</code></pre><p>最后的结果如下: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180127214341.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180127214341.jpg\" alt></a></p>\n<h3 id=\"归一化数值\"><a href=\"#归一化数值\" class=\"headerlink\" title=\"归一化数值\"></a>归一化数值</h3><p>我们可以发现,在数据集中,每种类的数据极差差距都很大,比如飞行常客里程数的极差,和每周消费冰淇淋公升数的极差相距交大. 所以我们尝试将不同的数据集按照相同的区间范围进行计算. 计算公式(和百分制化为150分制的道理一样): <strong>newValue = (OldValue-min)/(max-min)</strong> 其中min和max代表数据集中的最小特征值和最大特征值. 是用这个公式后的数值将统一变成0<del>1或者-1</del>1之间.</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>def autoNorm(dataSet):\n    &apos;&apos;&apos;\n    归一化数值\n    返回值\n    normDataSet:归一化后数值 - array\n    ranges:每类特征极差 - array\n    minVals:每类特征最小值 - array\n    &apos;&apos;&apos;\n    # numpy数组 .min(0)每列最小值\n    # .min(1)每行最小值\n    minVals = dataSet.min(0)\n    maxVals = dataSet.max(0)\n    ranges = maxVals - minVals\n    normDataSet = zeros(shape(dataSet))\n    m = dataSet.shape[0]\n    normDataSet = dataSet - tile(minVals,(m,1))\n    normDataSet = normDataSet/tile(ranges,(m,1))\n    return normDataSet,ranges,minVals</code></pre><h3 id=\"对约会网站的测试\"><a href=\"#对约会网站的测试\" class=\"headerlink\" title=\"对约会网站的测试\"></a>对约会网站的测试</h3><p>最后我们对之前的datingTestSet2.txt进行误差测试 其中hoRatio代表对数据集的测试普及率. 这里用<strong>0.1即1000*0.1=100个</strong>样本数据进行测试.</p>\n<pre><code>def datingClassTest():\n    hoRatio = 0.10\n    datingDataMat,datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)\n    normMat,ranges,minVals = autoNorm(datingDataMat)\n    m = normMat.shape[0]\n    numTestVecs = int(m*hoRatio)\n    errorCount = 0.0\n    for i in range(numTestVecs):\n        classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],\\\n                                    datingLabels[numTestVecs:m],3)\n        print(&apos;the classifier came back with: %d,the real answer is: %d&apos;\\\n              % (classifierResult,datingLabels[i]))\n        if(classifierResult != datingLabels[i]): errorCount += 1.0\n    print(&apos;the total error rate is: %f&apos; % (errorCount/float(numTestVecs)))\n\ndatingClassTest()</code></pre><p>测试结果:</p>\n<pre><code>the classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 2,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 2,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 3,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 3,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 2,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 1,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 3\nthe classifier came back with: 1,the real answer is: 2\nthe classifier came back with: 3,the real answer is: 1\nthe classifier came back with: 1,the real answer is: 1\nthe total error rate is: 0.600000</code></pre><h1 id=\"Done-And-thank-you-for-watching\"><a href=\"#Done-And-thank-you-for-watching\" class=\"headerlink\" title=\"Done,And thank you for watching!\"></a>Done,And thank you for watching!</h1>","text":"K临近算法概述简单地说,k临近算法就是采用不同的特征值之间的距离方法进行分类. 通过数据与数据集间的距离进行分类,以及断定新数据的类别. 这里我们选择使用欧氏距离来当做两点间的距离.实现KNN算法伪码对未知类别属性的数据集中的每个点依次执行以下操作计算已知类别数据集中的点 按照距","link":"","raw":null,"photos":[],"categories":[{"name":"K-邻近","slug":"K-邻近","count":1,"path":"api/categories/K-邻近.json"},{"name":"Python","slug":"K-邻近/Python","count":1,"path":"api/categories/K-邻近/Python.json"},{"name":"机器学习","slug":"K-邻近/Python/机器学习","count":1,"path":"api/categories/K-邻近/Python/机器学习.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"机器学习","slug":"机器学习","count":4,"path":"api/tags/机器学习.json"},{"name":"K-邻近","slug":"K-邻近","count":1,"path":"api/tags/K-邻近.json"}]},{"title":"pygame 碰撞检测","slug":"pygame-collision-detection","date":"2017-12-30T14:59:50.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/pygame-collision-detection.json","excerpt":"","keywords":null,"cover":null,"content":"<p>碰撞检测 即两个Sprite是否碰撞-重叠之类的(你懂得) :horse_racing: github: <a href=\"https://github.com/834930269/Pygame-Learn/tree/master/EatApple\" title=\"https://github.com/834930269/Pygame-Learn/tree/master/EatApple\" target=\"_blank\" rel=\"noopener\">https://github.com/834930269/Pygame-Learn/tree/master/EatApple</a> 吃苹果游戏:</p>\n<pre><code># MyLibrary.py\nfrom pygame import *\nimport sys, time, random, math, pygame\n\ndef print_text(font,x,y,text,color=(255,255,255)):\n    imgText = font.render(text,True,color)\n    #req&apos;d when function moved into MyLibrary\n    screen = pygame.display.get_surface()\n    #移动\n    screen.blit(imgText,(x,y))\n\nclass MySprite(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.master_image = None\n        self.frame = 0\n        self.old_frame = -1\n        self.frame_width = 1\n        self.frame_height = 1\n        self.first_frame = 0\n        self.last_frame = 0\n        self.columns = 1\n        self.last_time = 0\n        self.row = 1\n        self.direction = 0\n        self.velocity = Point(0.0,0.0)\n\n    #x property\n    def _getx(self): return self.rect.x\n    def _setx(self,value): self.rect.x = value\n    X = property(_getx,_setx)\n\n    #y property\n    def _gety(self): return self.rect.y\n    def _sety(self,value): self.rect.y = value\n    Y = property(_gety,_sety)\n\n    # position property\n    def _getpos(self): return self.rect.topleft\n    def _setpos(self,pos):self.rect.topleft = pos\n    position = property(_getpos,_setpos)\n\n    # filename 帧图宽度,帧图高度,帧图行,帧图列\n    def load(self,filename,width,height,columns,row):\n        self.master_image = pygame.image.load(filename).convert_alpha()\n        self.frame_width = width\n        self.frame_height = height\n        self.rect = Rect(0,0,width,height)\n        self.columns = columns\n        self.row = row\n        rect = self.master_image.get_rect()\n        self.last_frame = (rect.width // width)*(rect.height // height) - 1\n\n    def update(self,current_time,rate=30):\n        if current_time &gt; self.last_time +rate:\n            self.frame += 1\n            if self.frame &gt; self.last_frame:\n                self.frame = self.first_frame\n            self.last_frame = current_time\n\n        if self.frame != self.old_frame:\n            frame_x = (self.frame % self.columns) * self.frame_width\n            #添加了row以后每次计算对row取余即可计算出当前列数\n            frame_y = (self.frame // self.columns) % self.row * self.frame_height\n            #如果把frame_y置为0,则表示始终都是在位图的第一行\n            # 多行的话,可以通过frame_y来解决,但是要注意,y=0则返回\n            rect = Rect(frame_x, frame_y, self.frame_width, self.frame_height)\n            self.image = self.master_image.subsurface(rect)\n            self.old_frame = self.frame\n\n    def __str__(self):\n        return str(self.frame) + &quot;,&quot; + str(self.first_frame) + \\\n            &quot;,&quot; + str(self.last_frame) + &quot;,&quot; + str(self.frame_width) + \\\n            &quot;,&quot; + str(self.frame_height) + &quot;,&quot; + str(self.columns) + \\\n            &quot;,&quot; + str(self.rect)\n\n#Point class\nclass Point(object):\n    def __init__(self,x,y):\n        self.__x = x\n        self.__y = y\n    #X property\n    def getx(self): return self.__x\n    def setx(self, x): self.__x = x\n    x = property(getx, setx)\n\n    #Y property\n    def gety(self): return self.__y\n    def sety(self, y): self.__y = y\n    y = property(gety, sety)\n\n    def __str__(self):\n        return &quot;{X:&quot; + &quot;{:.0f}&quot;.format(self.__x) + \\\n            &quot;,Y:&quot; + &quot;{:.0f}&quot;.format(self.__y) + &quot;}&quot;\n\n\n#app.py\nimport itertools, sys, time, random, math, pygame\nfrom pygame import *\nfrom MyLibrary import *\n\ndef calc_velocity(direction,vel=1.0):\n    velocity = Point(0,0)\n    if direction == 0 :#上\n        velocity.y = -vel\n    elif direction == 2:#右\n        velocity.x=vel\n    elif direction == 4:#下\n        velocity.y=vel\n    elif direction == 6:#左\n        velocity.x=-vel\n    return velocity\n\npygame.init()\nscreen = pygame.display.set_mode((800,600))\npygame.display.set_caption(&quot;吃苹果&quot;)\nfont = pygame.font.Font(None,36)\ntimer = pygame.time.Clock()\n\n#创建精灵组\nplayer_group = pygame.sprite.Group()\nfood_group = pygame.sprite.Group()\n\n#初始化玩家精灵组\nplayer = MySprite()\nplayer.load(&quot;farmer walk.png&quot;,96,96,8,8)\n#初始位置\nplayer.position = 80,80\n#初始方向\nplayer.direction = 4\n#添加进组\nplayer_group.add(player)\n\n#初始化食物精灵组\nfor n in range(1,50):\n    food = MySprite()\n    food.load(&quot;food_low.png&quot;,35,35,1,1)\n    #随机分布\n    food.position = random.randint(0,780),random.randint(0,580)\n    food_group.add(food)\n\ngame_over=False\nplayer_moving = False\nplayer_health = 0\n\nwhile True:\n    timer.tick(30)\n    ticks = pygame.time.get_ticks()\n\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n    #获取当前按键\n    keys = pygame.key.get_pressed()\n    if keys[K_ESCAPE]:\n        sys.exit()\n    elif keys[K_UP] or keys[K_w]:#上\n        player.direction = 0\n        player_moving = True\n    elif keys[K_RIGHT] or keys[K_d]:#右\n        player.direction = 2\n        player_moving = True\n    elif keys[K_DOWN] or keys[K_s]:#下\n        player.direction = 4\n        player_moving = True\n    elif keys[K_LEFT] or keys[K_a]:#左\n        player.direction = 6\n        player_moving = True\n    else:\n        player_moving = False\n\n    if not game_over:\n        #根据角色方向不同,使用不同的动画帧\n        player.first_frame = player.direction * player.columns\n        player.last_frame = player.first_frame + player.columns-1\n        if player.frame &lt; player.first_frame:\n            player.frame = player.first_frame\n\n        if not player_moving:\n            # 当停止按键（即人物停止移动的时候），停止更新动画帧\n            player.frame = player.first_frame = player.last_frame\n        else:\n            player.velocity = calc_velocity(player.direction,1.5)\n            player.velocity.x *= 1.5\n            player.velocity.y *= 1.5\n\n        #更新玩家精灵组\n        player_group.update(ticks, 50)\n        # 移动玩家\n        if player_moving:\n            player.X += player.velocity.x\n            player.Y += player.velocity.y\n            if player.X &lt; 0:\n                player.X = 0\n            elif player.X &gt; 700:\n                player.X = 700\n            if player.Y &lt; 0:\n                player.Y = 0\n            elif player.Y &gt; 500:\n                player.Y = 500\n\n        attacker = None\n        #判断是否有碰撞产生\n        attacker = pygame.sprite.spritecollideany(player,food_group)\n        if attacker!=None:\n            #有,增加精度\n            if pygame.sprite.collide_circle_ratio(0.65)(player,attacker):\n                player_health += 2\n                food_group.remove(attacker)\n        if player_health &gt; 100:\n            player_health = 100\n        #更新食物精灵组\n        food_group.update(ticks,50)\n        if len(food_group)==0:\n            game_over = True\n\n    #清屏\n    screen.fill((50,50,100))\n    # 绘制精灵\n    food_group.draw(screen)\n    player_group.draw(screen)\n\n    # 绘制玩家血量条\n    pygame.draw.rect(screen, (50, 150, 50, 180), Rect(300, 570, player_health * 2, 25))\n    pygame.draw.rect(screen, (100, 200, 100, 180), Rect(300, 570, 200, 25), 2)\n\n    if game_over:\n        print_text(font, 300, 100, &quot;GAME OVER&quot;)\n\n    pygame.display.update()</code></pre><p>接下来才是难中之难…如果想要实现人物随场景移动. 估计要自己撸框架了. 大体思路如下: 1:近景(左侧)1/2前景不随人物移动 2:1/2以后景随人物移动 3:远景(右侧)1/2前景不随人物移动 4:景采用大地图形式,造可封装类(障碍物,场景地图,宽度,高度等信息) 5:考虑如何移动场景,数学公式想好,-移动方向,移动速度,景中心… 6:加油!</p>\n","text":"碰撞检测 即两个Sprite是否碰撞-重叠之类的(你懂得) :horse_racing: github: https://github.com/834930269/Pygame-Learn/tree/master/EatApple 吃苹果游戏:# MyLibrary.pyfrom","link":"","raw":null,"photos":[],"categories":[{"name":"pygame","slug":"pygame","count":3,"path":"api/categories/pygame.json"},{"name":"Python","slug":"pygame/Python","count":3,"path":"api/categories/pygame/Python.json"},{"name":"游戏制作","slug":"pygame/Python/游戏制作","count":3,"path":"api/categories/pygame/Python/游戏制作.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"游戏制作","slug":"游戏制作","count":4,"path":"api/tags/游戏制作.json"},{"name":"pygame","slug":"pygame","count":3,"path":"api/tags/pygame.json"}]},{"title":"Python Flask(五) Email","slug":"python-flask-email","date":"2017-10-10T11:07:25.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-email.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B77.png","content":"<p>moudule:Flask_mail 配置参数: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B77.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B77.png\" alt></a> 中文: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B78.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B78.png\" alt></a> 如果不进行配置,Flask_Mail会自动连接localhost上的端口25 啊……调了一大堆错,总算搞定了QQ的邮件发送…… :sob: :sob: :sob: :sob: :sob: :sob: :sob: :sob: <code>1.</code>向QQ发送邮件是通过<code>SMTP协议</code>发送的,所以我们需要在QQ邮箱的设置中<code>开启SMTP协议</code>: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010185347.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010185347.png\" alt></a> <code>2.</code>因为QQ采用的是<code>授权码</code>发送邮件的方式,所以发送邮件时的<code>密码是授权码</code>,需要<code>申请一下</code>(这个授权码会被改变,但我不知道是怎样的条件会改变).如上图的<code>生成授权码</code>. <code>3.</code>千万不要把TTL写成TLE!!!!!! <code>4.</code>set MAIL_USERNAME/PASSWORD=<code>***</code> 这个操作是在cmd界面下直接输入即可,意为将<code>key-value:环境变量-值</code>放在系统内.python取出是依赖<code>os模块</code>的<code>os.environ.get(&#39;key&#39;)</code>取出value的. <code>5.</code>对于QQ邮箱而言,新生成的<code>msg对象</code>的<code>sender</code>需要和你发送到的目标用户一样,否则会出现<code>501</code>错误:发送者与接收者不是同一人. <code>6.</code>发送的<code>shell</code>大概代码为: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190344.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190344.png\" alt></a> <code>7.</code>AC <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190501.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010190501.png\" alt></a> Code:</p>\n<pre><code>#--*--coding:utf-8--*--\nfrom datetime import datetime\nfrom flask import Flask, render_template,session,redirect,url_for,flash\nfrom flask_script import Manager\nfrom flask_bootstrap import Bootstrap   \nfrom flask_moment import Moment\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField,SubmitField\nfrom wtforms.validators import Required\nfrom flask_sqlalchemy import SQLAlchemy\nimport os\nfrom flask_mail import Mail\n\nclass NameForm(FlaskForm):\n    name=StringField(&apos;What is your name?&apos;,validators=[Required()])\n    submit=SubmitField(&apos;Submit&apos;)\n\napp = Flask(__name__)\n\n#Flask-WTF : secret_key\n#app.config dict used to save config message.\napp.config[&apos;MAIL_SERVER&apos;]=&apos;smtp.qq.com&apos;\napp.config[&apos;MAIL_PORT&apos;]=587\n#app.config[&apos;MAIL_USE_TLE&apos;]=True\napp.config[&apos;MAIL_USE_TLS&apos;] = True\napp.config[&apos;MAIL_USERNAME&apos;]=os.environ.get(&apos;MAIL_USERNAME&apos;)\napp.config[&apos;MAIL_PASSWORD&apos;]=os.environ.get(&apos;MAIL_PASSWORD&apos;)\napp.config[&apos;SECRET_KEY&apos;]=&apos;hard to guess string&apos;\napp.config[&apos;SQLALCHEMY_DATABASE_URI&apos;]=\\\n    &apos;mysql://root:zwt~19970210@localhost/data&apos;\napp.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = True\napp.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = False\ndb=SQLAlchemy(app)\n\nmanager = Manager(app)\nbootstrap = Bootstrap(app)\nmoment = Moment(app)\nmail=Mail(app)\n\nclass Role(db.Model):\n    __tablename__ = &apos;roles&apos;\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), unique=True)\n    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;, lazy=&apos;dynamic&apos;)\n\n    def __repr__(self):\n        return &apos;&lt;Role %r&gt;&apos; % self.name\n\n\nclass User(db.Model):\n    __tablename__ = &apos;users&apos;\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, index=True)\n    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;))\n\n    def __repr__(self):\n        return &apos;&lt;User %r&gt;&apos; % self.username\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template(&apos;404.html&apos;), 404\n\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    return render_template(&apos;500.html&apos;), 500\n\n\n@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef index():\n    form=NameForm()\n    if form.validate_on_submit():\n        user=User.query.filter_by(username=form.name.data).first()\n        if user is None:\n            user =User(username=form.name.data)\n            db.session.add(user)\n            session[&apos;known&apos;]=False\n        else:\n            session[&apos;known&apos;]=True\n        session[&apos;name&apos;]=form.name.data\n        form.name.data=&apos;&apos;\n        return redirect(url_for(&apos;index&apos;))\n    return render_template(&apos;index.html&apos;,\n                           current_time=datetime.utcnow(),form=form,name=session.get(&apos;name&apos;),known=session.get(&apos;known&apos;,False))\n\n\n@app.route(&apos;/user/&lt;name&gt;&apos;)\ndef user(name):\n    return render_template(&apos;user.html&apos;, name=name)\n\n\nif __name__ == &apos;__main__&apos;:\n    db.create_all()\n    manager.run()</code></pre><p>接下来我要试试Gmail.. 9.成功,而且好像知道了怎么用自己的一个账号发送给另一个账号的奇技淫巧…recipients参数是目标邮箱.结果如下: Gmail: 1. 给自己发的结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193039.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193039.png\" alt></a> 2.给QQ邮箱发的结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193200.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193200.png\" alt></a> QQ: 接收到Gmail发送的结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171010193350.png\" alt=\"Aaron\"><code>10.</code>将发送邮件功能集成到页面. 功能=&gt;每次添加新用户发送到邮箱信息:<code>&#39;User { { username }} has joined.&#39;</code> 主要<code>发送</code>代码如下:</p>\n<pre><code>def send_email(to,subject,template,**k):\n    msg=Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;]+subject,\n        sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;],recipients=[to])\n    msg.body=render_template(template+&apos;.txt&apos;,**k)\n    msg.html=render_template(template+&apos;.html&apos;,**k)\n    mail.send(msg)</code></pre><p><code>调用</code>代码:</p>\n<pre><code>@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\ndef index():\n    form=NameForm()\n    if form.validate_on_submit():\n        user=User.query.filter_by(username=form.name.data).first()\n        if user is None:\n            user =User(username=form.name.data)\n            db.session.add(user)\n            session[&apos;known&apos;]=False\n            if app.config[&apos;FLASKY_ADMIN&apos;]:\n                send_email(app.config[&apos;FLASKY_ADMIN&apos;],&apos;New User&apos;,&apos;mail/new_user&apos;,user=user)\n        else:\n            session[&apos;known&apos;]=True\n        session[&apos;name&apos;]=form.name.data\n        form.name.data=&apos;&apos;\n        return redirect(url_for(&apos;index&apos;))\n    return render_template(&apos;index.html&apos;,\n                           current_time=datetime.utcnow(),form=form,name=session.get(&apos;name&apos;),known=session.get(&apos;known&apos;,False))</code></pre><p><code>11.</code>最终结果如下: 添加新用户<code>Aaron Swartz</code>: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/ASDADASDAWDA1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/ASDADASDAWDA1.png\" alt></a> <code>12.</code>用异步的方法发送邮件:这样会产生一种无延迟感,用户体验更好. 代码如下:</p>\n<pre><code>from threading import Thread\n\ndef send_async_email(app,msg):\n    with app.app_context():\n        mail.send(msg)\n\ndef send_email(to,subject,template,**k):\n    msg=Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;]+subject,\n        sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;],recipients=[to])\n    msg.body=render_template(template+&apos;.txt&apos;,**k)\n    msg.html=render_template(template+&apos;.html&apos;,**k)\n    thr=Thread(target=send_async_email,args=[app,msg])\n    thr.start()\n    return thr</code></pre><h1 id=\"Done\"><a href=\"#Done\" class=\"headerlink\" title=\"Done!\"></a><strong>Done!</strong></h1>","text":"moudule:Flask_mail 配置参数:  [Figure]  12.用异步的方法发送邮件:这样会产生一种无延迟感,用户体验更好. 代码如下:from threading import Threaddef send_async_email(app,msg):    wit","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"Python","slug":"Flask/Python","count":16,"path":"api/categories/Flask/Python.json"},{"name":"未分类","slug":"Flask/Python/未分类","count":2,"path":"api/categories/Flask/Python/未分类.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"Python Flask 10 用户上传头像","slug":"python-flask-up-fil-to-app-2","date":"2017-10-18T03:54:20.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-flask-up-fil-to-app-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B718.png","content":"<p>借助上节的基础==&gt; <a href=\"http://be-sunshine.cn/index.php/2017/10/17/python-flask-upfile/\" title=\"&lt;code&gt;点我啊!  Python Flask 上传文件&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啊! Python Flask 上传文件</code></a> 这节我们实现一下<code>修改用户头像</code>以及<code>默认头像</code>的功能. 截止目前的项目进度: <a href=\"https://github.com/834930269/Flask_Study/tree/master/flask-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%845-%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F\" title=\"&lt;code&gt;点我啊! Github:flask-大型网站架构5-新增上传头像&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啊! Github:flask-大型网站架构5-新增上传头像</code></a> 最终效果如图: <code>1.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获18.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B718.png\" alt></a> <code>2.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获19.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B719.png\" alt></a> <code>3.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获21.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B721.png\" alt></a> <code>4.</code> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/捕获22.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/%E6%8D%95%E8%8E%B722.png\" alt></a></p>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始!\"></a>开始!</h1><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1:\"></a>1:</h3><p>因为我们需要对每个用户<code>存下他的头像信息</code>. 这里我们选择<code>直接存储图片url</code>的形式进行存储. 所以我们需要对<code>model层</code>的<code>User</code>添加一个<code>gravatar</code>列,存储头像url. 主要代码如下:</p>\n<pre><code>class User(UserMixin,db.Model):\n    __tablename__ = &apos;users&apos;\n    gravatar = db.Column(db.String(200),default=&apos;/_uploads/photos/default.jpg&apos;)</code></pre><p>其中<code>gravatar</code>的默认值是<code>默认头像相对url</code>.</p>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2:\"></a>2:</h3><p>首先我们依然需要<code>先码出</code>上传头像界面的<code>表单(form)</code>. 先配置<code>所要上传的目标地址</code>变量<code>/config.py</code>:</p>\n<pre><code>import os\nUPLOADED_PHOTOS_DEST = os.path.abspath(os.path.join(os.getcwd(),&quot;app/static/Gravatar&quot;))</code></pre><p>我们需要对<code>上传文件</code>进行约束为图片格式,这里我们用一个<code>UploadSet</code>模块,编辑代码<code>/app/__init__.py</code>:</p>\n<pre><code>from flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\n\nphotos = UploadSet(&apos;photos&apos;,IMAGES)</code></pre><p>然后将创建好的<code>photo</code>对象加入已经创建好的<code>app</code>中:</p>\n<pre><code>configure_uploads(app,photos)\npatch_request_class(app)  </code></pre><p>然后编写<code>form表单</code>:</p>\n<pre><code>from flask_wtf.file import FileField, FileRequired, FileAllowed\nfrom flask_uploads import UploadSet, configure_uploads, IMAGES, patch_request_class\nfrom .. import photos\nfrom flask_wtf import FlaskForm\n\nclass UploadForm(FlaskForm):\n    photo = FileField(validators=[\n        FileAllowed(photos, u&apos;只能上传图片！&apos;), \n        FileRequired(u&apos;请选择一个头像吧！&apos;)])\n    submit = SubmitField(u&apos;确认上传&apos;,render_kw={&quot;class&quot;:&quot;btn btn-primary&quot;})</code></pre><p>其中<code>render_kw</code>是一个<code>dict</code>类型,作用是<code>渲染对应表单的css</code>. <code>FileAllowed</code>用来检测上传文件类型,不对的的话返回<code>第二个参数</code>. <code>FileRequired</code>和<code>Required</code>作用近似,即<code>非空判断</code>.</p>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3:\"></a>3:</h3><p>接下来我们就要开始编写<code>view层</code>了. 这里我们将编辑头像页面的<code>url</code>设为<code>/edit-gravatar</code> 所以我们需要码一个有<code>GET</code>和<code>POST</code>的视图函数.</p>\n<pre><code>from flask_login import  current_user\nfrom flask_login import login_user,login_required,logout_user\nfrom .forms import UploadForm\nfrom flask import render_template, session, redirect, url_for, current_app,abort,flash\nfrom .. import db,photos\n\n@main.route(&apos;/edit-gravatar&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])\n@login_required\ndef edit_gravatar():\n    form = UploadForm()\n    if form.validate_on_submit():\n        filename = photos.save(form.photo.data)\n        file_url = photos.url(filename)\n        current_user.gravatar = file_url\n        db.session.add(current_user)\n        flash(&apos;修改成功!&apos;)\n        return redirect(url_for(&apos;.user&apos;,username=current_user.username,file_url=file_url))\n\n    return render_template(&apos;edit_gravatar.html&apos;,form=form,file_url=current_user.gravatar)</code></pre><p>注意我们所上传的头像文件<code>即使名字相同也不会覆盖掉之前的头像文件的</code>..(所以还是以二进制存到数据库中更好一点么).</p>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4:\"></a>4:</h3><p>接下来我们需要编写<code>前台界面</code>了: 首先,由于如果我们直接用<code>quick_form</code>创建表单的话,表单的<code>css</code>就不好改了.所以我们把每个表单分开放入<code>form type=file</code>中,并且通过<code>传参</code>或者<code>重叠覆盖</code>修改表单控件的<code>样式</code>. 其中,修改<code>input type=file</code>样式的通用方法是<code>将opacity设为0</code>,然后用一个<code>a</code>标签将<code>input和a组合</code>到一起,这样修改<code>a</code>的样式便相当于修改<code>input</code>的样式. 对应的几部分代码如下:</p>\n<pre><code>/*CSS*/\n.upload{\n    padding: 5px 10px;\n    height: 40px;\n    line-height: 30px;\n    position: relative;\n    border: 1px solid #999;\n    text-decoration: none;\n    text-align:center;\n    color: #fff;\n}\n.change{\n    position: absolute;\n    overflow: hidden;\n    right: 0;\n    top: 0;\n    opacity: 0;\n}\n\n\n&lt;a class=&quot;btn btn-success upload&quot; placeholder=&quot;上传头像&quot; &gt;\n    &lt;p id=&quot;show_gt&quot;&gt;选择您要上传的头像~&lt;/p&gt;\n    { { form.photo(class=&quot;change&quot;,placeholder=&quot;上传头像&quot;,onchange=&quot;c()&quot;) }}\n&lt;/a&gt;</code></pre><p>然后在<code>css</code>中修改<code>upload</code>样式即可. 其中<code>btn btn-xxx</code>是<code>bootstrap</code>样式. 但是到这里还需要考虑一个问题,就是当<code>选中图片以后,并不会显示到页面上,必选点击提交以后</code>才会修改,下次访问这个页面才会变成新图片. 所以我们需要一种方法使<code>选中图片的同时将图片显示在页面上</code>,并和之前的头像对比. 这里我们使用直接<code>通过JavaScript在本地显示</code>: 对应JS代码如下:</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function c () {\n        var gt=document.getElementById(&apos;show_gt&apos;);\n        gt.innerText = &apos;已选中图片~&apos;\n        var r= new FileReader();\n        f=document.getElementById(&apos;photo&apos;).files[0];\n        r.readAsDataURL(f);\n        r.onload=function  (e) {\n            document.getElementById(&apos;show&apos;).src=this.result;\n        };\n    }\n&lt;/script&gt;</code></pre><p>因为<code>FlaskForm</code>生成的表单的<code>id</code>和类中对应<code>表单实例的名字</code>是一样的,所以这里的<code>id</code>是photo. 获取<code>图片对象(object) f</code>. 把这个File对象传给FileReader对象的读取方法，就能读取文件了。 连接: <a href=\"http://blog.csdn.net/oscar999/article/details/37499743/\" title=\"&lt;code&gt;[JS进阶] HTML5 之文件操作(file)&lt;/code&gt;\" target=\"_blank\" rel=\"noopener\"><code>点我啦! [JS进阶] HTML5 之文件操作(file)</code></a> 最后的<code>r.result</code>即为对应图片的<code>二进制数据</code>. 然后就是修改一下排版即可:</p>\n<pre><code>&lt;!-- edit_gravatar.html --&gt;\n{% extends \"base.html\" %}\n{% import \"bootstrap/wtf.html\" as wtf %}\n{% block title %}编辑个人头像{% endblock %}\n    {% block page_content %}\n    <form method=\"POST\" enctype=\"multipart/form-data\">\n         { { form.hidden_tag() }}\n         <div class=\"page-header\"><h2>展览板~</h2></div>\n         <a class=\"btn btn-success upload\" placeholder=\"上传头像\"><p id=\"show_gt\">选择您要上传的头像~</p>\n            { { form.photo(class=\"change\",placeholder=\"上传头像\",onchange=\"c()\") }}\n         </a><br>\n         {% for error in form.photo.errors %}\n             <span style=\"color: red;\">{ { error }}</span>\n         {% endfor %}\n         {% if file_url %}\n         <br><img src=\"{ { file_url }}\" width=\"256\" height=\"256\">\n         {% endif %}\n         <a class=\"btn btn-success\"><-之前 之后-></-之前></a>\n         <img src=\"{ { file_url }}\" id=\"show\" width=\"256\" height=\"256\"><br><br>\n         { { form.submit }}\n    </form>\n    <script type=\"text/javascript\">\n        function c () {\n            var gt=document.getElementById('show_gt');\n            gt.innerText = '已选中图片~'\n            var r= new FileReader();\n            f=document.getElementById('photo').files[0];\n            r.readAsDataURL(f);\n            r.onload=function  (e) {\n                document.getElementById('show').src=this.result;\n            };\n        }\n    </script>\n    {% endblock %}</code></pre><h3 id=\"Done\"><a href=\"#Done\" class=\"headerlink\" title=\"Done\"></a>Done</h3>","text":"借助上节的基础==&gt; 点我啊! Python Flask 上传文件 这节我们实现一下修改用户头像以及默认头像的功能. 截止目前的项目进度: 点我啊! Github:flask-大型网站架构5-新增上传头像 最终效果如图: 1.  [Figure]          { { ","link":"","raw":null,"photos":[],"categories":[{"name":"Flask","slug":"Flask","count":18,"path":"api/categories/Flask.json"},{"name":"JS","slug":"Flask/JS","count":1,"path":"api/categories/Flask/JS.json"},{"name":"Python","slug":"Flask/JS/Python","count":1,"path":"api/categories/Flask/JS/Python.json"}],"tags":[{"name":"Flask","slug":"Flask","count":20,"path":"api/tags/Flask.json"},{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"JS","slug":"JS","count":5,"path":"api/tags/JS.json"}]},{"title":"Python Learnning Record","slug":"python-learnning-record","date":"2017-05-21T03:42:53.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/python-learnning-record.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/0.png","content":"<p><strong>【Link】</strong> <strong><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"noopener\">廖雪峰的python教程</a></strong> <strong>【直接运行py文件】</strong> <strong>有同学问，能不能像.exe文件那样直接运行<code>.py</code>文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在<code>.py</code>文件的第一行加上一个特殊的注释：</strong></p>\n<p>**`#!/usr/bin/env python3</p>\n<p>print(‘hello, world’)`** </p>\n<p><strong>然后，通过命令给<code>hello.py</code>以执行权限：</strong></p>\n<p><strong><code>$ chmod a+x hello.py</code></strong> </p>\n<p><strong>就可以直接运行<code>hello.py</code>了，比如在Mac下运行：</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/0.png\" alt></strong> <strong>【数据类型和变量】</strong> <strong>Python可以处理任意大小的整数，当然包括负整数. (惊了</strong> <strong>注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在<code>-2147483648</code>-<code>2147483647</code>。</strong> <strong>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</strong> <strong>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</strong></p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a><strong>字符串</strong></h4><p><strong>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</strong> <strong>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\\</code>来标识，比如：</strong></p>\n<p><strong><code>&#39;I\\&#39;m \\&quot;OK\\&quot;!&#39;</code></strong> </p>\n<p><strong>表示的字符串内容是：</strong></p>\n<p><strong><code>I&#39;m &quot;OK&quot;!</code></strong> </p>\n<p><strong>如果字符串里面有很多字符都需要转义，就需要加很多<code>\\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：</strong></p>\n<p>**`&gt;&gt;&gt; print(‘\\\\t\\‘)<br>\\       \\</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>print(r’\\\\t\\‘)<br>\\\\t\\`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果字符串内部有很多换行，用<code>\\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，可以自己试试：</strong></p>\n<p><strong><code>&gt;&gt;&gt; print(&#39;&#39;&#39;line1\n... line2\n... line3&#39;&#39;&#39;)\nline1\nline2\nline3</code></strong> </p>\n<p><strong>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入。如果写成程序，就是：</strong></p>\n<p><strong><code>print(&#39;&#39;&#39;line1\nline2\nline3&#39;&#39;&#39;)</code></strong> </p>\n<p><strong>多行字符串<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>还可以在前面加上<code>r</code>使用，请自行测试。</strong></p>\n<h4 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a><strong>空值</strong></h4><p><strong>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</strong> <strong>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</strong> <strong>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</strong></p>\n<p><strong><code>a = 123 # a是整数\nprint(a)\na = &#39;ABC&#39; # a变为字符串\nprint(a)</code></strong> </p>\n<p><strong>【整数的除法】</strong> <strong>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是<code>/</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 / 3\n3.3333333333333335</code></strong> </p>\n<p><strong><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 9 / 3\n3.0</code></strong> </p>\n<p><strong>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 // 3\n3</code></strong> </p>\n<p><strong>你没有看错，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</strong></p>\n<p><strong>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</strong></p>\n<p><strong><code>&gt;&gt;&gt; 10 % 3\n1</code></strong> </p>\n<p><strong>无论整数做<code>//</code>除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</strong> <strong>【字节】</strong> <strong>最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</strong> <strong>【编码】</strong> <strong>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</strong> <strong>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</strong> <strong>UTF-8:可变长编码.</strong> <strong>Unicode:不可变长全码.</strong> <strong>转换过程:</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/1-1.png\" alt></strong>   <strong>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/2.png\" alt></strong> <strong>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</strong> ** 【python的字符串】** ** 搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。** <strong>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</strong></p>\n<p><strong><code>&gt;&gt;&gt; print(&#39;包含中文的str&#39;)\n包含中文的str</code></strong> </p>\n<p><strong>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</strong></p>\n<p>**`&gt;&gt;&gt; ord(‘A’)<br>65</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>ord(‘中’)<br>20013<br>chr(66)<br>‘B’<br>chr(25991)<br>‘文’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;\\u4e2d\\u6587&#39;\n&#39;中文&#39;</code></strong> </p>\n<p><strong>【网络中文本的比特流传输转换】</strong> <strong>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</strong></p>\n<p><strong><code>x = b&#39;ABC&#39;</code></strong> </p>\n<p><strong>要注意区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</strong></p>\n<p><strong>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</strong></p>\n<p>**`&gt;&gt;&gt; ‘ABC’.encode(‘ascii’)<br>b’ABC’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘中文’.encode(‘utf-8’)<br>b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’<br>‘中文’.encode(‘ascii’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-1: ordinal not in range(128)`** </module></stdin></p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</strong></p>\n<p><strong>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\\x##</code>显示。</strong></p>\n<p><strong>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</strong></p>\n<p>**`&gt;&gt;&gt; b’ABC’.decode(‘ascii’)<br>‘ABC’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’.decode(‘utf-8’)<br>‘中文’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数：</strong></p>\n<p>**`&gt;&gt;&gt; len(‘ABC’)<br>3</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>len(‘中文’)<br>2`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</strong></p>\n<p>**`&gt;&gt;&gt; len(b’ABC’)<br>3</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>len(b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’)<br>6<br>len(‘中文’.encode(‘utf-8’))<br>6`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</strong></p>\n<p><strong>【格式化输入输出】</strong></p>\n<p><strong>最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似<code>&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</strong> <strong><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/3.png\" alt></strong> <strong>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</strong></p>\n<p>**`&gt;&gt;&gt; ‘Hello, %s’ % ‘world’<br>‘Hello, world’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘Hi, %s, you have $%d.’ % (‘Michael’, 1000000)<br>‘Hi, Michael, you have $1000000.’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>你可能猜到了，<code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</strong> <strong>常见的占位符有：</strong></p>\n<p><strong>%d</strong></p>\n<p><strong>整数</strong></p>\n<p><strong>%f</strong></p>\n<p><strong>浮点数</strong></p>\n<p><strong>%s</strong></p>\n<p><strong>字符串</strong></p>\n<p><strong>%x</strong></p>\n<p><strong>十六进制整数</strong></p>\n<p><strong>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</strong></p>\n<p>**`&gt;&gt;&gt; ‘%2d-%02d’ % (3, 1)<br>‘ 3-01’</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>‘%.2f’ % 3.1415926<br>‘3.14’`** </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><strong>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;Age: %s. Gender: %s&#39; % (25, True)\n&#39;Age: 25. Gender: True&#39;</code></strong> </p>\n<p><strong>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</strong></p>\n<p><strong><code>&gt;&gt;&gt; &#39;growth rate: %d %%&#39; % 7\n&#39;growth rate: 7 %&#39;</code></strong> </p>\n<p><strong>【list】</strong> <strong>如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</strong></p>\n<blockquote>\n<p><strong><code>&gt; classmates[-1] &#39;Tracy&#39;</code></strong> <strong><code>往后分块记笔记...</code></strong></p>\n</blockquote>\n<p><strong>【python3学习 模块】</strong> <strong>python3内置模块文档: <a href=\"https://docs.python.org/3/library/functions.html\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/3/library/functions.html</a></strong> <strong>python3自己写模块及使用: <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431845183474e20ee7e7828b47f7b7607f2dc1e90dbb000\" target=\"_blank\" rel=\"noopener\">廖雪峰-使用模块</a></strong> <strong>python3安装第三方模块:</strong> <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186362353505516c5d4e38456fb225c18cc5b54ffb000#0\" target=\"_blank\" rel=\"noopener\"><strong>安装第三方模块</strong></a></p>\n","text":"【Link】 廖雪峰的python教程 【直接运行py文件】 有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：**`#!/usr/bin/env python3","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"}]},{"title":"聊天室内核从0开始 – 2 处理语料库","slug":"type-3","date":"2019-01-04T12:48:01.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/type-3.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>最后更新于2019/1/4</p>\n</blockquote>\n<h1 id=\"处理语料库\"><a href=\"#处理语料库\" class=\"headerlink\" title=\"处理语料库\"></a>处理语料库</h1><h2 id=\"简单处理提问与应答\"><a href=\"#简单处理提问与应答\" class=\"headerlink\" title=\"简单处理提问与应答\"></a>简单处理提问与应答</h2><blockquote>\n<p>这里我们本来可以用jieba或者其他的一些库来帮忙分词,但是因为网上存在已经分好词的语料库,所以可以省略这一步. 至于语料库,可以在github上直接搜索语料库即可以搜到. 一般语料库如下:</p>\n</blockquote>\n<pre><code>E\nM 呵/呵\nM 是/王/若/猫/的/。\nE\nM 不/是\nM 那/是/什/么/？\nE\nM 怎/么/了\nM 我/很/难/过/，/安/慰/我/~\nE\nM 开/心/点/哈/,/一/切/都/会/好/起/来\nM 嗯/ /会/的</code></pre><p>其中E代表是下一组应答的开始,M代表的是一句话. 可以认为是一问一答.</p>\n<h2 id=\"将一个句子编码化\"><a href=\"#将一个句子编码化\" class=\"headerlink\" title=\"将一个句子编码化\"></a>将一个句子编码化</h2><blockquote>\n<p>因为我们如果企图对一个句子进行判断和操作时,我们需要将这串句子编码化成为一组数字更为方便,且占内存更少. 当然,我们用这组句子编码成数字以后也可以重新根据数字编码回字符.</p>\n</blockquote>\n<p>举个栗子: map[3]=’a’,map[2]=’b’ 则 32 = ab,且 ba = 23</p>\n<blockquote>\n<p>Python的一个语法糖:</p>\n<blockquote>\n<p>[2]*2=[2,2]</p>\n</blockquote>\n<p>2019/1/9 日更新-完善注释</p>\n</blockquote>\n<pre><code>import numpy as np\n\n# 句子编码化\nclass WordSequence(object):\n    #标注TAG\n    PAD_TAG=&apos;&lt;pad&gt;&apos;\n    UNK_TAG=&apos;&lt;unk&gt;&apos; # 未识别\n    START_TAG=&apos;&lt;s&gt;&apos;\n    END_TAG=&apos;&lt;/s&gt;&apos;\n\n    PAD=0\n    UNK=1\n    START=2\n    END=3\n\n    # 初始化标签\n    def __init__(self):\n        self.dict = {\n            WordSequence.PAD_TAG: WordSequence.PAD,\n            WordSequence.UNK_TAG: WordSequence.UNK,\n            WordSequence.START_TAG: WordSequence.START,\n            WordSequence.END_TAG: WordSequence.END\n        }\n        # 是否训练过了\n        self.fited=False\n\n    # 将word的词性转换为下标\n    def to_index(self,word):\n        assert self.fited,&apos;WordSequence尚未进行fit操作&apos;\n        # 如果有,返回下标\n        if word in self.dict:\n            return self.dict[word]\n        # 没有,返回UNKnow\n        return WordSequence.UNK\n\n    def to_word(self,index):\n        assert self.fited,&apos;WordSequence尚未进行fit操作&apos;\n        # 遍历dict,找到就返回value\n        for k,v in self.dict.items():\n            if v==index:\n                return k\n        # 否则返回不知道\n        return WordSequence.UNK_TAG\n\n    def size(self):\n        assert self.fited, &apos;WordSequence尚未进行fit操作&apos;\n        return len(self.dict) + 1\n\n    def __len__(self):\n        return self.size()\n\n    # 对数据进行处理\n    def fit(self,sentences,min_count=5,max_count=None,max_features=None):\n        assert not self.fited, &apos;WordSequence只能进行一次fit&apos;\n\n        count={}\n        # 遍历所有句子\n        for sentence in sentences:\n            arr=list(sentence)\n            # 统计词频\n            for a in arr:\n                if a not in count:\n                    count[a]=0\n                count[a]+=1\n        # 只统计词频大于最小值的\n        if min_count is not None:\n            count={k:v for k,v in count.items() if v&gt;=min_count}\n        # 仅统计词频小于最大值的\n        if max_count is not None:\n            count={k:v for k,v in count.items() if v&lt;=max_count}\n\n        # 如果有特征值数的限制,比如[1,2,3]max_features=2,则\n        # 需要用的是[1,2]\n        if isinstance(max_features,int):\n            # list(dict)=[(key,value),...]\n            count = sorted(list(count.items()),key=lambda x:x[1])\n            if max_features is not None and len(count) &gt; max_features:\n                count = count[-int(max_features):]# 从尾部向前\n            # 这个以及下面那个类似于前向星式存图法里的\n            # 下标递增式存法,即加入一个元素,该元素下标\n            # 变成当前已存在的元素个数\n            # 就是把count中的key作为dict的key\n            # 在dict中的下标作为dict的value\n            for w,_ in count:\n                self.dict[w]=len(self.dict)\n        else:\n            for w in sorted(count.keys()):\n                self.dict[w]=len(self.dict)\n\n        # 处理完成\n        self.fited=True\n\n    # 序列成数列\n    def transform(self, sentence, max_len=None):\n        assert self.fited, &apos;WordSequence尚未进行fit操作&apos;\n        # PAD -&gt; 填充标签,先填充本来的句子长度所有元素为PAD\n        # 如: [&apos;&lt;PAD&gt;&apos;,&apos;&lt;PAD&gt;&apos;...]\n        if max_len is not None:\n            r = [self.PAD] * max_len\n        else:\n            r = [self.PAD] * len(sentence)\n\n        for index, a in enumerate(sentence):\n            if max_len is not None and index &gt;= len(r):\n                break\n            r[index] = self.to_index(a)\n\n        return np.array(r)\n\n    # 序列转回字母\n    def inverse_transform(self, indices, ignore_pad=False, ignore_unk=False, ignore_start=False, ignore_end=False):\n        ret = []\n        for i in indices:\n            word = self.to_word(i)\n            if word == WordSequence.PAD_TAG and ignore_pad:\n                continue\n            if word == WordSequence.UNK_TAG and ignore_unk:\n                continue\n            if word == WordSequence.START_TAG and ignore_start:\n                continue\n            if word == WordSequence.END_TAG and ignore_end:\n                continue\n\n            ret.append(word)\n\n        return ret\n\n\ndef test():\n    ws = WordSequence()\n    ws.fit([[&apos;你&apos;, &apos;好&apos;, &apos;啊&apos;], [&apos;你&apos;, &apos;好&apos;, &apos;哦&apos;], ])\n\n    indice = ws.transform([&apos;我&apos;, &apos;们&apos;, &apos;好&apos;])\n    print(indice)\n\n    back = ws.inverse_transform(indice)\n    print(back)\n\n\nif __name__ == &apos;__main__&apos;:\n    test()</code></pre><blockquote>\n<p>可以发现其实都是一些简单的映射.将每个字符都映射到一个整数上面去.</p>\n<blockquote>\n<p>这样做以后再将其打包成pkl会大大减少占用硬盘: 83MB-&gt;750kb 了解一下</p>\n</blockquote>\n</blockquote>\n<h2 id=\"对于语料中句子的规范化\"><a href=\"#对于语料中句子的规范化\" class=\"headerlink\" title=\"对于语料中句子的规范化\"></a>对于语料中句子的规范化</h2><blockquote>\n<p>这里我们提供三个函数(可自行编码):</p>\n</blockquote>\n<pre><code># 这个函数的作用是在有多个回答的条件下将回答合并起来\ndef make_split(line):\n    if re.match(r&apos;.*([，···?!\\.,!？])$&apos;, &apos;&apos;.join(line)):\n        return []\n\n    return [&apos;, &apos;]\n\n# 是否是一个有意义的句子(这里我们不做规则)\ndef good_line(line):\n    #if len(re.findall(r&apos;[a-zA-Z0-9]&apos;, &apos;&apos;.join(line))) &gt; 2:\n        #return False\n    return True\n\n# 规范化语料,即对于已提取出的预料中的句子进行处理\ndef regular(sen):\n    #sen = re.sub(r&apos;\\.{3,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;···{2,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;[,]{1,100}&apos;, &apos;，&apos;, sen)\n    #sen = re.sub(r&apos;[\\.]{1,100}&apos;, &apos;。&apos;, sen)\n    #sen = re.sub(r&apos;[\\?]{1,100}&apos;, &apos;？&apos;, sen)\n    #sen = re.sub(r&apos;[!]{1,100}&apos;, &apos;！&apos;, sen)\n\n    return sen</code></pre><blockquote>\n<p>可以发现我基本都注释掉了,因为小黄鸡的语料库就是标准的一问一答,不是自然地语料库(微信随便提取的那类),所以不需要过多的处理.</p>\n</blockquote>\n<h2 id=\"打包成pkl文件\"><a href=\"#打包成pkl文件\" class=\"headerlink\" title=\"打包成pkl文件\"></a>打包成pkl文件</h2><blockquote>\n<p>首先说一下pkl文件:</p>\n<blockquote>\n<p>pkl文件是Python运行时产生的数据序列化后存储下来的文件格式,类似于其他语言的序列化.方便以后的继续使用和读取.</p>\n</blockquote>\n</blockquote>\n<p>具体的处理语料库和打包(一问一答Tuple)代码如下:</p>\n<pre><code># -*- coding:utf-8 -*-\n\nimport re\nimport pickle\nimport sys\nfrom tqdm import tqdm\n\n\ndef make_split(line):\n    if re.match(r&apos;.*([，···?!\\.,!？])$&apos;, &apos;&apos;.join(line)):\n        return []\n\n    return [&apos;, &apos;]\n\n# 是否是一个有意义的句子(这里我们不做规则)\ndef good_line(line):\n    #if len(re.findall(r&apos;[a-zA-Z0-9]&apos;, &apos;&apos;.join(line))) &gt; 2:\n        #return False\n    return True\n\n# 规范化语料\ndef regular(sen):\n    #sen = re.sub(r&apos;\\.{3,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;···{2,100}&apos;, &apos;···&apos;, sen)\n    #sen = re.sub(r&apos;[,]{1,100}&apos;, &apos;，&apos;, sen)\n    #sen = re.sub(r&apos;[\\.]{1,100}&apos;, &apos;。&apos;, sen)\n    #sen = re.sub(r&apos;[\\?]{1,100}&apos;, &apos;？&apos;, sen)\n    #sen = re.sub(r&apos;[!]{1,100}&apos;, &apos;！&apos;, sen)\n\n    return sen\n\n# 这样设置的意思是无限制\ndef main(limit=99999, x_limit=1, y_limit=1):\n    from word_sequence import WordSequence\n    print(&apos;extract lines&apos;)\n    fp=open(&quot;xiaohuangji.conv&quot;,&apos;r&apos;,errors=&apos;ignore&apos;,encoding=&apos;utf-8&apos;)\n\n    groups=[]\n    group=[]\n\n    # 提取出所有问答组\n    for line in tqdm(fp):\n        if line.startswith(&apos;M &apos;):\n            line=line.replace(&apos;\\n&apos;,&apos;&apos;)\n            if &apos;/&apos; in line:\n                line = line[2:].split(&apos;/&apos;)\n            else:\n                line=list(line[2:])\n            line=line[:-1]\n\n            group.append(list(regular(&apos;&apos;.join(line))))\n        else:\n            if group:\n                groups.append(group)\n                group = []\n    if group:\n        groups.append(group)\n        group = []\n\n    print(&apos;extract group&apos;)\n\n    x_data = []\n    y_data = []\n    # 将问与答分开\n    for group in tqdm(groups):\n        for i,line in  enumerate(group):\n            last_line=None\n            # last_line是上一句\n            if i&gt;0:\n                last_line = group[i-1]\n                if not good_line(last_line):\n                    last_line = None\n            if i&lt;len(group)-1:\n                next_line=group[i+1]\n                if not good_line(next_line):\n                    next_line=None\n            # 如果有下一句\n            if not last_line:\n                x_data.append(line)\n                y_data.append(next_line)\n\n        #print(len(x_data), len(y_data))\n\n    print(len(x_data), len(y_data))\n    # 构建问答,测试前20个\n    for ask,answer in zip(x_data[:20],y_data[:20]):\n        print(&apos;&apos;.join(ask))\n        print(&apos;&apos;.join(answer))\n        print(&apos;-&apos; * 20)\n\n    # 生成pkl文件\n    data=list(zip(x_data,y_data))\n\n    data=[\n        (x,y) for x,y in data if limit&gt;len(x) &gt;=x_limit and limit &gt; len(y) &gt;= y_limit\n    ]\n\n    # 打包成pkl\n    x_data, y_data = zip(*data)\n    ws_input = WordSequence()\n    ws_input.fit(x_data + y_data)\n    print(&apos;dump&apos;)\n    pickle.dump(\n        (x_data, y_data), open(&apos;chatbot.pkl&apos;, &apos;wb&apos;))\n    pickle.dump(ws_input, open(&apos;ws.pkl&apos;, &apos;wb&apos;))\n    print(&apos;done&apos;)\n\nif __name__ == &apos;__main__&apos;:\n    main()</code></pre><h1 id=\"聊天室内核从0开始-–-3-Seq2Seq\"><a href=\"#聊天室内核从0开始-–-3-Seq2Seq\" class=\"headerlink\" title=\"聊天室内核从0开始 – 3 Seq2Seq\"></a>聊天室内核从0开始 – 3 Seq2Seq</h1><p><a href=\"http://be-sunshine.cn/index.php/2019/01/06/seq2seq/\" title=\"聊天室内核从0开始 – 3 Seq2Seq\" target=\"_blank\" rel=\"noopener\">聊天室内核从0开始 – 3 Seq2Seq</a></p>\n","text":"最后更新于2019/1/4处理语料库简单处理提问与应答这里我们本来可以用jieba或者其他的一些库来帮忙分词,但是因为网上存在已经分好词的语料库,所以可以省略这一步. 至于语料库,可以在github上直接搜索语料库即可以搜到. 一般语料库如下:EM 呵/呵M 是/王/若/猫/的/","link":"","raw":null,"photos":[],"categories":[{"name":"Python","slug":"Python","count":41,"path":"api/categories/Python.json"},{"name":"聊天机器人内核","slug":"Python/聊天机器人内核","count":1,"path":"api/categories/Python/聊天机器人内核.json"}],"tags":[{"name":"Python","slug":"Python","count":65,"path":"api/tags/Python.json"},{"name":"聊天机器人内核","slug":"聊天机器人内核","count":3,"path":"api/tags/聊天机器人内核.json"}]}]}