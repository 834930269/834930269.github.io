{"name":"第二届ACM山东省塞","slug":"第二届ACM山东省塞","count":1,"postlist":[{"title":"第二届ACM山东省赛","slug":"2-acm-shandong","date":"2018-04-24T01:58:31.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/2-acm-shandong.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"A-Nim-Bash-博弈\"><a href=\"#A-Nim-Bash-博弈\" class=\"headerlink\" title=\"A: Nim+Bash 博弈\"></a>A: Nim+Bash 博弈</h1><blockquote>\n<p>Nim博弈可以看做只考虑取二进制化后的数的位数上的1,结合Bash就变成了从几堆中取相应的1 答案是 统计二进制位数,如果全部取模(3+1)等于0,则是必败态</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=11000;\n\nint a[maxn],N,T,K,max_tot;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        memset(a,0,sizeof(a));\n        max_tot=0;\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;K);\n            int tot=0;\n            while(K){\n                if(K&amp;1) a[tot++]++;\n                else tot++;\n                K&gt;&gt;=1;\n            }\n            max_tot=max(max_tot,tot);\n        }\n        //printf(&quot;max: %d\\n&quot;,max_tot);\n        bool flag=true;\n        for(int i=0;i&lt;max_tot;++i){\n            if(a[i]%4){\n                flag=false;\n                break;\n            }\n        }\n        printf(flag?&quot;No\\n&quot;:&quot;Yes\\n&quot;);\n    }\n    return 0;\n}</code></pre><h1 id=\"B-排序模拟\"><a href=\"#B-排序模拟\" class=\"headerlink\" title=\"B:排序模拟\"></a>B:排序模拟</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nstruct team{\n    char name[40];\n    bool all_girls;\n    int solved;\n    int pe;\n    int id;\n\n    bool operator&lt;(const team&amp; A) const{\n        if(solved==A.solved){\n            return pe&gt;A.pe;\n        }else return solved&lt;A.solved;\n    }\n};\n\nstruct Name{\n    char name[40];\n    int id;\n    bool operator&lt;(const Name&amp; A) const{\n        return id&lt;A.id;\n    }\n};\n\nint T,kase=1;\nint N,M;\nchar str[1000];\npriority_queue&lt;team&gt; pt;\nvector&lt;Name&gt; ans;\n\nvoid init(){\n    while(!pt.empty()) pt.pop();\n    ans.clear();\n}\n\nteam get_team(int id){\n    char name[40];\n    bool all_girls;\n    int solved;\n    int pe;\n    team t;\n\n    sscanf(str,&quot;%s %d %d %d&quot;,name,&amp;all_girls,&amp;solved,&amp;pe);\n    strcpy(t.name,name);\n    t.all_girls=all_girls;\n    t.solved=solved;\n    t.pe=pe;\n    t.id=id;\n    return t;\n}\n\nName new_me(char str[40],int ind){\n    Name me;\n    strcpy(me.name,str);\n    me.id=ind;\n    return me;\n}\n\nvoid can(){\n    bool has_girl=false;\n    while(!pt.empty()){\n        team a=pt.top();pt.pop();\n        if(a.solved&lt;=0) break;\n        if(a.all_girls) has_girl=true;\n        ans.push_back(new_me(a.name,a.id));\n        M--;\n        if(M==0)break;\n    }\n    if(M==0){\n        if(!has_girl){\n            while(!pt.empty()){\n                team a=pt.top();pt.pop();\n                if(a.solved&lt;=0) break;\n                if(a.all_girls){\n                    ans.push_back(new_me(a.name,a.id));\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid cant(){\n    while(!pt.empty()){\n        team a=pt.top();pt.pop();\n        ans.push_back(new_me(a.name,a.id));\n    }\n}\n\nvoid print(){\n    sort(ans.begin(),ans.end());\n    for(int i=0;i&lt;ans.size();++i){\n        printf(&quot;%s\\n&quot;,ans[i].name);\n    }\n    puts(&quot;&quot;);\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        init();\n        scanf(&quot;%d%d\\n&quot;,&amp;N,&amp;M);\n        int low=0;\n        for(int i=0;i&lt;N;++i){\n            gets(str);\n            team a=get_team(i);\n            if(a.solved&gt;=1) low++;\n            pt.push(a);\n        }\n        printf(&quot;Case %d:\\n&quot;,kase++);\n        if(low&gt;=M) can();\n        else cant();\n        print();\n    }\n    return 0;\n}</code></pre><h1 id=\"C-水\"><a href=\"#C-水\" class=\"headerlink\" title=\"C:水\"></a>C:水</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=200;\nchar str[maxn];\nint T;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        bool is=true;\n        gets(str);\n        int len=strlen(str);\n        if(isalpha(str[0]) || str[0]==&apos;_&apos;){\n            for(int i=1;i&lt;len;++i){\n                if(!(isalpha(str[i]) || isdigit(str[i]) || str[i]==&apos;_&apos;)){\n                    printf(&quot;No\\n&quot;);\n                    is=false;\n                    break;\n                }\n            }\n        }else{\n            printf(&quot;No\\n&quot;);\n            is=false;\n        }\n        if(is) printf(&quot;Yes\\n&quot;);\n    }\n\n    return 0;\n}</code></pre><h1 id=\"D-求组合数模-可以大数-可以打表\"><a href=\"#D-求组合数模-可以大数-可以打表\" class=\"headerlink\" title=\"D: 求组合数模,可以大数,可以打表\"></a>D: 求组合数模,可以大数,可以打表</h1><pre><code>///1000*1000的数据直接打表就好\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\nusing namespace std;\nconst int mod=10000003;\nconst int N=1002;\nint c[N][N];\n\nvoid init()//递推打表\n{\n    memset(c,0,sizeof(c));\n    c[0][0]=c[1][0]=c[1][1]=1;\n    for(int i=2;i&lt;N;i++)\n    {\n        c[i][i]=c[i][0]=1;\n        for(int j=0;j&lt;i;j++)\n        {\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//不会越界\n        }\n    }\n}\nint main()\n{\n    init();\n    int k;cin&gt;&gt;k;\n    int a,b;\n    while(k--)\n    {\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;c[a][b]&lt;&lt;endl;//直接输出\n    }\n}</code></pre><h1 id=\"E-快速幂模-数组模拟trie\"><a href=\"#E-快速幂模-数组模拟trie\" class=\"headerlink\" title=\"E:快速幂模+数组模拟trie\"></a>E:快速幂模+数组模拟trie</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int maxn=1e6+7;\n\nint mp[11][11][11];\nchar res[11][11][11];\nchar str[maxn];\n\nll mod_pow(ull x,ull n,int mod){\n    ull res=1;\n    while(n&gt;0){\n        if(n&amp;1) res=res*x%mod;\n        x=x*x%mod;\n        n&gt;&gt;=1;\n    }\n    return res;\n}\n\nvoid f(int id,int n){\n    int ans=mod_pow(id,n,997);\n    //cout&lt;&lt;ans&lt;&lt;endl;\n    int cnt=0;\n    int dt[3]={0,0,0};\n    while(ans){\n        dt[cnt++]=ans%10;\n        ans/=10;\n    }\n    mp[dt[2]][dt[1]][dt[0]]++;\n    res[dt[2]][dt[1]][dt[0]]=(char)id;\n}\n\nvoid init(int n){\n    memset(mp,0,sizeof(mp));\n    ///处理数字\n    for(int i=0;i&lt;10;++i)\n        f(&apos;0&apos;+i,n);\n    ///处理lowalpha\n    for(int i=0;i&lt;27;++i)\n        f(&apos;a&apos;+i,n);\n    ///处理upperalpha\n    for(int i=0;i&lt;27;++i)\n        f(&apos;A&apos;+i,n);\n}\n\nint main(){\n    int T,K;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        scanf(&quot;%d\\n%s&quot;,&amp;K,str);\n        init(K);\n        int len=strlen(str);\n        if(len%3){\n            printf(&quot;No Solution\\n&quot;);\n            continue;\n        }\n        bool flag=true;\n        string ans;\n        for(int i=0;i&lt;len;i+=3){\n            int x=str[i]-&apos;0&apos;,y=str[i+1]-&apos;0&apos;,z=str[i+2]-&apos;0&apos;;\n            //cout&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;mp[x][y][z]&lt;&lt;endl;\n            if(mp[x][y][z]&gt;1 || mp[x][y][z]==0){\n                flag=false;\n                break;\n            }\n            ans+=res[x][y][z];\n        }\n        if(flag) cout&lt;&lt;ans&lt;&lt;endl;\n        else cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;\n    }\n\n    return 0;\n}</code></pre><h1 id=\"I-区间DP\"><a href=\"#I-区间DP\" class=\"headerlink\" title=\"I: 区间DP\"></a>I: 区间DP</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\nconst int maxn=1010;\ntypedef long long LL;\nLL dp[maxn];\nLL sum[maxn],num;\nint T,N,M;\n\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        sum[0]=0ll;\n        dp[0]=0ll;\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;M);\n        for(int i=1;i&lt;=N;++i){\n            scanf(&quot;%lld&quot;,&amp;num);\n            sum[i]=sum[i-1]+num;\n            dp[i]=sum[i]*sum[i];\n        }\n\n        for(int i=2;i&lt;=M;++i){\n            ///枚举区间,j为i划分倒推的一维\n            for(int j=N-M+i;j&gt;=i;--j){\n                for(int k=1;k&lt;j;++k){\n                    dp[j]=min(dp[j],dp[k]+(sum[j]-sum[k])*(sum[j]-sum[k]));\n                }\n            }\n        }\n        printf(&quot;%lld\\n&quot;,dp[N]);\n    }\n    return 0;\n}</code></pre>","text":"A: Nim+Bash 博弈Nim博弈可以看做只考虑取二进制化后的数的位数上的1,结合Bash就变成了从几堆中取相应的1 答案是 统计二进制位数,如果全部取模(3+1)等于0,则是必败态#include&lt;bits/stdc++.h&gt;using namespace st","link":"","raw":null,"photos":[],"categories":[{"name":"第二届ACM山东省塞","slug":"第二届ACM山东省塞","count":1,"path":"api/categories/第二届ACM山东省塞.json"}],"tags":[{"name":"第二届ACM山东省塞","slug":"第二届ACM山东省塞","count":1,"path":"api/tags/第二届ACM山东省塞.json"}]}]}