{"name":"数位DP","slug":"数位DP","count":3,"postlist":[{"title":"动态规划","slug":"dynamic-program","date":"2018-03-13T13:24:32.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/dynamic-program.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>痛并不快乐着..</p>\n</blockquote>\n<h1><span id=\"数位dp\">数位dp</span></h1><blockquote>\n<p>HDU 3555</p>\n<blockquote>\n<p>不要49</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n\nLL dp[20][3];\nint digit[20];\n\nLL dfs(int pos,int pre,int state,bool jud){\n    //cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;state&lt;&lt;endl;\n    ///数位递归到0则返回\n    if(pos==0)\n        return 1;\n    ///如果有数据就返回数据\n    if(!jud&amp;&amp;dp[pos][state]!=-1)\n        return dp[pos][state];\n\n    LL ans=0;\n    int ed=jud?digit[pos]:9;\n    //cout&lt;&lt;ed&lt;&lt;endl;\n    for(int i=0;i&lt;=ed;++i){\n        if(pre==4&amp;&amp;i==9)continue;\n        ans+=dfs(pos-1,i,i==4,jud&amp;&amp;i==ed);\n    }\n    if(!jud){///不取上界时,可以取满\n        dp[pos][state]=ans;\n    }\n    return ans;\n}\n\n///数字处理函数\nLL cal(LL x){\n    int pos=0;\n    while(x){\n        digit[++pos]=x%10;\n        x/=10;\n    }\n    return dfs(pos,0,0,true);\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    int T;\n    for(scanf(&quot;%d&quot;,&amp;T);T;T--){\n        LL n;\n        scanf(&quot;%lld&quot;,&amp;n);\n        printf(&quot;%lld\\n&quot;,n-cal(n)+1);\n    }\n    return 0;\n}</code></pre><blockquote>\n<p>HDU 2089</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000000+7;\nLL dp[20][3];\nint digit[20];\n\nLL dfs(int pos,int pre,int state,bool jud){\n    //cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;state&lt;&lt;endl;\n    ///数位递归到0则返回\n    if(pos==0)\n        return 1;\n    ///如果有数据就返回数据\n    if(!jud&amp;&amp;dp[pos][state]!=-1)\n        return dp[pos][state];\n\n    LL ans=0;\n    int ed=jud?digit[pos]:9;//这句是判断他的上界\n    //cout&lt;&lt;ed&lt;&lt;endl;\n    for(int i=0;i&lt;=ed;++i){\n        if(pre==6&amp;&amp;i==2)continue;\n        if(i==4)continue;\n        ans+=dfs(pos-1,i,i==6,jud&amp;&amp;i==ed);\n    }\n    if(!jud){///不取上界时,可以取满\n        dp[pos][state]=ans;\n    }\n    return ans;\n}\n\n///数字处理函数\nLL cal(LL x){\n    int pos=0;\n    //cout&lt;&lt;&quot;tx: &quot;;\n    while(x){\n        digit[++pos]=x%10;\n        //cout&lt;&lt;x%10&lt;&lt;endl;\n        x/=10;\n    }\n    return dfs(pos,0,0,true);\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    LL n,m;\n    while(~scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m) &amp;&amp; n+m){\n        printf(&quot;%lld\\n&quot;,cal(m)-cal(n-1));\n    }\n    return 0;\n}</code></pre>","text":"痛并不快乐着..数位dpHDU 3555不要49#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL dp[20][3];int digit[20];LL dfs(int pos,int ","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"数位DP","slug":"动态规划/数位DP","count":1,"path":"api/categories/动态规划/数位DP.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"}]},{"title":"「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A","slug":"ecnucodera","date":"2017-05-21T09:49:16.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/ecnucodera.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题目来源】</strong> <strong><a href=\"http://acm.ecnu.edu.cn/contest/16/problem/A/\" target=\"_blank\" rel=\"noopener\">「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A</a></strong> <strong>【Tip】</strong> <strong>找进位规律找的自己恶心吐了,最后跪在了百位进位时忘了加最后的那几次十进位…(最后也是对拍了一个ACcode才找到了错误的地方</strong> <strong>思维漏洞还是太大了,或者说这种思维方式不太好.</strong> <strong>不过也算是又学会了一点东西.</strong> <strong>【My Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int main(){</strong> **    freopen(“in_2.txt”, “r”, stdin);** **    freopen(“out_2.txt”, “w”, stdout);** **    int T,N,M,B,C,EndN,EndM;** **    while(~scanf(“%d”,&amp;T)){** **        int ca=1;** **        while(T–){** **            int REG1,REG2,D1,D2,ans=-INF,r1[3],r2[3],r11[3],r22[3];** **            D1=D2=0;** **            scanf(“%d%d”,&amp;B,&amp;C);** **            REG1=B;** **            REG2=C;** **            red(i,2,0){** **                r1[i]=REG1%10;REG1/=10;** **                r2[i]=REG2%10;REG2/=10;** **            }** **            scanf(“%d”,&amp;N);** **            rep(i,N+1){//甲得i分,乙得M分** **                int D11,D22,all;** **                D11=D22=0;all=0;** **                M=N-i;** **                EndN=B+i;** **                EndM=C+M;** **                red(i,2,0){** **                    r11[i]=EndN%10;EndN/=10;** **                    r22[i]=EndM%10;EndM/=10;** **                }//百位进位19 十位进位9** **                r11[0]=r11[0]-r1[0];** **                if(r11[0]) {** **                    r11[1]=(r11[0]-1)<em>9+(9-r1[1])+r11[1];*</em> **                    all+=(r11[0]*18+r11[1]*9);** **                }else{** **                    r11[1]=r11[1]-r1[1];** **                    all+=(r11[1]<em>9);*</em> **                }** **                r22[0]=r22[0]-r2[0];** **                if(r22[0]) {** **                    r22[1]=(r22[0]-1)<em>9+(9-r2[1])+r22[1];*</em> **                    all+=(r22[0]*18+r22[1]*9);** **                }else{** **                    r22[1]=r22[1]-r2[1];** **                    all+=(r22[1]<em>9);*</em> **                }** **               // printf(“%d\\n”,all+N);** **                ans=max(ans,all+N);** **            }** **            printf(“Case %d: %d\\n”,ca++,ans);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【效率&amp;直观 code】</strong> <strong>感觉处理方法类似于数位dp</strong></p>\n<blockquote>\n<p>**    #include&lt;bits/stdc++.h&gt;** **    using namespace std;** **    #define maxn 1005** **    int dp[maxn];** **    void init(){** **        for(int i=1;i&lt;=999;i++){** **            if(i%100==0){** **                dp[i]=dp[i-1]+19;** **            }else if(i%10==0)** **                dp[i]=dp[i-1]+10;** **            else** **                dp[i]=dp[i-1]+1;** **        }** **        return;** **    }** **    int main(){** **        freopen(“in_2.txt”, “r”, stdin);** **        freopen(“out_3.txt”, “w”, stdout);** **        int T;** **        cin&gt;&gt;T;** **        init();** **        for(int cas=1;cas&lt;=T;cas++){** **            int a,b,k;** **            cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;** **            int ans=0;** **            int tans=0;** **            for(int i=0;i&lt;=k;i++){** **                tans=dp[a+i]-dp[a]+dp[b+k-i]-dp[b];** **               // printf(“%d\\n”,tans);** **                ans=max(ans,tans);** **            }** **            cout&lt;&lt;”Case “&lt;&lt;cas&lt;&lt;”: “;** **            cout&lt;&lt;ans&lt;&lt;”\\n”;** **        }** **        return 0;** **    }**</p>\n</blockquote>\n<p>【数据 in_2.txt】 13 000 000 1 000 000 10 000 000 100 001 000 109 001 001 109 123 123 89 458 253 500 327 652 200 320 602 58 227 725 63 102 103 37 023 001 900 21 23 5 【输出】 Case 1: 1 Case 2: 19 Case 3: 199 Case 4: 217 Case 5: 217 Case 6: 179 Case 7: 1013 Case 8: 398 Case 9: 112 Case 10: 126 Case 11: 73 Case 12: 1791 Case 13: 5</p>\n","text":"【题目来源】 「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A 【Tip】 找进位规律找的自己恶心吐了,最后跪在了百位进位时忘了加最后的那几次十进位…(最后也是对拍了一个ACcode才找到了错误的地方 思维漏洞还是太大了,或","link":"","raw":null,"photos":[],"categories":[{"name":"ECNU","slug":"ECNU","count":2,"path":"api/categories/ECNU.json"},{"name":"思维","slug":"ECNU/思维","count":2,"path":"api/categories/ECNU/思维.json"},{"name":"数位DP","slug":"ECNU/思维/数位DP","count":1,"path":"api/categories/ECNU/思维/数位DP.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"},{"name":"ECNU","slug":"ECNU","count":2,"path":"api/tags/ECNU.json"}]},{"title":"HDU 2098","slug":"hdu-2098","date":"2017-04-18T04:25:02.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/hdu-2098.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>数位dp入门</strong> <strong>【Tip】</strong> <strong><a href=\"http://www.cnblogs.com/wenruo/p/4725005.html\" target=\"_blank\" rel=\"noopener\">一个blog</a></strong> <strong><a href=\"https://wenku.baidu.com/view/9de41d51168884868662d623.html\" target=\"_blank\" rel=\"noopener\">一个ppt</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 数位dp入门 【Tip】 一个blog 一个ppt 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"动态规划","slug":"HDU/动态规划","count":1,"path":"api/categories/HDU/动态规划.json"},{"name":"数位DP","slug":"HDU/动态规划/数位DP","count":1,"path":"api/categories/HDU/动态规划/数位DP.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"}]}]}