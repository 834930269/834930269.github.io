{"name":"技术","slug":"技术","count":14,"postlist":[{"title":"并发测试 工具","slug":"concurrency-tools","date":"2018-07-04T12:28:36.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/concurrency-tools.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>港道理我不想写,记录下吧</p>\n</blockquote>\n<h1><span id=\"postman\">Postman</span></h1><h1><span id=\"ab\">Ab</span></h1><p>ab -n [请求个数] -c [同时允许并发请求数] [url] 例: ab -n 1000 -c 50 <a href=\"http://localhost:8080/test\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/test</a> concurrency-leverl：并发量 Time taken for tests: 测试所用时间 Complete requests: 完成请求数 Failed requests: 失败请求数 Total Transferred: 传输长度总和(服务器-&gt;用户(应用层)) Html transferred: 每个长度 Requests per second: 吞吐率(Complete requests/Time taken for tests) Time per requests: 一个是用户等待,一个是服务器等待 Transffer rate:单位时间服务器获取的数据长度</p>\n<h1><span id=\"jmeter\">Jmeter</span></h1><h1><span id=\"lombok-slf4j\">lombok - slf4j</span></h1><p>需要安装一下lombok插件才行</p>\n","text":"港道理我不想写,记录下吧PostmanAbab -n [请求个数] -c [同时允许并发请求数] [url] 例: ab -n 1000 -c 50 http://localhost:8080/test concurrency-leverl：并发量 Time taken for ","link":"","raw":null,"photos":[],"categories":[{"name":"Slf4j","slug":"Slf4j","count":1,"path":"api/categories/Slf4j.json"},{"name":"并发测试","slug":"Slf4j/并发测试","count":1,"path":"api/categories/Slf4j/并发测试.json"},{"name":"技术","slug":"Slf4j/并发测试/技术","count":1,"path":"api/categories/Slf4j/并发测试/技术.json"}],"tags":[{"name":"Slf4j","slug":"Slf4j","count":1,"path":"api/tags/Slf4j.json"},{"name":"并发测试","slug":"并发测试","count":1,"path":"api/tags/并发测试.json"},{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"加 - 并发编程基础","slug":"corplus","date":"2018-07-02T13:35:18.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/corplus.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/07/cf1e2049ec3ec10bd64b64336c485d03.png","content":"<blockquote>\n<p>并发的一些基础概念</p>\n</blockquote>\n<h1><span id=\"cpu-多级缓存\">CPU 多级缓存</span></h1><p>为了解决CPU与主存间速度不匹配的问题.</p>\n<h2><span id=\"时间局部性\">时间局部性</span></h2><p>数据可能被重复访问</p>\n<h2><span id=\"空间局部性\">空间局部性</span></h2><p>数据周围的一些数据,也可能被访问</p>\n<h2><span id=\"缓存一致性mesi协议\">缓存一致性(MESI协议)</span></h2><p>为了搞定共享数据一致的问题 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/cf1e2049ec3ec10bd64b64336c485d03.png\" alt> M: 已修改,待写回 E: 缓存只被缓存在CPU中,未被修改,修改后转为 M S: 共享态,可能被多个CPU共享 I: 有其他CPU修改了缓存行 lr: 本地读 lw: 本地写 rr: 内存读 rw: 缓存写到主存 状态转换 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/d44fed62558e13367358433f7c2e8bba.png\" alt></p>\n<h1><span id=\"乱序执行优化\">乱序执行优化</span></h1><p>这点与之前JVM对中间代码的优化一致,可能会导致在优化过程中导致的代码乱序执行(如果是并行则对原结果不影响),乱序优化是CPU为了提高执行效率(因为各组件的数量是有限的,为了防止一直等待一个组件而导致的时间浪费进行优化).</p>\n<h2><span id=\"脏数据\">脏数据</span></h2><h1><span id=\"java内存模型jmm\">Java内存模型(JMM)</span></h1><p>之前也聊过. JMM: Java Memory Model (为了屏蔽掉各种硬件和操作系统的访问差异,使一个代码在各平台下都可正常并行) JMM是一个规范模型. 规定一个线程如何和何时可以看到由其他变量修改过后的共享变量的值.以及在必须时如何同步的访问共享变量. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/9a429df8ec619d4952831b979fe0d40d.png\" alt> 堆是在运行时动态分配,存取速度慢. 栈,存取速度快,存储空间一定. 线程在栈上. 对象在堆上,引用在栈上. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/ad5214bd255a2751d0d98015ed3beadd.png\" alt></p>\n<h2><span id=\"高速缓存\">高速缓存</span></h2><p>CPU与主存间的缓存. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/eda78e84cd4268f0ff501ca2b10ef846.png\" alt></p>\n<h3><span id=\"抽象\">抽象</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/efebbee76283df7a42baab3c2557835f.png\" alt> 线程间通讯,必须通过主内存. 故出现问题就是因为主内存中没处理代码同时执行的操作.</p>\n<h1><span id=\"同步的八种操作以及操作规则\">同步的八种操作以及操作规则</span></h1><p>（1）lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态 （2）unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 （3）read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 （4）load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 （5）use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 （6）assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 （7）store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 （8）write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中 如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/07/67a8e36cfd2b4f7252a3b72a29d1d572.png\" alt> 同步规则分析： 1）不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中 2）一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。 3）一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。 4）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。 5）如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 6）对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>\n","text":"并发的一些基础概念CPU 多级缓存为了解决CPU与主存间速度不匹配的问题.时间局部性数据可能被重复访问空间局部性数据周围的一些数据,也可能被访问缓存一致性(MESI协议)为了搞定共享数据一致的问题  [Figure]  同步规则分析： 1）不允许一个线程无原因地（没有发生过任何a","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善4-设计模式","slug":"design-model","date":"2018-06-20T09:11:49.000Z","updated":"2019-07-03T13:51:36.844Z","comments":true,"path":"api/articles/design-model.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Link: 总共23种: <a href=\"http://be-sunshine.cn/index.php/2018/07/09/23-sort-dp/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/07/09/23-sort-dp/</a></p>\n","text":"Link: 总共23种: http://be-sunshine.cn/index.php/2018/07/09/23-sort-dp/","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"},{"name":"设计模式","slug":"技术/设计模式","count":1,"path":"api/categories/技术/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"},{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"深入分析Java Web技术内幕-第一章","slug":"javaweb-first","date":"2018-06-20T09:58:36.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/javaweb-first.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/2713303ae852b2a4f191b57ad8872441.png","content":"<h1><span id=\"cdn架构图\">CDN架构图</span></h1><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2713303ae852b2a4f191b57ad8872441.png\" alt></p>\n<h1><span id=\"发起请求\">发起请求</span></h1><p>一句话,发起一个HTTP请求的过程就是建立一个Socket通信的过程. 既然本质上就是建立一个Socket连接,那么我们完全可以模拟浏览器发出HTTP请求.(比如PostMan) -而HTTP协议的内容之前学过了,不再赘述(详见图灵的那本HTTP)</p>\n<h1><span id=\"http协议解析\">HTTP协议解析</span></h1><h2><span id=\"常见http请求头\">常见HTTP请求头:</span></h2><p>Accept-Charset: 用于指定<strong>客户端接受</strong>的字符集 Accept-Encoding: 用于指定<strong>可接受</strong>的<strong>内容编码</strong>如Accept-Encoding: gzip.deflate Accept-Language: 用于指定一种自然语言如 zh-cn Host: 用于指定被请求资源的主机和端口号 User-Agent: <strong>客户端</strong>将他的操作系统、浏览器和其他属性告诉服务器 Connection: 当前连接是否保持,如:Keep-Alive</p>\n<h2><span id=\"常见的http响应头\">常见的HTTP响应头</span></h2><p>Server: 使用的<strong>服务器</strong>名称,如 Server: Apache/1.3.6(Unix) Content-Type: 用于指定发送给<strong>接受者</strong>的实体正文的媒体类型 如: text/html;charset=GBK Content-Encoding: 与Accept-Encoding对应,告诉服务端采用什么压缩编码 Content-Language: 描述了资源所用的自然语言,与Accept-Language对应 Content-Length: 指明了实体正文长度.用以字节方存储的十进制数字来表示. Keep-Alive: 保持连接的时间,如-Keep-Alive: timeout=5,max=120</p>\n<h2><span id=\"创建http状态码\">创建HTTP状态码</span></h2><p>200 OK 302 临时跳转/缓存 400 请求有语法错误 403 拒绝 404 不存在 500 不可预期错误</p>\n<h2><span id=\"查看http工具\">查看HTTP工具</span></h2><p>F12</p>\n<h2><span id=\"拒绝缓存载入页面\">拒绝缓存载入页面</span></h2><p>Ctrl+F5</p>\n<h2><span id=\"dns域名解析\">DNS域名解析</span></h2><p>分十步进行: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/DNS.png\" alt=\"Aaron\"> 但可能不知这十步,因为name server可能会有多级,或者有一个GTM来负载均衡控制. <strong>nslookup</strong>可以来看域名的解析结果 linux 可以用dig来查询DNS解析过程</p>\n<h2><span id=\"清除缓存的域名\">清除缓存的域名</span></h2><p>windows下: ipconfig /flushdns Linux下: /etc/init.d/nscd restart</p>\n<h2><span id=\"其他的\">其他的</span></h2><p>JVM也会缓存一些DNS,这个缓存是在InetAddress类中完成的. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/68e30bf436883aac699fb1f2dc6a31b4.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/97fed91e3b53394a68b9a38125e2142f.png\" alt></p>\n<h1><span id=\"几种域名解析方式\">几种域名解析方式</span></h1><blockquote>\n<p>有服务器的童鞋一定接触过 A记录</p>\n<blockquote>\n<p>Address,可将多个域名解析到一个地址</p>\n</blockquote>\n<p>MX记录</p>\n<blockquote>\n<p>Mail Exchange,将某域名下的邮件服务器指向自己的Mail Server，DNS会将邮件发向对应的邮件路由</p>\n</blockquote>\n<p>CNAME记录</p>\n<blockquote>\n<p>Canonical Name(别名解析),为一个域名设置一个或多个别名,如,taobao.com解析到xulingbo.net.则xulingbo.net是taobao.net的别名.</p>\n</blockquote>\n<p>NS记录</p>\n<blockquote>\n<p>为某域名指定DNS解析服务器.</p>\n</blockquote>\n<p>TXT记录</p>\n<blockquote>\n<p>为某个主机名或域名设置说明.</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"cdn工作机制\">CDN工作机制</span></h1><blockquote>\n<p>Content Delivery Network,内容分布网络. 将信息发布到最接近用户的”边缘”,使用户可以就近取得所需的内容. CDN=镜像(Mirror)+缓存(Cache)+整体负载均衡(GSLB). CDN可以明显提高Internet中信息流动的效率.</p>\n</blockquote>\n<p>目前CDN都以缓存静态数据为主,如CSS,JS,图片和静态页面等. 淘宝有90%的数据由CDN提供. 通常来说CDN要完成以下几个目标:</p>\n<blockquote>\n<p>可扩展 安全性 可靠性,响应和执行</p>\n</blockquote>\n<h2><span id=\"通常的cdn架构\">通常的CDN架构</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/32a0ba63290137ab8b526df51e354bae.png\" alt></p>\n<h1><span id=\"负载均衡load-balance\">负载均衡(Load Balance)</span></h1><p>负载均衡就是对工作任务进行平衡,分摊到多个操作单元上执行,如图片服务器,应用服务器等,共同完成工作任务。它可以提高服务器响应速度及利用效率. 负载均衡是有DNS解析来完成的. 常用在集群中,分为软件/硬件负载均衡.</p>\n","text":"CDN架构图 [Figure] 负载均衡(Load Balance)负载均衡就是对工作任务进行平衡,分摊到多个操作单元上执行,如图片服务器,应用服务器等,共同完成工作任务。它可以提高服务器响应速度及利用效率. 负载均衡是有DNS解析来完成的. 常用在集群中,分为软件/硬件负载均衡","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"深入分析Java Web技术内幕-第二章","slug":"javaweb-two","date":"2018-06-21T07:28:30.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/javaweb-two.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/1ad8ecc702cf83a89ac412c4e586aed3.png","content":"<h1><span id=\"深入分析java-io机制\">深入分析Java I/O机制</span></h1><h2><span id=\"java-io类库的基础架构\">Java I/O类库的基础架构</span></h2><p>类库大概分为四组:</p>\n<blockquote>\n<p>基于字节操作的I/O接口:InputStream 和 OutputStream 基于字符操作的I/O接口: Writer和Reader 基于磁盘操作的I/O接口: File 基于网络操作的I/O接口: Socket (这尼玛也能划到一起,不过这样好像也行)</p>\n</blockquote>\n<h2><span id=\"基于字节的io操作接口\">基于字节的I/O操作接口</span></h2><blockquote>\n<p>InputStream</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/1ad8ecc702cf83a89ac412c4e586aed3.png\" alt></p>\n<blockquote>\n<p>OutputStream</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/268a47ba3edf2add83c46b8f5a2a5342.png\" alt></p>\n<blockquote>\n<blockquote>\n<p>详见JDK API.</p>\n</blockquote>\n</blockquote>\n<p>Tip: 操作数据可以组合使用-&gt;某流转某流 OutputStream out=new PipeOutputStream(new ObjectOutputStream(new FileOutputStream(“fileName”))); 还有一点是一定要制定流最终要写到哪里</p>\n<h2><span id=\"基于字符的io操作接口\">基于字符的I/O操作接口</span></h2><blockquote>\n<p>I/O接口一般都是字节流,但是为了方便起见,也有字符流.</p>\n</blockquote>\n<p><strong>字符到字节必须经过编码转换,而编码很耗时</strong></p>\n<blockquote>\n<p>写字符接口以及涉及到的类</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d1c5a427e25d73e1ea7d0e04af57c65f.png\" alt> Writer类提供了一个抽象接口:Write(char cbuf[],int off,int len)</p>\n<blockquote>\n<p>读字符</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0b3cd200a1da4d54aaa17d095e16cf42.png\" alt> int Read(char cbuf[],int off,int len) 返回读到的n个字节数 他们只规定了读取和写入的方式,但没有规定读和写到哪里去.</p>\n<h2><span id=\"字节与字符的转化接口\">字节与字符的转化接口</span></h2><blockquote>\n<p>数据持久化或网络传输都是以字节进行的，所以必要有对应的接口</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/8aa6ff0a0ffe1b15ad470370844d78b5.png\" alt> InputStreamReader是<strong>字节到字符</strong>的桥梁,InputStream到Reader的过程<strong>要指定编码字符集</strong>,否则将采用操作系统默认字符集,很可能会出现乱码. StreamDecoder是<strong>字节到字符</strong>解码的实现类. StreamEncoder类似 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f38fb77be5e4351910897b9df42403e3.png\" alt></p>\n<h2><span id=\"磁盘io工作机制\">磁盘I/O工作机制</span></h2><h3><span id=\"应用程序访问文件的几种方式\">应用程序访问文件的几种方式</span></h3><p>read()和write()这两个是系统调用. 系统调用可能会存在内核空间地址和用户空间地址切换的问题,这是操作系统为了保护系统本身的运行安全而将<strong>内核程序运行使用的内存空间和用户活动使用的内核空间隔离</strong>,但是这样虽然保证了内核程序运行的安全性,但是也必然存在<strong>时间耗费的问题</strong> 磁盘I/O非常缓慢,所以操作系统使用了缓存的机制.</p>\n<h4><span id=\"标准访问文件方式\">标准访问文件方式</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6de33c5d864a218b1d3a0fe38565f411.png\" alt></p>\n<h4><span id=\"直接io方式\">直接I/O方式</span></h4><blockquote>\n<p>直接IO就是直接访问磁盘数据,来减少从内和缓冲区到用户活动区的复制.</p>\n<blockquote>\n<p>这种思想常用于 由应用实现的数据库管理系统. 提前将热点数据加入内存,可以加速数据的访问速度.</p>\n</blockquote>\n<p>但操作系统并不知道哪些是热点数据,所以直接I/O也有负面影响.而我们一般将异步IO和直接IO结合使用.</p>\n</blockquote>\n<p>直接IO方式如图(没有穿过高速页缓存): <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/74d178a897ed7f8fd8ba0439ccaceba1.png\" alt></p>\n<h4><span id=\"同步访问文件方式\">同步访问文件方式</span></h4><blockquote>\n<p>即读取与写入都是同步操作的.</p>\n</blockquote>\n<p>但他的标志是:<strong>只有写入完成才是成功的标志</strong> 性能较差</p>\n<h4><span id=\"异步访问文件方式\">异步访问文件方式</span></h4><blockquote>\n<p>异步访问就是,当访问数据的线程发出请求后,线程会继续去处理其它事情,而不是阻塞等待,当请求的数据返回后再继续处理接下来的操作.</p>\n</blockquote>\n<p>这种方式可以明显的提高应用程序的效率,但并不会改变访问文件的效率. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/423d961b94b4779ba7212af4db51017c.png\" alt></p>\n<h4><span id=\"内存映射方式\">内存映射方式</span></h4><blockquote>\n<p>将操作系统某一块区域与磁盘中的文件关联起来,增加缓冲区的个数,减少缓冲区-&gt;用户活动区的复制操作</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/246dcd50203f24f93da00714daae2db3.png\" alt></p>\n<h3><span id=\"java访问磁盘文件\">Java访问磁盘文件</span></h3><p>接下来我们来讨论数据的流向</p>\n<h4><span id=\"数据持久化到磁盘\">数据持久化到磁盘</span></h4><p>数据在磁盘中唯一<strong>最小描述</strong>就是<strong>文件</strong>. 文件也是操作系统和磁盘驱动器交互的<strong>最小单元</strong> Java中的File<strong>并不代表一个真实存在的对象</strong>.而是一个路径和虚拟对象. 因为我们更多关心的是操作,而不是整个文件. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/76a6f5098ea16378295a325a05064602.png\" alt> 从磁盘中读取文件流程: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f6b5aefd246cf978ed0563d0f999191e.png\" alt></p>\n<ul>\n<li>先创建一个FileDescriptor对象</li>\n<li>然后创建FileInputStream</li>\n<li>因为要读取的是字符格式,所以需要StreamDecoder类将byte解码为char格式…</li>\n</ul>\n","text":"深入分析Java I/O机制Java I/O类库的基础架构类库大概分为四组:基于字节操作的I/O接口:InputStream 和 OutputStream 基于字符操作的I/O接口: Writer和Reader 基于磁盘操作的I/O接口: File 基于网络操作的I/O接口: S","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"技术","slug":"Java/技术","count":1,"path":"api/categories/Java/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"},{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Maven","slug":"maven","date":"2018-06-20T15:27:49.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/maven.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>总而言之说下吧,Maven其实就类似于.Net的NuGet和Python-Anaconda 的pip和conda.包的管理工具更贴切?</p>\n</blockquote>\n<h1><span id=\"maven下载地址\">Maven下载地址</span></h1><p><a href=\"http://maven.apache.org/download.cgi\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/download.cgi</a></p>\n<h1><span id=\"基本操作\">基本操作</span></h1><p>mvn -v (查看版本) mvn archetype:generate -DgroupId=com.how2java -DartifactId=j2se -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false -archetype: generate 表示创建个项目 -DgroupId 项目包名: com.how2java -DartifactId 项目名称: j2se -DarchetypeArtifactId 项目类型: maven-archetype-quickstart -DinteractiveMode: false 表示前面参数都给了，就不用一个一个地输入了 mvn package (打包成jar) java -cp target/j2se-1.0-SNAPSHOT.jar com.how2java.App (执行jar) mvn archetype: generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DgroupId=com.how2java -DartifactId=j2ee -DinteractiveMode=false 创建Web App,可以发现其中是maven-archetype-webapp</p>\n<h1><span id=\"仓库\">仓库</span></h1><p>仓库就是来存放项目需要的jar包的。 maven采用一个仓库，多个项目的方式，让多个项目共享一个仓库里的相同jar包。 仓库默认位置: .\\apache-maven-3.5.3\\conf\\settings.xml 第53行</p>\n<pre><code>Default: ${user.home}/.m2/repository</code></pre><h1><span id=\"修改下载路径\">修改下载路径</span></h1><p>这里用阿里的. 这里修改仓库默认地址(随便,好找): D:/Software/maven/repository 然后修改maven的镜像(mirrors)</p>\n<pre><code>&lt;mirrors&gt;\n  &lt;!-- mirror\n   | Specifies a repository mirror site to use instead of a given repository. The repository that\n   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n   | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n   |\n  &lt;mirror&gt;\n    &lt;id&gt;mirrorId&lt;/id&gt;\n    &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;\n    &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;\n    &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;\n  &lt;/mirror&gt;\n   --&gt;\n   &lt;mirror&gt;\n   &lt;id&gt;alimaven&lt;/id&gt;\n       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n       &lt;name&gt;aliyun maven&lt;/name&gt;\n       &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;\n   &lt;mirror&gt;\n&lt;/mirrors&gt;</code></pre><h1><span id=\"maven风格的java项目听说很少用\">Maven风格的Java项目(听说很少用)</span></h1><blockquote>\n<p>莫名其妙的东东,运行jar???多个入口怎么处理啊?迷,不过用来封jar包挺方便的/大概</p>\n</blockquote>\n<p>给个链接:<a href=\"http://how2j.cn/k/maven/maven-create-maven-project/1331.html#nowhere\" target=\"_blank\" rel=\"noopener\">http://how2j.cn/k/maven/maven-create-maven-project/1331.html#nowhere</a></p>\n<h2><span id=\"windows-盘符跳转\">windows 盘符跳转</span></h2><p>cd /d D:\\Java 要在中间加上/d 或者直接 :e</p>\n<h1><span id=\"配置安装以及接下来\">配置安装以及接下来</span></h1><p>配置见how2j 之后再Maven中添加包,直接在pom.xml下的Depen…中点Add 如果无法自动搜索 菜单-&gt;Window-&gt;Show View-&gt;Other-&gt;Maven-&gt;Maven Repositories-&gt;Local Repository-&gt;Rebuild Index 没有run on server 解决办法: <a href=\"https://blog.csdn.net/mr_yzko/article/details/78458873\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/mr_yzko/article/details/78458873</a> 然后可能出现jsp报错:导包即可 <a href=\"http://how2j.cn/k/maven/maven-eclipse-web-project/1334.html\" target=\"_blank\" rel=\"noopener\">http://how2j.cn/k/maven/maven-eclipse-web-project/1334.html</a></p>\n<h1><span id=\"总结一下新建maven-webapp所出现的所有问题\">总结一下新建maven webapp所出现的所有问题</span></h1><ol>\n<li><p>创建项目后的JDK版本错误</p>\n<blockquote>\n<p>右键-&gt;属性-&gt;Build Path-&gt;Libraries-&gt;JRE System…-&gt;Edit-&gt;Default JRE</p>\n</blockquote>\n</li>\n<li><p>无Run on server</p>\n<blockquote>\n<p>右键-&gt;属性-&gt;Project Facets-&gt;点那个蓝条-&gt;选中Dynamic Web Module和Javascript-&gt;OK</p>\n</blockquote>\n</li>\n<li><p>.jsp报错</p>\n<blockquote>\n<p>双击pom.xml-&gt;Dependencies-&gt;Add-&gt;javax.servlet-api</p>\n</blockquote>\n</li>\n<li><p>无法找到web文件夹和主页(初始404)</p>\n<blockquote>\n<p>完成第二步后-&gt;Deployment Assembly-&gt;查看Deploy Path为/的那一条的源路径是否正确-&gt;不正确,删除后修改为index.jsp所在目录-&gt;添加Maven Dependencies-&gt;OK</p>\n</blockquote>\n</li>\n<li><p>完成!</p>\n</li>\n</ol>\n<h1><span id=\"pomxml-基础模板\">pom.xml 基础模板</span></h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;hello-maven&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;1.7.25&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;</code></pre><h1><span id=\"maven统一架构\">Maven统一架构</span></h1><pre><code>├─src\n│  ├─main\n│  │  ├─java\n│  │  ├─resources\n│  │  └─webapp\n│  │      └─WEB-INF\n│  └─test\n│      └─java</code></pre><blockquote>\n<p>src：源码目录</p>\n<blockquote>\n<p>src/main/java：Java 源码目录 src/main/resources：资源文件目录 src/main/webapp：Web 相关目录 src/test：单元测试</p>\n</blockquote>\n</blockquote>\n","text":"总而言之说下吧,Maven其实就类似于.Net的NuGet和Python-Anaconda 的pip和conda.包的管理工具更贴切?Maven下载地址http://maven.apache.org/download.cgi基本操作mvn -v (查看版本) mvn archet","link":"","raw":null,"photos":[],"categories":[{"name":"Maven","slug":"Maven","count":2,"path":"api/categories/Maven.json"},{"name":"技术","slug":"Maven/技术","count":1,"path":"api/categories/Maven/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"},{"name":"Maven","slug":"Maven","count":2,"path":"api/tags/Maven.json"}]},{"title":"计划","slug":"my-plan","date":"2018-06-14T08:45:55.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/my-plan.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/fabc862147ac8e0ad3ed25d6bfa9c7e5.png","content":"<p>[toc]</p>\n<h1><span id=\"课外知识\"><strong>课外知识:</strong></span></h1><blockquote>\n<p>需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？</p>\n</blockquote>\n<blockquote>\n<p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？ 好，下面在浏览器中输入你的网站域名（<a href=\"http://www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。\" target=\"_blank\" rel=\"noopener\">www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。</a> 浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。 那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。 重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？ 这就是为什么，越是大中型的web应用，他们越是要解耦。理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。 如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。（注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~） 此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？ 正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。</p>\n</blockquote>\n<h1><span id=\"jsonpdone\">JSONP(Done)</span></h1><blockquote>\n<p>当我们尝试彻底分离开前后端时,会出现跨域的问题.人类很有趣,想出了将它作为函数来解决的方法. 一般而言我们可以在后台为每一个Response提供一个</p>\n<blockquote>\n<p>access-Control-Allow-Origin: *</p>\n</blockquote>\n<p>这个字段来欲盖弥彰,但这种手段会出现API滥用或者XSS攻击等情况.</p>\n</blockquote>\n<h2><span id=\"实现jsonp\">实现JSONP</span></h2><h3><span id=\"python-突击后台\">Python 突击后台</span></h3><pre><code># coding:utf-8\nfrom flask import Flask\nfrom flask import request\nfrom flask import json\napp=Flask(__name__)\n\n@app.route(&quot;/us&quot;)\ndef ruin():\n    return request.args.get(&apos;callback&apos;)+&quot;({a:1,b:2})&quot;\n\nif __name__ == &apos;__main__&apos;:\n    app.run(port=8888,debug=True)</code></pre><h3><span id=\"jquery接到命令\">Jquery接到命令</span></h3><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;a&lt;/title&gt;\n        &lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js&quot;&gt;&lt;/script&gt;   \n&lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;script&gt;\n    function AB(obj){\n        console.log(obj);\n    }\n    $.getScript(&quot;http://127.0.0.1:8888/us?callback=AB&quot;,function(data){\n        console.log(data);\n    });\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre><h3><span id=\"控制台告诉我答案\">控制台告诉我答案</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/fabc862147ac8e0ad3ed25d6bfa9c7e5.png\" alt></p>\n<h1><span id=\"mavendone\">Maven(Done)</span></h1><blockquote>\n<p>学习记录贴</p>\n</blockquote>\n<p><a href=\"http://be-sunshine.cn/index.php/2018/06/20/maven/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/20/maven/</a></p>\n<h1><span id=\"oauth-微服务-socket-nio-redis-消息队列\">OAuth 、 微服务 、 Socket、NIO、Redis、消息队列</span></h1>","text":"[toc]课外知识:需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善3-深入分析Java Web技术内幕-Category","slug":"paln3-category","date":"2018-06-20T01:44:16.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/paln3-category.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>太多了…</p>\n</blockquote>\n<h1><span id=\"第一章-深入web请求过程done\">第一章 - 深入Web请求过程(Done)</span></h1><p><a href=\"http://be-sunshine.cn/index.php/2018/06/20/javaweb-first/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/20/javaweb-first/</a></p>\n<h1><span id=\"第二章-深入分析-java-io的工作机制s\">第二章 - 深入分析 Java I/O的工作机制(S)</span></h1><p><a href=\"http://be-sunshine.cn/index.php/2018/06/21/javaweb-two/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/21/javaweb-two/</a></p>\n<h1><span id=\"第三章-深入分析-javav-web-中的中文编码问题\">第三章 - 深入分析 Javav Web 中的中文编码问题</span></h1><h1><span id=\"第四章-javac编译原理\">第四章 - javac编译原理</span></h1><h1><span id=\"第五章-深入class文件结构\">第五章 - 深入class文件结构</span></h1><h1><span id=\"第六章-深入分析classloader-工作机制\">第六章 - 深入分析ClassLoader 工作机制</span></h1><h1><span id=\"第七章-jvm体系结构与工作方式\">第七章 - JVM体系结构与工作方式</span></h1><h1><span id=\"第八章-jvm内存管理\">第八章 - JVM内存管理</span></h1><h1><span id=\"第九章-servlet工作原理解析\">第九章 - Servlet工作原理解析</span></h1><h1><span id=\"第十章-深入理解seesion与cookie\">第十章 - 深入理解Seesion与Cookie</span></h1><h1><span id=\"第十一章-tomcat的系统架构与-设计模式\">第十一章 - Tomcat的系统架构与 设计模式</span></h1><h1><span id=\"第十二章-jetty的工作原理解析\">第十二章 - Jetty的工作原理解析</span></h1><h1><span id=\"第十三章-spring框架的设计理念与设计模式分析\">第十三章 - Spring框架的设计理念与设计模式分析</span></h1><h1><span id=\"第十四章-spring-mvc-工作机制与设计模式\">第十四章 - Spring MVC 工作机制与设计模式</span></h1><h1><span id=\"第十五章-深入分析ibaits框架之系统-架构与映射原理\">第十五章 - 深入分析Ibaits框架之系统 架构与映射原理</span></h1><h1><span id=\"第十六章-velocity工作原理解析\">第十六章 - Velocity工作原理解析</span></h1><h1><span id=\"第十七章-velocity优化实践\">第十七章 - Velocity优化实践</span></h1>","text":"太多了…第一章 - 深入Web请求过程(Done)http://be-sunshine.cn/index.php/2018/06/20/javaweb-first/第二章 - 深入分析 Java I/O的工作机制(S)http://be-sunshine.cn/index.php","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善2-实战Java高并发程序设计-Category","slug":"plan-category","date":"2018-06-17T06:38:13.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-category.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>更新到第三章</p>\n</blockquote>\n<h1><span id=\"第一章-done\">第一章 (Done)</span></h1><p><strong>2018/6/16</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/16/plan-two/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第一章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第一章</a></p>\n<h1><span id=\"第二章-done\">第二章 (Done)</span></h1><p><strong>2018/6/17</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/17/plan-two-2/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第一章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第二章</a></p>\n<h1><span id=\"第三章-done\">第三章 (Done)</span></h1><p><strong>2018/6/19</strong> <a href=\"http://be-sunshine.cn/index.php/2018/06/19/plan-three/\" title=\"计划:技术栈完善2-实战JAVA高并发程序设计-第三章\" target=\"_blank\" rel=\"noopener\">计划:技术栈完善2-实战JAVA高并发程序设计-第三章</a></p>\n<h1><span id=\"第四章\">第四章</span></h1><h1><span id=\"第五章\">第五章</span></h1><h1><span id=\"第六章\">第六章</span></h1><h1><span id=\"第七章\">第七章</span></h1><h1><span id=\"第八章\">第八章</span></h1>","text":"更新到第三章第一章 (Done)2018/6/16 计划:技术栈完善2-实战JAVA高并发程序设计-第一章第二章 (Done)2018/6/17 计划:技术栈完善2-实战JAVA高并发程序设计-第二章第三章 (Done)2018/6/19 计划:技术栈完善2-实战JAVA高并发程","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"redis启动","slug":"redis-undo","date":"2018-03-26T06:40:22.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/redis-undo.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>cmd-</p>\n<blockquote>\n<p>redis-server.exe (redis.windows.conf) 第二个参数可以写也可以不写</p>\n</blockquote>\n<p>开启</p>\n<blockquote>\n<p>redis-cli.exe -h 127.0.0.1 -p 6379</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"java-springboot使用redis\">Java-SpringBoot使用Redis</span></h1><h2><span id=\"redisconfig\">RedisConfig</span></h2><p>其中Bean代表由Spring管理,当Resouorce的name和Bean的name一样时,就会自动通过Bean创建实例. @Value的字段是在application.properties中,有’.’的话要加${} 这里调用的只是Redis的一个构造函数,传入ip和端口号.</p>\n<pre><code>package com.mall.concurrency.cache;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport redis.clients.jedis.JedisPool;\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean(name=&quot;redisPool&quot;)\n    public JedisPool jedispool(@Value(&quot;${jedis.host}&quot;) String host,@Value(&quot;${jedis.port}&quot;) int port){\n        return new JedisPool(host,port);\n    }\n}</code></pre><h2><span id=\"redisclient\">RedisClient</span></h2><p>类似于Orm的操作方式.用完即扔.</p>\n<pre><code>package com.mall.concurrency.cache;\n\nimport javax.annotation.Resource;\n\nimport org.springframework.stereotype.Component;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n//http://redis.cn/\n@Component\npublic class RedisClient {\n    @Resource(name=&quot;redisPool&quot;)\n    private JedisPool jedisPool;\n\n    public void set(String key,String value)throws Exception{\n        Jedis jedis=null;\n        try{\n            jedis = jedisPool.getResource();\n            jedis.set(key, value);\n        }finally {\n            if(jedis!=null){\n                jedis.close();\n            }\n        }\n    }\n\n    public String get(String key)throws Exception{\n        Jedis jedis=null;\n        try{\n            jedis = jedisPool.getResource();\n            return jedis.get(key);\n        }finally {\n            if(jedis!=null){\n                jedis.close();\n            }\n        }\n    }\n}</code></pre><h2><span id=\"cachecontroller\">CacheController</span></h2><p>其中@Autowired和@Resource的区别是: - @Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配 - @Resource(import javax.annotation.Resource;)是J2EE的注解，@Autowired( import org.springframework.beans.factory.annotation.Autowired;)是Spring的注解</p>\n<pre><code>package com.mall.concurrency.cache;\n\nimport javax.annotation.Resource;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\n@RequestMapping(&quot;/cache&quot;)\npublic class CacheController {\n    @Autowired\n    private RedisClient redisClient;\n\n    @RequestMapping(&quot;/set&quot;)\n    @ResponseBody\n    public String set(@RequestParam(&quot;k&quot;) String k,@RequestParam(&quot;v&quot;) String v)throws Exception{\n        redisClient.set(k, v);\n        return &quot;SUCCESS&quot;;\n    }\n\n    @RequestMapping(&quot;/get&quot;)\n    @ResponseBody\n    public String get(@RequestParam(&quot;k&quot;) String k)throws Exception{\n        return redisClient.get(k);\n    }\n\n}</code></pre><h2><span id=\"applicationproperties的书写格式\">application.properties的书写格式</span></h2><pre><code># redis\njedis.host=127.0.0.1\njedis.port=6379</code></pre>","text":"cmd-redis-server.exe (redis.windows.conf) 第二个参数可以写也可以不写开启redis-cli.exe -h 127.0.0.1 -p 6379Java-SpringBoot使用RedisRedisConfig其中Bean代表由Spring管","link":"","raw":null,"photos":[],"categories":[{"name":"redis","slug":"redis","count":1,"path":"api/categories/redis.json"},{"name":"技术","slug":"redis/技术","count":1,"path":"api/categories/redis/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"},{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}]},{"title":"近期在更","slug":"updating","date":"2019-01-15T04:09:32.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/updating.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>最后更新于 <code>2019/2/12</code></p>\n<blockquote>\n<p>本贴记录的是2019/1 以后所发的贴的整合</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"闲时杂兴\">闲时杂兴</span></h1><hr>\n<h2><span id=\"gamemaker-studio-2-系列开坑\">《Gamemaker studio 2 系列开坑》</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/12/gamemaker-studio-2/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/12/gamemaker-studio-2/</a></p>\n<h2><span id=\"jeffe算法课程系列个人翻译\">JeffE算法课程系列个人翻译</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/04/08/jeffe-traslation/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/04/08/jeffe-traslation/</a></p>\n<hr>\n<h1><span id=\"技术\">技术</span></h1><hr>\n<h2><span id=\"1-神经网络nlp实现聊天机器人\">1 - 神经网络+NLP实现聊天机器人</span></h2><h3><span id=\"01-nlp与基础知识\">01 NLP与基础知识</span></h3><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/01/type-2/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/01/type-2/</a></p>\n<h3><span id=\"02-处理语料库\">02 处理语料库</span></h3><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/04/type-3/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/04/type-3/</a></p>\n<h3><span id=\"03-seq2seq\">03 Seq2Seq</span></h3><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/06/seq2seq/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/06/seq2seq/</a></p>\n<h2><span id=\"2-聊天室架构从0开始\">2 - 聊天室架构从0开始</span></h2><h3><span id=\"01-tcpampudp-基础知识\">01 TCP&amp;UDP 基础知识</span></h3><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/01/type-1/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/01/type-1/</a></p>\n<h3><span id=\"02-客户端udp请求服务端tcp端口\">02 客户端UDP请求服务端TCP端口</span></h3><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/14/ty2/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/14/ty2/</a></p>\n<h2><span id=\"3-java虚拟机\">3 - Java虚拟机</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/wp-admin/post.php?post=2384&action=edit\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/wp-admin/post.php?post=2384&amp;action=edit</a></p>\n<h2><span id=\"4-mybatis\">4 - MyBatis</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/18/mybatis/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/18/mybatis/</a></p>\n<h2><span id=\"5-maven\">5 - Maven</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2018/06/20/maven/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/20/maven/</a></p>\n<h2><span id=\"6-本地远程连接mysql\">6 - 本地远程连接Mysql</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/20/linke-mysql/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/20/linke-mysql/</a></p>\n<hr>\n<h1><span id=\"spring系列\">Spring系列</span></h1><hr>\n<h2><span id=\"单体应用-三层架构\">单体应用-三层架构</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/18/spring/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/18/spring/</a></p>\n<h2><span id=\"依赖注入和控制反转\">依赖注入和控制反转</span></h2><p>连接也是上面那个</p>\n<h2><span id=\"bean的装配\">Bean的装配</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/01/25/bean/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/01/25/bean/</a></p>\n<h2><span id=\"maven项目间依赖\">Maven项目间依赖</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/02/02/maven-modules/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/02/02/maven-modules/</a></p>\n<h2><span id=\"spring胶水框架粘贴druid\">Spring(胶水框架)粘贴Druid</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/02/03/spring-druid/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/02/03/spring-druid/</a></p>\n<h2><span id=\"spring-粘贴-mybatis\">Spring 粘贴 Mybatis</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/02/04/spring-cohesive-mybatis/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/02/04/spring-cohesive-mybatis/</a></p>\n<h2><span id=\"拦截器aop\">拦截器(AOP)</span></h2><p>Emmm…= =懒得写了.</p>\n<h2><span id=\"modelattribute\">@ModelAttribute</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/02/05/spring-annotation-modelattribute/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/02/05/spring-annotation-modelattribute/</a></p>\n<h2><span id=\"热部署\">热部署</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/02/05/asdasdas/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/02/05/asdasdas/</a></p>\n<h2><span id=\"spring-validation\">Spring Validation</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2019/02/09/spring-validation-spring/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/02/09/spring-validation-spring/</a></p>\n<hr>\n<h1><span id=\"闲时码题\">闲时码题</span></h1><hr>\n<h2><span id=\"1-lintcode1-11114\">1 - LintCode(1-11+114)</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2018/06/17/pl2-lintcode/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/06/17/pl2-lintcode/</a></p>\n<h2><span id=\"2-lintcode12-22\">2 - LintCode(12-22)</span></h2><p><a href=\"http://be-sunshine.cn/index.php/2019/02/10/lintcode12-22/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2019/02/10/lintcode12-22/</a></p>\n<hr>\n<h1><span id=\"整理java全部笔记\">整理Java(全部笔记)</span></h1><hr>\n<h2><span id=\"类与对象\">类与对象</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2018/01/12/java-class-object/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/12/java-class-object/</a></p>\n<p>包<br>-</p>\n<p><a href=\"http://be-sunshine.cn/index.php/2018/01/12/java-package/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/12/java-package/</a></p>\n<h2><span id=\"枚举类\">枚举类</span></h2><p><a href=\"http://be-sunshine.cn/index.php/2018/01/12/java-enum/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/12/java-enum/</a></p>\n<h2><span id=\"接口\">接口</span></h2><p><a href=\"http://be-sunshine.cn/index.php/2018/01/12/java-interface/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/12/java-interface/</a></p>\n<h2><span id=\"默认方法\">默认方法</span></h2><p><a href=\"http://be-sunshine.cn/index.php/2018/01/13/java-8-default/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/13/java-8-default/</a></p>\n<h2><span id=\"throwable\">Throwable</span></h2><p><a href=\"http://be-sunshine.cn/index.php/2018/01/15/java-throwable/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/15/java-throwable/</a></p>\n<h2><span id=\"java-io\">Java I/O</span></h2><p>:cyclone:<a href=\"http://be-sunshine.cn/index.php/2018/01/16/java-i-o/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/16/java-i-o/</a></p>\n<hr>\n<h1><span id=\"设计模式\">设计模式</span></h1><hr>\n<h2><span id=\"单例\">单例</span></h2><p><a href=\"http://be-sunshine.cn/index.php/2018/01/12/java-singleton/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/12/java-singleton/</a></p>\n","text":"最后更新于 2019/2/12本贴记录的是2019/1 以后所发的贴的整合闲时杂兴《Gamemaker studio 2 系列开坑》:cyclone:http://be-sunshine.cn/index.php/2019/01/12/gamemaker-studio-2/Jef","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善2-实战Java高并发程序设计-第一章","slug":"plan-two","date":"2018-06-16T07:28:51.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-two.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/89864d67883030d36838db52c72af586.png","content":"<h1><span id=\"第一章\">第一章</span></h1><h2><span id=\"同步与异步\">同步与异步</span></h2><blockquote>\n<p>如图 同步是链式进行:只有当一个任务结束后才可以继续下一个 而异步则是前进-&gt;等待消息返回(同时继续前进进行其他的任务)-&gt;消息返回,继续前进.</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/89864d67883030d36838db52c72af586.png\" alt></p>\n<h2><span id=\"并发concurrency和并行parallelism\">并发(Concurrency)和并行(Parallelism)</span></h2><blockquote>\n<p>如图 并发是以时间片为单位看似同步进行 并行是实际上的同步进行(一般为多核) <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/a580d15d23bbcbaa2c928b770d15b275.png\" alt></p>\n</blockquote>\n<h2><span id=\"临界区\">临界区</span></h2><blockquote>\n<p>即可以有多个线程来使用它,但同一时刻只能有一个线程来使用它. 一但临界区被一个线程占用,其他线程就必须等待.</p>\n</blockquote>\n<h2><span id=\"阻塞blocking和非阻塞non-blocking\">阻塞(Blocking)和非阻塞(Non-Blocking)</span></h2><blockquote>\n<p>阻塞: 一个线程占用了临界区资源,那么<code>其他所有</code>需要这个资源的线程就必须在这个临界区中进行等待. 非阻塞: 任何线程都不会阻碍其他线程的执行,所有的线程都会尝试不断向前继续执行.</p>\n</blockquote>\n<h2><span id=\"死锁deadlock-饥饿starvation和活锁livelock\">死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/892f79594c910e601ccc98a27ec395f0.png\" alt></p>\n<blockquote>\n<p><code>死锁</code>: 如上图,在专业课程中,我们所学到的死锁经常会这样描述-</p>\n<blockquote>\n<p>单行道(堵塞/等待):</p>\n<blockquote>\n<p>线程A需求资源B,占用资源A(资源A最大为1个) 线程B需求资源A,占用资源B(资源B最大为1个) 他俩同时锁住了这两个资源并等待想要的资源.卡掉了.</p>\n</blockquote>\n<p>N个同理.大家都不想放掉自己的资源,又想要别人的.</p>\n</blockquote>\n<p><code>饥饿</code>: 在每一个线程都有优先级的时候,如果一个线程的优先级始终在下面,他就永远得不到资源了，当然,不一定只有这种情况.</p>\n<blockquote>\n<p>与死锁相比,姐还是有可能在一段时间后自行解决的</p>\n</blockquote>\n<p><code>活锁</code>: 两人互相谦让,死脑筋的想着从相同的口出/进就是活锁,本来有机会解锁的…</p>\n</blockquote>\n<h2><span id=\"并发级别\">并发级别</span></h2><blockquote>\n<p>由于临界区的存在,多线程之间的并发必须受到控制。根据控制并发的策略,我们可以把并发的级别进行分类,大致可以分为阻塞、无饥饿、无障碍、无锁、无等待几种.</p>\n</blockquote>\n<h3><span id=\"阻塞blocking\">阻塞(Blocking)</span></h3><blockquote>\n<p>当我们使用synchronized关键字,或者重入锁时,我们得到的就是阻塞的线程. 无论哪种情况,都会在试图执行后续代码前,得到的是临界区的锁,如果得不到,都会被挂起等待,知道占用了所需资源为止.</p>\n<blockquote>\n<p>PS:以上均未遇见,书上说在后面</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"无饥饿starvation-free\">无饥饿(Starvation-Free)</span></h3><blockquote>\n<p>如果线程有优先级,而<code>选用的线程调度算法</code>允许插队,成为非公平,如下图,那么最下面的很大可能会产生饥饿</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/552bc58e0ac12208199b9fad12fc3a04.png\" alt></p>\n<blockquote>\n<p>如果线程是公平的,就不会产生饥饿,不管来的线程优先级多么的高,要想获得资源,就必须 乖 ♂ 乖 ♂ 站 ♂ 好 ♂,所有的线程都会执行.</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/5a479a4139398cbca7e9b73bd2d8cfa5.png\" alt></p>\n<h3><span id=\"无障碍obstruction-free\">无障碍(Obstruction-Free)</span></h3><blockquote>\n<p>不对临界区设任何门栏,任何线程想进就进,想出就出,如果出现数据混乱了怎么办</p>\n<blockquote>\n<p>一旦检测到了数据改坏了,就会对自己所做的修改进行回滚.确保数据安全.如果没有竞争发生,数据就会很安全的离开临界区.</p>\n</blockquote>\n<p>故如果有严重的错误时,所有的线程都会不断地会滚自己的操作.导致没有一个线程可以走出来,顾我们会希望至少有一个县城可以安全地走出来. <code>一致性标记</code>:线程在操作之前,先读取并保存这个标记,在操作完成后,再次读取,检查这个标记是否被更改过.如果两者一致,说明资源访问没又发生冲突,安全.如果不一致,需要重试操作.而任何尝试修改数据的线程,都需要在修改前更改这个一致性标记,表示这个数据不再安全.</p>\n<blockquote>\n<p>如下图</p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0982523d459a08c27cc6a2f902333ce0.png\" alt></p>\n<h3><span id=\"无锁lock-free\">无锁(Lock-Free)</span></h3><blockquote>\n<p>所有线程都可以尝试对临界区进行访问,但不同的是,无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区. 无锁是一个无穷循环。在这个循环中,线程会不断尝试修改共享变量,如果没有冲突,修改成功,则退出,否则继续尝试修改,但无论如何,无锁一定会有一个线程可以胜出.</p>\n<blockquote>\n<p>但是无锁会出现类似于饥饿的情况.</p>\n</blockquote>\n<p>例:</p>\n</blockquote>\n<pre><code>while(!atomicVar.compareAndSet(localVar,localVal+1)){\n    localVar=atomicVar.get();\n}</code></pre><h3><span id=\"无等待wait-free\">无等待(Wait-Free)</span></h3><blockquote>\n<p>无等待是无锁++</p>\n<blockquote>\n<p>它要求所有的线程都需要在有限步内完成,这样就不会引起饥饿问题。如果限制这个步骤上限,还可以进一步分解成有界无等待和线程数无关的无等待几种,他们之间的区别只是对循环次数的限制不同.</p>\n</blockquote>\n<p>一种常用的方法是RCU(Read-Copy-Update)。它的基本思想是,对数据的读写可以不加控制。因此所有的读线程都是无等待的。</p>\n<blockquote>\n<p>怎么处理数据混乱问题呢?</p>\n<blockquote>\n<p>拿走需要修改的数据的Copy那部分,然后寻找合适的时机回写数据.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2><span id=\"有关并行的两个重要定律\">有关并行的两个重要定律</span></h2><blockquote>\n<p>主要作用,提高性能</p>\n</blockquote>\n<h3><span id=\"amdahl定律\">Amdahl定律</span></h3><p>加速比定义: <strong>加速比 = 优化前系统耗时 / 优化后系统耗时</strong> 加速比越高,表明优化效果越明显 T: 时间 T1: 一个处理器优化前耗时 Tn: n个处理器优化后的耗时 n: 处理器个数1 F: 程序中只能串行执行的比例 公式推导: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/22598c64eec40f893a98249a57670466.png\" alt> 通俗来讲: 1/n(1-F)就是将多核时一个核的比 加速比,当n-&gt;无穷,那么加速比与系统的串行率成反比,如果系统中必须有50%的代码串行执行,那么系统的最大加速比为2. 例: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f615f003b46f7c5ae3b6529423fb83b9.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/14a787b8048fee067f5ebdcc8387bd3d.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/3bc7ff881f0402493d61271248e5384f.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/4a703832b4c17c8c9b4b3cefe141296b.png\" alt></p>\n<h3><span id=\"gustafson定律\">Gustafson定律</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2cbd7c085f349d05f504677421c14862.png\" alt> 可以发现Gf定律是通过时间来推导的.</p>\n<h2><span id=\"jmm\">JMM</span></h2><blockquote>\n<p>JVM是Java虚拟机 而JMM是Java的内存模型 故JMM多用于线程/进程管理</p>\n<blockquote>\n<p>JMM是围绕着多线程的原子性,可见性和有序性来建立的</p>\n</blockquote>\n</blockquote>\n<h3><span id=\"原子性\">原子性</span></h3><p>原子性是指一个程序不可中断,一旦开始执行,就不会被其他线程干扰. 值得一提的是,int是原子性的,而long在32位JVM上的读取和输入是非原子性的.</p>\n<pre><code>public class p11 {\n\n    public static long t=0;\n    public static class ChangeT implements Runnable{\n        private long to;\n        public ChangeT(long to){\n            this.to=to;\n        }\n        @Override\n        public void run(){\n            while(true){\n                p11.t=to;\n                Thread.yield();\n            }\n        }\n    }\n\n    public static class ReadT implements Runnable{\n        @Override\n        public void run(){\n            while(true){\n                long tmp=p11.t;\n                if(tmp!=111L &amp;&amp; tmp!=-999L &amp;&amp; tmp!=333L &amp;&amp; tmp!=-444L)\n                    System.out.println(tmp);\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new Thread(new ChangeT(111L)).start();\n        new Thread(new ChangeT(-999L)).start();\n        new Thread(new ChangeT(333L)).start();\n        new Thread(new ChangeT(444L)).start();\n        new Thread(new ReadT()).start();\n    }\n}</code></pre><p>输出: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/db56fde22062e276c391e1a6f6c9fc9b.png\" alt> 会发现根本就不是输入的四个值中的一个,因为他们互相影响了. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2dbc843299c02770553d5e4c1ffa322b.png\" alt></p>\n<h3><span id=\"可见性visibility\">可见性(Visibility)</span></h3><p>可见性是当一个线程修改了变量后,其他线程是否能够立即知道这个修改,显然,对于船型程序而言,可见性是不存在的.因为你在任何一个操作步骤中修改了某个变量,那么在后续步骤中,读取的这个变量,一定是修改后的(临界区被占用). 但在并行程序中就不同了.有可能知道,也可能不知道. 如: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/627ac143df47fe3a851b7eb87fb4f1b8.png\" alt> CPU2和CPU1在一开始读取了cache上的数据,但CPU2在某条路径上更快的修改了cache,而CPU1无法得知,故CPU1内还是一个旧的值.修改则一定会发生错误. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/db7630826e2f662dd9a063f26a3e7bce.png\" alt> 故<code>无法保证</code>能够从一个线程中观察另一个线程的变量.</p>\n<h3><span id=\"编译器的向前优化\">编译器的向前优化</span></h3><p>一个复杂一点的例子 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/810eb542db9f9f179f5f486d0416bf03.png\" alt> 对于大部分编译器而言,可能会对线程1进行向前替换优化,也就是r5=r1.x这条指令会被直接替换成r5=r2.因为他们都读取了r1.x,又发生在同一个线程中,因此,编译器可能会认为没必要二次读取. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6456a7a1fec8e84fcec9d166bea5254d.png\" alt></p>\n<h3><span id=\"有序性ordering\">有序性(Ordering)</span></h3><p>程序在执行时,会出现指令重排,重拍后的指令与原指令未必一致. 这就导致了有可能出现在前面的代码后执行，在后面的代码先执行. 如: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/34204dc9edb67299da132429d63009d8.png\" alt></p>\n<h4><span id=\"指令重排\">指令重排</span></h4><p>可以保证与串行语义一致,但没义务保证多线程间的语义也一致. 为什么要进行指令重排呢? 指令的执行分以下几步: - 取值 IF - 译码和去寄存器操作数 ID - 执行或者有效地址计算 EX - 存储器访问 MEM - 写回 WB 汇编指令也不是一步就可以执行完的. ALU:算数逻辑单元,是CPU的执行单元,是CPU的核心组成部分,主要功能是进行二进制算术运算. 因为指令执行的每一步都使用不同的硬件完成,聪明的工程师就发明了流水线技术. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/e0c81a1d89a95441a84f3253a391e34a.png\" alt></p>\n<h4><span id=\"防止流水线中断\">防止流水线中断</span></h4><p>流水线满载时,性能很不错,但是一旦中断,所有的硬件设备都会进入一个停顿期,再次满载又需要几个周期.因此,性能的损失蛮大的. 而指令重排则是防止流水线中断的一种方式. 我们来以一个例子看看中断到底是什么意思. 下图展示的是 A=B+C 这个操作的执行过程: LW: load LW R1,B 将B加载到R1寄存器中 ADD: 加法 ADD R3,R1,R2 将R1+R2的值放到R3寄存器中 SW: store 存储,就是将R3寄存器的值保存到变量A中. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/606348f53bcc59044914f16b1f54f201.png\" alt> 那两个<code>大X</code>代表的是等待R2的值,因为R2还未MEM,WB,所以R2寄存器内还没有值, 这就是一个中断,会直接的导致后面的慢一拍.</p>\n<blockquote>\n<p>如何防止呢?</p>\n</blockquote>\n<p>一个更复杂的例子: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/4802b1724ff994decb93bf9f43eeb03a.png\" alt> 好多中断是吧.为了减少中断,我们将将对程序没有影响的代码放到中断之前,将中断代码往后移一个单位即可,即充分利用时间. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ab4078495c1184503f0097c6e18f0a36.png\" alt> 重排后的结果: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/94dd41a67f8b3bded551e4ce0d6567e0.png\" alt></p>\n<h4><span id=\"哪些指令不能重排-happen-before-规则\">哪些指令不能重排: Happen-Before 规则</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/5b5ebdca081ab4893f7b990c4b05dcdb.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ac2718210f9da072c0b9f966bed59f6a.png\" alt></p>\n<h1><span id=\"第一章结束\">第一章结束</span></h1>","text":"第一章同步与异步如图 同步是链式进行:只有当一个任务结束后才可以继续下一个 而异步则是前进-&gt;等待消息返回(同时继续前进进行其他的任务)-&gt;消息返回,继续前进. [Figure] 第一章结束","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善2-实战JAVA高并发程序设计-第二章","slug":"plan-two-2","date":"2018-06-17T06:41:01.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-two-2.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/d705faf4fec8f9026144efa61d6b9b6d.png","content":"<h1><span id=\"java并行程序基础\">Java并行程序基础</span></h1><h2><span id=\"进程process\">进程(Process)</span></h2><p><strong>进程</strong>:</p>\n<blockquote>\n<p>1.是计算机中的程序关于某数据集合上的一次运行活动. 2.是系统进行资源分配和调度的基本单位 3.是操作系统结构的基础 4.早期,进程是程序的基本执行实体 5.当代,进程是线程的容器 6.程序是指令、数据及其组织形式的描述,进程是程序的实体</p>\n</blockquote>\n<p>我们使用多线程而非使用多进程去进行并发程序的设计,是因为线程间的切换和调度的成本<strong>远小于进程</strong>.</p>\n<h2><span id=\"线程的生命周期\">线程的生命周期</span></h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d705faf4fec8f9026144efa61d6b9b6d.png\" alt> Java中的线程就是继承Runnable,故生命周期如上图所示. 以下是<code>Java.lang.Thread</code>中关于State的枚举定义源码:</p>\n<pre><code>public enum State {\n    /**\n     * Thread state for a thread which has not yet started.\n     */\n    NEW,\n\n    /**\n     * Thread state for a runnable thread.  A thread in the runnable\n     * state is executing in the Java virtual machine but it may\n     * be waiting for other resources from the operating system\n     * such as processor.\n     */\n    RUNNABLE,\n\n    /**\n     * Thread state for a thread blocked waiting for a monitor lock.\n     * A thread in the blocked state is waiting for a monitor lock\n     * to enter a synchronized block/method or\n     * reenter a synchronized block/method after calling\n     * {@link Object#wait() Object.wait}.\n     */\n    BLOCKED,\n\n    /**\n     * Thread state for a waiting thread.\n     * A thread is in the waiting state due to calling one of the\n     * following methods:\n     * &lt;ul&gt;\n     *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;\n     * &lt;/ul&gt;\n     *\n     * &lt;p&gt;A thread in the waiting state is waiting for another thread to\n     * perform a particular action.\n     *\n     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;\n     * on an object is waiting for another thread to call\n     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on\n     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;\n     * is waiting for a specified thread to terminate.\n     */\n    WAITING,\n\n    /**\n     * Thread state for a waiting thread with a specified waiting time.\n     * A thread is in the timed waiting state due to calling one of\n     * the following methods with a specified positive waiting time:\n     * &lt;ul&gt;\n     *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;\n     *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;\n     *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;\n     * &lt;/ul&gt;\n     */\n    TIMED_WAITING,\n\n    /**\n     * Thread state for a terminated thread.\n     * The thread has completed execution.\n     */\n    TERMINATED;\n}</code></pre><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/68a53d6f77b170185ae936fc85487b8c.png\" alt></p>\n<h2><span id=\"初始线程-线程的基本操作\">初始线程: 线程的基本操作</span></h2><h3><span id=\"新建线程\">新建线程</span></h3><p>线程启动时的调用顺序 start()-&gt;run() 所以,当我们使用start启动线程时是<code>真正</code>启动了一个线程,而在这个线程中调用run方法. 而如果使用了run(),则代表只是<code>调用了一次run函数</code>.</p>\n<blockquote>\n<p>使用匿名内部类修改run方法,然后启动线程</p>\n</blockquote>\n<pre><code>public class p21 {\n\n    public static void main(String[] args){\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                System.out.println(&quot;Hello, I&apos;m t1&quot;);\n            }\n        };\n        t1.start();\n    }\n}</code></pre><h3><span id=\"使用runnable接口来作为thread的构造参数传入\">使用Runnable接口来作为Thread的构造参数传入</span></h3><p>以下是Runnable接口的源码:</p>\n<pre><code>@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}</code></pre><p>可以发现,我们只需要实现run方法即可. 当我们调用Thread的run方法时,他会先判断下是否有Rannable,如果有,则调用Runnable的run方法.</p>\n<pre><code>@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}</code></pre><p>我们来使用Runnable接口实现线程</p>\n<pre><code>public class p21 implements Runnable {\n\n    public static void main(String[] args){\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                System.out.println(&quot;Hello, I&apos;m t1&quot;);\n            }\n        };\n        t1.start();\n        Thread t2=new Thread(new p21());\n        t2.start();\n    }\n\n    @Override\n    public void run(){\n        System.out.println(&quot;Hello,I&apos;m t2.&quot;);\n    }\n\n}</code></pre><p>这样就避免了重载Thread的run()方法,也是最常用的做法</p>\n<h3><span id=\"终止线程\">终止线程</span></h3><p>当我们在实现某些功能时,可能会让一些线程常驻在内存中. 那么我们该如何停止这些线程呢? Thread内部有一个Stop()的方法,但他已被标注为将废弃,因为该方法太过暴力,很有可能造成数据不一致的问题. 因为stop方法会在结束线程时,直接终止线程,并且释放掉这个线程的所有锁.而这些锁则是为了保证对象的一致性.如果此时,写线程写到一半,被强行终止,那么对象的完整性就可能会被破坏. 而因为锁被释放了,所以另一个线程就顺理成章的读到了这个不完整的对象… <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d4573f33d24bfc236e8d0da6dae4a164.png\" alt></p>\n<h4><span id=\"测试\">测试</span></h4><p>我们用一个程序来模拟下上面说的情况: 具体思路为-&gt;开启读取线程,如果User名字和id不一样,输出-&gt;不停地创建修改线程,修改的id和name一样-&gt;修改完成后stop()-&gt;观察结果</p>\n<pre><code>public class p22 {\n    public static User u=new User();\n    public static class User{\n        private int id;\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        private String name;\n        public User(){\n            id=0;\n            name=&quot;0&quot;;\n        }\n        @Override\n        public String toString(){\n            return &quot;User [id=&quot;+id+&quot;,name=&quot;+name+&quot;]&quot;;\n        }\n    }\n\n    public static class ChangeObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    int v=(int)(System.currentTimeMillis()/1000);\n                    u.setId(v);\n                    //Oh,do sth.else\n                    try{\n                        Thread.sleep(100);\n                    }catch(InterruptedException e){\n                        e.printStackTrace();\n                    }\n                    u.setName(String.valueOf(v));\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static class ReadObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(u.getId()!=Integer.parseInt(u.getName())){\n                        System.out.println(u.toString());\n                    }\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReadObjectThread().start();\n        while(true){\n            Thread t=new ChangeObjectThread();\n            t.start();\n            Thread.sleep(100);\n            t.stop();\n        }\n    }\n}</code></pre><p>输出: … User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] User [id=1529221875,name=1529221874] … 我们发现会出现很多如此的错误,为什么呢?和之前一样的原因,指令的顺序在优化中可能被更改,而线程的执行顺序也和调度算法有关,所以就造成了有可能某线程对User数据修改时sleep了一段时间,而这段时间内突然被stop了,其他的线程就拿到了不完整的数据. <strong>当然,如果你将两个sleep都设置为0就不会出现这种错误了.</strong></p>\n<h4><span id=\"自定义线程停止\">自定义线程停止</span></h4><blockquote>\n<p>如何解决这种问题呢?</p>\n</blockquote>\n<p>我们自行决定线程何时退出就可以了。</p>\n<ul>\n<li>volatile关键字 &gt; 添加该关键字的变量是: &gt;&gt; 不同线程访问和修改的变量</li>\n</ul>\n<blockquote>\n<p>即该指令不会因为编译器的优化而忽略,且要求每次直接读值.</p>\n</blockquote>\n<p>我们只需要为ChangeObjectThread添加一个方法stopMe(), 当stopme为true的时候才可以读取,为false的时候就禁止读取.并且直接退出run方法. 这也就保证了不会导致修改中途被撤销.</p>\n<pre><code>public class p22 {\n    public static User u=new User();\n    public static class User{\n        private int id;\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        private String name;\n        public User(){\n            id=0;\n            name=&quot;0&quot;;\n        }\n        @Override\n        public String toString(){\n            return &quot;User [id=&quot;+id+&quot;,name=&quot;+name+&quot;]&quot;;\n        }\n    }\n\n    public static class ChangeObjectThread extends Thread{\n\n        volatile boolean stopme=false;\n\n        public void stopMe(){\n            stopme=true;\n        }\n\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(stopme){\n                        System.out.println(&quot;exit by stop me&quot;);\n                        break;\n                    }\n                    int v=(int)(System.currentTimeMillis()/1000);\n                    u.setId(v);\n                    //Oh,do sth.else\n                    try{\n                        Thread.sleep(100);\n                    }catch(InterruptedException e){\n                        e.printStackTrace();\n                    }\n                    u.setName(String.valueOf(v));\n                }\n                Thread.yield();\n            }\n        }\n\n\n\n    }\n\n    public static class ReadObjectThread extends Thread{\n        @Override\n        public void run(){\n            while(true){\n                synchronized(u){\n                    if(u.getId()!=Integer.parseInt(u.getName())){\n                        System.out.println(u.toString());\n                    }\n                }\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReadObjectThread().start();\n        while(true){\n            ChangeObjectThread t=new ChangeObjectThread();\n            t.start();\n            Thread.sleep(100);\n            t.stopMe();\n        }\n    }\n\n}</code></pre><h3><span id=\"线程中断\">线程中断</span></h3><p>为了解决stop可能会导致数据冲突的问题,JDK中提供了三个方法来实现线程中断.</p>\n<blockquote>\n<p>线程中断</p>\n<blockquote>\n<p>即线程中断不会使线程立即退出,而是给线程发一个通知,告知目标线程要中断了,至于如何处理,何时中断,<strong>由目标决定.</strong></p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ec4bce7b33d0b7bbbb972f5ef2404bc2.png\" alt></p>\n<pre><code>public class p23 {\n\n    public static void main(String[] args) throws Exception{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                while(true){\n                    if(Thread.currentThread().isInterrupted()){\n                        System.out.println(&quot;Interruted!&quot;);\n                        break;\n                    }\n                    Thread.yield();\n                }\n            }\n        };\n        t1.start();\n        Thread.sleep(100);\n        t1.interrupt();\n    }\n\n}</code></pre><h4><span id=\"threadsleep函数\">Thread.sleep函数</span></h4><p>他的签名如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b5e83f7565ce436cf16a37f5917f11ad.png\" alt> Thread.sleep()会让当前线程休眠若干时间,他会抛出一个InterruptedException中断异常,这个异常不是运行时异常,也就是说程序必须捕获并处理它,当线程休眠时,如果被中断,该异常就会产生.</p>\n<pre><code>public class p23 {\n\n    public static void main(String[] args) throws Exception{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(){\n            @Override\n            public void run(){\n                while(true){\n                    if(Thread.currentThread().isInterrupted()){\n                        System.out.println(&quot;Interruted!&quot;);\n                        break;\n                    }\n                    try{\n                        Thread.sleep(2000);\n                    }catch(InterruptedException e){\n                        System.out.println(&quot;Interrpted When Sleep&quot;);\n                        Thread.currentThread().interrupt();\n                    }\n                    Thread.yield();\n                }\n            }\n        };\n        t1.start();\n        Thread.sleep(100);\n        t1.interrupt();\n    }\n\n}</code></pre><p>所以我们必须在捕捉该异常的同时再次放出中断异常,这样才能保证该线程被正常中断.</p>\n<h4><span id=\"wait与notify\">wait()与notify()</span></h4><p>为了支持多线程间协作,JDK提供了等待wait()和通知notify()两个方法. 但这两个方法不存在Thread类中,而是输出Object类.这也就意味着任意的对象都可以调用该方法. 两个方法签名如下:</p>\n<pre><code>public final void wait() throws InterruptedException\npublic final native void notify()</code></pre><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/45787c634458f214da51856102ddff30.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b5278147272b76af3b33e061e68201b6.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b6d82ba876ebf51839908d5453046041.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/b48a839ed1fa92328e6d7d2b3533f3ac.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/34da980742c79e179903c43f753e473a.png\" alt> 简单的例子:</p>\n<pre><code>public class p24 {\n    final static Object object = new Object();\n    public static class T1 extends Thread{\n        public void run(){\n            synchronized(object){\n                System.out.println(System.currentTimeMillis()+&quot;:T1 start!&quot;);\n                try{\n                    System.out.println(System.currentTimeMillis()+&quot;:T1 wait for object&quot;);\n                    object.wait();\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                }\n                System.out.println(System.currentTimeMillis()+&quot;:T1 end!&quot;);\n            }\n        }\n    }\n    public static class T2 extends Thread{\n        public void run(){\n            synchronized(object){\n                System.out.println(System.currentTimeMillis()+&quot;:T2 start! notify one thread&quot;);\n                object.notify();\n                System.out.println(System.currentTimeMillis()+&quot;:T2 end!&quot;);\n                try{\n                    Thread.sleep(2000);\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread t1=new T1();\n        Thread t2=new T2();\n        t1.start();\n        t2.start();\n    }\n\n}</code></pre><p>结果:</p>\n<pre><code>1529292002347:T1 start!\n1529292002347:T1 wait for object\n1529292002348:T2 start! notify one thread\n1529292002348:T2 end!\n1529292004348:T1 end!</code></pre><p>Tip: wait会释放所有的锁</p>\n<h4><span id=\"挂起suspend和继续执行resume线程\">挂起(suspend)和继续执行(resume)线程</span></h4><p>suspend乍看起来和stop或者wait相似简单的用法,但是,值得注意的是,suspend并不会释放任何资源和锁.所以就会导致其他想要索取资源的线程也被牵连. 而且resume也是存在问题,有可能在suspend前执行,这就会导致当前线程的状态被误判.</p>\n<h4><span id=\"等待线程结束join和谦让yield\">等待线程结束(join)和谦让(yield)</span></h4><p>一个线程需要等待另一个线程的结束才能继续执行(依赖输出)则用join. public final void join() throws InterruptedExcption public final synchronized void join(long millis) throws InterruptedException 第一个表示无限等待,他会一直阻塞线程,直到目标线程执行完毕. 第二个表示如果超过一段时间还没等到,则不等待,继续执行. 例:</p>\n<pre><code>public class p25 {\n    public volatile static int i=0;\n    public static class AddThread extends Thread{\n        @Override\n        public void run(){\n            for(i=0;i&lt;10000000;++i);\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        AddThread at=new AddThread();\n        at.start();\n        at.join();\n        System.out.println(i);\n\n    }\n\n}</code></pre><p>上述主函数中,如果不执行join来等待线程结束,则更多的可能是只会出现在线程结束前输出i的值(比如0)的情况. 如果用join来等待的话,则最终一定会输出1e7. join的本质是让调用线程wait()在当前线程对象实例上. 另一个: yield()方法是让当前线程让出CPU,然后重新加入到资源的争抢当中.如果觉得一个线程不是很重要,又害怕它占用过多的CPU,可以调用yield方法.</p>\n<h4><span id=\"volatile与java内存模型jmm\">volatile与Java内存模型(JMM)</span></h4><p>使用volatitle就表示告诉了虚拟机这个变量很可能被某线程修改. 虚拟机会特别小心的处理这个变量,尤其是当发现修改的顺序是反的时候. volatile可以很大程度上保证变量的完整性,但不保证操作的原子性,比如i++的原子操作完整性(i为32位下的长整型) 此外,volatile也能保证数据的可见性和有序性. 例:</p>\n<pre><code>public class p26 {\n\n    private volatile static boolean ready;\n    private static int number;\n\n    private static class ReaderThread extends Thread{\n        public void run(){\n            while(!ready);\n            System.out.println(number); \n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        new ReaderThread().start();\n        Thread.sleep(1000);\n        number=42;\n        ready=true;\n        Thread.sleep(10000);\n    }\n}</code></pre><p>因为指令的优化,在Server下线程无法”看到”ready”被修改.所以会无限的执行下去,这就是典型的可见性问题. 而加了volatiel修饰后的ready就不会出现这种情况了.</p>\n<h3><span id=\"线程组\">线程组</span></h3><p>一个系统中如果存在过多的线程,而且分工比较明确,就可以将相同功能的线程放置在一个线程组内.这样会使效率更高些.</p>\n<pre><code>public class p27 implements Runnable{\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        ThreadGroup tg=new ThreadGroup(&quot;PrintGroup&quot;);\n        Thread t1=new Thread(tg,new p27(),&quot;T1&quot;);\n        Thread t2=new Thread(tg,new p27(),&quot;T2&quot;);\n        t1.start();\n        t2.start();\n        System.out.println(tg.activeCount());\n        tg.list();\n        //tg.stop();-慎用\n    }\n    @Override\n    public void run(){\n        String groupAndName=Thread.currentThread().getThreadGroup().getName()\n                +&quot;-&quot;+Thread.currentThread().getName();\n        while(true){\n            System.out.println(&quot;I am &quot;+groupAndName);\n            try{\n                Thread.sleep(3000);\n            }catch(InterruptedException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre><h3><span id=\"驻守后台-守护线程daemon\">驻守后台-守护线程(Daemon)</span></h3><p>JVM内部的实现是如果运行的程序只剩下守护线程的话，程序将终止运行，直接结束。所以守护线程是作为辅助线程存在的</p>\n<h3><span id=\"线程优先级\">线程优先级</span></h3><p>Java可以自定义线程的优先级. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d05785fceddb6610ce2c0cf81eb21716.png\" alt> 设置优先级用 (Thread).setPriority(优先级(1~10))</p>\n<h3><span id=\"线程安全概念与synchronized\">线程安全概念与synchronized</span></h3><p>线程安全是并行程序开发的一大重点. 线程安全例子:</p>\n<pre><code>public class p28 implements Runnable{\n    static p28 instance=new p28();\n    static volatile int i=0;\n    public static void increase(){\n        i++;\n    }\n    @Override\n    public void run(){\n        for(int j=0;j&lt;10000000;++j){\n            increase();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        Thread t1=new Thread(instance);\n        Thread t2=new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();t2.join();\n        System.out.println(i);\n    }\n}</code></pre><p>如果把t1.join()放到t1.start()后面的话,输出就为正常结果.但如上这样子放的话,也就代表了两个线程实际上是一起执行的.但在某一时刻t1.join开启以后t2就暂停执行等待t1执行完再继续. 我们可以使用synchronized关键字来对同步的代码加锁.使得每一次只能有一个线程进入同步块. 代码在书上的-P58,之前写过很多次了.</p>\n<h3><span id=\"并发下的arraylist\">并发下的ArrayList</span></h3><p>ArrayList是线程不安全的,用Vector代替线程不安全的ArrayList即可.</p>\n<h3><span id=\"并发下的hashmap\">并发下的HashMap</span></h3><p>并发下的HashMap可能会出现死循环的现象,为什么?下面来看一段代码 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/7be0b2035576e2b5202c4ba9360fb90d.png\" alt> 这段代码证明HashMap的插入是按照链表的方法插入的.而当死循环时就代表当前的HashMap链表被破坏成了环.也就导致了死循环. (但JDK8已经避免了这种情况的产生)</p>\n<h3><span id=\"jps和jstack工具\">jps和jstack工具</span></h3><p>jps是查看当前所有大线程 jstack是定位到对应的线程以及代码</p>\n<h3><span id=\"integer其实使用工厂方法进行赋值的\">Integer其实使用工厂方法进行赋值的</span></h3><p>如果我们想要给Integer加锁时,我们不能直接在Integer(int)变量上加锁,因为Integer是用工厂方法进行赋值,每次给int赋值时都会重新生成一个Integer对象. 所以我们需要在改变量所在的实例化对象上加锁. 比如: public class k implements Runnable{ int a; public void run(){ Code here. } } 我们就需要在实例化后的k对象上加锁,而不是在a上加锁.</p>\n","text":"Java并行程序基础进程(Process)进程:1.是计算机中的程序关于某数据集合上的一次运行活动. 2.是系统进行资源分配和调度的基本单位 3.是操作系统结构的基础 4.早期,进程是程序的基本执行实体 5.当代,进程是线程的容器 6.程序是指令、数据及其组织形式的描述,进程是程","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]},{"title":"计划:技术栈完善2-实战JAVA高并发程序设计-第三章","slug":"plan-three","date":"2018-06-19T01:06:07.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/plan-three.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/482e4b0a1461a4d73d554ac253836c8a.png","content":"<h1><span id=\"jdk并发包\">JDK并发包</span></h1><h2><span id=\"多线程间的团队协作-同步控制\">多线程间的团队协作: 同步控制</span></h2><p>比如之前的synchronized关键字就是一种最简单的控制方法.它决定了一个线程是否可以访问临界资源区. 还有wait和notify.</p>\n<h3><span id=\"synchronized的功能扩展-重入锁\">synchronized的功能扩展: 重入锁</span></h3><p>重入锁可以完全替代synchronized关键字. 重入锁使用 java.util.concurrent.locks.ReentrantLock 类来实现. 例:</p>\n<pre><code>import java.util.concurrent.locks.ReentrantLock;\npublic class p31 implements Runnable{\n\n    public static ReentrantLock lock=new ReentrantLock();\n    public static int i=0;\n    @Override\n    public void run(){\n        for(int j=0;j&lt;10000000;++j){\n            lock.lock();\n            try{\n                i++;\n            }finally{\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        p31 tl=new p31();\n        Thread t1=new Thread(tl);\n        Thread t2=new Thread(tl);\n        t1.start();t2.start();\n        t1.join();t2.join();\n        System.out.println(i);\n    }\n}</code></pre><p>可以看出这段代码是手动加锁的.故重入锁在逻辑控制的灵活性上远高于某关键字. <strong>但一定注意推出临界区要释放锁</strong> 为什么叫重入锁呢?因为允许一个线程获得N个锁,所以叫重入锁. <strong>一个线程获取多个锁后,也必须释放相同次数的锁</strong></p>\n<h4><span id=\"重入锁的中断响应\">重入锁的中断响应</span></h4><p>如果你一个线程一直等待锁,而拿锁的那个线程始终不放开锁,那不就死锁了么. 它提供了一种机制,即通知等待者无须再等待.即时停止工作. isHeldByCurrentThread()方法是返回当前线程是否拥有该锁. lockInterruptibly()方法是获取一个允许中断响应的锁. lock()方法获取的锁不允许中断. 例：</p>\n<pre><code>import java.util.concurrent.locks.ReentrantLock;\n\npublic class p32 implements Runnable {\n    public static ReentrantLock lock1=new ReentrantLock();\n    public static ReentrantLock lock2=new ReentrantLock();\n\n    int lock;\n    /*\n     * 控制加锁顺序,防止死锁\n     */\n    public p32(int lock){\n        this.lock=lock;\n    }\n\n    @Override\n    public void run(){\n        try{\n            if(lock==1){\n                lock1.lockInterruptibly();\n                try{\n                    Thread.sleep(500);\n                }catch(InterruptedException e){}\n                System.out.println(&quot;Lock1 Here IN&quot;);\n                lock2.lockInterruptibly();\n                System.out.println(&quot;Lock1 Here OUT&quot;);\n            }else{\n                lock2.lockInterruptibly();\n                try{\n                    Thread.sleep(500);\n                }catch(InterruptedException e){}\n                System.out.println(&quot;Lock2 Here IN&quot;);\n                lock1.lockInterruptibly();\n                System.out.println(&quot;Lock2 Here OUT&quot;);\n            }\n        }catch(InterruptedException e){\n            e.printStackTrace();\n        }finally{\n            if(lock1.isHeldByCurrentThread())\n                lock1.unlock();\n            if(lock2.isHeldByCurrentThread())\n                lock2.unlock();\n            System.out.println(Thread.currentThread().getId()+&quot;线程退出&quot;);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        p32 r1=new p32(1);\n        p32 r2=new p32(2);\n        Thread t1 = new Thread(r1);\n        Thread t2 = new Thread(r2);\n        t1.start();t2.start();\n        Thread.sleep(1000);\n        t2.interrupt();\n    }\n\n}</code></pre><p>线程启动后,r1先占用lock1,再请求lock2 r2相反,这也就导致了t1和t2互相等待,形成死锁. 而当我们将r2中断以后,r2释放了所有的锁,r1检测到了,故只有r1完全执行完毕,r2则会抛出一个中断异常.</p>\n<h4><span id=\"第二种中断方法\">第二种中断方法</span></h4><blockquote>\n<p>lock.tryLock(5,TimeUnit.SECONDS)</p>\n<blockquote>\n<p>县城在这个锁请求中等待5秒,如果五秒内无法得到锁,则False</p>\n</blockquote>\n</blockquote>\n<h4><span id=\"公平锁\">公平锁</span></h4><blockquote>\n<p>公平锁的效率不高,所以一般不用,因为公平锁需要维护一个优先队列. 公平锁是通过对谁先获得当前资源进行合理的调度来防止死锁的产生. 使用方法: ReentrantLock</p>\n<blockquote>\n<p>性质:</p>\n<blockquote>\n<p>1.原子状态 2.等待队列(没有请求到锁就进入等待队列) 3.阻塞原语pair()与unpair()</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4><span id=\"重入锁好搭档-condition条件\">重入锁好搭档: Condition条件</span></h4><blockquote>\n<p>Condition和wait与notify的用法大致相同</p>\n</blockquote>\n<pre><code>package s;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class p31 implements Runnable {\n\n    public static ReentrantLock lock=new ReentrantLock();\n    public static Condition condition=lock.newCondition();\n\n    @Override\n    public void run(){\n        try{\n            lock.lock();\n            System.out.println(&quot;SD&quot;);\n            condition.await();\n            System.out.println(&quot;This is going on.&quot;);\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally{\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        p31 tl=new p31();\n        Thread t1=new Thread(tl);\n        t1.start();\n        Thread.sleep(2000);\n        ///通知线程t1继续执行\n        lock.lock();\n        condition.signal();\n        System.out.println(&quot;AA&quot;);\n        lock.unlock();\n    }\n\n}</code></pre><blockquote>\n<p>注: Condition只能在lock和unlock保护下才可以解锁. wait 是等待,notify是返回通知开始执行</p>\n</blockquote>\n<h4><span id=\"允许多个线程同时访问-信号量semaphore\">允许多个线程同时访问: 信号量(Semaphore)</span></h4><blockquote>\n<p>构造函数:</p>\n<blockquote>\n<p>public Semaphore(int permits) public Semaphore(int permits,boolean fair) 第二个参数是是否公平</p>\n</blockquote>\n<p>信号量主要逻辑方法</p>\n<blockquote>\n<p>public void acquire() -准入许可,等待 public void acquireUninterruptibly() -不接收中断 public boolean tryAcquire() - 获得许可,不等待 public boolean tryAcquire(long timeout,TimeUnit unit) public void release() - 释放许可</p>\n</blockquote>\n</blockquote>\n<p>例子:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Semaphore;\n\npublic class p33 implements Runnable{\n    final Semaphore semp=new Semaphore(5);\n    public void run(){\n        try{\n            semp.acquire();\n            Thread.sleep(2000);\n            System.out.println(Thread.currentThread().getId()+&quot;:done!&quot;);\n            semp.release();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        ExecutorService exec =Executors.newFixedThreadPool(20);\n        final p33 t1= new p33();\n        for(int i=0;i&lt;20;++i){\n            exec.submit(t1);\n        }\n    }\n\n}</code></pre><p>为信号量传入的5代表线程队列中课同时存在的线程数量的最大值. 开启程序后,你会发现每一瞬间都会有5个线程执行并打印出数据,但在这5个释放占用的信号量后才会继续向下执行.</p>\n<h4><span id=\"readwritelock-读写锁\">ReadWriteLock 读写锁</span></h4><blockquote>\n<p>读操作不会破坏数据完整性,所以当读-读-…操作产生时,不需要加锁即可.这样使得大量读操作的系统会有很明显的效率上的提升. 但写会阻塞读,所以效率由写操作的次数来决定.</p>\n</blockquote>\n<p>锁的创建:</p>\n<pre><code>private static ReentrantReadWriteLock readWriteLock=new RenntrantReadWriteLock();\nprivate static Lock readLock=readWriteLock.readLock();\nprivate static Lock WriteLock=readWriteLock.WriteLock();</code></pre><h4><span id=\"倒计时器-countdownlatch\">倒计时器: CountDownLatch</span></h4><p>它可以让一个线程在倒计时结束后再执行. 执行方式如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/482e4b0a1461a4d73d554ac253836c8a.png\" alt> 必须所有的线程都完成任务后,等待在CountDownLatch上的线程才能继续执行. 例:</p>\n<pre><code>import java.util.Random;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class p34 implements Runnable{\n    static final CountDownLatch end=new CountDownLatch(10);\n\n    static final p34 demo=new p34();\n\n    public void run(){\n        try{\n            Thread.sleep(new Random().nextInt(10)*1000);\n            System.out.println(&quot;check complete&quot;);\n            end.countDown();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    public static class now{\n        public static void print() throws InterruptedException{\n            end.await();\n            System.out.println(&quot;我来了~~~~&quot;);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        final now t1=new now();\n        ExecutorService exec=Executors.newFixedThreadPool(10);\n        for(int i=0;i&lt;10;++i){\n            exec.submit(demo);\n        }\n        t1.print();\n        exec.shutdown();\n    }\n}</code></pre><h4><span id=\"循环栅栏-cyclicbarrier\">循环栅栏： CyclicBarrier</span></h4><blockquote>\n<p>它比上面那个更加复杂和强大</p>\n<blockquote>\n<p>可以将它理解为一种障碍物.它是用来阻止线程继续执行,并且这个计数器可以反复使用,比如,10个执行完以后,再来一遍.</p>\n</blockquote>\n</blockquote>\n<p>例:</p>\n<pre><code>import java.util.Random;\nimport java.util.concurrent.CyclicBarrier;\n\npublic class p35 {\n    public static class Soldier implements Runnable{\n        private String soldier;\n        private final CyclicBarrier cyclic;\n        Soldier(CyclicBarrier cyclic,String s){\n            this.cyclic=cyclic;\n            this.soldier=s;\n        }\n\n        public void run(){\n            try{\n                //等待所有士兵到齐\n                cyclic.await();\n                doWork();\n                //等待所有士兵完成工作\n                cyclic.await();\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n\n        void doWork(){\n            try{\n                Thread.sleep(Math.abs(new Random().nextInt()%10000));\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n            System.out.println(soldier+&quot;任务完成!&quot;);\n        }\n\n    }\n\n    public static class BarrierRun implements Runnable{\n        boolean flag;\n        int N;\n        public BarrierRun(boolean a,int b){\n            this.flag=a;\n            this.N=b;\n        }\n        public void run(){\n            if(flag){\n                System.out.println(&quot;司令:[士兵&quot;+N+&quot;个,任务完成!]&quot;);\n            }else{\n                System.out.println(&quot;司令:[士兵&quot;+N+&quot;个,集合完毕!]&quot;);\n                flag=true;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N=5;\n        Thread[] allSoldier=new Thread[10];\n        boolean flag=false;\n        CyclicBarrier cyclic=new CyclicBarrier(N,new BarrierRun(flag,N));\n        //设置屏障点\n        System.out.println(&quot;集合队伍!&quot;);\n        for(int i=0;i&lt;10;++i){\n            System.out.println(&quot;士兵&quot;+i+&quot;报道!&quot;);\n            allSoldier[i]=new Thread(new Soldier(cyclic,&quot;士兵 &quot;+i));\n            allSoldier[i].start();\n        }\n    }\n\n}</code></pre><p>输出: 集合队伍! 士兵0报道! 士兵1报道! 士兵2报道! 士兵3报道! 士兵4报道! 士兵5报道! 司令:[士兵5个,集合完毕!] 士兵6报道! 士兵7报道! 士兵8报道! 士兵9报道! 司令:[士兵5个,任务完成!] 士兵 8任务完成! 士兵 7任务完成! 士兵 1任务完成! 士兵 0任务完成! 士兵 4任务完成! 司令:[士兵5个,任务完成!] 士兵 5任务完成! 士兵 3任务完成! 士兵 9任务完成! 士兵 2任务完成! 士兵 6任务完成! 司令:[士兵5个,任务完成!] 你会发现是每5个释放一次锁.</p>\n<h4><span id=\"locksupport\">LockSupport</span></h4><blockquote>\n<p>它可以在线程内任意位置让其阻塞 之前suspend和resume时,如果resume在suspend前执行,则一定会出现线程被无限挂起,导致无法正常退出. 我们可以用LockSupport解决这一问题.</p>\n</blockquote>\n<p>因为LockSupport是用信号量来实现的.它为每一个线程准备了一个许可,如果许可可用,则park()函数会立即返回,并且消费许可(变为不可用).如果许可不可用,就会被阻塞. 但和信号量不同的是,许可永远只有一个. LockSupport.park() LockSupport.unpark(Runnable) LockSupport.parkNanos() LockSupport.parkUtil() 此外,如果是用park(Object),则这个阻塞对象会出现在线程Dump中(报错),分析问题就更方便了.</p>\n<h3><span id=\"线程复用-线程池\">线程复用: 线程池</span></h3><blockquote>\n<p>多线程的软件设计方法确实可以最大限度的发挥现代多核处理器的计算能力,提高生产系统的吞吐量和性能。但是,若不加控制和管理的随意使用线程,对系统的性能反而会产生不利影响.</p>\n</blockquote>\n<p>一种极简的处理方法:</p>\n<pre><code>new Thread(new Runnable(){\n    public void run(){\n        //do sth\n    }\n}).start();</code></pre><p>这样的线程在run完后就会自动回收,但线程量过大时,则会耗尽CPU和内存资源. 而且如果为每一个小程序都创建一个线程,就可能出现销毁时间远大于该线程实际工作所消耗的时间. 其次,可能因线程过多而爆栈/堆. 大量的线程回收也会给GC造成很大压力,延长GC的停顿时间.</p>\n<h4><span id=\"什么是线程池\">什么是线程池</span></h4><p>为了避免系统频繁的创建和销毁线程,我们会尽量的让线程复用. <strong>数据库连接池:</strong> 为了避免每次数据库查询都重新建立和销毁数据库连接,我们可以使用数据库连接池保护一些数据库连接,让他们长期在激活状态.当系统需要数据库时,并不是真正创建一个新的连接,而是从连接池中获得一个可用的连接即可.反之,当需要关闭连接时,并不是真的把链接关闭,而是将这个链接还给连接池即可. <strong>线程池</strong>: 线程池中,总有那么几个活跃线程,当你需要时,可以从池子中随便拿一个空闲线程,当完成工作时,并不着急关闭线程,而是将这个线程退回到池子,方便别人使用. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/88267587709716bb6b7d5a183b7bea85.png\" alt> 换言之,创建线程变成了从池子中获得线程,销毁变成了归还.</p>\n<h4><span id=\"jdk内置线程池框架-executor\">JDK内置线程池框架: Executor</span></h4><blockquote>\n<p>框架结构图</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2c1925682e53b6a81146256a57ce2e88.png\" alt> 关于Executor的设计模式: 生产者-消费者模式和工厂方法 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6085df9c51bc40c12d4bee50128f9130.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/25117913abc15c1b6a431d930ac4c390.png\" alt> 例子:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class p36 {\n    public static class MyTask implements Runnable{\n        public void run(){\n            System.out.println(System.currentTimeMillis()+&quot;:Thread ID:&quot;+Thread.currentThread().getId());\n            try{\n                Thread.sleep(1000);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args){\n        // TODO Auto-generated method stub\n        MyTask task=new MyTask();\n        ExecutorService es=Executors.newFixedThreadPool(5);\n        for(int i=0;i&lt;10;++i){\n            es.submit(task);\n        }\n        es.shutdown();\n    }\n\n}</code></pre><p>可能我们之前一直对<strong>为什么我们传入submit的是一个对象,但他们得ID却不同呢?</strong> 这是因为线程的ID与对象并无直接关系,线程的ID是直接分配好的. 我们可以尝试打印出<strong>this.toString()</strong>来查看是否是同一个对象,结果表明确实是同一个对象,如果不想使用用同一个对象来做测试,那就用new MyTask()作为参数就可以了. 但直接new的话,会出现一个很严重的问题,就是new出来的对象的执行顺序可能产生混乱.因为不是同一个对象,所以就不会按照顺序来执行了. 例:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class p36 { \n    public static ReentrantLock lock=new ReentrantLock();\n    public static class MyTask implements Runnable{\n        private int kt=0;\n        public void cal(int t){\n            kt=kt+t;\n        }\n        public void run(){\n            //lock.lock();\n            cal(1);\n            //lock.unlock();\n            //System.out.println(System.currentTimeMillis()+&quot;:Thread ID:&quot;+Thread.currentThread().getId());\n            if(kt&gt;9990)\n                System.out.println(this.toString()+&quot; &quot;+kt);\n            try{\n                Thread.sleep(1);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        // TODO Auto-generated method stub\n        MyTask tk=new MyTask(); \n        Thread pk=new Thread(tk);\n        ExecutorService es=Executors.newFixedThreadPool(10);\n\n        for(int i=0;i&lt;10000;++i){\n            es.submit(tk);\n        }\n        es.shutdown();\n        System.out.println(&quot;AAAAAA&quot;+tk.kt);\n    }\n\n}</code></pre><p>打印后会发现,结果并不是正确的,甚至10000的数据前提下9990也不能保证. 当然,加上锁以后就正常了.</p>\n<h4><span id=\"刨根问底-核心线程池的内部实现\">刨根问底: 核心线程池的内部实现</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/7c53caa4fa9b345ab9b03b92bda61465.png\" alt></p>\n<h4><span id=\"拒接策略\">拒接策略</span></h4><p>P108</p>\n<h4><span id=\"扩展线程池\">扩展线程池</span></h4><blockquote>\n<p>ThreadPoolExecutor是一个可扩展的线程池 它为我们提供了三个接口</p>\n<blockquote>\n<p>beforeExecute() afterExecute() terminated()</p>\n</blockquote>\n</blockquote>\n<p>字面意思 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/852095dd0c714bd6f84dfbab510688f6.png\" alt> 我们重写一下试试:</p>\n<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class p37 {\n    public static class MyTask implements Runnable{\n        public String name;\n\n        public MyTask(String name){\n            this.name=name;\n        }\n\n        public void run(){\n            System.out.println(&quot;正在执行&quot;+&quot;:Thread ID:&quot;+Thread.currentThread().getId()+&quot;:Task Name:&quot;+name);\n            try{\n                Thread.sleep(1000);\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        ExecutorService es=new ThreadPoolExecutor(5,5,0L,TimeUnit.MILLISECONDS,new LinkedBlockingDeque&lt;Runnable&gt;()){\n            @Override\n            protected void beforeExecute(Thread t,Runnable r){\n                System.out.println(&quot;准备执行: &quot;+((MyTask)r).name);\n            }\n\n            @Override\n            protected void afterExecute(Runnable r,Throwable t){\n                System.out.println(&quot;执行完成: &quot;+((MyTask)r).name);\n            }\n\n            @Override\n            protected void terminated(){\n                System.out.println(&quot;线程池退出&quot;);\n            }\n        };\n        for(int i=0;i&lt;5;++i){\n            MyTask task=new MyTask(&quot;TASK-GEYM-&quot;+i);\n            es.execute(task);\n            Thread.sleep(10);\n        }\n        es.shutdown();\n    }\n}</code></pre><p>注: shutdown方法会等所有的线程执行结束后才关闭线程池.</p>\n<h4><span id=\"合理的选择-优化线程池线程数量\">合理的选择: 优化线程池线程数量</span></h4><p>线程池的大小对系统的性能也有影响.过大或过小都不可以.但也不需要特别精确. 一般来说确定线程池的大小需要考虑CPU的数量,内存大小等因素. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2fdb2eba1f1763034b55e7c321ef1bab.png\" alt></p>\n<h4><span id=\"注线程池可能会吃掉异常\">注:线程池可能会吃掉异常</span></h4><p>而 execute方法会打印出部分异常, 或者修改submit的使用: Future re=pools.submit(new DivTask(100,0)); re.get(); 这样也可以.</p>\n<h4><span id=\"扩展threadpoolexecutor以显示异常\">扩展ThreadPoolExecutor以显示异常</span></h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/be5bdfeba0ba5e3d7cf870cdd78a0747.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/ca0feb96b4362f4ca128ce48747e546a.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/bf9c0ac33c3b0339653f64917ef6eb1b.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/bf1b6e3a4fae52e8b048039894cc3cd6.png\" alt></p>\n<h3><span id=\"分而治之-forkjoin框架\">分而治之: Fork/Join框架</span></h3><p>著名的MapReduce也是采用了分而治之的思想,简单来说,如果你要处理1000个数据,但是你并不具备处理1000个数据的能力,那么你可以只处理10个,然后,分阶段处理100个,将100个结果进行合成.就是1000个结果. JDK为我们提供了ForkJoinPool线程池. <strong>Fork/join执行逻辑</strong> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c06d16d76d0568a8e5133f62436d4b68.png\" alt> <strong>互相帮助的线程</strong> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c68c5120e1a1f1e9216f0948c0e543ff.png\" alt> 其中ForkJoinTask有两个重要的子类.关系如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/c706a5a90f343ea864742a01af91ca8e.png\" alt> RecursiveTask&lt;&gt; 是实现一个compute函数(返回值要与泛型一致)即可. 例:</p>\n<pre><code>import java.util.ArrayList;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\n\npublic class p38 extends RecursiveTask&lt;Long&gt; {\n    private static final int THRESHOLD = 10000;\n    private long start;\n    private long end;\n\n    public p38(long start,long end){\n        this.start=start;\n        this.end=end;\n    }\n\n    public Long compute(){\n        long sum=0;\n        boolean canCompute=(end-start)&lt;THRESHOLD;\n        if(canCompute){\n            ///如果大于THRESHOLD的话才进行分解,否则直接进行即可\n            for(long i=start;i&lt;=end;++i){\n                sum+=i;\n            }\n        }else{\n            //分成100个小任务(整块)\n            long step=(start+end)/100;\n            ArrayList&lt;p38&gt; subTasks=new ArrayList&lt;p38&gt;();\n            long pos=start;\n            for(int i=0;i&lt;100;++i){\n                long lastOne=pos+step;\n                if(lastOne&gt;end)lastOne=end;\n                p38 subTask=new p38(pos,lastOne);\n                pos+=step+1;\n                subTasks.add(subTask);\n                //使用fork提交子任务\n                subTask.fork();\n            }\n            //所有子任务结束后,再次求和\n            for(p38 t:subTasks){\n                sum+=t.join();\n            }\n        }\n        return sum;\n    }\n\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        ForkJoinPool forkjoinpool=new ForkJoinPool();\n        p38 task=new p38(0,200000L);\n        ForkJoinTask&lt;Long&gt; result=forkjoinpool.submit(task);\n        try{\n            long res=result.get();\n            System.out.println(&quot;sum=&quot;+res);\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n}</code></pre><h4><span id=\"什么时候要加锁\">什么时候要加锁?</span></h4><p>如果只是读操作，没有写操作，则可以不用加锁，此种情形下，变量加上final关键字； 如果有写操作，但是变量的写操作跟当前的值无关联，且与其他的变量也无关联，则可考虑变量加上volatile关键字，同时写操作方法通过synchronized加锁； 如果有写操作，且写操作依赖变量的当前值(如：i++)，则getXXX和写操作方法都要通过synchronized加锁。 线程池是自带锁的.</p>\n<h3><span id=\"jdk-并发容器\">JDK 并发容器</span></h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0096034273dcb98f075add481ae7e975.png\" alt> <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/a783c28c5e7b94a1fe4171318ae14cf4.png\" alt> Tip: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/2dda3fce55b9b7aac0ae9da17b57d594.png\" alt> 这点有点迷:P128 其中CopyOnWrite是高效的读取,在这个容器中,写入不会阻塞读取.</p>\n<h4><span id=\"跳表\">跳表</span></h4><p>跳表是一种可以快速查找的数据结构,它有点类似于平衡树,它只需要部分锁即可,而跳表的时间复杂度也是O(log n) 更多的数据结构可以见线程那个包 Done</p>\n","text":"JDK并发包多线程间的团队协作: 同步控制比如之前的synchronized关键字就是一种最简单的控制方法.它决定了一个线程是否可以访问临界资源区. 还有wait和notify.synchronized的功能扩展: 重入锁重入锁可以完全替代synchronized关键字. 重入锁","link":"","raw":null,"photos":[],"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"}]}]}