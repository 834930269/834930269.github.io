{"name":"Spring","slug":"Spring","count":6,"postlist":[{"title":"Bean的装配","slug":"bean","date":"2019-01-25T03:09:02.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/bean.json","excerpt":"","keywords":null,"cover":null,"content":"<p>对于Bean的获取,完全可以通过Ioc容器来获取.但是这样产生的问题即代码复用率过高.所以使用其他更方便获取Bean的装配方式就显得格外重要.</p>\n<h1 id=\"基于注解的装配方式\"><a href=\"#基于注解的装配方式\" class=\"headerlink\" title=\"基于注解的装配方式\"></a>基于注解的装配方式</h1><h2 id=\"Spring-context-xml配置\"><a href=\"#Spring-context-xml配置\" class=\"headerlink\" title=\"Spring-context.xml配置\"></a>Spring-context.xml配置</h2><blockquote>\n<p>为了告诉Spring你要用这种注解:</p>\n</blockquote>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd \n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n&quot;&gt;\n\n    &lt;context:annotation-config /&gt;\n    &lt;context:component-scan base-package=&quot;com.funtl.leeshop&quot;/&gt;\n&lt;/beans&gt;</code></pre><h2 id=\"注解类型\"><a href=\"#注解类型\" class=\"headerlink\" title=\"注解类型\"></a>注解类型</h2><p>注解</p>\n<p>作用</p>\n<p>@Component(value=”name”)</p>\n<p>类上,value属性用于指定类的id</p>\n<p>@Repository</p>\n<p>用于对DAO实现类进行注解</p>\n<p>@Service</p>\n<p>用于对 Service 实现类进行注解</p>\n<p>@Controller</p>\n<p>用于对 Controller 实现类进行注解</p>\n<p>@Scope</p>\n<p>需要在<code>类</code>上使用注解 @Scope，其 value 属性用于指定作用域。默认为 singleton。</p>\n<p>@Value</p>\n<p>需要在<code>属性</code>上使用注解 @Value，该注解的 value 属性用于指定要注入的值。</p>\n<p>@Autowired</p>\n<p>需要在<code>域属性</code>上使用注解 @Autowired，该注解默认使用 按类型自动装配 Bean 的方式。</p>\n<p>@Resource</p>\n<p>需要在<code>域属性</code>上使用注解 @Resource，该注解有一个 name 属性，可以创建指定的 bean</p>\n<p>@PostConstruct</p>\n<p>在方法上使用 @PostConstruct 相当于初始化</p>\n<h1 id=\"XML配置\"><a href=\"#XML配置\" class=\"headerlink\" title=\"XML配置\"></a>XML配置</h1><blockquote>\n<p>之前讲过,用标签</p>\n<blockquote>\n<p>就自动添加到IoC容器中了.</p>\n</blockquote>\n</blockquote>\n","text":"对于Bean的获取,完全可以通过Ioc容器来获取.但是这样产生的问题即代码复用率过高.所以使用其他更方便获取Bean的装配方式就显得格外重要.基于注解的装配方式Spring-context.xml配置为了告诉Spring你要用这种注解:&lt;?xml version=&quot","link":"","raw":null,"photos":[],"categories":[{"name":"Spring","slug":"Spring","count":4,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}]},{"title":"Spring 注解 @ModelAttribute","slug":"spring-annotation-modelattribute","date":"2019-02-05T09:25:30.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-annotation-modelattribute.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Spring-MVC-表单标签库\"><a href=\"#Spring-MVC-表单标签库\" class=\"headerlink\" title=\"Spring MVC 表单标签库\"></a>Spring MVC 表单标签库</h1><p><a href=\"http://www.funtl.com/zh/spring-mvc/Spring-MVC-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E5%BA%93.html#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%EF%BC%88%E5%A4%9A%E9%80%89%EF%BC%89\" target=\"_blank\" rel=\"noopener\">http://www.funtl.com/zh/spring-mvc/Spring-MVC-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E5%BA%93.html#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%EF%BC%88%E5%A4%9A%E9%80%89%EF%BC%89</a></p>\n<h1 id=\"JQuery-Validation-Bootstrap-前端验证\"><a href=\"#JQuery-Validation-Bootstrap-前端验证\" class=\"headerlink\" title=\"JQuery Validation+Bootstrap(前端验证)\"></a>JQuery Validation+Bootstrap(前端验证)</h1><p><a href=\"http://www.funtl.com/zh/supplement1/jQuery-Validation.html#%E9%A1%B5%E9%9D%A2%E5%BC%95%E7%94%A8\" target=\"_blank\" rel=\"noopener\">http://www.funtl.com/zh/supplement1/jQuery-Validation.html#%E9%A1%B5%E9%9D%A2%E5%BC%95%E7%94%A8</a></p>\n<h1 id=\"JQuery-iCheck-Bootstrap-前端复选框\"><a href=\"#JQuery-iCheck-Bootstrap-前端复选框\" class=\"headerlink\" title=\"JQuery iCheck+Bootstrap(前端复选框)\"></a>JQuery iCheck+Bootstrap(前端复选框)</h1><p><a href=\"http://www.funtl.com/zh/supplement1/jQuery-iCheck.html#%E6%BF%80%E6%B4%BB-icheck\" target=\"_blank\" rel=\"noopener\">http://www.funtl.com/zh/supplement1/jQuery-iCheck.html#%E6%BF%80%E6%B4%BB-icheck</a></p>\n<h1 id=\"什么是-ModelAttribute\"><a href=\"#什么是-ModelAttribute\" class=\"headerlink\" title=\"什么是 @ModelAttribute?\"></a>什么是 @ModelAttribute?</h1><ul>\n<li>绑定请求参数到命令对象：放在功能处理方法的入参上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用</li>\n<li>暴露 @RequestMapping 方法返回值为模型数据：放在功能处理方法的返回值上时，是暴露功能处理方法的返回值为模型数据，用于视图页面展示时使用</li>\n<li>暴露表单引用对象为模型数据：放在处理器的一般方法（非功能处理方法）上时，是为表单准备要展示的表单引用对象，如注册时需要选择的所在城市等，而且在执行功能处理方法（@RequestMapping 注解的方法）之前，自动添加到模型对象中，用于视图页面展示时使用</li>\n</ul>\n<blockquote>\n<p>即简化AOP编程,不使用拦截器在同一Controller下直接进行拦截或者预处理,其属性会继承给每一个RequestMapping的视图层.</p>\n</blockquote>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><pre><code>package com.funtl.my.shop.web.admin.web.controller;\n\nimport com.funtl.my.shop.commons.dto.BaseResult;\nimport com.funtl.my.shop.domain.TbUser;\nimport com.funtl.my.shop.web.admin.service.TbUserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport java.util.List;\n\n@Controller\n@RequestMapping(value=&quot;user&quot;)\npublic class UserController {\n    @Autowired\n    private TbUserService tbUserService;\n\n    @ModelAttribute\n    public TbUser getTbUser(Long id){\n        TbUser tbUser=null;\n        if(id!=null){\n            tbUser=tbUserService.getById(id);\n        }\n\n        else{\n            tbUser=new TbUser();\n        }\n        return tbUser;\n    }\n\n\n    /**\n     * 跳转到用户列表页\n     * @param model\n     * @return\n     */\n    @RequestMapping(value=&quot;list&quot;,method= RequestMethod.GET)\n    public String list(Model model){\n        List&lt;TbUser&gt; tbUsers=tbUserService.selectAll();\n        model.addAttribute(&quot;tbUsers&quot;,tbUsers);\n        return &quot;user_list&quot;;\n    }\n\n    @RequestMapping(value=&quot;form&quot;,method=RequestMethod.GET)\n    public String form(){\n        return &quot;user_form&quot;;\n    }\n\n    @RequestMapping(value=&quot;save&quot;,method=RequestMethod.POST)\n    public String save(TbUser tbUser, Model model,RedirectAttributes redirectAttributes){\n        BaseResult baseResult=tbUserService.save(tbUser);\n        //保存成功\n        if(baseResult.getStatus()==200){\n            redirectAttributes.addFlashAttribute(&quot;baseResult&quot;,baseResult);\n            return &quot;redirect:/user/list&quot;;\n        }\n        //保存失败\n        else{\n            model.addAttribute(&quot;baseResult&quot;,baseResult);\n            return &quot;user_form&quot;;\n        }\n    }\n}</code></pre><blockquote>\n<p>这样操作过后可以很轻松的将 预处理的TbUser绑定到Model上.</p>\n</blockquote>\n","text":"Spring MVC 表单标签库http://www.funtl.com/zh/spring-mvc/Spring-MVC-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E5%BA%93.html#%E5%8D%95%E9%80%89%E6%8C%89","link":"","raw":null,"photos":[],"categories":[{"name":"Spring","slug":"Spring","count":4,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}]},{"title":"Spring 黏合 Mybatis (已整合druid前提下)","slug":"spring-cohesive-mybatis","date":"2019-02-04T02:20:51.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-cohesive-mybatis.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"前提-已经创建好了druid\"><a href=\"#前提-已经创建好了druid\" class=\"headerlink\" title=\"前提,已经创建好了druid\"></a>前提,已经创建好了druid</h1><blockquote>\n<p>且druid的id为datasource,作为mybatis的数据源</p>\n</blockquote>\n<h1 id=\"Document\"><a href=\"#Document\" class=\"headerlink\" title=\"Document\"></a>Document</h1><p><a href=\"http://www.mybatis.org/mybatis-3/zh/index.html\" target=\"_blank\" rel=\"noopener\">http://www.mybatis.org/mybatis-3/zh/index.html</a></p>\n<h1 id=\"创建-mybatis-config-xml\"><a href=\"#创建-mybatis-config-xml\" class=\"headerlink\" title=\"创建 mybatis-config.xml\"></a>创建 mybatis-config.xml</h1><blockquote>\n<p>因为已经整合过了druid,所以数据源为datasource,即不用再设置连接数据库等操作,直接从连接池druid中取出即可.</p>\n<blockquote>\n<p>只需要配置几个setting属性</p>\n</blockquote>\n</blockquote>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;!-- 全局参数 --&gt;\n    &lt;settings&gt;\n        &lt;!-- 打印 SQL 语句 --&gt;\n        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;\n\n        &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;\n        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;\n\n        &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;\n        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;\n        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;\n        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;\n\n        &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;\n        &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;\n\n        &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;\n        &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;\n\n        &lt;!-- 使用驼峰命名法转换字段。 --&gt;\n        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;\n\n        &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;\n        &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;\n\n        &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;\n        &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;</code></pre><h1 id=\"创建-spring-context-mybatis-xml\"><a href=\"#创建-spring-context-mybatis-xml\" class=\"headerlink\" title=\"创建 spring-context-mybatis.xml\"></a>创建 spring-context-mybatis.xml</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n    &lt;!-- 配置 SqlSession --&gt;\n    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n        &lt;!-- 用于配置对应实体类所在的包，多个 package 之间可以用 &apos;,&apos; 号分割 --&gt;\n        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.funtl.my.shop.domain&quot;/&gt;\n        &lt;!-- 用于配置对象关系映射配置文件所在目录 --&gt;\n        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:/mapper/**/*.xml&quot;/&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:/mybatis-config.xml&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 扫描 Mapper --&gt;\n    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n        &lt;property name=&quot;basePackage&quot; value=&quot;com.funtl.my.shop.web.admin.dao&quot; /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><h1 id=\"然后\"><a href=\"#然后\" class=\"headerlink\" title=\"然后\"></a>然后</h1><blockquote>\n<p>只需要创建Dao接口即可,SQL语句放在Mapper中,Service中调用接口即可. 其中关于mapper.xml的标签和OOP原则都在最上面Document中可以查到.</p>\n</blockquote>\n","text":"前提,已经创建好了druid且druid的id为datasource,作为mybatis的数据源Documenthttp://www.mybatis.org/mybatis-3/zh/index.html创建 mybatis-config.xml因为已经整合过了druid,所以数","link":"","raw":null,"photos":[],"categories":[{"name":"MyBatis","slug":"MyBatis","count":2,"path":"api/categories/MyBatis.json"},{"name":"Spring","slug":"MyBatis/Spring","count":1,"path":"api/categories/MyBatis/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"},{"name":"MyBatis","slug":"MyBatis","count":2,"path":"api/tags/MyBatis.json"}]},{"title":"使用Spring(胶水框架)粘贴druid","slug":"spring-druid","date":"2019-02-03T09:40:59.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-druid.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2019/02/QQ%E6%88%AA%E5%9B%BE20190203175906.png","content":"<h1 id=\"完善druid所需配置-myshop-properties\"><a href=\"#完善druid所需配置-myshop-properties\" class=\"headerlink\" title=\"完善druid所需配置 myshop.properties\"></a>完善druid所需配置 myshop.properties</h1><pre><code>#============================#\n#==== Database settings ====#\n#============================#\n# JDBC\n# MySQL 8.x: com.mysql.cj.jdbc.Driver\njdbc.driverClass=com.mysql.jdbc.Driver\njdbc.connectionURL=jdbc:mysql://127.0.0.1:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\njdbc.username=你的用户\njdbc.password=你的密码\n\n# JDBC Pool\n# 初始化池的数量\njdbc.pool.init=1\n# 最小数量\njdbc.pool.minIdle=3\n# 最大可活动数量\njdbc.pool.maxActive=20\n\n# JDBC Test\njdbc.testSql=SELECT &apos;x&apos; FROM DUAL</code></pre><h1 id=\"建立-spring-context-druid-xml\"><a href=\"#建立-spring-context-druid-xml\" class=\"headerlink\" title=\"建立 spring-context-druid.xml\"></a>建立 spring-context-druid.xml</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;!-- 加载配置属性文件 --&gt;\n    &lt;context:property-placeholder ignore-unresolvable=&quot;true&quot; location=&quot;classpath:myshop.properties&quot;/&gt;\n\n    &lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt;\n    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClass}&quot;/&gt;\n\n        &lt;!-- 基本属性 url、user、password --&gt;\n        &lt;property name=&quot;url&quot; value=&quot;${jdbc.connectionURL}&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;\n\n        &lt;!-- 配置初始化大小、最小、最大 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;${jdbc.pool.init}&quot;/&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;${jdbc.pool.minIdle}&quot;/&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;${jdbc.pool.maxActive}&quot;/&gt;\n\n        &lt;!-- 配置获取连接等待超时的时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;/&gt;\n\n        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;\n        &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot;/&gt;\n\n        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;\n        &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot;/&gt;\n\n        &lt;property name=&quot;validationQuery&quot; value=&quot;${jdbc.testSql}&quot;/&gt;\n        &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt;\n        &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt;\n        &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt;\n\n        &lt;!-- 配置监控统计拦截的filters --&gt;\n        &lt;property name=&quot;filters&quot; value=&quot;stat&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><h2 id=\"加载配置属性文件-properties\"><a href=\"#加载配置属性文件-properties\" class=\"headerlink\" title=\"加载配置属性文件(.properties)\"></a>加载配置属性文件(.properties)</h2><blockquote>\n<p>context:property-placeholder</p>\n<blockquote>\n<p>属性:location=classpath:属性文件名字.properties</p>\n</blockquote>\n</blockquote>\n<h2 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h2><blockquote>\n<p>在这里开始配置druid,指定数据源时</p>\n<blockquote>\n<p>id=”dataSource” spring-context-*.xml叫做同级别配置</p>\n</blockquote>\n<p>init-method:规定初始化方法 destory-method:规定销毁方法 然后用property标签填充属性</p>\n</blockquote>\n<h2 id=\"druid属性集\"><a href=\"#druid属性集\" class=\"headerlink\" title=\"druid属性集\"></a>druid属性集</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/02/QQ%E6%88%AA%E5%9B%BE20190203175906.png\" alt></p>\n<h1 id=\"然后在web-xml中修改context-xml的引用方式为\"><a href=\"#然后在web-xml中修改context-xml的引用方式为\" class=\"headerlink\" title=\"然后在web.xml中修改context.xml的引用方式为*\"></a>然后在web.xml中修改context.xml的引用方式为*</h1><pre><code>&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;classpath:spring-context*.xml&lt;/param-value&gt;\n&lt;/context-param&gt;</code></pre><h1 id=\"开启druid监控中心\"><a href=\"#开启druid监控中心\" class=\"headerlink\" title=\"开启druid监控中心\"></a>开启druid监控中心</h1><blockquote>\n<p>将以下配置粘贴到web.xml中</p>\n</blockquote>\n<pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;</code></pre><h1 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done\"></a>done</h1><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/02/QQ%E6%88%AA%E5%9B%BE20190203182905.png\" alt></p>\n","text":"完善druid所需配置 myshop.properties#============================##==== Database settings ====##============================## JDBC# MySQL 8.x: com","link":"","raw":null,"photos":[],"categories":[{"name":"Spring","slug":"Spring","count":4,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}]},{"title":"基础概念、项目结构和配置","slug":"spring","date":"2019-01-18T11:03:03.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/spring.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2019/01/%E6%8D%95%E8%8E%B72.png","content":"<h1 id=\"1-实现简单三层架构单体应用-登入\"><a href=\"#1-实现简单三层架构单体应用-登入\" class=\"headerlink\" title=\"1 - 实现简单三层架构单体应用(登入)\"></a>1 - 实现简单三层架构单体应用(登入)</h1><h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/%E6%8D%95%E8%8E%B72.png\" alt></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><blockquote>\n<p>不使用新建项目,而采用单独新建文件夹架构项目的方式.</p>\n</blockquote>\n<ol>\n<li>Mark Directory <code>src/main/java</code> as Sources Root</li>\n<li>Mark Directory <code>src/main/resources</code> as Resources Root</li>\n<li>将webapp设置为web目录</li>\n</ol>\n<h2 id=\"宏观流程\"><a href=\"#宏观流程\" class=\"headerlink\" title=\"宏观流程\"></a>宏观流程</h2><blockquote>\n<p>即不深入运行过程,仅从简单逻辑层面来判断.</p>\n</blockquote>\n<p>document.write(“graph TD\\nA[客户端请求] –&gt;|请求到达| B(Controller中 Get/Post处理方法)\\nB –&gt; C(ServiceImpl - extends Service)\\nC –&gt; D(DaoImpl - extends Dao)\\nD –&gt; E(Model实体)\\n”);</p>\n<h2 id=\"xml配置以及基本框架\"><a href=\"#xml配置以及基本框架\" class=\"headerlink\" title=\"xml配置以及基本框架\"></a>xml配置以及基本框架</h2><blockquote>\n<p>对于servlet的配置</p>\n<blockquote>\n<p>WEB-INF下web.xml -&gt; 将Controller映射到某一个Uri上</p>\n</blockquote>\n<p>pom.xml</p>\n<blockquote>\n<p>Maven配置依赖项</p>\n</blockquote>\n<p>spring-context.xml</p>\n<blockquote>\n<p>控制反转,将bean交给SpringIoC容器</p>\n</blockquote>\n</blockquote>\n<h3 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n         version=&quot;4.0&quot;&gt;\n&lt;/web-app&gt;</code></pre><h3 id=\"pom-xml\"><a href=\"#pom-xml\" class=\"headerlink\" title=\"pom.xml\"></a>pom.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-demo&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.12&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;1.7.25&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;</code></pre><h3 id=\"spring-context-xml\"><a href=\"#spring-context-xml\" class=\"headerlink\" title=\"spring-context.xml\"></a>spring-context.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n&lt;/beans&gt;</code></pre><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><a href=\"https://github.com/834930269/Spring_demo/tree/master/demo/login-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/834930269/Spring_demo/tree/master/demo/login-demo</a></p>\n<hr>\n<h1 id=\"2-理解依赖注入和控制反转\"><a href=\"#2-理解依赖注入和控制反转\" class=\"headerlink\" title=\"2 - 理解依赖注入和控制反转\"></a>2 - 理解依赖注入和控制反转</h1><h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/SPRING-DEMO.png\" alt> Tip: 如果文件名显示,而没有任何错误，大抵是开了版本控制,比如Git.在.idea的vcs.xml文件中将git删掉即可</p>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>DI: Dependency injection From Spring实战(第四版) P5</p>\n<blockquote>\n<p>背景: 任何一个实际意义的应用,都会由两个或者更多的类组成.这些类相互协作形成应用.</p>\n<blockquote>\n<p>这样子导致的直接结果是耦合度过高.</p>\n</blockquote>\n<p>DI: 为了解决这一问题,Spring提供了依赖注入这一解决方案.</p>\n</blockquote>\n<h3 id=\"什么叫依赖注入\"><a href=\"#什么叫依赖注入\" class=\"headerlink\" title=\"什么叫依赖注入?\"></a>什么叫依赖注入?</h3><p>举个栗子: 我们想要实现骑士探险这一类,可以自由的为骑士选择探险任务. Knight.java</p>\n<pre><code>package DI;\n\npublic interface Knights {\n    public void embarkOnQuest();\n}</code></pre><p>探险任务</p>\n<pre><code>package DI;\n\npublic class RescueDamselQuest {\n    public void embark(){\n        System.out.println(&quot;已接收&quot;);\n    }\n}</code></pre><p>骑士接受任务</p>\n<pre><code>package DI;\n\npublic class DamselRescuingKnight implements Knights {\n    private RescueDamselQuest quest;\n\n    public DamselRescuingKnight() {\n        quest=new RescueDamselQuest();\n    }\n\n    @Override\n    public void embarkOnQuest() {\n        quest.embark();\n    }\n}</code></pre><p>我们会发现这样写代码使得探险和骑士的耦合度达到了密不可分的地步,写一个探险就要新建一个结合类. 改进措施,提出了依赖注入:</p>\n<blockquote>\n<p>构造器注入</p>\n<blockquote>\n<p>这个比较简单,即将探险类作为构造参数传递进来,但这样依然没有达到代码层面的解耦.</p>\n</blockquote>\n</blockquote>\n<pre><code>public class DamselRescuingKnight implements Knights {\n    private RescueDamselQuest quest;\n\n    public DamselRescuingKnight(Quest quest) {\n        this.quest=quest;\n    }\n\n    @Override\n    public void embarkOnQuest() {\n        quest.embark();\n    }\n}</code></pre><blockquote>\n<p>mock注入</p>\n<blockquote>\n<p>和Spring的依赖注入很像.</p>\n</blockquote>\n</blockquote>\n<h3 id=\"Spring的依赖注入\"><a href=\"#Spring的依赖注入\" class=\"headerlink\" title=\"Spring的依赖注入\"></a>Spring的依赖注入</h3><blockquote>\n<p>接上本小节一开始的那张项目结构图.</p>\n</blockquote>\n<p>Spring是这样做的.你将需要解耦的类交给Spring的容器去保管,需要使用时直接从Spring中取出来即可,而不需要有任何new出来的类.</p>\n<blockquote>\n<p>比如Service,Bean等,都可以交给Spring保管.</p>\n</blockquote>\n<p>举个栗子: UserService.java(接口)</p>\n<pre><code>package com.funtl.spring.service;\n\npublic interface UserService {\n    public void sayhi();\n}</code></pre><p>UserServiceImpl.java</p>\n<pre><code>package com.funtl.spring.service.impl;\n\nimport com.funtl.spring.service.UserService;\n\npublic class UserServiceImpl implements UserService {\n    public void sayhi() {\n        System.out.println(&quot;hello&quot;);\n    }\n}</code></pre><p>resources/spring-context.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;userService&quot; class=&quot;com.funtl.spring.service.impl.UserServiceImpl&quot; /&gt;\n&lt;/beans&gt;</code></pre><p>OK,前序工作做完了,我们在运行时就已经将这个类托管给了Spring容器. 那么我们该如何取出来呢? MyTest.java</p>\n<pre><code>package com.funtl.spring;\n\nimport com.funtl.spring.service.UserService;\nimport com.funtl.spring.service.impl.UserServiceImpl;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args){\n        //获取Spring容器\n        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);\n\n        //从Spring容器中获取对象\n        UserService userService= (UserService) applicationContext.getBean(&quot;userService&quot;);\n        userService.sayhi();\n\n    }\n}</code></pre><p>我们可以看到,上面的代码并没有new一个Service,而是从Spring上下文中取出了userService这个对象. 仔细想想,这样是不是就类似于调用静态的工具类那样轻松了呢?</p>\n<blockquote>\n<p>依赖注入的魅力就在于此.</p>\n<blockquote>\n<p>而将类的加载交给容器时,这个容器的模式就叫做 IoC(控制反转)</p>\n</blockquote>\n</blockquote>\n<h1 id=\"最终架构\"><a href=\"#最终架构\" class=\"headerlink\" title=\"最终架构\"></a>最终架构</h1><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2019/01/%E6%8D%95%E8%8E%B73.png\" alt></p>\n","text":"1 - 实现简单三层架构单体应用(登入)项目架构 [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"Spring","slug":"Spring","count":4,"path":"api/categories/Spring.json"},{"name":"随笔","slug":"Spring/随笔","count":1,"path":"api/categories/Spring/随笔.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"}]},{"title":"Spring Validation-Spring后台验证框架","slug":"spring-validation-spring","date":"2019-02-09T15:34:46.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/spring-validation-spring.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"JSR-303简介\"><a href=\"#JSR-303简介\" class=\"headerlink\" title=\"JSR-303简介\"></a>JSR-303简介</h1><p>JSR-303 是 JavaEE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator。 此实现与 Hibernate ORM 没有任何关系。JSR-303 用于对 Java Bean 中的字段的值进行验证。 Spring MVC 3.x 之中也大力支持 JSR-303，可以在控制器中使用注解的方式对表单提交的数据方便地验证。 Spring 4.0 开始支持 Bean Validation 功能。</p>\n<h1 id=\"JSR-303-基本的校验规则\"><a href=\"#JSR-303-基本的校验规则\" class=\"headerlink\" title=\"JSR-303 基本的校验规则\"></a>JSR-303 基本的校验规则</h1><p>注解</p>\n<p>作用</p>\n<p>@Null</p>\n<p>验证对象是否为 null</p>\n<p>@NotNull</p>\n<p>验证对象是否不为 null, 无法查检长度为 0 的字符串</p>\n<p>@NotBlank</p>\n<p>检查约束字符串是不是 Null 还有被 Trim 的长度是否大于 0,只对字符串,且会去掉前后空格</p>\n<p>@NotEmpty</p>\n<p>检查约束元素是否为 NULL 或者是 EMPTY</p>\n<p>@AssertTrue</p>\n<p>验证 Boolean 对象是否为 true</p>\n<p>@AssertFalse</p>\n<p>验证 Boolean 对象是否为 false</p>\n<p>@Size(min=, max=)</p>\n<p>验证对象（Array, Collection , Map, String）长度是否在给定的范围之内</p>\n<p>@Length(min=, max=)</p>\n<p>验证字符串长度介于 min 和 max 之间</p>\n<p>@Past</p>\n<p>验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期</p>\n<p>@Future</p>\n<p>验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期</p>\n<p>@Pattern</p>\n<p>验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式</p>\n<p>@Min</p>\n<p>验证 Number 和 String 对象是否大等于指定的值</p>\n<p>@Max</p>\n<p>验证 Number 和 String 对象是否小等于指定的值</p>\n<p>@DecimalMax</p>\n<p>被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过 BigDecimal 定义的最大值的字符串表示 .小数 存在精度</p>\n<p>@DecimalMin</p>\n<p>被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过 BigDecimal 定义的最小值的字符串表示 .小数 存在精度</p>\n<p>@Digits</p>\n<p>验证 Number 和 String 的构成是否合法</p>\n<p>@Digits(integer=,fraction=)</p>\n<p>验证字符串是否是符合指定格式的数字，integer 指定整数精度，fraction 指定小数精度</p>\n<p>@Range(min=, max=)</p>\n<p>被指定的元素必须在合适的范围内@Range(min=10000,max=50000,message=”range.bean.wage”)</p>\n<p>@Valid</p>\n<p>递归的对关联对象进行校验, 如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个 map，则对其中的值部分进行校验.(是否进行递归验证)</p>\n<p>@CreditCardNumber</p>\n<p>信用卡验证</p>\n<p>@Email</p>\n<p>验证是否是邮件地址，如果为 null，不进行验证，算通过验证</p>\n<h1 id=\"粘贴到Spring上\"><a href=\"#粘贴到Spring上\" class=\"headerlink\" title=\"粘贴到Spring上\"></a>粘贴到Spring上</h1><h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n    &lt;version&gt;5.3.4.Final&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><h2 id=\"定义验证工具类\"><a href=\"#定义验证工具类\" class=\"headerlink\" title=\"定义验证工具类\"></a>定义验证工具类</h2><blockquote>\n<p>把所有类型的异常都转换为List&lt;&gt;型异常,然后在出口函数除捕捉异常并打印出来.调用validation的方法即直接调用.</p>\n</blockquote>\n<pre><code>import org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.validation.ConstraintViolation;\nimport javax.validation.ConstraintViolationException;\nimport javax.validation.Validator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * JSR303 Validator(Hibernate Validator)工具类.\n * &lt;p&gt;\n * ConstraintViolation 中包含 propertyPath, message 和 invalidValue 等信息.\n * 提供了各种 convert 方法，适合不同的 i18n 需求:\n * 1. List&lt;String&gt;, String 内容为 message\n * 2. List&lt;String&gt;, String 内容为 propertyPath + separator + message\n * 3. Map&lt;propertyPath, message&gt;\n * &lt;p&gt;\n * 详情见wiki: https://github.com/springside/springside4/wiki/HibernateValidator\n *\n * &lt;p&gt;Title: BeanValidator&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/26 17:21\n */\npublic class BeanValidator {\n\n    @Autowired\n    private static Validator validator;\n\n    public static void setValidator(Validator validator) {\n        BeanValidator.validator = validator;\n    }\n\n    /**\n     * 调用 JSR303 的 validate 方法, 验证失败时抛出 ConstraintViolationException.\n     */\n    private static void validateWithException(Validator validator, Object object, Class&lt;?&gt;... groups) throws ConstraintViolationException {\n        Set constraintViolations = validator.validate(object, groups);\n        if (!constraintViolations.isEmpty()) {\n            throw new ConstraintViolationException(constraintViolations);\n        }\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 中为 List&lt;message&gt;.\n     */\n    private static List&lt;String&gt; extractMessage(ConstraintViolationException e) {\n        return extractMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 List&lt;message&gt;\n     */\n    private static List&lt;String&gt; extractMessage(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        List&lt;String&gt; errorMessages = new ArrayList&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 Map&lt;property, message&gt;.\n     */\n    private static Map&lt;String, String&gt; extractPropertyAndMessage(ConstraintViolationException e) {\n        return extractPropertyAndMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 Map&lt;property, message&gt;.\n     */\n    private static Map&lt;String, String&gt; extractPropertyAndMessage(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        Map&lt;String, String&gt; errorMessages = new HashMap&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.put(violation.getPropertyPath().toString(), violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(ConstraintViolationException e) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), &quot; &quot;);\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(Set&lt;? extends ConstraintViolation&gt; constraintViolations) {\n        return extractPropertyAndMessageAsList(constraintViolations, &quot; &quot;);\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set&lt;ConstraintViolations&gt; 为 List&lt;propertyPath + separator + message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(ConstraintViolationException e, String separator) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), separator);\n    }\n\n    /**\n     * 辅助方法, 转换 Set&lt;ConstraintViolation&gt; 为 List&lt;propertyPath + separator + message&gt;.\n     */\n    private static List&lt;String&gt; extractPropertyAndMessageAsList(Set&lt;? extends ConstraintViolation&gt; constraintViolations, String separator) {\n        List&lt;String&gt; errorMessages = new ArrayList&lt;&gt;();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getPropertyPath() + separator + violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 服务端参数有效性验证\n     *\n     * @param object 验证的实体对象\n     * @param groups 验证组\n     * @return 验证成功：返回 null；验证失败：返回错误信息\n     */\n    public static String validator(Object object, Class&lt;?&gt;... groups) {\n        try {\n            validateWithException(validator, object, groups);\n        } catch (ConstraintViolationException ex) {\n            List&lt;String&gt; list = extractMessage(ex);\n            list.add(0, &quot;数据验证失败：&quot;);\n\n            // 封装错误消息为字符串\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i &lt; list.size(); i++) {\n                String exMsg = list.get(i);\n                if (i != 0 ){\n                    sb.append(String.format(&quot;%s. %s&quot;, i, exMsg)).append(list.size() &gt; 1 ? &quot;&lt;br/&gt;&quot; : &quot;&quot;);\n                } else {\n                    sb.append(exMsg).append(list.size() &gt; 1 ? &quot;&lt;br/&gt;&quot; : &quot;&quot;);\n                }\n            }\n\n            return sb.toString();\n        }\n\n        return null;\n    }\n}</code></pre><h2 id=\"为实体类添加注解\"><a href=\"#为实体类添加注解\" class=\"headerlink\" title=\"为实体类添加注解\"></a>为实体类添加注解</h2><p>(domain,model,Entity)</p>\n<pre><code>@Length(min = 6, max = 20, message = &quot;用户名长度必须介于 6 和 20 之间&quot;)\nprivate String username;\n@Length(min = 6, max = 20, message = &quot;密码长度必须介于 6 和 20 之间&quot;)\nprivate String password;\n@Pattern(regexp = RegexpUtils.PHONE, message = &quot;手机号格式不正确&quot;)\nprivate String phone;\n@Pattern(regexp = RegexpUtils.EMAIL, message = &quot;邮箱格式不正确&quot;)\nprivate String email;</code></pre><h2 id=\"注入工具类\"><a href=\"#注入工具类\" class=\"headerlink\" title=\"注入工具类\"></a>注入工具类</h2><blockquote>\n<p>因为在工具类中,static修饰的对象,无法直接注入,所以需要手工注入</p>\n</blockquote>\n<h3 id=\"直接注入\"><a href=\"#直接注入\" class=\"headerlink\" title=\"直接注入\"></a>直接注入</h3><pre><code>&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;/&gt;</code></pre><h3 id=\"手工注入\"><a href=\"#手工注入\" class=\"headerlink\" title=\"手工注入\"></a>手工注入</h3><blockquote>\n<p>两个都必须有</p>\n</blockquote>\n<pre><code>&lt;!-- 配置 Bean Validator 定义 --&gt;\n&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;/&gt;\n&lt;bean id=&quot;beanValidator&quot; class=&quot;com.funtl.my.shop.commons.validator.BeanValidator&quot;&gt;\n    &lt;property name=&quot;validator&quot; ref=&quot;validator&quot; /&gt;\n&lt;/bean&gt;</code></pre>","text":"JSR-303简介JSR-303 是 JavaEE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator。 此实现与 Hibernate ORM 没有任何关系。JSR-303 用于对 Java Bean 中的字段的值进行","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"Spring","slug":"Java/Spring","count":1,"path":"api/categories/Java/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"},{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]}]}