{"name":"KMP","slug":"KMP","count":3,"postlist":[{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） C KMP-Next数组","slug":"5-c-kmp","date":"2018-02-27T12:23:59.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/5-c-kmp.json","excerpt":"","keywords":null,"cover":null,"content":"<p>[toc]</p>\n<blockquote>\n<p>Next数组</p>\n</blockquote>\n<h1 id=\"自己写的卡在-95-00的代码\"><a href=\"#自己写的卡在-95-00的代码\" class=\"headerlink\" title=\"自己写的卡在%95.00的代码\"></a>自己写的卡在%95.00的代码</h1><p>我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nmap&lt;int,int&gt; ex;\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=1;i&lt;=len;++i){\n        printf(&quot;%d &quot;,Next[i]);\n    }\n}\n\nvoid solve(){\n    ex.clear();\n    getNext();\n    //print();\n    int bef=Next[len],now,max_len=0;\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    while(bef!=0){\n        now=bef;\n        bef=Next[bef];\n    }\n\n    for(int i=1;i&lt;=len;++i){\n        if(Next[i] &amp;&amp; Next[i]%now==0){\n            int k=Next[i]/now;\n            for(int j=1;j&lt;=k;++j){\n                ex[j*now]++;\n            }\n        }\n    }\n    map&lt;int,int&gt;::iterator it;\n    for(it=ex.begin();it!=ex.end();it++){\n        if(it-&gt;second&gt;1) max_len=max(max_len,it-&gt;first);\n    }\n    if(max_len){\n        max_len=min(max_len,Next[len]);\n        for(int i=0;i&lt;max_len;++i){\n            printf(&quot;%c&quot;,str[i]);\n        }\n    }else printf(&quot;Just a legend&quot;);\n    printf(&quot;\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><blockquote>\n<p>AC代码</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nint exist[maxn];\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid solve(){\n    memset(exist,0,sizeof(exist));\n    getNext();\n    int bef=Next[len];\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    //忽略第一个和最后一个\n    for(int i=2;i&lt;len;++i){\n        exist[Next[i]]++;\n    }\n\n    while(bef&gt;0){\n        if(exist[bef]){\n            for(int i=0;i&lt;bef;++i){\n                printf(&quot;%c&quot;,str[i]);\n            }\n            printf(&quot;\\n&quot;);\n            return;\n        }\n        bef=Next[bef];\n    }\n    printf(&quot;Just a legend\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1 id=\"当然-还有一种方法是比较特别的-比较直观-把每个可能子串KMP一下-如果匹配成功了-就直接输出就好了\"><a href=\"#当然-还有一种方法是比较特别的-比较直观-把每个可能子串KMP一下-如果匹配成功了-就直接输出就好了\" class=\"headerlink\" title=\"当然,还有一种方法是比较特别的(比较直观),把每个可能子串KMP一下,如果匹配成功了,就直接输出就好了\"></a>当然,还有一种方法是比较特别的(比较直观),把每个可能子串KMP一下,如果匹配成功了,就直接输出就好了</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nchar a[1000005],b[1000005];\nint next[1000006];\nvoid getnext(char *c)\n{\n    next[0]=next[1]=0;\n    int i,j,len=strlen(c);\n    for(i=1,j=0;i&lt;len;i++)\n    {\n        while(c[i]!=c[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(c[i]==c[j])j++;\n        next[i+1]=j;\n    }\n}\nint kmp(char *o,char *f)\n{\n    int cont=0;\n    int i,j,len1=strlen(o),len2=strlen(f);\n    for(i=0,j=0;i&lt;len1;i++)\n    {\n        while(o[i]!=f[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(o[i]==f[j])j++;\n        if(j==len2)\n        {\n            cont++;\n            j=next[j];\n        }\n    }\n    return cont;\n}\nint main()\n{\n    int i;\n    scanf(&quot;%s&quot;,a);\n    getnext(a);\n    int len=next[strlen(a)];\n    if(len==0)\n    {\n        printf(&quot;Just a legend\\n&quot;);\n        return 0;\n    }\n    for(i=0;i&lt;len;i++)\n        b[i]=a[i];\n    b[i]=&apos;\\0&apos;;\n    int cont=kmp(a,b);\n    while(cont&lt;3)\n    {\n        len=next[len];\n        if(len==0)break;\n        for(i=0;i&lt;len;i++)\n            b[i]=a[i];\n        b[i]=&apos;\\0&apos;;\n        cont=kmp(a,b);\n    }\n    if(cont&gt;=3&amp;&amp;len)printf(&quot;%s\\n&quot;,b);\n    else printf(&quot;Just a legend\\n&quot;);\n    return 0;\n}</code></pre><p>1<br>=</p>\n<p>2<br>=</p>\n","text":"[toc]Next数组自己写的卡在%95.00的代码我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1001000;int Next[max","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"字符串处理","slug":"KMP/字符串处理","count":1,"path":"api/categories/KMP/字符串处理.json"},{"name":"牛客练习赛","slug":"KMP/字符串处理/牛客练习赛","count":1,"path":"api/categories/KMP/字符串处理/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"}]},{"title":"POJ 1961","slug":"poj-1961","date":"2018-02-25T05:26:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-1961.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVALive-3026\" title=\"https://vjudge.net/problem/UVALive-3026\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-3026</a></p>\n<h1 id=\"Type-KMP-Next数组\"><a href=\"#Type-KMP-Next数组\" class=\"headerlink\" title=\"Type: KMP-Next数组\"></a>Type: KMP-Next数组</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><h2 id=\"前置\"><a href=\"#前置\" class=\"headerlink\" title=\"前置\"></a>前置</h2><h3 id=\"关于Next数组\"><a href=\"#关于Next数组\" class=\"headerlink\" title=\"关于Next数组\"></a>关于Next数组</h3><blockquote>\n<p>(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符进行再次匹配. (2) j=Next[k]表示第 j 个字符和第 k 个字符一样. (3) j=Next[k]表示前 j 个字符和后 j 个字符一样</p>\n<blockquote>\n<p>即 1<del>j-1 和 k-j+1</del>k 这两个子串相等</p>\n</blockquote>\n</blockquote>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><blockquote>\n<p>即我们求出该字符串的Next数组后我们可以判断当前 (i-Next[i]) 是否能被 i 整除.</p>\n<blockquote>\n<p>即 i%(i-Next[i]) 是否等于0.</p>\n<blockquote>\n<p>i-Next[i]为该子串的长度,如果可以整除则证明该子串为循环节,循环节长度为 i-Next[i] ,循环次数为 i/(i-Next[i]).</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nchar ts[maxn];\nint n,kase=1;\nint Next[maxn];\nvoid getNext(){\n    int j=0,k=-1;\n    Next[0]=-1;\n    while(j&lt;n){\n        if(k==-1 || ts[j]==ts[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\nvoid print(){\n    for(int i=1;i&lt;=n;++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(!n)break;\n        scanf(&quot;%s&quot;,ts);\n        getNext();\n        //print();\n        printf(&quot;Test case #%d\\n&quot;,kase++);\n        for(int i=2;i&lt;=n;++i){\n            if(Next[i]&lt;=0) continue;\n            if(i%(i-Next[i])==0){\n                printf(&quot;%d %d\\n&quot;,i,i/(i-Next[i]));\n            }\n        }\n        printf(&quot;\\n&quot;);\n        getchar();\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVALive-3026Type: KMP-Next数组题意给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度题解前置关于Next数组(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"LA","slug":"KMP/LA","count":1,"path":"api/categories/KMP/LA.json"},{"name":"POJ","slug":"KMP/LA/POJ","count":1,"path":"api/categories/KMP/LA/POJ.json"},{"name":"字符串处理","slug":"KMP/LA/POJ/字符串处理","count":1,"path":"api/categories/KMP/LA/POJ/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"字符串算法","slug":"charset-algorithm","date":"2018-02-24T10:32:39.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/charset-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png","content":"<h1 id=\"Trie\"><a href=\"#Trie\" class=\"headerlink\" title=\"Trie\"></a>Trie</h1><blockquote>\n<p>这个…不想写了</p>\n</blockquote>\n<h1 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h1><blockquote>\n<p>朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)</p>\n</blockquote>\n<h2 id=\"Next数组\"><a href=\"#Next数组\" class=\"headerlink\" title=\"Next数组\"></a>Next数组</h2><blockquote>\n<p>对于KMP而言最重要的莫过于这个Next数组了.</p>\n<blockquote>\n<p>Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.</p>\n</blockquote>\n<p>构造方法:</p>\n<blockquote>\n<p>Next[i]=max{j | j\\&lt;i 且N[1..j]=N[i-j+1..i]}</p>\n<blockquote>\n<p>即Next[i]球的试串P[1..i]的一个最长的前缀P[1..j],这个前缀同时也是他的后缀。当这个前缀找不到的时候,Next[i]=0</p>\n</blockquote>\n</blockquote>\n<p>例如:</p>\n<blockquote>\n<p>模式串 P = ababc</p>\n<blockquote>\n<p>则Next[4]=2,因为ab不仅是abab的前缀,也是他的后缀. 而Next[5]=0，因为无法找到ababc(P[1..5])的一个前缀同时又是他的后缀.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"附上一张图\"><a href=\"#附上一张图\" class=\"headerlink\" title=\"附上一张图\"></a>附上一张图</h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" alt></a></p>\n<h2 id=\"匹配时逻辑\"><a href=\"#匹配时逻辑\" class=\"headerlink\" title=\"匹配时逻辑\"></a>匹配时逻辑</h2><blockquote>\n<p>KMP 在匹配时同时维护两个下标 i 和 j ,表示当前模式串 P 的前 j 个字符与主串 T 在位置 i 前的 j 个字符匹配,即 P[1..j]=T[i-j..i-1]。 当算法尝试对 T[i] 和 P[j+1] 匹配中遇到不相同的字符,就会通过Next数组进行跳跃。</p>\n</blockquote>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><h3 id=\"Next数组-1\"><a href=\"#Next数组-1\" class=\"headerlink\" title=\"Next数组\"></a>Next数组</h3><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(cin&gt;&gt;T){\n        getNext();\n        print();\n    }\n    return 0;\n}</code></pre><h4 id=\"几组数据\"><a href=\"#几组数据\" class=\"headerlink\" title=\"几组数据\"></a>几组数据</h4><pre><code>ababc\nNext: -1 0 0 1 2\n\nabcdef\nNext: -1 0 0 0 0 0\n\nabcdabce\nNext: -1 0 0 0 0 1 2 3\n\nabcabcabc\nNext: -1 0 0 0 1 2 3 4 5\n\nabcdabcabcd\nNext: -1 0 0 0 0 1 2 3 1 2 3</code></pre><h3 id=\"KMP-返回第一个匹配的下标\"><a href=\"#KMP-返回第一个匹配的下标\" class=\"headerlink\" title=\"KMP - 返回第一个匹配的下标\"></a>KMP - 返回第一个匹配的下标</h3><h4 id=\"主程\"><a href=\"#主程\" class=\"headerlink\" title=\"主程\"></a>主程</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint KMP_index(){\n    int i=0,j=0,slen=S.length(),tlen=T.length();\n    getNext();\n    while(i&lt;slen &amp;&amp; j&lt;tlen){\n        if(j==-1 || S[i]==T[j]){\n            i++;\n            j++;\n        }else j=Next[j];\n    }\n    if(j==tlen) return i-tlen;\n    else return -1;\n}\n\nint main(){\n    while(cin&gt;&gt;S&gt;&gt;T){\n        int ans=KMP_index();\n        if(ans==-1) cout&lt;&lt;&quot;Failed!&quot;&lt;&lt;endl;\n        else cout&lt;&lt;&quot;Succesed!String T was matched in index &quot;&lt;&lt;ans&lt;&lt;&quot;.&quot;&lt;&lt;endl;\n        print();\n    }\n    return 0;\n}</code></pre><h4 id=\"两组数据\"><a href=\"#两组数据\" class=\"headerlink\" title=\"两组数据\"></a>两组数据</h4><pre><code>IN[0]: jashdjashdjabababcabcsdas\nIN[1]: abcabc\nOUT[0]: Succesed!String T was matched in index 15.\nOUT[1]: -1 0 0 0 1 2\nIN[2]: jashdjashdjabababcabcsdas\nIN[3]: abcabcd\nOUT[2]: Failed!\nOUT[3]: -1 0 0 0 1 2 3</code></pre><h1 id=\"AC-Corasick-自动机\"><a href=\"#AC-Corasick-自动机\" class=\"headerlink\" title=\"AC-Corasick 自动机\"></a>AC-Corasick 自动机</h1><blockquote>\n<p>思想是KMP+Trie,在Trie上建立失配指针.</p>\n<blockquote>\n<p>常用于主串匹配多个字符串</p>\n</blockquote>\n</blockquote>\n<h2 id=\"尾节点记录字符串下标的AC自动机\"><a href=\"#尾节点记录字符串下标的AC自动机\" class=\"headerlink\" title=\"尾节点记录字符串下标的AC自动机\"></a>尾节点记录字符串下标的AC自动机</h2><blockquote>\n<p>优点是可以直接输出字符串.</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2 id=\"尾节点记录可重复子串在总串中出现次数\"><a href=\"#尾节点记录可重复子串在总串中出现次数\" class=\"headerlink\" title=\"尾节点记录可重复子串在总串中出现次数\"></a>尾节点记录可重复子串在总串中出现次数</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    int ch[maxn][sigma_size];\n    int f[maxn],last[maxn];\n    int cnt[maxn],val[maxn];\n    int siz;\n\n    int ans;\n\n    void init(){\n        siz=ans=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///表示以第u棵节点为字符串最后一个字符节点的个数\n       ///如果想存储该节点代表的是哪个字符串.即存储该字符串的下标\n       ///val[u]=v;(v是下标)\n       ///但是这样存储就会出现无法统计之前有多少个重复字符串\n       ///比如这道题如果输入\n       ///3\n       ///sha\n       ///sha\n       ///sha\n       ///shashasha\n       ///则用第一种方法最后结果是3\n       ///但用第二种方法只能匹配一次sha\n       val[u]++;\n    }\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        if(u){\n            if(!cnt[u]) ans+=val[u],cnt[u]=1;\n            add(last[u]);\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i]);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2 id=\"失配函数优化\"><a href=\"#失配函数优化\" class=\"headerlink\" title=\"失配函数优化\"></a>失配函数优化</h2><blockquote>\n<p>接下来都基于第一个代码进行优化,可以复刻到第二个代码上</p>\n<blockquote>\n<p>即将失配记录转变成 一条确定的边连到Trie中(这样应该就不能被称之为树了)</p>\n</blockquote>\n<p>if(!u) continue; =&gt;</p>\n<blockquote>\n<p>if(!u) {ch[k][c]=ch[f[k]][c];continue;} 删掉适配函数BFS中的 while()</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) {ch[k][c]=ch[f[k]][c];continue;}\n                Q.push(u);\n                int v=f[k];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2 id=\"MLE和TLE优化–内存优化\"><a href=\"#MLE和TLE优化–内存优化\" class=\"headerlink\" title=\"MLE和TLE优化–内存优化\"></a>MLE和TLE优化–内存优化</h2><blockquote>\n<p>听说之前网络赛的时候就有道AC自动机的题,然后普通的模板总是MLE. 少了一半的时间,一半的内存</p>\n<blockquote>\n<p>意在每次不全初始化,每多一个节点初始化一次</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组fail,last\n    int f[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数,根节点编号\n    int siz,root;\n\n    int ans;\n\n    int newNode(){\n        memset(ch[siz],0,sizeof(ch[siz]));\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        ans=0;siz=0;root=newNode();\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    //Fail树,build\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2 id=\"但是以上自动机识别形如a-ab-abc-abcd这类子串会出问题-在刷题时发现的-下面重新用新的方法来解决这个问题-建议用下面的AC自动机\"><a href=\"#但是以上自动机识别形如a-ab-abc-abcd这类子串会出问题-在刷题时发现的-下面重新用新的方法来解决这个问题-建议用下面的AC自动机\" class=\"headerlink\" title=\"但是以上自动机识别形如a,ab,abc,abcd这类子串会出问题,在刷题时发现的,下面重新用新的方法来解决这个问题,建议用下面的AC自动机\"></a>但是以上自动机识别形如a,ab,abc,abcd这类子串会出问题,在刷题时发现的,下面重新用新的方法来解决这个问题,建议用下面的AC自动机</h2><h3 id=\"HDU-2222，上面的那些题-修改\"><a href=\"#HDU-2222，上面的那些题-修改\" class=\"headerlink\" title=\"HDU 2222，上面的那些题,修改\"></a>HDU 2222，上面的那些题,修改</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root,ans;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n        ans=0;\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        gets(str);\n        tot_len=strlen(str);\n        aho.Find(str);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h3 id=\"HDU-5880-青岛区域赛网赛\"><a href=\"#HDU-5880-青岛区域赛网赛\" class=\"headerlink\" title=\"HDU 5880,青岛区域赛网赛\"></a>HDU 5880,青岛区域赛网赛</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            if(!isalpha(s[i])){\n                u=0;\n                continue;\n            }\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            /*\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                p=f[p];\n            }\n            */\n            add(u,i);\n        }\n    }\n\n    void print(){\n        for(int i=0;i&lt;tot_len;++i){\n            if(cle[i]) putchar(&apos;*&apos;);\n            else putchar(str[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str,i+1);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(str);\n        tot_len=strlen(str);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(str);\n        aho.print();\n    }\n    return 0;\n}</code></pre><h1 id=\"后缀数组\"><a href=\"#后缀数组\" class=\"headerlink\" title=\"后缀数组\"></a>后缀数组</h1><h1 id=\"后缀自动机\"><a href=\"#后缀自动机\" class=\"headerlink\" title=\"后缀自动机\"></a>后缀自动机</h1>","text":"Trie这个…不想写了KMP朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)Next数组对于KMP而言最重要的莫过于这个Next数组了.Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.构","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"KMP","slug":"AC自动机/KMP","count":1,"path":"api/categories/AC自动机/KMP.json"},{"name":"字符串处理","slug":"AC自动机/KMP/字符串处理","count":1,"path":"api/categories/AC自动机/KMP/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]}]}