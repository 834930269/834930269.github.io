{"name":"AOJ","slug":"AOJ","count":5,"postlist":[{"title":"AOJ \tALDS1_11_D Connected Components","slug":"1464","date":"2017-11-19T13:15:58.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/1464.json","excerpt":"","keywords":null,"cover":null,"content":"<p>MathJax.Hub.Config({ tex2jax: { inlineMath: [[“$”,”$”], [“\\(“,”\\)“]], processEscapes: true }});</p>\n<h1><span id=\"connected-components\">Connected Components</span></h1><p>Write a program which reads relations in a SNS (Social Network Service), and judges that given pairs of users are reachable each other through the network.</p>\n<h2><span id=\"input\">Input</span></h2><p>In the first line, two integer $n$ and $m$ are given. $n$ is the number of users in the SNS and $m$ is the number of relations in the SNS. The users in the SNS are identified by IDs $0, 1, …, n-1$. In the following $m$ lines, the relations are given. Each relation is given by two integers $s$ and $t$ that represents $s$ and $t$ are friends (and reachable each other). In the next line, the number of queries $q$ is given. In the following $q$ lines, $q$ queries are given respectively. Each query consists of two integers $s$ and $t$ separated by a space character.</p>\n<h2><span id=\"output\">Output</span></h2><p>For each query, print “yes” if $t$ is reachable from $s$ through the social network, “no” otherwise.</p>\n<h2><span id=\"constraints\">Constraints</span></h2><ul>\n<li>$2 \\leq n \\leq 100,000$</li>\n<li>$0 \\leq m \\leq 100,000$</li>\n<li>$1 \\leq q \\leq 10,000$</li>\n</ul>\n<h2><span id=\"sample-input\">Sample Input</span></h2><p>10 9<br>0 1<br>0 2<br>3 4<br>5 7<br>5 6<br>6 7<br>6 8<br>7 8<br>8 9<br>3<br>0 1<br>5 9<br>1 3</p>\n<h2><span id=\"sample-output\">Sample Output</span></h2><p>yes<br>yes<br>no</p>\n<p>求连通分量,对每一个连通分量进行染色.不在同一个联通分量的肯定无法联系.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;stack&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int maxn=100000;\nconst int NIL=-1;\nint n;\nvector&lt;int&gt; G[maxn];\nint color[maxn];\n\nvoid dfs(int r,int c){\n    stack&lt;int&gt; S;\n    S.push(r);\n    color[r]=c;\n    while(!S.empty()){\n        int u=S.top();S.pop();\n        for(int i=0;i&lt;G[u].size();++i){\n            int v=G[u][i];\n            if(color[v]==NIL){\n                color[v]=c;\n                S.push(v);\n            }\n        }\n    }\n}\n\nvoid setColor(){\n    int id=1;\n    for(int i=0;i&lt;n;++i){\n        color[i]=NIL;\n    }\n    for(int u=0;u&lt;n;++u){\n        if(color[u]==NIL) dfs(u,id++);\n    }\n}\n\nint main(){\n    int s,t,m,q;\n\n    cin&gt;&gt;n&gt;&gt;m;\n\n    for(int i=0;i&lt;m;++i){\n        cin&gt;&gt;s&gt;&gt;t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n\n    setColor();\n\n    cin&gt;&gt;q;\n    for(int i=0;i&lt;q;++i){\n        cin&gt;&gt;s&gt;&gt;t;\n        if(color[s]==color[t]){\n            puts(&quot;yes&quot;);\n        }else{\n            puts(&quot;no&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre>","text":"MathJax.Hub.Config({ tex2jax: { inlineMath: [[“$”,”$”], [“\\(“,”\\)“]], processEscapes: true }});Connected ComponentsWrite a program which rea","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"图论","slug":"AOJ/图论","count":1,"path":"api/categories/AOJ/图论.json"},{"name":"连通分量","slug":"AOJ/图论/连通分量","count":1,"path":"api/categories/AOJ/图论/连通分量.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"}]},{"title":"ALDS1_4_C Dictionary","slug":"alds1-4-c-dictionary","date":"2018-01-08T10:47:39.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/alds1-4-c-dictionary.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: <a href=\"https://vjudge.net/problem/Aizu-ALDS1_4_C\" title=\"https://vjudge.net/problem/Aizu-ALDS1_4_C\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/Aizu-ALDS1_4_C</a> 题型: 开放式散列表(可以用c++库函数做,但那样就忒没诚意了是啊吧 :triumph: ) PS:对于散列表性能影响最大的一般是散列函数.如果出现TLE,证明散列函数出问题了,改改试试. Code:</p>\n<pre><code>/*\n//alds1_4_c:Dictionary\n//算法:开放地址法散列表\n//Time: 2018/1/8 星期一\n*/\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nconst int M=1000003;\nconst int L=14;\n\nchar H[M][L];\n\n//对于每个字符返回的定义值\nint getChar(char ch){\n    if(ch==&apos;A&apos;) return 1;\n    if(ch==&apos;C&apos;) return 2;\n    if(ch==&apos;D&apos;) return 3;\n    if(ch==&apos;T&apos;) return 4;\n    return 0;\n}\n//对于字符串返回的初始散列值\nlong long getKey(char str[]){\n    long long len=strlen(str),sum=0,p=1;\n    for(int i=0;i&lt;len;++i){\n        sum+=p*getChar(str[i]);\n        //每次获取定义值后p*5,相当于转换成五进制,不会冲突\n        p*=5;\n    }\n    return sum;\n}\n\n//开放式散列值计算式: h(k,i)=(h1(k)+i*h2(k))%M\nint h1(int key){\n    return key%M;\n}\n//为了保证不会递归冲突(即往下算结果始终相同),必须使h2(key)与M互素\n//TLE最好的情况就是改这个函数= =\n//目前可以AC的: 1+(key%(M-1))\n//(1+key)%(M-1)\nint h2(int key){\n    return (1+key)%(M-1);\n}\n\n//查找\n//-1表示找到\n//h表示找到第一个可插入点\nint find(char str[]){\n    long long key=getKey(str),i,h;\n    for(i=0;;++i){\n        h=(h1(key)+i*h2(key))%M;\n        if(strcmp(H[h],str)==0) return -1;\n        else if(strlen(H[h])==0) return h;\n    }\n    return 0;\n}\n\n//插入\nvoid insert(char str[]){\n    int key=find(str);\n    if(key!=-1) strcpy(H[key],str);\n}\n\nint main(){\n    for(int i=0;i&lt;M;++i) H[M][0]=&apos;\\0&apos;;\n    char str[L],com[L];\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%s %s&quot;,com,str);\n\n        if(com[0]==&apos;i&apos;){\n            insert(str);\n        }else{\n            if(find(str)==-1)\n                printf(&quot;yes\\n&quot;);\n            else\n                printf(&quot;no\\n&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre>","text":"原题连接: https://vjudge.net/problem/Aizu-ALDS1_4_C 题型: 开放式散列表(可以用c++库函数做,但那样就忒没诚意了是啊吧 :triumph: ) PS:对于散列表性能影响最大的一般是散列函数.如果出现TLE,证明散列函数出问题了,改改试","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"散列表","slug":"AOJ/散列表","count":1,"path":"api/categories/AOJ/散列表.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"散列表","slug":"散列表","count":1,"path":"api/tags/散列表.json"}]},{"title":"AOJ DPL_3 B Largest Rectangle","slug":"aoj-dpl-3-b-largest-rectangle","date":"2017-11-19T08:22:23.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-dpl-3-b-largest-rectangle.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"largest-rectangle\">Largest Rectangle</span></h1><p>Given a matrix (H × W) which contains only 1 and 0, find the area of the largest rectangle which only contains 0s.</p>\n<h2><span id=\"input\">Input</span></h2><p>H W<br>c1,1 c1,2 … c1,W<br>c2,1 c2,2 … c2,W<br>:<br>cH,1 cH,2 … cH,W</p>\n<p>In the first line, two integers H and W separated by a space character are given. In the following H lines, ci,j, elements of the H × W matrix, are given.</p>\n<h2><span id=\"output\">Output</span></h2><p>Print the area (the number of 0s) of the largest rectangle.</p>\n<h2><span id=\"constraints\">Constraints</span></h2><ul>\n<li>1 ≤ H, W ≤ 1,400</li>\n</ul>\n<h2><span id=\"sample-input\">Sample Input</span></h2><p>4 5<br>0 0 1 0 0<br>1 0 0 0 0<br>0 0 0 1 0<br>0 0 0 1 0</p>\n<h2><span id=\"sample-output\">Sample Output</span></h2><p>6</p>\n<p>最大子矩阵(直方图)的变形. 首先需要把每一行都预处理成<code>距离第0行</code>的高度的表.然后每一行都相当于一个直方图,对每个直方图求可以围成的所有矩形面积,用<code>maxv维护</code>最大矩形的值.</p>\n<pre><code>例 处理前:\n    0 0 1 0 0\n    1 0 0 0 0\n    0 0 0 1 0\n    0 0 0 1 0\n\nAfter 处理后:\n    1 1 0 1 1\n    0 2 1 2 2\n    1 3 2 0 3\n    2 4 3 0 4</code></pre><p>Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size,int buffer[]){\n    stack&lt;Rectangle&gt; S;\n    int maxv=0;\n    //通过后一位向前面的计算\n    //这里用到的DP大概是无参数getLargestRectangle里面的预处理\n    //这里用到的更多是思维吧,对每一行进行计算,最后求出最大值.\n    buffer[size]=0;\n\n    for(int i=0;i&lt;=size;++i){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height &lt; rect.height){\n                S.push(rect);\n            }else if(S.top().height &gt; rect.height){\n                int target=i;\n                while(!S.empty() &amp;&amp; S.top().height &gt;= rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    //printf(&quot;\\nmaxv: %d\\n&quot;,maxv);\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    //预处理每个点离他最近的上边未被污染地板的高度\n    for(int j=0;j&lt;W;++j){\n        for(int i=0;i&lt;H;++i){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i&gt;0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    /*\n    例:\n        0 0 1 0 0\n        1 0 0 0 0\n        0 0 0 1 0\n        0 0 0 1 0\n\n    After:\n        1 1 0 1 1\n        0 2 1 2 2\n        1 3 2 0 3\n        2 4 3 0 4\n    */\n    int maxv=0;\n    //传入两个值 W,列数,处理后T[i]第i行的首地址\n    for(int i=0;i&lt;H;++i){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(&quot;%d %d&quot;,&amp;H,&amp;W);\n    for(int i=0;i&lt;H;++i){\n        for(int j=0;j&lt;W;++j){\n            scanf(&quot;%d&quot;,&amp;buffer[i][j]);\n        }\n    }\n\n    printf(&quot;%d\\n&quot;,getLargestRectangle());\n    return 0;\n}</code></pre>","text":"Largest RectangleGiven a matrix (H × W) which contains only 1 and 0, find the area of the largest rectangle which only contains 0s.InputH W<","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"动态规划","slug":"AOJ/动态规划","count":1,"path":"api/categories/AOJ/动态规划.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"AOJ NTL_1_D Euler's Phi Function & 欧拉函数相关","slug":"aoj-ntl-1-d-eulers-phi-function","date":"2017-11-25T07:35:20.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-ntl-1-d-eulers-phi-function.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg","content":"<p>欧拉函数: 提供1到N中与N互质的数的个数.</p>\n<h2><span id=\"定义和简单性质\">定义和简单性质</span></h2><p>欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. <strong>对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).</strong></p>\n<h3><span id=\"性质\">性质</span></h3><blockquote>\n<p>1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(q-1)</p>\n<blockquote>\n<p>欧拉函数是积性函数,但不是完全积性函数.</p>\n</blockquote>\n</blockquote>\n<p>证明： 函数的积性即： 若m,n互质,则φ(mn)=φ(m)φ(n).由“m,n互质”可知m,n无公因数,所以: φ(m)φ(n)=m(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)·n(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 其中p1,p2,p3…pn为m的质因数,p1’,p2’,p3’…pn’为n的质因数,而m,n无公因数,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 互不相同,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 均为mn的质因数且为mn质因数的全集,所以: φ(mn)=mn(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 所以: φ(mn)=φ(m)φ(n). 即φ(mn)=φ(n)*φ(m)只在(n,m)=1时成立(n与m互质).</p>\n<blockquote>\n<p>2.对于一个正整数N的素数幂分解N=P1^q1_P2^q2_…*Pn^qn.</p>\n</blockquote>\n<pre><code>则 φ(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn).</code></pre><blockquote>\n<p>3.除了N=2,φ(N)都是偶数. 4.设N为正整数,∑φ(d)=N (d|N)(d是N的质因数).</p>\n</blockquote>\n<p>根据性质二,我们可以在O(sqrt(n))的时间内暴力求出一个数的欧拉函数值. 如果我们要求1000000以内所有数的欧拉函数,怎么办. 上面的方法复杂度将高达O(N*sqrt(N)). 暴力方法:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int a[10]={2,10,100,1000,5,7,9,11,12,13};\n    for(int i=0;i&lt;10;++i)\n        cout&lt;&lt;euler(a[i])&lt;&lt;endl;\n    return 0;\n}</code></pre><p>结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" alt></a> 我们可以将这个方法和筛法求素数的想法结合,试用筛法求出1~n内各个数字的euler(n). φ(n)=n_（1-1/p1)(1-1/p2)….(1-1/pk) 其中p1、p2…pk为n的所有素因子(这个素因子是由整数素分得来的)。 比如：φ(12)=12_(1-1/2)(1-1/3)=4。 比如求10以内所有数的φ值：</p>\n<blockquote>\n<p>1.设一数组phi[11]，赋初值phi[1]=1,phi[2]=2…phi[10]=10 2.然后从2开始循环</p>\n<blockquote>\n<p>把2的倍数的φ值<em>(1-1/2)，则phi[2]=2_1/2=1,phi[4]=4_1/2=2,phi[6]=6_1/2=3….； 再是3，3的倍数的φ值</em>(1-1/3)，则phi[3]=3_2/3=2,phi[6]=3*2/3=2，phi[9]=…..； 再5，再7…因为对每个素数都进行如此操作，因此任何一个n都得到了φ(n)=n*（1-1/p1)(1-1/p2)….(1-1/pk)的运算</p>\n</blockquote>\n</blockquote>\n<p>代码如下:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h2><span id=\"aoj-ntl_1_d-eulers-phi-function\">AOJ NTL_1_D Euler’s Phi Function</span></h2><p>这道题数值范围是1e10,没超过int.而且只需要求一个数的euler. O(lgn)暴力即可.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;euler(n)&lt;&lt;endl;\n\n    return 0;\n}</code></pre>","text":"欧拉函数: 提供1到N中与N互质的数的个数.定义和简单性质欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. 对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).性质1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"},{"name":"欧拉函数","slug":"AOJ/数论/欧拉函数","count":1,"path":"api/categories/AOJ/数论/欧拉函数.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"数论 -  幂乘以及取模相关推导","slug":"number-theory-pow-and-mod","date":"2017-11-25T06:21:18.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/number-theory-pow-and-mod.json","excerpt":"","keywords":null,"cover":null,"content":"<p>幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.</p>\n<blockquote>\n<p>mod相关</p>\n<blockquote>\n<p>:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由如下</p>\n</blockquote>\n</blockquote>\n<pre><code>设a除以M的余数和商分别为ar,aq.\nb除以M的余数和商分别为br,bq.\na*b =(aq*M+ar)*(bq*M+br)\n    =aq*bq*M^2+ar*bq*M+aq*br*M+ar*br\n    =(aq*bq*M^+ar*bq+aq*br)*M+ar*br\n\n故 (a*b)%M = ar*br\n             = a%M*b%M</code></pre><blockquote>\n<blockquote>\n<p>:arrow_forward:除法相对复杂,具体可以通过费小马定理求解.</p>\n</blockquote>\n</blockquote>\n<p>幂乘模板题: <code>NTL_1_B:Power</code></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst ull md=1000000007;\n\nll mod_pow(ull x,ull n,ull mod){\n    ull res=1;\n    while(n&gt;0){\n        if(n&amp;1) res=res*x%mod;\n        x=x*x%mod;\n        n&gt;&gt;=1;\n    }\n    return res;\n}\n\nint main(){\n    ull m,n;\n    scanf(&quot;%llu %llu&quot;,&amp;m,&amp;n);\n    printf(&quot;%lld\\n&quot;,mod_pow(m,n,md));\n    return 0;\n}</code></pre>","text":"幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.mod相关:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"}]}]}