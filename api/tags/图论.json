{"name":"图论","slug":"图论","count":6,"postlist":[{"title":"AOJ \tALDS1_11_D Connected Components","slug":"1464","date":"2017-11-19T13:15:58.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/1464.json","excerpt":"","keywords":null,"cover":null,"content":"<p>MathJax.Hub.Config({ tex2jax: { inlineMath: [[“$”,”$”], [“\\(“,”\\)“]], processEscapes: true }});</p>\n<h1><span id=\"connected-components\">Connected Components</span></h1><p>Write a program which reads relations in a SNS (Social Network Service), and judges that given pairs of users are reachable each other through the network.</p>\n<h2><span id=\"input\">Input</span></h2><p>In the first line, two integer $n$ and $m$ are given. $n$ is the number of users in the SNS and $m$ is the number of relations in the SNS. The users in the SNS are identified by IDs $0, 1, …, n-1$. In the following $m$ lines, the relations are given. Each relation is given by two integers $s$ and $t$ that represents $s$ and $t$ are friends (and reachable each other). In the next line, the number of queries $q$ is given. In the following $q$ lines, $q$ queries are given respectively. Each query consists of two integers $s$ and $t$ separated by a space character.</p>\n<h2><span id=\"output\">Output</span></h2><p>For each query, print “yes” if $t$ is reachable from $s$ through the social network, “no” otherwise.</p>\n<h2><span id=\"constraints\">Constraints</span></h2><ul>\n<li>$2 \\leq n \\leq 100,000$</li>\n<li>$0 \\leq m \\leq 100,000$</li>\n<li>$1 \\leq q \\leq 10,000$</li>\n</ul>\n<h2><span id=\"sample-input\">Sample Input</span></h2><p>10 9<br>0 1<br>0 2<br>3 4<br>5 7<br>5 6<br>6 7<br>6 8<br>7 8<br>8 9<br>3<br>0 1<br>5 9<br>1 3</p>\n<h2><span id=\"sample-output\">Sample Output</span></h2><p>yes<br>yes<br>no</p>\n<p>求连通分量,对每一个连通分量进行染色.不在同一个联通分量的肯定无法联系.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;stack&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int maxn=100000;\nconst int NIL=-1;\nint n;\nvector&lt;int&gt; G[maxn];\nint color[maxn];\n\nvoid dfs(int r,int c){\n    stack&lt;int&gt; S;\n    S.push(r);\n    color[r]=c;\n    while(!S.empty()){\n        int u=S.top();S.pop();\n        for(int i=0;i&lt;G[u].size();++i){\n            int v=G[u][i];\n            if(color[v]==NIL){\n                color[v]=c;\n                S.push(v);\n            }\n        }\n    }\n}\n\nvoid setColor(){\n    int id=1;\n    for(int i=0;i&lt;n;++i){\n        color[i]=NIL;\n    }\n    for(int u=0;u&lt;n;++u){\n        if(color[u]==NIL) dfs(u,id++);\n    }\n}\n\nint main(){\n    int s,t,m,q;\n\n    cin&gt;&gt;n&gt;&gt;m;\n\n    for(int i=0;i&lt;m;++i){\n        cin&gt;&gt;s&gt;&gt;t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n\n    setColor();\n\n    cin&gt;&gt;q;\n    for(int i=0;i&lt;q;++i){\n        cin&gt;&gt;s&gt;&gt;t;\n        if(color[s]==color[t]){\n            puts(&quot;yes&quot;);\n        }else{\n            puts(&quot;no&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre>","text":"MathJax.Hub.Config({ tex2jax: { inlineMath: [[“$”,”$”], [“\\(“,”\\)“]], processEscapes: true }});Connected ComponentsWrite a program which rea","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"图论","slug":"AOJ/图论","count":1,"path":"api/categories/AOJ/图论.json"},{"name":"连通分量","slug":"AOJ/图论/连通分量","count":1,"path":"api/categories/AOJ/图论/连通分量.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"}]},{"title":"Educational Codeforces Round 25 B","slug":"educational-codeforces-round-25-b","date":"2017-07-16T18:37:23.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/educational-codeforces-round-25-b.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【题目】</p>\n<h2><span id=\"b-five-in-a-row\">B. Five-In-a-Row</span></h2><h5><span id=\"time-limit-per-test1-second-memory-limit-per-test256megabytes\">time limit: per test1 second memory limit: per test256megabytes</span></h5><h5><span id=\"input-standard-input-output-standard-output\">input: standard input output: standard output</span></h5><p>Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts. In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately. Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.</p>\n<p><strong>Input</strong></p>\n<p>You are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell. It is guaranteed that in the current arrangement nobody has still won.</p>\n<p><strong>Output</strong></p>\n<p>Print ‘YES’ if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print ‘NO’.</p>\n<p><strong>Examples</strong></p>\n<p><strong>Input</strong></p>\n<p>XX.XX…..<br>…..OOOO.<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….</p>\n<p><strong>Output</strong></p>\n<p>YES</p>\n<p><strong>Input</strong></p>\n<p>XXOXX…..<br>OO.O……<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….</p>\n<p><strong>Output</strong></p>\n<p>NO Link: <a href=\"http://codeforces.com/contest/825/problem/B\" target=\"_blank\" rel=\"noopener\">http://codeforces.com/contest/825/problem/B</a> 【题意】 X是否能在一步以内连成五子.可以则赢. 【题解】 数据量不大,枚举八个方向即可,注意,每次只能往一个方向走,不能拐弯.而且必须枚举八方向,不能只枚举向下的几个方向. 如果找到第一个五子,则往后就不需要计算了. 【Sourcr Code】 github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/Educational%20Codeforces%20Round%2025%20%20B.cpp\" target=\"_blank\" rel=\"noopener\">Educational Codeforces Round 25 B.cpp</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>char mp[11][11];<br>bool re;<br>int d[8][3]={ {0,1},{1,0},{1,1},{1,-1},{-1,1},{-1,-1},{0,-1},{-1,0}};</p>\n<p>bool check(int x,int i,int y,int j){<br>    if(x+i&gt;=0&amp;&amp;x+i&lt;10&amp;&amp;y+j&gt;=0&amp;&amp;y+j&lt;=10)<br>        return true;<br>    else return false;<br>}</p>\n<p>void dfs(int x,int y,int win,int ct,int dir){<br> //   if(dir==3)<br> //       printf(“(%d,%d):%d %d\\n”,x,y,win,dir);<br>    if(win==5 || re){re=true;return;}<br>    int i=d[dir][0],j=d[dir][1];<br>    if(check(x,i,y,j)){<br>        if(mp[x+i][y+j]==’X’) dfs(x+i,y+j,win+1,ct,dir);<br>        if(mp[x+i][y+j]==’.’ &amp;&amp; ct==0) dfs(x+i,y+j,win+1,1,dir);<br>    }<br>}</p>\n<p>int main(){<br>    re=false;<br>    for(int i=0;i&lt;10;++i)<br>        gets(mp[i]);<br>    for(int i=0;i&lt;10;++i){<br>        if(re)break;<br>        for(int j=0;j&lt;10;++j){<br>            if(mp[i][j]==’X’){<br>                for(int k=0;k&lt;8;++k){<br>                    dfs(i,j,1,0,k);<br>                    if(re)break;<br>                }<br>                if(re)break;<br>            }<br>        }<br>    }<br>    if(re)printf(“YES\\n”);<br>    else printf(“NO\\n”);<br>    return 0;<br>}</p>\n<p>/**<br>….X…..<br>…X.OOOO.<br>..X…….<br>.X……..<br>……….<br>……….<br>……….<br>……….<br>……….<br>……….<br>**/</p>\n","text":"【题目】B. Five-In-a-Rowtime limit: per test1 second memory limit: per test256megabytesinput: standard input output: standard outputAlice and Bo","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"},{"name":"dfs","slug":"Codeforce/dfs","count":1,"path":"api/categories/Codeforce/dfs.json"},{"name":"图论","slug":"Codeforce/dfs/图论","count":1,"path":"api/categories/Codeforce/dfs/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]},{"title":"牛客练习赛 12 A,B","slug":"nk-12-ab","date":"2018-02-10T08:28:45.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/nk-12-ab.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://www.nowcoder.net/acm/contest/68#question\" title=\"https://www.nowcoder.net/acm/contest/68#question\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/68#question</a></p>\n<h1><span id=\"题目都很易懂\">题目都很易懂</span></h1><h1><span id=\"第一题题解\">第一题题解</span></h1><blockquote>\n<p>把弧度值当角度来做即可,如果弧度是负数,把它转换成顺时针下的弧度值即可, 那么如果 a-b\\&lt;0则代表b在a顺时针前面,否则是a在b顺时针之前</p>\n<blockquote>\n<p>然后分情况讨论即可,即钝角和锐角的情况</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    double a,b;\n    int t;\n    cin&gt;&gt;t;\n    while(t--){\n        cin&gt;&gt;a&gt;&gt;b;\n        if(a&lt;0.0) a=M_PI+a;\n        if(b&lt;0.0) b=M_PI+b;\n        double rg=a-b,rt=abs(rg);\n        if(rt&gt;M_PI){\n            if(rg&gt;0.0){\n                printf(&quot;counterclockwise\\n&quot;);\n            }else{\n                printf(&quot;clockwise\\n&quot;);\n            }\n        }else{\n            if(rg&gt;0.0){\n                printf(&quot;clockwise\\n&quot;);\n            }else{\n                printf(&quot;counterclockwise\\n&quot;);\n            }\n        }\n    }\n    return 0;\n}</code></pre><h1><span id=\"第二题题解\">第二题题解</span></h1><blockquote>\n<p>我们将vis数组设为两重,一重是有钥匙,一重是无钥匙</p>\n<blockquote>\n<p>vis[has_key?1：0][x][y]</p>\n</blockquote>\n<p>bfs即可</p>\n</blockquote>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef struct Node{\n    int has_key;\n    int cnt,x,y;\n}node;\n\nchar mp[510][510];\nint h,w,sx,sy;\n//об,ио,ср,вС\nint mv[4][2]={ {0,1},{0,-1},{1,0},{-1,0}};\n\nint vis[2][600][600];\n\nvoid bfs(){\n    bool yes=false;\n    queue&lt;node&gt; st;\n    st.push((Node){0,0,sx,sy});\n    vis[0][sx][sy]=1;\n    while(!st.empty()){\n        node nd=st.front();st.pop();\n        if(mp[nd.x][nd.y]==&apos;E&apos;){\n            printf(&quot;%d\\n&quot;,nd.cnt);\n            return;\n        }\n        if(mp[nd.x][nd.y]==&apos;K&apos;){\n            nd.has_key=1;\n        }\n        int nx,ny;\n        for(int i=0;i&lt;4;++i){\n            nx=nd.x+mv[i][0],ny=nd.y+mv[i][1];\n            if(vis[nd.has_key][nx][ny]) continue;\n            if(mp[nx][ny]==&apos;W&apos;) continue;\n            if(mp[nx][ny]==&apos;D&apos; &amp;&amp; !nd.has_key) continue;\n            vis[nd.has_key][nx][ny]=1;\n            st.push((Node){nd.has_key,nd.cnt+1,nx,ny});\n        }\n    }\n    printf(&quot;-1\\n&quot;);\n}\n\nint main(){\n    cin&gt;&gt;h&gt;&gt;w;\n    bool flag=true;\n    memset(vis,0,sizeof(vis));\n    for(int i=0;i&lt;h;++i){\n        scanf(&quot;%s&quot;,mp[i]);\n        for(int j=0;flag &amp;&amp; j&lt;w;++j){\n            if(mp[i][j]==&apos;S&apos;){\n                sx=i,sy=j;\n                flag=false;\n            }\n        }\n    }\n    bfs();\n    return 0;\n}</code></pre>","text":"Linkhttps://www.nowcoder.net/acm/contest/68#question题目都很易懂第一题题解把弧度值当角度来做即可,如果弧度是负数,把它转换成顺时针下的弧度值即可, 那么如果 a-b\\&lt;0则代表b在a顺时针前面,否则是a在b顺时针之前然后分","link":"","raw":null,"photos":[],"categories":[{"name":"bfs","slug":"bfs","count":1,"path":"api/categories/bfs.json"},{"name":"图论","slug":"bfs/图论","count":1,"path":"api/categories/bfs/图论.json"},{"name":"牛客练习赛","slug":"bfs/图论/牛客练习赛","count":1,"path":"api/categories/bfs/图论/牛客练习赛.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"bfs","slug":"bfs","count":1,"path":"api/tags/bfs.json"}]},{"title":"PAT L3-005","slug":"pat-l3-005","date":"2017-04-03T17:18:58.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/pat-l3-005.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>Dijsktra模板题</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>const int maxn=30000;</strong> <strong>int N,M,K,D;</strong> <strong>char alpha1[100],alpha2[100];</strong> <strong>int now,goal,di;</strong>  <strong>struct Edge{</strong> <strong>int from,to,dist;</strong> <strong>};</strong> <strong>struct HeapNode{  //Dijkstra算法用到的优先队列的节点</strong> **    int d,u;** **    bool operator&lt;(const HeapNode&amp; rhs)const{** <strong>return d&gt;rhs.d;</strong> <strong>}</strong> <strong>};</strong> <strong>struct Dijkstra{</strong> **    int n,m; //点数和边数** **    vector<edge> edges; //边列表** **    vector<int> G[maxn]; //每个节点出发的边编号(从0开始编号)** **    bool done[maxn];    //是否永久标号** **    int d[maxn];        //s到各个点的距离** <strong>int p[maxn];        //最短路中的上一条边</strong> **    void init(int n){** **        this-&gt;n=n;** **        for(int i=0;i&lt;n;++i) G[i].clear();//清空邻接表** <strong>edges.clear();//清空边表</strong> <strong>}</strong>  **    void AddEdge(int from,int to,int dist){** **        //如果是无向图,每条无向边需调用两次AddEdge** **        edges.push_back((Edge){from,to,dist});** **        m=edges.size();** <strong>G[from].push_back(m-1);</strong> <strong>}</strong>  **    void dijkstra(int s){//求s到所有点的距离** **         priority_queue<heapnode> Q;** **         for(int i=0;i&lt;n;++i) d[i]=INF;** **         d[s]=0;** **         fill(done);** **         Q.push((HeapNode){0,s});** **         while(!Q.empty()){** **             HeapNode x=Q.top(); Q.pop();** **            int u=x.u;** **            if(done[u])continue;** **            done[u]=true;** **            for(int i=0;i&lt;G[u].size();++i){** **                Edge &amp;e=edges[G[u][i]];** **                if(d[e.to]&gt;d[u]+e.dist){** **                    d[e.to]=d[u]+e.dist;** **                    p[e.to]=G[u][i];** <strong>Q.push((HeapNode){d[e.to],e.to});</strong> <strong>}</strong> <strong>}</strong> **         }** <strong>}</strong> <strong>};</strong> <strong>int main(){</strong> **    while(~scanf(“%d%d%d%d”,&amp;N,&amp;M,&amp;K,&amp;D)){** **        Dijkstra dj;** <strong>dj.init(N+M);</strong> **        for(int i=0;i&lt;K;++i){** <strong>scanf(“\\n%s %s %d”,alpha1,alpha2,&amp;di);</strong> **            //因为可能出现G10 123等字符串** **            //所以这里转换必须用atoi或stoi** <strong>//后者是c11的</strong> <strong>if(alpha1[0]==’G’){</strong> <strong>now = N-1 + atoi(alpha1+1);</strong> **            }else** <strong>now = atoi(alpha1)-1;</strong>  <strong>if(alpha2[0]==’G’){</strong> **                goal = N-1 + atoi(alpha2+1);** **            }else** **                goal = atoi(alpha2)-1;**  **            dj.AddEdge(now,goal,di);** <strong>dj.AddEdge(goal,now,di);</strong> <strong>}</strong> **        int ansid=-1,ansdis=INF;** <strong>double ansave=INF;</strong>  **        for(int i=0;i&lt;M;++i){** **            int index=i+N,mindis=INF;** **            bool flag=true;** **            double ave=0.0;** **            dj.dijkstra(index);** **            for(int j=0;j&lt;N;++j){** **                if(dj.d[j]&gt;D){** **                    flag=false;** **                    break;** **                }** **                ave+=1.0<em>dj.d[j];*</em> **                mindis=mindis&gt;dj.d[j]?dj.d[j]:mindis;** <strong>}</strong> **            if(!flag)** **                continue;** **            else{** **                if(ansdis==INF){** **                    ave=ave/N;** **                    ansave=ave;** **                    ansid=i;** **                    ansdis=mindis;** **                }else if(mindis&gt;ansdis){** **                    ave=ave/N;** **                    ansave=ave;** **                    ansid=i;** **                    ansdis=mindis;** **                }else if(ansdis==mindis){** **                    ave=ave/N;** **                    if(ave&lt;ansave){** **                        ansave=ave;** **                        ansid=i;** **                        ansdis=mindis;** **                    }else if(ave==ansave){** **                        ansid=i&gt;ansid?ansid:i;** **                        ansdis=mindis;** **                    }** **                }** **            }** **        }**  **        if(ansid==-1)** **            printf(“No Solution\\n”);** **        else{** **            printf(“G%d\\n”,ansid+1);** <strong>printf(“%.1f %.1f\\n”,1.0*ansdis,ansave);</strong> <strong>}</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></heapnode></int></edge></p>\n</blockquote>\n","text":"【Tip】 Dijsktra模板题 【Code】#include&lt;bits/stdc++.h&gt; #define fill(x) memset(x,0,sizeof(x)) #define INF 0x3f3f3f3f using namespace std; cons","link":"","raw":null,"photos":[],"categories":[{"name":"Dijsktra","slug":"Dijsktra","count":1,"path":"api/categories/Dijsktra.json"},{"name":"图论","slug":"Dijsktra/图论","count":1,"path":"api/categories/Dijsktra/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"Dijsktra","slug":"Dijsktra","count":1,"path":"api/tags/Dijsktra.json"}]},{"title":"Tarjan 强连通分量算法","slug":"tarjan-scc-algorithm","date":"2018-01-17T10:03:54.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/tarjan-scc-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg","content":"<p>Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.</p>\n<h2><span id=\"学习契机-hdu-6038\">学习契机: </span></h2><p>首先介绍下:</p>\n<h2><span id=\"强连通分量\">强连通分量:</span></h2><p>画图以明志 -- <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" alt></a> <code>Tarjan</code>算法的时间复杂度是线性的,而kos算法则需要计算图的转置.该算法由Tarjan于1972年提出,是SCC<code>(Strongly Connected Componenet,强连通分量)</code>的第一个线性算法,Tarjan算法借助于DFS,但它并不需要靠遍历顺序(Kos算法的思想)来分离SCC,而是允许SCC并存于同一颗DFS树中,然后通过某种手段将他们分开.</p>\n<h2><span id=\"dag\">DAG:</span></h2><p>如果把一个集合看成一个点,那么所有的SCC构成了一个SCC图.这个SCC图不会存在有向环,因此是一个DAG<code>(Directed Acyclic Graph,有向无环图)</code>. 那他喵的什么是DAG呢?我把上面的那个强连通分量图给DAG化: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" alt></a></p>\n<h2><span id=\"算法流程\">算法流程</span></h2><p>考虑强连通分量C,设其中第一个被发现的点为x,则C中其他点都是x的后代.我们希望在x dfs访问完成后立即输出C.这样,就可以在一棵DFS树中区分开所有SCC了.因此,问题的关键是如何发现每个SCC的第一个点.</p>\n<h3><span id=\"如何判断是否是scc顶点\">如何判断是否是SCC顶点</span></h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" alt></a> 假设我们正在判断u是否为某SCC的第一个被发现节点.如果我们发现<code>从u的子节点出发可以达到u的祖先w,显然u就不是SCC的顶点.</code>反之,如果SCC最远的顶点可以到u,则u是SCC的顶点.图中虚线表示一条或多条边和点. 我们使用两个数组来记录每个节点的状态.pre[]和lowlink[]. 当递归回溯时如果这两个数组的值相同,则表明该节点为某SCC顶点.</p>\n<h2><span id=\"证明\">证明</span></h2><p>见: <a href=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" title=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/keyboarderqq/article/details/71308102</a></p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1><span id=\"此致画个图你就知道low数组的具体作用了\">此致:画个图你就知道low数组的具体作用了.</span></h1>","text":"Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.学习契机: 首先介绍下:强连通分量:画图以明志 --  [Figure]  假设我们正在判断u是否为某SCC的第一个被发现节点.","link":"","raw":null,"photos":[],"categories":[{"name":"Tarjan","slug":"Tarjan","count":1,"path":"api/categories/Tarjan.json"},{"name":"图论","slug":"Tarjan/图论","count":1,"path":"api/categories/Tarjan/图论.json"},{"name":"算法学习","slug":"Tarjan/图论/算法学习","count":1,"path":"api/categories/Tarjan/图论/算法学习.json"},{"name":"连通分量","slug":"Tarjan/图论/算法学习/连通分量","count":1,"path":"api/categories/Tarjan/图论/算法学习/连通分量.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]},{"title":"2017 杭电多校训练赛 补题","slug":"2017-hdu-up","date":"2018-01-14T04:25:53.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/2017-hdu-up.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif","content":"<p>[toc]</p>\n<h1><span id=\"第一场\"><strong>第一场</strong></span></h1><h2><span id=\"1003-colorful-tree-hdoj6035\"><strong>1003 Colorful Tree hdoj6035</strong></span></h2><p>题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n<em>(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) *</em> //思路<strong>：Answer = 所有颜色种类 * 所有路径数量 - 每一种颜色有多少路径没有经过 . 一开始假设每条路径都经过了所有颜色，再把每种颜色没经过的路径数减去就行，这个应该很好理解。问题是怎么算没经过的路径数？操作是这样的，如果算颜色1没经过的路径数，我们先把图里所有颜色是1的节点遮起来（假设这个点不存在，图在这个点是断路），图就被分成了很多块，</strong>每块的值= 那一块里的顶点数<em>（那一块里的顶点数-1）/2*</em>。 所有块的值加起来就是不经过颜色1的所有路径数。 到这里是不是还是很好理解，那么问题来了，怎么实现？…题解里说用虚树什么的… 用一个DFS即可，复杂度O（n） 用Size数组储存以每个节点为根节点的子树大小（即子树里节点的个数），Sum数组…很难解释，大概是表示以每种颜色为根节点的子树的大小和，但不是非常准确，如果以颜色2为根节点的子树里还含有颜色为2的节点，那只要算根节点这个颜色为2的子树大小即可，若在以这个颜色为2的点为根节点的子树之外还有颜色为2的点，那还要加上这个点的值…不知道能不能理解…解释不清楚，大概就这个意思… 以下图颜色2为例，代码里最后的for里(即以根<strong>第一个节点</strong>计算中)减去的（n-sum[2]）*（n-sum[2]-1）/2的那部分减去的是下图橙色圈里的那块，dfs里<code>减去pp那部分</code>是下图里蓝色圈的那块。其他具体的按照自己的理解再思考思考。 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" alt></a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 200005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\n//c[]数组是每个节点的颜色\nint c[maxn],head[maxn],len,sum[maxn],size[maxn],vis[maxn];\nLL d;\n//边表\n//邻接表\nstruct node{\n    int v,next;\n}p[maxn&lt;&lt;1];\n\nvoid addedge(int u,int v){\n    //有向边指向点的编号\n    p[len].v=v;\n    //每条边的下一条边是上一次纪录的边的号码\n    p[len].next=head[u];\n    //邻接表的方法\n    //len为当前边的编号\n\n    //只记录当前节点的最后一个边的位置\n    head[u]=len++;\n}\n//对树进行dfs\nvoid dfs(int x,int fa){\n    //非这个点为根的所有该颜色的点\n    LL pre=sum[c[x]];\n    //size数组是当前节点的子节点总数目\n    size[x]=1;\n    int add=0;\n    //通过邻接表对当前节点x进行dfs\n    //等于0则退出\n    for(int i=head[x];~i;i=p[i].next){\n        //如果遇到反向边了,跳过,继续往其他边走\n        if(p[i].v==fa)\n            continue;\n        dfs(p[i].v,x);\n        size[x] += size[p[i].v];\n        //计算当前节点子树所有和当前节点颜色不同的点的个数\n        LL count = size[p[i].v] - sum[c[x]] + pre;\n        pre = sum[c[x]];\n        //当前子树的不同颜色点的个数\n        add += count;\n        //假设其他颜色都是白色,d即等于不同颜色所组成的边的总个数\n        d += count*(count-1)&gt;&gt;1;\n    }\n    //计算以x为根节点子树的所有与x不同颜色的点的个数\n    sum[c[x]] += add + 1;\n}\n\nint main(){\n    int n,tcase=1;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        memset(head,-1,sizeof(head));\n        memset(sum,0,sizeof(sum));\n        memset(vis,0,sizeof(vis));\n        d=len=0;\n        LL number = 0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            //记录颜色,颜色范围是[1,n]\n            if(!vis[c[i]]){\n                vis[c[i]]=1;\n                number++;\n            }\n        }\n        for(int i=1;i&lt;n;++i){\n            int u,v;\n            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);\n            addedge(u,v);\n            addedge(v,u);\n        }\n        dfs(1,0);\n        //ans初始等于(颜色个数)*(所有边的个数)-d(d为每个颜色在每个子树上被减去的不会经过那个颜色的路径的个数)\n        LL ans=(number*(n-1)*n&gt;&gt;1)-d;\n        for(int i=1;i&lt;=n;++i){\n            //不存在的颜色不需要计算,把已存在的颜色计算一下\n            if(vis[i]&amp;&amp;i!=c[1]){\n                //在根节点中与颜色i不同的颜色的个数\n                LL count=n-sum[i];\n                //每个颜色的路径数=(n*(n-1)&gt;&gt;1)-(count*(count-1)&gt;&gt;1)\n                //以根节点为中心减去不同于当前颜色的路径的个数\n                //最终得到的ans即为 每个颜色路径个数 的和\n                ans-=count*(count-1)&gt;&gt;1;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,tcase++,ans);\n    }\n    return 0;\n}</code></pre><h2><span id=\"1006-function-hdoj6038\"><strong>1006 Function hdoj6038</strong></span></h2><p>这道题似懂非懂的写了出来… 大体是寻找循环节. 我写的代码有点乱… 原式为: f[i]=b[f[a[i]]] A:{1,0,2} B{0,1} 可组成f: 000 111 110 001 A:{2,0,1} b{0,2,3,1} 可组成f: 000 231 312 123 以i -&gt; a[i] i -&gt; b[i] 为图的边进行Tarjan. 用Tarjan判断a和b各自有几个环(强连通分量),并且记录下每个环的大小. 然后AC代码如下(以后思路清楚了再重新看看…):</p>\n<pre><code>//HDU 6038\n#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\nconst int maxn=100000+100;\nconst int mod=1e9+7;\ntypedef long long int lli;\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint a[maxn],b[maxn];\n\nstack&lt;int&gt; S;\nmap&lt;int,int&gt; A,B;\n\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\ninline lli qp(lli aa,lli x){\n    if(aa == 0) return 0;\n    lli ans = 1;\n    for(;x;x&gt;&gt;=1){\n        if(x&amp;1) ans = ans*aa % mod;\n        aa = aa*aa % mod;\n    }\n    return ans % mod;\n}\n\nvoid dfs(int u,map&lt;int,int&gt;&amp; T){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v,T);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            //未回溯时计算low数组需要通过pre数组\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        int cnt=0;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            cnt++;\n            if(x==u)break;\n        }\n        T[cnt]++;\n    }\n}\n\nvoid Tarjan(int n,map&lt;int,int&gt;&amp; T){\n    while(!S.empty()){\n        S.pop();\n    }\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i,T);\n    }\n}\n\nint main(){\n    int n,m,kase=0;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;a[i]);\n        }\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;b[i]);\n        }\n        //对aTarjan\n        for(int i=0;i&lt;n;++i){\n            addAdge(i,a[i]);\n        }\n        Tarjan(n,A);\n        for(int i=0;i&lt;n;++i){\n            G[i].clear();\n        }\n        //对bTarjan\n        for(int i=0;i&lt;m;++i){\n            addAdge(i,b[i]);\n        }\n        Tarjan(m,B);\n        for(int i=0;i&lt;m;++i){\n            G[i].clear();\n        }\n\n        long long ans=1;\n        map&lt;int,int&gt;::iterator it1;\n        map&lt;int,int&gt;::iterator it2;\n        for(it1=A.begin();it1!=A.end();it1++){\n            long long tmp=0;\n            for(it2=B.begin();it2!=B.end();it2++){\n                if(it1-&gt;first%it2-&gt;first==0){\n                    tmp=tmp+it2-&gt;second*it2-&gt;first;\n                }\n                //printf(&quot;%d %d : %d %d\\n&quot;,it1-&gt;first,it2-&gt;first,it1-&gt;second,it2-&gt;second);\n            }\n            ans=ans*qp(tmp,it1-&gt;second)%mod;\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n        A.clear();\n        B.clear();\n    }\n    return 0;\n}</code></pre><h2><span id=\"1008-hints-of-sd0061-hdoj6040\"><strong>1008 Hints of sd0061 hdoj6040</strong></span></h2><h1><span id=\"第二场\"><strong>第二场</strong></span></h1><h1><span id=\"第三场\"><strong>第三场</strong></span></h1>","text":"[toc]第一场1003 Colorful Tree hdoj6035题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) * //思路：Answer = 所有颜色种类 * 所有路径数量","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"dfs","slug":"2017多校/dfs","count":1,"path":"api/categories/2017多校/dfs.json"},{"name":"图论","slug":"2017多校/dfs/图论","count":1,"path":"api/categories/2017多校/dfs/图论.json"},{"name":"思维","slug":"2017多校/dfs/图论/思维","count":1,"path":"api/categories/2017多校/dfs/图论/思维.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]}]}