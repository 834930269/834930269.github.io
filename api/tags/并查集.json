{"name":"并查集","slug":"并查集","count":5,"postlist":[{"title":"数据结构补充","slug":"datastruct-add","date":"2018-02-13T13:12:07.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/datastruct-add.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…</p>\n<blockquote>\n<p>注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.</p>\n</blockquote>\n</blockquote>\n<h1 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h1><h2 id=\"要领\"><a href=\"#要领\" class=\"headerlink\" title=\"要领\"></a>要领</h2><blockquote>\n<p>以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.</p>\n<blockquote>\n<p>并查集是不可能分割的,即只能合并,不可分割.</p>\n<blockquote>\n<p>在牛客上听大佬讲课貌似存在可分割并查集,带权并查集.</p>\n</blockquote>\n</blockquote>\n<p>现在拓宽下,并查集常用于判断加入一个点后是否会在原图上形成环. 或者判断有几个连通分量(通常是无向图),然后问你这些节点全部关联起来至少需要添加几条边.</p>\n</blockquote>\n<h2 id=\"实现前奏\"><a href=\"#实现前奏\" class=\"headerlink\" title=\"实现前奏\"></a>实现前奏</h2><blockquote>\n<p>首先是逻辑,并查集实现规则是一个点一个点入图时进行合并,即join,然后在合并时进行find,查找根节点是否相同,不同则将浅的树合并到深的树上,判断深浅通过每次合并时对rank进行操作,然后在一个优化是路径压缩,即如果a节点的最高根节点是c,则直接将a记录为c即可.</p>\n<blockquote>\n<p>以上实现的前提是我们只需要逻辑上正确即可.</p>\n</blockquote>\n</blockquote>\n<h2 id=\"以题为马\"><a href=\"#以题为马\" class=\"headerlink\" title=\"以题为马\"></a>以题为马</h2><blockquote>\n<p>HDU 1232 判断有多少个连通块,然后答案就是ans-1</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nstruct DisjointSet{\n    vector&lt;int&gt; father,rank;\n    int Num;\n    DisjointSet(int n):father(n),rank(n),Num(n){\n        for(int i=1;i&lt;n;++i){\n            father[i]=i;\n        }\n    }\n\n    int find(int v){\n        return father[v]=father[v]==v?v:find(father[v]);\n    }\n\n    void merge(int x,int y){\n        int a=find(x),b=find(y);\n        if(rank[a]&lt;rank[b]){\n            father[a]=b;\n        }else{\n            father[b]=a;\n            if(rank[a]==rank[b]){\n                ++rank[a];\n            }\n        }\n    }\n\n    int getCnum(){\n        int ans=0;\n        for(int i=1;i&lt;Num;++i){\n            if(father[i]==i) ans++;\n        }\n        return ans-1;\n    }\n};\n\nint main(){\n    int m,n;\n\n    while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){\n        DisjointSet ds(n+1);\n        int s,t;\n        scanf(&quot;%d&quot;,&amp;m);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d %d&quot;,&amp;s,&amp;t);\n            ds.merge(s,t);\n        }\n        printf(&quot;%d\\n&quot;,ds.getCnum());\n    }\n    return 0;\n}</code></pre><h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><h1 id=\"线段树区间更新和查询\"><a href=\"#线段树区间更新和查询\" class=\"headerlink\" title=\"线段树区间更新和查询\"></a>线段树区间更新和查询</h1><p>POJ 3468</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q;\nLL lazy[maxn];\nLL sum[maxn];\nLL tree[maxn];\nLL a[maxn];\n\nvoid build(int p,int l,int r){\n    if(l==r){tree[p]=a[l];return;}\n    int mid=(l+r)&gt;&gt;1;\n    build(p&lt;&lt;1,l,mid);\n    build(p&lt;&lt;1|1,mid+1,r);\n    tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];\n}\n\nvoid PushDown(int p,int m){\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nLL find(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return tree[p];\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=find(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=find(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n    for(int i=1;i&lt;=N;++i) scanf(&quot;%lld&quot;,&amp;a[i]);\n    build(1,1,N);\n    char op;\n    int l,r,c;\n    while(Q--){\n        cin&gt;&gt;op;\n        if(op==&apos;Q&apos;){\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            printf(&quot;%lld\\n&quot;,Query(1,1,N,l,r)+find(1,1,N,l,r));\n        }else if(op==&apos;C&apos;){\n            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);\n            update(1,1,N,c,l,r);\n        }\n    }\n    return 0;\n}</code></pre>","text":"2018/2/13,头有点晕emmmm…所以学一波数据结构,暂缓数论剩下的高深理论…注意,这波数据结构是为了补充以前所不足的而撰写的,并无重头再来的意思.并查集要领以前使用并查集多用于Kruskal的优化,现在要拓宽一下了.并查集是不可能分割的,即只能合并,不可分割.在牛客上听大","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"并查集","slug":"HDU/并查集","count":1,"path":"api/categories/HDU/并查集.json"}],"tags":[{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"}]},{"title":"POJ 1182","slug":"poj-1182","date":"2017-04-12T10:10:17.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-1182.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>并查集</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>const int MAX_N=150000+10;</strong> <strong>int N,K;</strong> <strong>int T[MAX_N],X[MAX_N],Y[MAX_N];</strong> <strong>//并查集</strong> <strong>int par[MAX_N];//父亲</strong> <strong>int rank[MAX_N];//树的高度</strong> <strong>void init(int n){</strong> **    for(int i=0;i&lt;n;++i){** **        par[i]=i;** **        rank[i]=0;** **    }** <strong>}</strong> <strong>//查询树的根</strong> <strong>int find(int x){</strong> **    if(par[x]==x){** **        return x;** **    }else{** **        return par[x]=find(par[x]);** **    }** <strong>}</strong> <strong>//合并x和y所属集合</strong> <strong>void unite(int x,int y){</strong> **    x=find(x);** **    y=find(y);** **    if(x==y) return;** **    if(rank[x]&lt;rank[y]){** **        par[x]=y;** **    }else{** **        par[y]=x;** **        if(rank[x]==rank[y]) rank[x]++;** **    }** <strong>}</strong> <strong>//判断x和y是否属于同一个集合</strong> <strong>bool same(int x,int y){</strong> **    return find(x)==find(y);** <strong>}</strong> <strong>void solve(){</strong> **    //初始化并查集** **    //元素X,X+N,X+2N分别代表X-A,X-B,X-C** **    init(N<em>3);*</em> **    int ans=0;** **    for(int i=0;i&lt;K;++i){** **        int t=T[i];** **        int x=X[i]-1,y=Y[i]-1;//将x,y转换为从下标为0开始编号的号码** **        if(x&lt;0||x&gt;=N||y&lt;0||y&gt;=N){//不满足条件2** **            ans++;** **            continue;** **        }** **        if(t==1){** **            if(same(x,y+N)||same(x,y+2<em>N)){*</em> **                ans++;** **            }else{** **                unite(x,y);** **                unite(x+N,y+N);** **                unite(x+2*N,y+2*N);** **            }** **        }else{** **            if(same(x,y) || same(x,y+2<em>N)){*</em> **                ans++;** **            }else{** **                unite(x,y+N);** **                unite(x+N,y+2<em>N);*</em> **                unite(x+2<em>N,y);*</em> **            }** **        }** **    }** **    printf(“%d\\n”,ans);** <strong>}</strong> <strong>int main(){</strong> **    scanf(“%d%d”,&amp;N,&amp;K);** **    for(int i=0;i&lt;K;++i){** **        scanf(“%d%d%d”,&amp;T[i],&amp;X[i],&amp;Y[i]);** **    }** **    solve();** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 并查集 【Code】#include #include using namespace std; const int MAX_N=150000+10; int N,K; int T[MAX_N],X[MAX_N],Y[MAX_N]; //并查集 int par[MAX_","link":"","raw":null,"photos":[],"categories":[{"name":"并查集","slug":"并查集","count":1,"path":"api/categories/并查集.json"},{"name":"数据结构","slug":"并查集/数据结构","count":1,"path":"api/categories/并查集/数据结构.json"}],"tags":[{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"}]},{"title":"POJ 3723","slug":"poj-3723","date":"2017-04-14T02:57:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3723.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>并查集优化kruskal</strong> <strong>【Tip】</strong> <strong>并查集使得可以判断任意两点是否可归溯于同一点,藉此来判断若链接两点是否会形成一个环.</strong> <strong>这道题的输入是两个人以及两个人之间的亲密关系,征募某个人的花费为10000-(已征募人中亲密关系和自己的最大值).</strong> <strong>这里我们在每征募某个人a时,若使用了a,b的关系,就连一条a,b的边。</strong> <strong>如果这个图中存在圈,则一定会出现矛盾(谁是第一个被征募的？).</strong> <strong>所以这个图一定是森林.</strong> <strong>把人看做顶点.关系看做边,则这个问题就可以转化为求解无向图中的最大权森林问题(即亲密度之和最大),最大权森林问题可以通过把所有边权取反来求最小生成树.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>using namespace std;</strong> <strong>const int MAX_N=60000;</strong> <strong>struct edge{</strong> <em>*    int u,v,cost;** <strong>};</strong> <strong>bool comp(const edge&amp; e1,const edge&amp; e2){</strong> **    return e1.cost&lt;e2.cost;** <strong>}</strong> <strong>edge es[MAX_N];</strong> <strong>int V,E;//顶点数和边数</strong> <strong>//并查集</strong> <strong>int par[MAX_N];//父亲</strong> <strong>int rank[MAX_N];//树的高度</strong> <strong>void init_union_find(int n){</strong> **    for(int i=0;i&lt;n;++i){** **        par[i]=i;** **        rank[i]=0;** **    }** <strong>}</strong> <strong>//查询树的根</strong> <strong>int find(int x){</strong> **    if(par[x]==x){** **        return x;** **    }else{** **        return par[x]=find(par[x]);** **    }** <strong>}</strong> <strong>//合并x和y所属集合</strong> <strong>void unite(int x,int y){</strong> **    x=find(x);** **    y=find(y);** **    if(x==y) return;** **    if(rank[x]&lt;rank[y]){** **        par[x]=y;** **    }else{** **        par[y]=x;** **        if(rank[x]==rank[y]) rank[x]++;** **    }** <strong>}</strong> <strong>//判断x和y是否属于同一个集合</strong> <strong>bool same(int x,int y){</strong> **    return find(x)==find(y);** <strong>}</strong> <strong>int kruskal(){</strong> **    sort(es,es+E,comp);** **    int res=0;** **    init_union_find(V);** **    for(int i=0;i&lt;E;++i){** **        edge e=es[i];** **        if(!same(e.u,e.v)){** **            unite(e.u,e.v);** **            res+=e.cost;** **        }** **    }** **    return res;** <strong>}</strong> <strong>int main(){</strong> **    int N;** **    scanf(“%d”,&amp;N);** **    while(N–){** **        int B,G,R;** **        scanf(“%d%d%d”,&amp;G,&amp;B,&amp;R);** **        V=G+B;** **        E=R;** **        for(int i=0;i&lt;R;++i){** **            int a,b,c;** **            scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **            es[i]=(edge){a,G+b,-c};** **        }** **        printf(“%d\\n”,10000</em>(V)+kruskal());** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 并查集优化kruskal 【Tip】 并查集使得可以判断任意两点是否可归溯于同一点,藉此来判断若链接两点是否会形成一个环. 这道题的输入是两个人以及两个人之间的亲密关系,征募某个人的花费为10000-(已征募人中亲密关系和自己的最大值). 这里我们在每征募某个人a时,若","link":"","raw":null,"photos":[],"categories":[{"name":"kruskal","slug":"kruskal","count":1,"path":"api/categories/kruskal.json"},{"name":"POJ","slug":"kruskal/POJ","count":1,"path":"api/categories/kruskal/POJ.json"},{"name":"并查集","slug":"kruskal/POJ/并查集","count":1,"path":"api/categories/kruskal/POJ/并查集.json"}],"tags":[{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"}]},{"title":"PTA 朋友圈 并查集","slug":"pta-fiend-ufs","date":"2017-05-27T09:53:06.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/pta-fiend-ufs.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>并查集</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/PAT-/blob/master/pta%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5-25.cpp\" target=\"_blank\" rel=\"noopener\">5-25.cpp</a></strong></p>\n","text":"【类型】 并查集 【Code】 5-25.cpp","link":"","raw":null,"photos":[],"categories":[{"name":"PTA","slug":"PTA","count":1,"path":"api/categories/PTA.json"},{"name":"并查集","slug":"PTA/并查集","count":1,"path":"api/categories/PTA/并查集.json"}],"tags":[{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"pta","slug":"pta","count":2,"path":"api/tags/pta.json"}]},{"title":"ccf 2017前四题","slug":"ccf-2017-pre-f","date":"2017-08-19T05:25:33.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2017-pre-f.json","excerpt":"","keywords":null,"cover":null,"content":"<p>第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *<em>要登录和会员 *</em> <a href=\"http://118.190.20.162/home.page\" target=\"_blank\" rel=\"noopener\">http://118.190.20.162/home.page</a> github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/tree/master/CCSP/2017-3\" title=\"CCF 2017-3 前四题\" target=\"_blank\" rel=\"noopener\">CCF 2017-3 前四题</a> 第一题:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    int N,K;\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;K)){\n        int ans=0,d,n=0;\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;d);\n            n+=d;\n            if(n&gt;=K){\n                n=0;\n                ans++;\n            }\n        }\n        if(n)ans++;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>第二题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint N,M;\nint I,J;\n\nlist&lt;int&gt; li;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        li.clear();\n        for(int i=1;i&lt;=N;++i){\n            li.push_back(i);\n        }\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%d%d&quot;,&amp;I,&amp;J);\n            if(J==0)continue;\n            list&lt;int&gt;::iterator it,it2;\n            for(it=li.begin();*it!=I;it++){}\n            it2=it;\n            int flag=J&gt;0?1:-1;\n            J=abs(J)+(flag&gt;0?1:0);\n            while(J){\n                J--;\n                flag&gt;0?it++:it--;\n            }\n            li.insert(it,I);\n            li.erase(it2);\n        }\n        list&lt;int&gt;::iterator it;\n        it=li.begin();\n        printf(&quot;%d&quot;,*it);\n        it++;\n        for(;it!=li.end();it++){\n            printf(&quot; %d&quot;,*it);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>第三题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define BUF_SS 101\n\nusing namespace std;\n\nchar buf[101];\nint pre=-1;\n\nint check_hl(int st){\n    char hr[100];\n    string tip;\n    int ind=st+1,cs=0,hs=0;\n    while(buf[ind]!=&apos;]&apos;){\n        if(buf[ind]==&apos;_&apos;){\n            tip+=&quot;&lt;em&gt;&quot;;\n            ind++;\n            while(buf[ind]!=&apos;_&apos;){\n                tip+=buf[ind];\n                ind++;\n            }\n            tip+=&quot;&lt;/em&gt;&quot;;\n            ind++;\n        }else{\n            tip+=buf[ind];\n            ind++;\n        }\n    }\n    ind+=2;\n    while(buf[ind]!=&apos;)&apos;){\n        hr[hs++]=buf[ind];\n        ind++;\n    }\n    hr[hs]=&apos;\\0&apos;;\n    printf(&quot;&lt;a href=\\&quot;%s\\&quot;&gt;&quot;,hr);\n    cout&lt;&lt;tip&lt;&lt;&quot;&lt;/a&gt;&quot;;\n    return ind-st;\n}\n\nint check_em(int st){\n    int ind=st+1;\n    printf(&quot;&lt;em&gt;&quot;);\n    while(buf[ind]!=&apos;_&apos;){\n        if(buf[ind]==&apos;[&apos;){\n            int ed=check_hl(ind);\n            ind+=(ed+1);\n        }else{\n            putchar(buf[ind]);\n            ind++;\n        }\n    }\n    printf(&quot;&lt;/em&gt;&quot;);\n    return ind-st;\n}\n\nvoid check_h(int sz){\n    int n,r=0;\n    char sts[20],ste[20];\n    while(buf[r]==&apos;#&apos;){\n        r++;\n    }\n    int s=r,e=sz-1;\n    sprintf(sts,&quot;&lt;h%d&gt;&quot;,r);\n    sprintf(ste,&quot;&lt;/h%d&gt;&quot;,r);\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;%s&quot;,sts);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;%s\\n&quot;,ste);\n}\n\nvoid check_u(int sz){\n    if(pre!=2)printf(&quot;&lt;ul&gt;\\n&quot;);\n    int s=1,e=sz-1;\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;&lt;li&gt;&quot;);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;&lt;/li&gt;\\n&quot;);\n}\n\nvoid check_p(int sz){\n    if(pre!=3)printf(&quot;&lt;p&gt;&quot;);\n    if(pre==3)putchar(&apos;\\n&apos;);\n    for(int i=0;buf[i]!=&apos;\\n&apos; &amp;&amp; i&lt;sz;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n}\n\nint main(){\n    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n    while(fgets(buf,BUF_SS,stdin)){\n        if(buf[0]==&apos;\\n&apos;){\n            if(pre==3){\n                printf(&quot;&lt;/p&gt;\\n&quot;);\n                pre=0;continue;\n            }else if(pre==2){\n                printf(&quot;&lt;/ul&gt;\\n&quot;);\n                pre=0;continue;\n            }\n            continue;\n        }\n        int sz=strlen(buf);\n        if(buf[0]==&apos;#&apos;) check_h(sz),pre=1;\n        else if(buf[0]==&apos;*&apos;) check_u(sz),pre=2;\n        else check_p(sz),pre=3;\n    }\n    if(pre==3)printf(&quot;&lt;/p&gt;\\n&quot;);\n    if(pre==2)printf(&quot;&lt;/ul&gt;\\n&quot;);\n    return 0;\n}</code></pre><p>写题的时候写了一组测试数据: In[1]:</p>\n<pre><code># Heading\n\n## Sub-heading\n\nParagraphs are separated\nby a blank line.\n\nText attributes _italic_.\n\nBullet list:\n\n*      apples\n* oranges\n* pears\n\nA _[NLJ6link616lins1](http://example.com)_.\n\n[NLJ6_link_616_lins_1](http://example.com)</code></pre><p>out[1]:</p>\n<pre><code>&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;h2&gt;Sub-heading&lt;/h2&gt;\n&lt;p&gt;Paragraphs are separated\nby a blank line.&lt;/p&gt;\n&lt;p&gt;Text attributes &lt;em&gt;italic&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Bullet list:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;apples&lt;/li&gt;\n&lt;li&gt;oranges&lt;/li&gt;\n&lt;li&gt;pears&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A &lt;em&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6link616lins1&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6&lt;em&gt;link&lt;/em&gt;616&lt;em&gt;lins&lt;/em&gt;1&lt;/a&gt;&lt;/p&gt;</code></pre><p>第四题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAX_M=200000+10;\nconst int maxn=200000+10;\nint N,M;\nint A,B,C;\n\nstruct Edge{\n    int from,to,dist;\n};\nstruct HeapNode{\n    int d,from,to;\n    bool operator&lt;(const HeapNode&amp; rhs)const{\n        return d&gt;rhs.d;\n    }\n};\n\nstruct Kruskal{\n    int n,m;///点数和边数\n    vector&lt;Edge&gt; edges;///边表\n    vector&lt;int&gt; G[maxn];///每个节点出发的边编号\n    priority_queue&lt;HeapNode&gt; Q;\n\n    ///并查集\n    int fa[maxn];///父亲\n    int ra[maxn];///高度\n    ///init:初始化(点数)\n    ///find_Root:查找树的根\n    ///unite:合并x和y所属集合\n    ///same:判断x和y是否是同一个集合\n    void init(int n){\n        this-&gt;n=n;\n        for(int i=0;i&lt;n;++i){\n            fa[i]=i;\n            ra[i]=0;\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    int find_Root(int x){\n        if(fa[x]==x){\n            return x;\n        }else{\n            return fa[x]=find_Root(fa[x]);\n        }\n    }\n    void unite(int x,int y){\n        x=find_Root(x);\n        y=find_Root(y);\n        if(x==y) return;\n\n        if(ra[x]&lt;ra[y]){\n            fa[x]=y;\n        }else{\n            fa[y]=x;\n        }\n    }\n    bool same(int x,int y){\n        return find_Root(x)==find_Root(y);\n    }\n\n    void AddEdge(int from,int to,int dist){\n        edges.push_back((Edge){from,to,dist});\n        m=edges.size()-1;\n        G[from].push_back(m-1);\n        Q.push((HeapNode){dist,from,to});\n    }\n\n    int kruskal(){\n        HeapNode h;\n        while(!Q.empty()){\n            if(find_Root(N)==find_Root(1))break;\n            h=Q.top();Q.pop();\n            if(find_Root(h.from)==find_Root(h.to))continue;\n            unite(h.from,h.to);\n        }\n        printf(&quot;%d\\n&quot;,h. d);\n    }\n}K;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        K.init(N);\n        for(int i=0;i&lt;M;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);\n            K.AddEdge(A,B,C);\n        }\n        K.kruskal();\n    }\n    return 0;\n}</code></pre>","text":"第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *要登录和会员 * http://118.190.20.162/home.page git","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"kruskal","slug":"ccf/kruskal","count":1,"path":"api/categories/ccf/kruskal.json"},{"name":"并查集","slug":"ccf/kruskal/并查集","count":1,"path":"api/categories/ccf/kruskal/并查集.json"},{"name":"模拟","slug":"ccf/kruskal/并查集/模拟","count":1,"path":"api/categories/ccf/kruskal/并查集/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"},{"name":"CCF","slug":"CCF","count":1,"path":"api/tags/CCF.json"}]}]}