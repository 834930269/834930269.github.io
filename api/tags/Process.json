{"name":"Process","slug":"Process","count":2,"postlist":[{"title":"Windows下fork()进程","slug":"on-windows-fork-process","date":"2017-10-05T02:29:10.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/on-windows-fork-process.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171005101046-1.png","content":"<p>和Unix下一样,windows下也可以fork一个子进程. 不过需要引用multiprocessing.Process模块. 代码如下:</p>\n<pre><code>from multiprocessing import Process\nimport os\n\ndef run_proc(name):\n    print(&apos;Run child process %s (%s)...&apos; % (name,os.getpid()))\n\nif __name__ == &apos;__main__&apos;:\n    print(&apos;Parent process %s.&apos; % os.getpid())\n    p=Process(target=run_proc,args=(&apos;test&apos;,))\n\n    print(&apos;Child process will start.&apos;)\n    p.start()\n    p.join()\n    print(&apos;Child process end.&apos;)</code></pre><p>之后运行需要在cmd下运行.因为创建子进程的命令无法在IDLE中执行.(或者说进程的pid就是IDLE的pid?) 结果如下: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171005101046-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171005101046-1.png\" alt></a></p>\n","text":"和Unix下一样,windows下也可以fork一个子进程. 不过需要引用multiprocessing.Process模块. 代码如下:from multiprocessing import Processimport osdef run_proc(name):    prin","link":"","raw":null,"photos":[],"categories":[{"name":"Process","slug":"Process","count":2,"path":"api/categories/Process.json"}],"tags":[{"name":"Process","slug":"Process","count":2,"path":"api/tags/Process.json"}]},{"title":"关于Python-threading中的args参数传递到std中","slug":"python-threading-args-on-pass-on-std","date":"2017-10-05T05:32:23.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/python-threading-args-on-pass-on-std.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171005132855.png","content":"<p>示例代码及标注如下</p>\n<pre><code>import threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    # 获取当前线程关联的student:\n    std = local_school.student\n    #以下这句证明了std是args的第一个元素的值\n    if isinstance(std,list):\n        print(std[2][&apos;Hello&apos;])\n    print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=([&apos;Alice&apos;,123,{&quot;Hello&quot;:&quot;seek&quot;}],), name=&apos;Thread-A&apos;)\nt2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)\nt1.start()\nt2.start()\nt1.join()\nt2.join()</code></pre><p>结果如下: <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171005132855.png\" alt=\"Aaron\"> 可以看到,第一个参数的第三个参数是dict类型,,不是string. 而且所有的参数都是在args的第一个元素内传递的.</p>\n","text":"示例代码及标注如下import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student():    # 获取当前线程关联的student:    std = local_sc","link":"","raw":null,"photos":[],"categories":[{"name":"Process","slug":"Process","count":2,"path":"api/categories/Process.json"}],"tags":[{"name":"Process","slug":"Process","count":2,"path":"api/tags/Process.json"}]}]}