{"name":"组合数学","slug":"组合数学","count":12,"postlist":[{"title":"51nod 1119 机器人走方格V2","slug":"51nod-1119-reboot-in-v2","date":"2018-03-07T07:42:36.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1119-reboot-in-v2.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-组合数学-二项式定理-逆元\"><a href=\"#Type-组合数学-二项式定理-逆元\" class=\"headerlink\" title=\"Type: 组合数学,二项式定理,逆元\"></a>Type: 组合数学,二项式定理,逆元</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>M * N的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行，2个数M,N，中间用空格隔开。（2 &lt;= m,n &lt;= 1000000)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出走法的数量 Mod 10^9 + 7。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>2 3</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>3</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>画一下图会发现这就是杨辉三角,而我们需要求的是C(N+M-2,N-1) 用逆元和递推公式算一下就可以了</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int maxn=1000000+10;\nint m,n;\n\nLL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}\n\nLL solve(int N,int M){\n    ///ans=C(N,M)\n    //cout&lt;&lt;N&lt;&lt;&quot; &quot;&lt;&lt;M&lt;&lt;endl;\n    LL ans=1;\n    for(int i=1;i&lt;=M;++i){\n        ans=ans*(N-i+1)*1ll%mod*inv[i]%mod;\n    }\n    return ans;\n}\n\nint main(){\n    init();\n    while(cin&gt;&gt;m&gt;&gt;n){\n        cout&lt;&lt;solve(n+m-2,n-1)&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type: 组合数学,二项式定理,逆元题目M * N的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。Input第1行，2个数M,N，中间用空格隔开。（2 &lt;= m,n &lt;= 100","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"二项式定理","slug":"51nod/二项式定理","count":1,"path":"api/categories/51nod/二项式定理.json"},{"name":"组合数学","slug":"51nod/二项式定理/组合数学","count":1,"path":"api/categories/51nod/二项式定理/组合数学.json"},{"name":"逆元","slug":"51nod/二项式定理/组合数学/逆元","count":1,"path":"api/categories/51nod/二项式定理/组合数学/逆元.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"二项式定理","slug":"二项式定理","count":1,"path":"api/tags/二项式定理.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"}]},{"title":"51nod 1120 机器人走方格 V3","slug":"51nod-1120-rm-v3","date":"2018-03-07T12:59:38.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1120-rm-v3.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png","content":"<h1 id=\"Type-Lucas-Catalan序列-逆元\"><a href=\"#Type-Lucas-Catalan序列-逆元\" class=\"headerlink\" title=\"Type:Lucas+Catalan序列+逆元\"></a>Type:Lucas+Catalan序列+逆元</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>输入一个数N(2 &lt;= N &lt;= 10^9)。</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出走法的数量 Mod 10007。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>4</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>10</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>画图会发现就是一个Catalan序列, 但我一开始没理解题意,原来只是不能跨过斜线,但可以在斜线上走…</p>\n<blockquote>\n<p>在Excel中画了一下,因为两边是对称的,所以我们只需要求一边,将最终的答案*2即可.</p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png\" alt></p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=10007;\n\nLL Pow(LL a,LL b,LL p){\n    LL ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%p;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%p;\n    }\n    return ans;\n}\n\nLL Comb(LL a,LL b,LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Pow(cb, p-2,p))%p;\n    return ans;\n}\nLL Lucas(LL n, LL m, LL p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inv(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nint main(){\n    LL N;\n    while(cin&gt;&gt;N){\n        N=N-1;\n        LL d1,d2;\n        LL x=Lucas(2*N,N,mod);\n        LL d=inv(N+1,mod);\n        //cout&lt;&lt;&quot;Lucas: &quot;&lt;&lt;x&lt;&lt;endl;\n        //cout&lt;&lt;&quot;Inv: &quot;&lt;&lt;d&lt;&lt;endl;\n        cout&lt;&lt;2*x*d%mod&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:Lucas+Catalan序列+逆元题目N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。Input输入一个","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"Catalan","slug":"51nod/Catalan","count":1,"path":"api/categories/51nod/Catalan.json"},{"name":"Lucas","slug":"51nod/Catalan/Lucas","count":1,"path":"api/categories/51nod/Catalan/Lucas.json"},{"name":"数论","slug":"51nod/Catalan/Lucas/数论","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论.json"},{"name":"组合数学","slug":"51nod/Catalan/Lucas/数论/组合数学","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学.json"},{"name":"逆元","slug":"51nod/Catalan/Lucas/数论/组合数学/逆元","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"Catalan","slug":"Catalan","count":1,"path":"api/tags/Catalan.json"},{"name":"Lucas","slug":"Lucas","count":1,"path":"api/tags/Lucas.json"}]},{"title":"51nod 1383 整数分解为2的幂","slug":"51nod-1383-2-mo","date":"2018-03-07T04:50:34.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1383-2-mo.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-组合数学-母函数\"><a href=\"#Type-组合数学-母函数\" class=\"headerlink\" title=\"Type: 组合数学,母函数\"></a>Type: 组合数学,母函数</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>任何正整数都能分解成2的幂，给定整数N，求N的此类划分方法的数量！由于方案数量较大，输出Mod 1000000007的结果。 比如N = 7时，共有6种划分方法。 7=1+1+1+1+1+1+1 =1+1+1+1+1+2 =1+1+1+2+2 =1+2+2+2 =1+1+1+4 =1+2+4</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>输入一个数N（1 &lt;= N &lt;= 10^6)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出划分方法的数量Mod 1000000007</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>7</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>6</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>生成函数</p>\n<blockquote>\n<p>我们可以将题意理解为:</p>\n<blockquote>\n<p>有1,2,4,…,2^N&lt;=1000000 种物品可以选择,每种物品可以选择数量为无限,问你当背包重量为 M 时有多少种选择.</p>\n</blockquote>\n</blockquote>\n<p>列出生成函数为:</p>\n<blockquote>\n<p>g(m)=(1+x+x^2+x^3+…)(1+x^2+x^4+x^6+…) (1+x^4+x^8+x^12+…)(1+x^8+x^16+x^24+…) …(1+x^19) | (因为x^20&gt;1e6)</p>\n</blockquote>\n<p>只需要求出展开式中每项的序数即可,输入 N 输出 K[N] 我们给定一个数组 c1 作为储存系数用.</p>\n<blockquote>\n<p>只需要将每个括号内的式子乘入数组 c1 即可.</p>\n<blockquote>\n<p>限制条件为 i=2^t &lt;= 1000000 j+i &lt;= 1000000</p>\n</blockquote>\n</blockquote>\n<p>所有的计算都向第一个括号 (1+x+x^2+…+x^1000000) 为基准进行合并，合并到 j+i&gt;1000000 为止. 其他部分解释放在代码中</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=1000100;\nint c1[maxn]={1};\n\ninline void init(int n){\n    for(int i=1;i&lt;=n;i&lt;&lt;=1){\n        for(int j=0;(j+i)&lt;=n;++j){\n            ///j+i是 当前值为j,加上第log2(i)括号内的等差幂次i\n            ///后计算出目标待加值为 (j+i)\n            ///即幂次为(j+i)的母函数系数计算过程为:\n            /// (k)x^(i+j)=(k1)x^j*x^i*(k2)x^(i+j)\n            /// 即 k=k1+k2\n            /// 即 c1[j+i]=c[j]+c[j+i]\n            ///x^i系数为1因为生成函数第log2(i)个括\n            ///号中所有x^i的系数为1\n            c1[j+i]=(c1[j+i]+c1[j])%mod;\n        }\n    }\n}\n\n\nint main(){\n    init(1000000);\n    int N;\n\n    while(cin&gt;&gt;N){\n        cout&lt;&lt;c1[N]&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type: 组合数学,母函数题目任何正整数都能分解成2的幂，给定整数N，求N的此类划分方法的数量！由于方案数量较大，输出Mod 1000000007的结果。 比如N = 7时，共有6种划分方法。 7=1+1+1+1+1+1+1 =1+1+1+1+1+2 =1+1+1+2+2 =1","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"母函数","slug":"51nod/母函数","count":1,"path":"api/categories/51nod/母函数.json"},{"name":"组合数学","slug":"51nod/母函数/组合数学","count":1,"path":"api/categories/51nod/母函数/组合数学.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"母函数","slug":"母函数","count":1,"path":"api/tags/母函数.json"}]},{"title":"山东省第八届ACM省赛 fireworks","slug":"fireworks","date":"2018-02-18T12:54:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/fireworks.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>迟来的祝福,新年快乐.</p>\n</blockquote>\n<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><blockquote>\n<p>要登录</p>\n</blockquote>\n<p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" title=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html</a></p>\n<h1 id=\"Type-杨辉三角-lt-组合数学-逆元\"><a href=\"#Type-杨辉三角-lt-组合数学-逆元\" class=\"headerlink\" title=\"Type: 杨辉三角&lt;-组合数学,逆元\"></a>Type: 杨辉三角&lt;-组合数学,逆元</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>假设x位置有一个烟花,则每秒烟花都会分裂到x+1与x-1这两个位置. 给你n个烟花的初始位置xi和个数ci,问你T秒后,位置w上的烟花个数有多少个.</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>画一下样例的图会发现很像杨辉三角,我们可以将每个初始点分开计算,最后的结果就是所有初始点分裂后落在目标点的烟花个数和. 但我们发现它们的初始值大小与杨辉三角不同,并且比杨辉三角多了许多0, 然后我们考虑如何解决这两个情况.</p>\n<blockquote>\n<p>(1) 初始值ci,因为只有一个初始点,这点和杨辉三角一样.所以答案是</p>\n<blockquote>\n<p>ans(原杨辉三角在该位置的结果)*ci</p>\n</blockquote>\n<p>(2) 中间有0,这点好想,我们只需要通过推导公式将实际坐标转换为逻辑坐标即可.</p>\n</blockquote>\n<p>然后我们分情况讨论,我们在图上可以发现</p>\n<blockquote>\n<p>(1) 当 <code>分裂次数</code> 与 <code>目标位置和原位置的距离差</code> 同奇偶时该位置结果为0. (2) 当距离大于T+1时(即杨辉三角第T行值的个数),永远不可能分裂到.</p>\n</blockquote>\n<p>因为只需要考虑最后一次分裂的结果,所以只需要计算杨辉三角第T行即可,即 C(T,0<del>T) 预处理组合公式我们用 <code>组合数学</code> 性质4那个公式. 所以我们需要预处理一下1</del>1e5的逆元,将除法转换为乘法. 最后答案就是</p>\n<blockquote>\n<p>ans=Sigma(i=1~n,c*C[实际位置] | 根据情况忽略i)</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int MOD = 1e9+7;\nconst int maxn = 1e5+7;\n\nLL C[maxn];\n///逆元\nLL inv[maxn];\nvoid init_(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(MOD-MOD/i)*1ll*inv[MOD%i]%MOD;\n    }\n}\n\n///快速幂模求逆元,调动方式quick_mod(i,MOD-2)\n//这里我们用预处理.\nLL quick_mod(LL x, int n){\n    LL ret = 1;\n    while(n){\n        if(n &amp; 1) ret = ret * x % MOD;\n        x = x * x %MOD;\n        n &gt;&gt;= 1;\n    }\n    return ret;\n}\n\nvoid init(int t){\n    C[0]=1;\n    for(int i=1;i&lt;=t;++i){\n        C[i]=C[i-1]*(t-i+1)*1ll%MOD*inv[i]%MOD;\n        //printf(&quot;Num: %d %lld, INV: %lld\\n&quot;,i,C[i],inv[i]);\n    }\n}\n//判断是否同奇同偶\nbool same(int x,int y){\n    if((x&amp;1)^(y&amp;1)) return false;\n    return true;\n}\n\nint query(int t,int d){\n    if(t&amp;1){\n        return t/2-d/2;\n    }\n    return t/2+(d-1)/2;\n}\n\nint main(){\n    init_();\n    int n,T,w;\n    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;T,&amp;w)){\n        init(T);\n        LL ans=0;\n        for(int i=1;i&lt;=n;++i){\n            int x,c;\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;c);\n            int dist=abs(x-w);\n            if(!same(T+1,dist) &amp;&amp; dist&lt;T+1){\n                ans=(ans+c*C[query(T+1,dist)]%MOD)%MOD;\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n\n    return 0;\n}</code></pre>","text":"迟来的祝福,新年快乐.Link要登录http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.htmlType: 杨辉三角&lt;-组合数学,逆元题意假设x位置有一个烟花,则每秒","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"二项式定理","slug":"Sdut/二项式定理","count":1,"path":"api/categories/Sdut/二项式定理.json"},{"name":"数论","slug":"Sdut/二项式定理/数论","count":1,"path":"api/categories/Sdut/二项式定理/数论.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛.json"},{"name":"组合数学","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"poj 3370","slug":"poj-3370","date":"2018-01-26T07:47:40.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-3370.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【鸽巢原理】 题意: 给你两个整数c和n,以及n个整数,问这n个整数中是否有一些整数和为c的倍数. 同样可以证明,当c&lt;=n时,同样可以使用鸽巢原理证明有连续的序列和为c的倍数. 另外有一点是,Sigma ai最大可能100000^2.所以要用long long存. PS:这道题用G++提交就超时了…C++提交无事.WTF</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=100000+10;\nlong long sum[maxn];\nint num;\nint r[maxn];\nint c,n;\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;c,&amp;n)&amp;&amp;c&amp;&amp;n){\n        memset(r,0,sizeof(r));\n        int k=0,l=1;\n        sum[0]=0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;num);\n            sum[i]=sum[i-1]+num;\n\n            int remainder=sum[i]%c;\n            if(remainder==0){\n                k=0;\n                l=i;\n            }else if(r[remainder]){\n                k=r[remainder];\n                l=i;\n            }else r[remainder]=i;\n        }\n        printf(&quot;%d&quot;,k+1);\n        for(int i=k+2;i&lt;=l;++i){\n            printf(&quot; %d&quot;,i);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【鸽巢原理】 题意: 给你两个整数c和n,以及n个整数,问这n个整数中是否有一些整数和为c的倍数. 同样可以证明,当c&lt;=n时,同样可以使用鸽巢原理证明有连续的序列和为c的倍数. 另外有一点是,Sigma ai最大可能100000^2.所以要用long long存. PS:","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"组合数学","slug":"POJ/组合数学","count":1,"path":"api/categories/POJ/组合数学.json"},{"name":"鸽巢原理","slug":"POJ/组合数学/鸽巢原理","count":1,"path":"api/categories/POJ/组合数学/鸽巢原理.json"}],"tags":[{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"鸽巢原理","slug":"鸽巢原理","count":1,"path":"api/tags/鸽巢原理.json"}]},{"title":"UVa 11401","slug":"uva-11401","date":"2018-02-04T10:10:32.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11401.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11401\" title=\"https://vjudge.net/problem/UVA-11401\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11401</a></p>\n<h1 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h1><p>组合数学,加法原理,三角形三边定理</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>考虑三角形三边定理.</p>\n<blockquote>\n<p>设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条边. 则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边) 考虑y的取值,确定z的取值.</p>\n<blockquote>\n<p>y∈[1,x-1] 当y取1时,z无值.当y取2时,z有唯一值x-1 当y取3时,z可以取(x-1),(x-2). 故y取x-1时,z可以取的种数为x-2种.</p>\n<blockquote>\n<p>根据等差数列求和公式: 总种类数Sn = 0+1+2+…+(x-2)</p>\n</blockquote>\n<p>Sn = (x-2)(x-1)/2(种) 但这个值并不等于c(x) 因为:</p>\n<blockquote>\n<p>1.对于每个三角形都计数了两遍 =&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2 2.以上的计算方式存在y=z的情况 (这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z) =&gt; 比如x=7 y=4时,z就可以取到4</p>\n<blockquote>\n<p>对于第二种问题的解决很简单. 对于每个x考虑y==z的情况: 设t为c(x)中y=z时的情况总数: 则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.</p>\n</blockquote>\n<p>故t=(x-1)-(x/2+1)+1=x-1-(int)x/2</p>\n</blockquote>\n</blockquote>\n<p>故c(x)=(Sn-t)/2</p>\n<blockquote>\n<p>又因为c(x)是最长边为x时的种类数.</p>\n</blockquote>\n<p>故设f(n)为最长边不超过n时的种类数 根据加法原理,因为互无交集 故 f(n)=c(1)+c(2)+c(3)+…+c(n)</p>\n</blockquote>\n<p>化成递推: f(n)=f(n-1)+c(n)</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11401\ntype: 组合数学,加法原理,三角形三边定理\n题意: 给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形\n\n题解:\n考虑三角形三边定理.\n设c(x)为以x为最长边的可拼成三角形的数目.\n设y,z为另外两条边.\n则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边)\n考虑y的取值,确定z的取值.\ny∈[1,x-1]\n当y取1时,z无值.当y取2时,z有唯一值x-1\n当y取3时,z可以取(x-1),(x-2).\n故y取x-1时,z可以取的种数为x-2种.\n根据等差数列求和公式:\n总种类数Sn\n= 0+1+2+...+(x-2)\n= (x-2)(x-1)/2(种)\n但这个值并不等于c(x)\n因为:\n1.对于每个三角形都计数了两遍\n=&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2\n2.以上的计算方式存在y=z的情况\n(这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z)\n=&gt; 比如x=7 y=4时,z就可以取到4\n对于第二种问题的解决很简单.\n对于每个x考虑y==z的情况:\n设t为c(x)中y=z时的情况总数:\n则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.\n故t=(x-1)-(x/2+1)+1=x-1-(int)x/2\n故c(x)=(Sn-t)/2\n又因为c(x)是最长边为x时的种类数.\n故设f(n)为最长边不超过n时的种类数\n根据加法原理,因为互无交集\n故 f(n)=c(1)+c(2)+c(3)+...+c(n)\n化成递推: f(n)=f(n-1)+c(n)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nlong long sum[maxn];\nint n;\ninline void init(){\n    long long Sn,Cn,t;\n    memset(sum,0,sizeof(sum));\n    for(long long i=4;i&lt;=1000000;++i){\n        Sn=(i-2)*(i-1)/2;\n        t=i-1-i/2;\n        Cn=(Sn-t)&gt;&gt;1;\n        int id=(int)i;\n        sum[id]=sum[id-1]+Cn;\n    }\n}\nint main(){\n    init();\n    while(cin&gt;&gt;n){\n        if(n&lt;3)break;\n        cout&lt;&lt;sum[n]&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11401type组合数学,加法原理,三角形三边定理题意给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形题解考虑三角形三边定理.设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11538","slug":"uva-11538","date":"2018-02-04T04:55:35.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11538.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"题目连接：\"><a href=\"#题目连接：\" class=\"headerlink\" title=\"题目连接：\"></a>题目连接：</h1><p><a href=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" title=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" target=\"_blank\" rel=\"noopener\">https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087</a> PS: 蓝书P105，书上有一个错误的地方,Sigma(1<del>n-1) i(i-1)那里书上得到的结果是2*Sigma(1</del>n-1) i(i-1)的结果.我在代码中标注了.</p>\n<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link:\"></a>Link:</h1><p><a href=\"https://vjudge.net/problem/UVA-11538\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11538</a> type: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意:\"></a>题意:</h1><p>有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解:\"></a>题解:</h1><blockquote>\n<p>分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线</p>\n<blockquote>\n<p>同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1) 同一列: 合同一行类似,结果是nm(n-1) 同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)</p>\n<blockquote>\n<p>可以观测到所有’/‘方向的斜线长度为: 1,2,3,…,n,n,n,n-1,n-2…,2,1 其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可) 其中每条斜线上的取法种数 = i<em>(i-1) diagonal=Sigma(1~n-1) i(i-1) =&gt; i==1时确实是0种可能,因为皇后是放在块内而不是点上的. 则 All_diagonal = 2(2*diagonal+(m-n+1)*n</em>(n-1)) =&gt; 这里的乘2是因为有两种斜线’/‘和’\\‘的可能 其中</p>\n<blockquote>\n<p>diagonal =Sigma(1<del>n-1) i^2 - Sigma(1</del>n-1) i =n(n-1)(2n-1)/6 - n(n-1)/2 =n(n-1)(2n-4)/6 All_diagonal = 2(2<em>(n(n-1)(2n-4)/6)+(m-n+1)*n\\</em>(n-1)) = 2n(n-1)(3m-n-1)/3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>这三种情况互不相交,最终答案就等于三者和.</p>\n</blockquote>\n<p>Code:</p>\n<pre><code>/*\nLink: https://vjudge.net/problem/UVA-11538\ntype: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6\n\n题意: 有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.\n\n题解: 分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线\n\n同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1)\n同一列: 合同一行类似,结果是nm(n-1)\n同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)\n    可以观测到所有&apos;/&apos;方向的斜线长度为: 1,2,3,...,n,n,n,n-1,n-2...,2,1\n    其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可)\n    其中每条斜线上的取法种数 = i*(i-1)\n    diagonal=Sigma(1~n-1) i(i-1)   =&gt;   i==1时确实是0种可能,因为皇后是放在块内而不是点上的.\n    则   All_diagonal = 2(2*diagonal+(m-n+1)*n*(n-1))  =&gt; 这里的乘2是因为有两种斜线&apos;/&apos;和&apos;\\&apos;的可能\n    其中diagonal=Sigma(1~n-1) i^2 - Sigma(1~n-1) i  =&gt;n方和展开公式,等差数列求和\n                =n(n-1)(2n-1)/6 - n(n-1)/2\n                =n(n-1)(2n-4)/6\n\n        All_diagonal = 2(2*(n(n-1)(2n-4)/6)+(m-n+1)*n*(n-1))\n                     = 2n(n-1)(3m-n-1)/3\n\n这三种情况互不相交,最终答案就等于三者和.\n*/\n\n//Code\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nunsigned long long N,M;\nint main(){\n    while(cin&gt;&gt;N&gt;&gt;M){\n        if(N==0&amp;&amp;M==0)break;\n        unsigned long long row=N*M*(M-1);\n        unsigned long long column=N*M*(N-1);\n\n        if(N&gt;M) swap(N,M);\n        cout&lt;&lt;row+column+2*N*(N-1)*(3*M-N-1)/3&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"题目连接：https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087 PS: 蓝书P105，书上有一个错误的地方,Sigma(1n-1) i(i-1)那里书上得到的结果是2*Sigma(1n-","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11806","slug":"uva-11806","date":"2018-02-05T09:48:17.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11806.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11806\" title=\"https://vjudge.net/problem/UVA-11806\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11806</a></p>\n<h1 id=\"Type\"><a href=\"#Type\" class=\"headerlink\" title=\"Type:\"></a>Type:</h1><blockquote>\n<p>组合数学,排列预处理,容斥原理,减法取模公式</p>\n</blockquote>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,</p>\n<blockquote>\n<p>问最上边,最左边,最下边,最右边都有石子的种数为多少?</p>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>我们可以将问题转化为:</p>\n<blockquote>\n<p>全集|S|-至少有一条边上没有棋子的种类个数. 并且我们可以发现,当四条边上都没有棋子时的种类个数为</p>\n<blockquote>\n<p>C((m-2)*(n-2),k).</p>\n</blockquote>\n<p>我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,D为下边没有石子. 则(我们设~A为非A集合):</p>\n<blockquote>\n<p>ans=|(<del>A)∩(</del>B)∩(<del>C)∩(</del>D)|</p>\n</blockquote>\n<p>可以发现就是容斥原理 至于每个集合的计算,在图中就相当于少了一行或一列, 即:</p>\n<blockquote>\n<p>C(row*column,k)</p>\n</blockquote>\n<p>因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能 即 可以用四位2进制表示</p>\n<blockquote>\n<p>0000 0001 0010</p>\n</blockquote>\n<p>我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行)) 等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0</p>\n</blockquote>\n<p>答案为全部的和.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11806\nType: 组合数学,排列预处理,容斥原理,减法取模公式\n题意: 给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,\n问最上边,最左边,最下边,最右边都有石子的种数为多少?\n\n题解:\n我们可以将问题转化为:\n全集|S|-至少有一条边上没有棋子的种类个数.\n并且我们可以发现,当四条边上都没有棋子时的种类个数为\nC((m-2)*(n-2),k).\n我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,\nD为下边没有石子.\n则(我们设~A为非A集合):\nans=|(~A)∩(~B)∩(~C)∩(~D)|\n可以发现就是容斥原理\n至于每个几何的计算,在图中就相当于少了一行或一列,\n即:\nC(row*column,k)\n因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能\n即 可以用四位2进制表示\n0000\n0001\n0010\n我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行))\n等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0\n答案为全部的和.\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11806Type:组合数学,排列预处理,容斥原理,减法取模公式题意给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,问最上边,最左边,最下边,最右边都有石子的种数为多少?题解我们可以将","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"容斥原理","slug":"UVa/容斥原理","count":1,"path":"api/categories/UVa/容斥原理.json"},{"name":"数论","slug":"UVa/容斥原理/数论","count":1,"path":"api/categories/UVa/容斥原理/数论.json"},{"name":"组合数学","slug":"UVa/容斥原理/数论/组合数学","count":1,"path":"api/categories/UVa/容斥原理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1262","slug":"uva-1262","date":"2017-01-13T15:45:11.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1262.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 组合数学 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-1262\" target=\"_blank\" rel=\"noopener\">UVa-1262-Password</a> 【思路】 见紫书P323例10-8 【WA Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;</cstring></p>\n<p>char m[8][8];<br>char a[8][8];<br>int reg[8][8]={0},n;</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=reg[i][0];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=reg[i][0];<br>        j=n/tot;<br>        printf(“%c”,reg[i][j+1]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        memset(reg,0,sizeof(reg));<br>        int flag=1;<br>        cin&gt;&gt;n;<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>for(int i=1;i&lt;=6;++i)\n        scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\nfor(int j=1;j&lt;=5;++j)\n    for(int t=1;t&lt;=6;++t)\n        for(int i=1;i&lt;=6;++i)\n            if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\]){\n                reg\\[j\\]\\[++reg\\[j\\]\\[0\\]\\]=a\\[t\\]\\[j\\];\n                break;\n            }\n\nfor(int t=1;t&lt;=5;++t){\n    if(reg\\[t\\]\\[0\\]==0) flag=0;\n    sort(&amp;reg\\[t\\]\\[1\\],&amp;reg\\[t\\]\\[reg\\[t\\]\\[0\\]+1\\]);\n}</code></pre><p> /*<br>        for(int t=1;t&lt;=5;++t){<br>            for(int q=1;q&lt;=reg[t][0];++q)<br>                printf(“%c “,reg[t][q]);<br>            printf(“\\n”);<br>        }<br>        */</p>\n<pre><code>    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n<p>【AC Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>char m[10][10];<br>char a[10][10];<br>int n,k[10];<br>vector<char> v[10];</char></p>\n<p>bool init(){</p>\n<p>}</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=k[i];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=k[i];<br>        j=n/tot;<br>        printf(“%c”,v[i][j]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    scanf(“%d”,&amp;N);<br>    while(N–){<br>        for(int i=1;i&lt;=5;++i) v[i].clear();<br>        int flag=1;<br>        scanf(“%d”,&amp;n);<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>    for(int i=1;i&lt;=6;++i)\n            scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\n    for(int j=1;j&lt;=5;++j)\n        for(int t=1;t&lt;=6;++t)\n            for(int i=1;i&lt;=6;++i)\n                if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\])\n                    v\\[j\\].push_back(a\\[t\\]\\[j\\]);\n\n    for(int i=1;i&lt;=5;++i){\n        if(v\\[i\\].empty()){\n            flag=0;\n            break;\n        }\n        sort(v\\[i\\].begin(),v\\[i\\].end());\n        unique(v\\[i\\].begin(),v\\[i\\].end());\n        k\\[i\\]=0;\n        while(k\\[i\\]&lt;v\\[i\\].size()-1 &amp;&amp; v\\[i\\]\\[k\\[i\\]+1\\]&gt;v\\[i\\]\\[k\\[i\\]\\]) k\\[i\\]++;\n        k\\[i\\]++;\n    }\n\n    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n","text":"【类型】 组合数学 【题目来源】 UVa-1262-Password 【思路】 见紫书P323例10-8 【WA Code】#include#include#include#include<br>using namespace std;char m[8][8];<br>char ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1635","slug":"uva-1635","date":"2017-01-10T11:13:32.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1635.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 <a href=\"https://vjudge.net/problem/UVA-1635\" target=\"_blank\" rel=\"noopener\">UVa-1635-Irrelevant Elements</a> 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)<em>(n-k+1)/k. 即 C[i]=C[i-1]</em>(n-i+1)/i. 注意,应该先乘再除,因为C[i-1]/i可能不是整数.但结果一定是整数.而且,因为二项式是递归乘法,所以有时可能会溢出long long,这题就是个例子. 【思路】 因为C(n,i)可能会爆long long,所以先对m做唯一分解，分解成若干素数,并记录每个素数的指数.然后以此计算m的唯一分解式中哥哥素因子在C(n-1,i-1)中的指数即可完成判断.这些指数依然可以用上面那个递推式递推,并且不会涉及高精度. 【参考】 <a href=\"http://blog.csdn.net/u014800748/article/details/43927205\" target=\"_blank\" rel=\"noopener\">Hengjie Yang</a> 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cmath></cmath></p>\n<p>#include<cstring><br>using namespace std;<br>typedef long long LL;<br>LL C[100005];<br>int prime[101][2];<br>int fac_c[100];<br>int N,M;</cstring></p>\n<p>int initM(int m){<br>    int primenum=0;<br>    for(int i=2;i&lt;=sqrt(m);++i){<br>        if(m%i==0){<br>            prime[++primenum][0]=i;<br>            prime[primenum][1]=0;<br>            while(m%i==0){<br>                prime[primenum][1]++;<br>                m/=i;<br>            }<br>        }<br>    }<br>    if(m&gt;1){<br>        prime[++primenum][0]=m;<br>        prime[primenum][1]=1;<br>    }<br>    return primenum;<br>}</p>\n<p>bool check(int m,int k,int primenum){<br>    int a=m-k;<br>    int b=k;<br>    for(int i=1;i&lt;=primenum;++i){<br>        for(;a%prime[i][0]==0;a/=prime[i][0],fac_c[i]++);<br>        for(;b%prime[i][0]==0;b/=prime[i][0],fac_c[i]–);<br>    }<br>    for(int i=1;i&lt;=primenum;++i)<br>        if(prime[i][1]&gt;fac_c[i])<br>        return false;<br>    return true;<br>}</p>\n<p>int main(){<br>    while(cin&gt;&gt;N&gt;&gt;M){<br>        int primenum=initM(M);//唯一分解M,防止爆LL<br>        memset(fac_c,0,sizeof(fac_c));<br>        int cnt=0;//无关数个数<br>        for(int i=1;i&lt;N;++i){<br>            //0~(n-1),这个是组合数C(m,n)的n.  m=n-1 index=i+1<br>            if(check(N,i,primenum))<br>                C[cnt++]=i+1;<br>        }<br>        printf(“%d\\n”,cnt);<br>        for(int i=0;i&lt;cnt;++i)<br>            printf(i==(cnt-1)?”%d\\n”:”%d “,C[i]);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 UVa-1635-Irrelevant Elements 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)(n-k+1)/k. 即 C[i]=C[i-1](n-i+1","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"二项式定理","slug":"UVa/二项式定理","count":1,"path":"api/categories/UVa/二项式定理.json"},{"name":"唯一分解定理","slug":"UVa/二项式定理/唯一分解定理","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理.json"},{"name":"数论","slug":"UVa/二项式定理/唯一分解定理/数论","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论.json"},{"name":"组合数学","slug":"UVa/二项式定理/唯一分解定理/数论/组合数学","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"Wannafly 挑战赛11","slug":"wannafly-cha-11","date":"2018-03-10T00:53:16.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/wannafly-cha-11.json","excerpt":"","keywords":null,"cover":null,"content":"<p>A. 水</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nint main(){\n    LL n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;n+1&lt;&lt;endl;\n    return 0;\n}</code></pre><p>B: 组合数学, 预处理阶乘逆元</p>\n<blockquote>\n<p>因为不可能暴力,所以我们想到是推式子 我们可以把前几项放在Excel表中推一下 然后我们会发现 关于m,n的式子为</p>\n<blockquote>\n<p>常数k*b^(m-1)*a^(n-m)</p>\n<blockquote>\n<p>该式子即为目标结果</p>\n</blockquote>\n<p>如何求常数k呢</p>\n<blockquote>\n<p>设k[n][m] 为n行m列的常数</p>\n<blockquote>\n<p>我们发现 k[n][m]=k[n-1][m]+k[n-1][m-1] 这个式子和组合数学里的 C(n,k)+C(n,k+1)=C(n+1,k+1) 相似</p>\n</blockquote>\n</blockquote>\n<p>所以 k[n][m]=C(n-1,m-1)</p>\n<blockquote>\n<p>但因为我们无法以O（N^2）解决这道题,所以不能用递推式求组合数</p>\n<blockquote>\n<p>那我们就直接用 组合数的公式求</p>\n<blockquote>\n<p>C(n,m)=n!/((n-m)!*m!)</p>\n</blockquote>\n</blockquote>\n<p>预处理n!和n!的逆元</p>\n<blockquote>\n<p>这里因为数组有限,无法使用递推式求逆元,</p>\n<blockquote>\n<p>所以我们用费马小定理求逆元</p>\n</blockquote>\n<p>a^(p-1)≡1(mod p)</p>\n</blockquote>\n<p>则 a^(p-2) 即为 a 对于 p 的逆元.</p>\n</blockquote>\n<p>预处理即可</p>\n</blockquote>\n<p>当n &lt; m时,ans=0</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 998244353;\nconst int maxn = 100000;\n\nint a,b,n,m;\nint T;\n\nll inv[maxn+10],fac[maxn+10];\n///预处理N!的逆元\n//费马小定理\n/*\n *假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡1（mod p）\n *根据这个性质我们可以知道 a的逆元为a^(p-2)\n */\nll fast_pow(ll a,ll b)\n{\n    ll ans=1;\n    while(b){\n        if(b&amp;1ll)ans=a*ans%MOD;\n        a=a*a%MOD;\n        b&gt;&gt;=1ll;\n    }\n    return ans;\n}\nvoid pre()\n{\n    inv[0]=1ll;\n    fac[0]=1ll;\n    for(int i=1;i&lt;=maxn;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=fast_pow(fac[i],MOD-2ll);\n    }\n}\nll C(ll a,ll b)\n{\n    return fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}\n\nint main(){\n    pre();\n    scanf(&quot;%d&quot;,&amp;T);\n    for(int k=0;k&lt;T;++k){\n        scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;n,&amp;m);\n        if(n&lt;m){\n            printf(&quot;0\\n&quot;);\n            continue;\n        }\n        int t=n-1,s=m-1;\n        ll ans=1;\n\n        ans=ans*C(n-1,m-1)%MOD*fast_pow(a,n-m)%MOD*fast_pow(b,m-1)%MOD;\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n/// C(N-1,M-1)*b^(M-1)*a^(N-M)\n/// N&lt;M 0</code></pre>","text":"A. 水#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main(){    LL n;    cin&gt;&gt;n;    cout&lt;&lt;n+1&lt;&lt;en","link":"","raw":null,"photos":[],"categories":[{"name":"牛客练习赛","slug":"牛客练习赛","count":2,"path":"api/categories/牛客练习赛.json"},{"name":"组合数学","slug":"牛客练习赛/组合数学","count":1,"path":"api/categories/牛客练习赛/组合数学.json"},{"name":"逆元","slug":"牛客练习赛/组合数学/逆元","count":1,"path":"api/categories/牛客练习赛/组合数学/逆元.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"}]},{"title":"组合数学","slug":"combinatorics","date":"2018-01-25T13:04:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/combinatorics.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png","content":"<blockquote>\n<p>因为组合数学涉及面广,采取边学边更新.</p>\n<blockquote>\n<p>预计大部分会摘自《组合数学》</p>\n</blockquote>\n</blockquote>\n<h1 id=\"【鸽巢定理】\"><a href=\"#【鸽巢定理】\" class=\"headerlink\" title=\"【鸽巢定理】\"></a>【鸽巢定理】</h1><p>也叫作<code>狄利克雷抽屉原理</code>以及<code>鞋盒原理</code>. 对于鸽巢定理的简单阐释,粗略的说就是如果有许多鸽子飞进不够多的鸽巢内。那么至少要有一个鸽巢被两个或多个鸽子占据.</p>\n<h2 id=\"简单形式\"><a href=\"#简单形式\" class=\"headerlink\" title=\"简单形式\"></a>简单形式</h2><p>很通俗的定理 : 如果要把n+1个物体放进n个盒子内,那么至少有一个盒子包含两个或更多的物体.</p>\n<h2 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h2><blockquote>\n<ol>\n<li><p>在13个人中存在两个人,他们的生日在同一个月份里.</p>\n</li>\n<li><p>设有n对已婚夫妻,至少从这2n个人中选出n+1个人可以保证有一对夫妻.</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"应用3\"><a href=\"#应用3\" class=\"headerlink\" title=\"应用3\"></a>应用3</h2><h3 id=\"这一条要拿出来-因为比较重要\"><a href=\"#这一条要拿出来-因为比较重要\" class=\"headerlink\" title=\"这一条要拿出来,因为比较重要\"></a>这一条要拿出来,因为比较重要</h3><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215134.png\" alt></p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>考虑$$m$$个和: $$a_1,a_1+a_2,a_1+a_2+a_3,…,a_1+a_2+a_3+…+a_m$$ 如果这些和当中的任意一个可被$$m$$整除,那么结论就成立。因此,我们可以假设这些和中的每一个除以$$m$$都有一个非零余数,余数等于$$1,2,3,4,…,m-1$$中的一个数。因为有$$m$$个和,而只有$$m-1$$个余数,所以必然有两个序列的和除以$$m$$有相同的余数.因此,存在整数$$k,l,k \\&lt; l$$,使得$$a_1+a_2+…+a_k$$和$$a_1+a_2+…+a_l$$除以$$m$$有相同的余数$$r$$: $$a_1+a_2+…+a_k = bm+r,a_1+a_2+…+a_l = cm+r$$ 二式相减,我们发现$$ a_{k+1} $$+$$a_{k+2}+…+a_l = (c-b)m$$。 从而推断出,$$m$$个正整数的序列.一定存在一组序列的和为$$m$$的整数倍. <strong>上面的Latex公示如果没显示完全看下面的图片(PS:Latex公式好麻烦,而且支持也好麻烦):</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ截图20180125215217.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/QQ%E6%88%AA%E5%9B%BE20180125215217.png\" alt></a></p>\n<h3 id=\"具体应用POJ2356\"><a href=\"#具体应用POJ2356\" class=\"headerlink\" title=\"具体应用POJ2356\"></a>具体应用POJ2356</h3><p>题意:输入N个正整数,选择序列中的一些数字,使其和为$$N\\*k$$(k为正整数). 代码:</p>\n<pre><code>//问从N个数中选取多少个数,使得这些数的和%N==0\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=10000+10;\nint num[maxn],sum[maxn];\nint r[maxn];\nint main(){\n    int N,ans=0,k=0,l=1;\n    memset(r,-1,sizeof(r));\n    scanf(&quot;%d&quot;,&amp;N);\n    sum[0]=0;\n\n    for(int i=1;i&lt;=N;++i){\n        scanf(&quot;%d&quot;,&amp;num[i]);\n        sum[i]=sum[i-1]+num[i];\n\n        int remainder=sum[i]%N;\n        if(remainder==0){\n            ans=i;\n            k=0;\n            l=i;\n        }else if(r[remainder]!=-1){\n            ans=i-r[remainder];\n            k=r[remainder];\n            l=i;\n        }else r[remainder]=i;\n    }\n    printf(&quot;%d\\n&quot;,ans);\n    for(int i=k+1;i&lt;=l;++i){\n        printf(&quot;%d\\n&quot;,num[i]);\n    }\n    return 0;\n}</code></pre><h1 id=\"基本计数方法\"><a href=\"#基本计数方法\" class=\"headerlink\" title=\"基本计数方法\"></a>基本计数方法</h1><h2 id=\"加法原理\"><a href=\"#加法原理\" class=\"headerlink\" title=\"加法原理\"></a>加法原理</h2><blockquote>\n<p>做一件事情有n种方法,第i中方法有Pi种方案,则一共有P1+P2+P3+…+Pn种方法.</p>\n</blockquote>\n<h2 id=\"乘法原理\"><a href=\"#乘法原理\" class=\"headerlink\" title=\"乘法原理\"></a>乘法原理</h2><blockquote>\n<p>做一件事情有n个步骤,第i个步骤有Pi种方案,则一共有P1P2P3…Pn中方案.</p>\n</blockquote>\n<h2 id=\"容斥原理\"><a href=\"#容斥原理\" class=\"headerlink\" title=\"容斥原理\"></a>容斥原理</h2><blockquote>\n<p>最基本的公式:</p>\n<blockquote>\n<p>|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|</p>\n</blockquote>\n</blockquote>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><h4 id=\"错位排列\"><a href=\"#错位排列\" class=\"headerlink\" title=\"错位排列\"></a>错位排列</h4><blockquote>\n<p>待填充</p>\n</blockquote>\n<h1 id=\"组合问题\"><a href=\"#组合问题\" class=\"headerlink\" title=\"组合问题\"></a>组合问题</h1><blockquote>\n<p>有n个不同的数,选出k个(顺序无关),每个数最多选一次,有多少种选法?</p>\n<blockquote>\n<p>记答案为C(n,k)。把n选k的排列问题看成两个步骤,首先选出k个数的组合,然后把这k个数进行全排列.由乘法原理知:</p>\n<blockquote>\n<p>P(n,k)=C(n,k)*P(k,k) 即<br>C(n,k)=n!/((n-k)!k!)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"性质1\"><a href=\"#性质1\" class=\"headerlink\" title=\"性质1\"></a>性质1</h2><blockquote>\n<p>C(n,0)=C(n,n)=1</p>\n</blockquote>\n<h2 id=\"性质2\"><a href=\"#性质2\" class=\"headerlink\" title=\"性质2\"></a>性质2</h2><blockquote>\n<p>C(n,k)=C(n,n-k)</p>\n</blockquote>\n<h2 id=\"性质3\"><a href=\"#性质3\" class=\"headerlink\" title=\"性质3\"></a>性质3</h2><blockquote>\n<p>C(n,k)+C(n,k+1)=C(n+1,k+1) 通常用于预处理C(n+1,…)</p>\n</blockquote>\n<h2 id=\"性质4\"><a href=\"#性质4\" class=\"headerlink\" title=\"性质4\"></a>性质4</h2><blockquote>\n<p>C(n,k+1)=C(n,k)*(n-k)/(k+1) 使用这个公式可以在O(n)的时间内求出C(n) 但注意不要发生乘法溢出.及后面的除法溢出</p>\n</blockquote>\n<h3 id=\"性质4通常运用-gt-二项式展开\"><a href=\"#性质4通常运用-gt-二项式展开\" class=\"headerlink\" title=\"性质4通常运用 =&gt; 二项式展开\"></a>性质4通常运用 =&gt; 二项式展开</h3><blockquote>\n<p>问题:</p>\n<blockquote>\n<p>求(a+b)^n展开式的各项系数</p>\n<blockquote>\n<p>二项式定理 (a+b)^n=Sigma(k=0~n)C(n,k)a^(n-k)b^k</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"其余三个问题\"><a href=\"#其余三个问题\" class=\"headerlink\" title=\"其余三个问题\"></a>其余三个问题</h2><h2 id=\"有重复元素的全排列\"><a href=\"#有重复元素的全排列\" class=\"headerlink\" title=\"有重复元素的全排列\"></a>有重复元素的全排列</h2><blockquote>\n<p>有重复元素的全排列</p>\n<blockquote>\n<p>有k个元素,其中第i个元素有Ni个,求全排列个数.</p>\n<blockquote>\n<p>直接看结论,可以简单证得 N1!*N2!*N3!<em>…\\</em>Nn!*ans=N! (移项即可)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"可重复选择的组合\"><a href=\"#可重复选择的组合\" class=\"headerlink\" title=\"可重复选择的组合\"></a>可重复选择的组合</h2><blockquote>\n<p>可重复选择的组合</p>\n<blockquote>\n<p>有n个不同的元素,每个元素可以选择多次,一共选k个元素,有多少种选法?</p>\n<blockquote>\n<p>例如n=3,k=2有6种</p>\n<blockquote>\n<p>(1,1)、(1,2)、(1,3)、(2,2)、(2,3)、(3,3)</p>\n</blockquote>\n</blockquote>\n<p>分析:</p>\n<blockquote>\n<p>设第i个元素选xi个,问题转化为求方程x1+x2+…+x3=k的非负整数解的个数. 令yi=xi+1,则答案为 y1+y2+y3+…+yn=k+n</p>\n</blockquote>\n</blockquote>\n<p>没太搞懂,直接放答案吧 C(k+n-1,n-1) =C(n+k-1,k)(性质2)</p>\n</blockquote>\n<h2 id=\"单色三角形\"><a href=\"#单色三角形\" class=\"headerlink\" title=\"单色三角形\"></a>单色三角形</h2><blockquote>\n<p>给定空间内的n(n&lt;=1000)个点,其中没有三点共线,每两个点之间都用红色或黑色线段链接.求三条边同色的三角形个数.</p>\n<blockquote>\n<p>考虑非单色三角形. 如果第i个点连接了ai条红边和n-1-ai条黑边,则这些边属于ai(n-1-ai)个非单色三角形。每个非单色三角形被考虑了两次,所以最终答案除以2 即 1/2*Sigma(i=1~n) ai(n-1-ai) 用总三角形减去非单色即为单色三角形个数</p>\n</blockquote>\n</blockquote>\n<h1 id=\"生成函数\"><a href=\"#生成函数\" class=\"headerlink\" title=\"生成函数\"></a>生成函数</h1><blockquote>\n<p>母函数是用于解决组合问题计数的一种方法。 在了解它之前我们先看看熟悉的杨辉三角。</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170611212741764.jpg\" alt></p>\n<blockquote>\n<p>杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)^n的展开式从低项到高项的各项系数，也可以表示为组合数的形式C(i,n)。如果将两者联系起来我们会发现，(1+x)可以看成对于一件取舍，1=x^0就是不取，x就是取。这样在(1+x)^n的展开式中x^i项的系数就是从n件物品选取i件的方案数。</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>给定数列a0,a1,a2…an，构造函数</p>\n<blockquote>\n<p>G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)</p>\n<blockquote>\n<p>其中G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)为标志函数。 母函数主要有两种形式：普通型母函数和指数型母函数。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"普通型母函数\"><a href=\"#普通型母函数\" class=\"headerlink\" title=\"普通型母函数\"></a>普通型母函数</h3><blockquote>\n<p>先看一个例题：HDU 1085</p>\n<blockquote>\n<p>普通型母函数的标志函数一般为x^0,x^1,x^2…x^n</p>\n</blockquote>\n<p>因为每个硬币有个数限制，但是也不难构造出</p>\n<blockquote>\n<p>G(x)=(1+x+x^2+x^3+…+x^num1)(1+x^2+x^4+…+x^(2∗num2))(1+x^5+x^10+…+x^(5∗num5)) 。</p>\n</blockquote>\n<p>将多项式展开后，x^i项对应的系数就是组成面值为i的方案数。 例题: 51nod 1383</p>\n</blockquote>\n<h3 id=\"指数型母函数\"><a href=\"#指数型母函数\" class=\"headerlink\" title=\"指数型母函数\"></a>指数型母函数</h3><blockquote>\n<p>再看一个例题：HDU 1521</p>\n<blockquote>\n<p>指数型母函数的标志函数一般为x^0/0!,x^1/1!,x^2/2!…x^n/n!，对于x^i/i!表示在一个方案中某个元素出现了i次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！</p>\n</blockquote>\n<p>对于这道题就不难构造出母函数为</p>\n<blockquote>\n<p>G(x)=(1/0!+X/1!+X^2/2!+…+X^a1/a1!)(1/0!+X/1!+X^2/2!+…+X^a2/a2!)(1/0!+X/1!+X^2/2!+…+X^an/an!)</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Catalan数列\"><a href=\"#Catalan数列\" class=\"headerlink\" title=\"Catalan数列\"></a>Catalan数列</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h3 id=\"待整理\"><a href=\"#待整理\" class=\"headerlink\" title=\"待整理\"></a>待整理</h3><blockquote>\n<p>Catalan数列可以解决很多问题.</p>\n<blockquote>\n<p>比如51nod 1120</p>\n</blockquote>\n</blockquote>\n<h2 id=\"Catalan前几项\"><a href=\"#Catalan前几项\" class=\"headerlink\" title=\"Catalan前几项\"></a>Catalan前几项</h2><pre><code>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, 18367353072152, 69533550916004, 263747951750360, 1002242216651368, 3814986502092304, 14544636039226909, 55534064877048198, 212336130412243110, 812944042149730764, 3116285494907301262, 11959798385860453492, 45950804324621742364, ...</code></pre><h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"一个小链接\"><a href=\"#一个小链接\" class=\"headerlink\" title=\"一个小链接\"></a>一个小链接</h3><p><a href=\"https://www.cnblogs.com/yaoyueduzhen/p/5456490.html\" title=\"Catalan应用及介绍\" target=\"_blank\" rel=\"noopener\">Catalan应用及介绍</a></p>\n<h3 id=\"待整理-1\"><a href=\"#待整理-1\" class=\"headerlink\" title=\"待整理\"></a>待整理</h3><h2 id=\"三种方法求Catalan整合\"><a href=\"#三种方法求Catalan整合\" class=\"headerlink\" title=\"三种方法求Catalan整合\"></a>三种方法求Catalan整合</h2><h3 id=\"注-其中有牵扯Lucas-Lucas在下面-直接放代码-注释在代码中-有对各个类型进行耗时对比\"><a href=\"#注-其中有牵扯Lucas-Lucas在下面-直接放代码-注释在代码中-有对各个类型进行耗时对比\" class=\"headerlink\" title=\"注:其中有牵扯Lucas,Lucas在下面,直接放代码,注释在代码中,有对各个类型进行耗时对比\"></a>注:其中有牵扯Lucas,Lucas在下面,直接放代码,注释在代码中,有对各个类型进行耗时对比</h3><h3 id=\"注2-求逆元中牵扯到了费马求逆元和欧拉求逆元\"><a href=\"#注2-求逆元中牵扯到了费马求逆元和欧拉求逆元\" class=\"headerlink\" title=\"注2:求逆元中牵扯到了费马求逆元和欧拉求逆元\"></a>注2:求逆元中牵扯到了费马求逆元和欧拉求逆元</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int maxn=1000000+10;\nLL h[10100];\n\n//函数功能: 预处理前N向Catalan\n//函数参数: n为项数\n//适合N比较小的情况\nvoid Catalan(int n){\n    h[0] = h[1] = 1;        //h(0)和h(1)\n    for(int i = 2; i &lt;= n; i++)    //依次计算h(2),h(3)...h(n)\n    {\n        h[i] = 0;\n        for(int j = 0; j &lt; i; j++) //根据递归式计算 h(i)= h(0)*h(i-1)+h(1)*h(i-2) + ... + h(i-1)h(0)\n            h[i] = (h[i]+(h[j] * h[i-1-j])%mod)%mod;\n    }\n}\n\n///h(n)=C(2n,n)/(n+1) (n=0,1,2,...)\n///+逆元+Lucas组合数取模\n///预处理逆元的话,大小会被限制,直接求的话可能会有常数\n///但是N就可以大一点\n///返回第N个catalan数\nLL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}\n///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nLL N_L_Catalan(int N){\n    return Lucas(2*N,N,mod)*inv[N+1]%mod;\n}\n\n///第三种方法\n///h(n)=C(2n,n)-C(2n,n+1)\n///由上式子可以直接两个Lucas+同余定理解决\n///复杂度可能会比第二种方法换成直接求逆元要高点\nLL T_Catalan(int N){\n    return (Lucas(2*N,N,mod)-Lucas(2*N,N+1,mod)+mod)%mod;\n}\n\n\n///第四种方法\n///直接求逆元(扩展欧几里得求逆元)+Lucas\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inverse(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nLL F_Catalan(int N){\n    return Lucas(2*N,N,mod)*inverse(1ll*N+1,1ll*mod)%mod;\n}\n\n///第五种\n///欧拉定理求逆元+Lucas\n///mod是素数且与N互质\nlong long Pow(long long a,long long b){\n    long long ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%mod;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%mod;\n    }\n    return ans;\n}\n\nlong long euler(int p)\n{\n    long long ans=p,a=p;\n    long long i;\n    for(i=2;i*i&lt;=a;i++)\n    {\n        if(a%i==0)\n        {\n            ans=ans/i*(i-1);\n            while(a%i==0)\n                a/=i;\n        }\n    }\n    if(a&gt;1)\n        ans=ans/a*(a-1);\n    return ans;\n}\n\nlong long eu=euler(mod)-1;\n\nlong long Einv(long long a)\n{\n    return Pow(a,eu);\n}\n\nLL Fi_Catalan(int N){\n    return Lucas(2*N,N,mod)*Einv(1ll*(N+1))%mod;\n}\n\nint main(){\n    Catalan(10000);\n    init();//初始化逆元\n    int k;\n    while(cin&gt;&gt;k){\n        if(k&lt;=10000)\n            cout&lt;&lt;&quot;第一种方法(预处理): &quot;&lt;&lt;h[k]&lt;&lt;endl;\n        if(k&lt;=1000000)\n            cout&lt;&lt;&quot;第二种方法(h(n)=C(2n,n)/(n+1),预处理逆元+Lucas): &quot;&lt;&lt;N_L_Catalan(k)&lt;&lt;endl;\n        clock_t startTime,endTime;\n        startTime = clock();\n        cout&lt;&lt;&quot;第三种方法(h(n)=C(2n,n)-C(2n,n+1),Lucas): &quot;&lt;&lt;T_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第四种方法(h(n)=C(2n,n)/(n+1),Lucas+扩欧求逆元): &quot;&lt;&lt;F_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n        startTime = clock();\n        cout&lt;&lt;&quot;第五种方法(h(n)=C(2n,n)/(n+1),Lucas+欧拉定理求逆元): &quot;&lt;&lt;Fi_Catalan(k)&lt;&lt;endl;\n        endTime=clock();\n        cout&lt;&lt;&quot;  &quot;&lt;&lt;(double)(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\n    }\n    return 0;\n}</code></pre><h1 id=\"Lucas\"><a href=\"#Lucas\" class=\"headerlink\" title=\"Lucas\"></a>Lucas</h1><h2 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>Lucas定理用于对组合数求模</p>\n<blockquote>\n<p>因为组合数是一个大式子,无法直接求模,所以用到了Lucas</p>\n</blockquote>\n</blockquote>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><pre><code>///Lucas\nLL Power_mod(LL a, LL b, LL p)\n{\n    LL res = 1;\n    while(b!=0)\n    {\n        if(b&amp;1) res = (res*a)%p;\n        a = (a*a)%p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nLL Comb(LL a,LL b, LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Power_mod(cb, p-2, p))%p;\n    return ans;\n}\nLL Lucas(int n, int m, int p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}</code></pre>","text":"因为组合数学涉及面广,采取边学边更新.预计大部分会摘自《组合数学》【鸽巢定理】也叫作狄利克雷抽屉原理以及鞋盒原理. 对于鸽巢定理的简单阐释,粗略的说就是如果有许多鸽子飞进不够多的鸽巢内。那么至少要有一个鸽巢被两个或多个鸽子占据.简单形式很通俗的定理 : 如果要把n+1个物体放进n","link":"","raw":null,"photos":[],"categories":[{"name":"组合数学","slug":"组合数学","count":1,"path":"api/categories/组合数学.json"}],"tags":[{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"}]}]}