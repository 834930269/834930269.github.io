{"name":"VJ","slug":"VJ","count":3,"postlist":[{"title":"VJ SWPU-ACM省赛集训赛ONE A  Easy Math","slug":"vj-swpu-acmone-a-easy-math","date":"2017-04-20T06:39:20.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmone-a-easy-math.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>直觉只要有一个不是平方根就输出No,直觉是对的…</strong> <strong>可以当做结论?</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N;</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        bool flag=true;** **        ll num;** **        while(N–){** **            SI(num);** **            ll t=sqrt(num);** **            if(t<em>t!=num)*</em> **                flag=false;** **        }** **        printf(flag?”Yes\\n”:”No\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 直觉只要有一个不是平方根就输出No,直觉是对的… 可以当做结论? 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3","link":"","raw":null,"photos":[],"categories":[{"name":"VJ","slug":"VJ","count":2,"path":"api/categories/VJ.json"}],"tags":[{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]},{"title":"VJ SWPU-ACM省赛集训赛ONE E Rectangle","slug":"vj-swpu-acmone-e-rectangle","date":"2017-04-20T06:44:53.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmone-e-rectangle.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>枚举长的长度,则对于长有N-i+1种情况.</strong> <strong>然后得出宽的取值范围为[1,tmp=(K-i)&lt;M?(K-i):M].防溢出.</strong> <strong>画图知在宽的取值范围内情况分别为:M,M-1,M-2…M-tmp+1.共tmp项.</strong> <strong>用等差数列求和公式得出该长下的宽的情况个数.</strong> <strong>乘积累加.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N,M,K;</strong> <strong>ll ans;</strong> <strong>int main(){</strong> **    while(~SIII(N,M,K)){** **        K&gt;&gt;=1;** **        ans=0;** **        for(int i=1;i&lt;=N &amp;&amp; K-i&gt;0;++i){** **            ll tmp=(K-i)&lt;M?(K-i):M;** **            ll sumC=N-i+1;** **            ll sumK=(M+M-tmp+1)<em>tmp/2;*</em> **            ans+=sumC<em>sumK;*</em> **        }** **        printf(“%lld\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 枚举长的长度,则对于长有N-i+1种情况. 然后得出宽的取值范围为[1,tmp=(K-i)&lt;M?(K-i):M].防溢出. 画图知在宽的取值范围内情况分别为:M,M-1,M-2…M-tmp+1.共tmp项. 用等差数列求和公式得出该长下的宽的情况个数. 乘积累加","link":"","raw":null,"photos":[],"categories":[{"name":"VJ","slug":"VJ","count":2,"path":"api/categories/VJ.json"}],"tags":[{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]},{"title":"VJ SWPU-ACM省赛集训赛ONE J Right turn","slug":"vj-swpu-acmne-j-right-turn","date":"2017-04-20T11:04:34.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmne-j-right-turn.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>模拟</strong> <strong>【Tip】</strong> <strong>我的代码感觉上很对…然而莫名其妙总WA.然后把代码改成网上搜的题解的思路,A了…</strong> <strong>我一开始的思路是floyd判圈法,若会碰到同一个路障第二次,则一定无法逃出去.</strong> <strong>这个思路是错的,因为有可能在同一个点转的方向不同,所以如果经过同一个点两次有可能逃出去.</strong> <strong>但每个点最多只能经过三次,第四次时一定是一个圈.所以判断是否经过一个点四次就好了.依然是floyd判圈法.不过要判四次.</strong> <strong>然后成型代码如下.</strong> <strong>【WA Code1】</strong></p>\n<blockquote>\n<p>**`#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long ll;<br>const int INF = 0x3f3f3f3f;</p>\n<p>#define cle(a,val) memset(a,(val),sizeof(a))</p>\n<p>#define SI(N) scanf(“%lld”,&amp;(N))</p>\n<p>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</p>\n<p>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</p>\n<p>#define rep(i,b) for(int i=0;i&lt;(b);i++)</p>\n<p>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</p>\n<p>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)<br>const ll LINF = 0x3f3f3f3f3f3f3f3f;</p>\n<p>#define PU(x) puts(#x);</p>\n<p>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</p>\n<p>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</p>\n<p>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</p>\n<p>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</p>\n<p>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</p>\n<p>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}<br>const double EPS = 1e-9 ;<br>pair&lt;int,int&gt; node;<br>map&lt;pair&lt;int,int&gt;,bool&gt; mp;<br>map&lt;int,vector<int> &gt; EdgeX,EdgeY;<br>int N,X,Y,step;<br>int toward[4]={1,-2,-1,2},t=0;//右下左上</int></p>\n<p>bool floyd(){<br>    X=0,Y=0;<br>    while(1){<br>        if(toward[t]==1){<br>            vector<int>&amp; Just=EdgeY[Y];<br>            int si=Just.size(),flag=0;<br>            rep(i,si){<br>                if(Just[i]&gt;X){<br>                    if(mp[make_pair(Just[i],Y)]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(Just[i],Y)]=true;<br>                    flag=1;<br>                    X=Just[i]-1;<br>                    step++;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==-2){<br>            vector<int>&amp; Just=EdgeX[X];<br>            int si=Just.size(),flag=0;<br>            red(i,si-1,0){<br>                if(Just[i]&lt;Y){<br>                    if(mp[make_pair(X,Just[i])]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(X,Just[i])]=true;<br>                    Y=Just[i]+1;<br>                    step++;<br>                    flag=1;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==-1){<br>            vector<int>&amp; Just=EdgeY[Y];<br>            int si=Just.size(),flag=0;<br>            red(i,si-1,0){<br>                if(Just[i]&lt;X){<br>                    if(mp[make_pair(Just[i],Y)]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(Just[i],Y)]=true;<br>                    flag=1;<br>                    X=Just[i]+1;<br>                    step++;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==2){<br>            vector<int>&amp; Just=EdgeX[X];<br>            int si=Just.size(),flag=0;<br>            rep(i,si){<br>                if(Just[i]&gt;Y){<br>                    if(mp[make_pair(X,Just[i])]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(X,Just[i])]=true;<br>                    Y=Just[i]-1;<br>                    step++;<br>                    flag=1;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }<br>    }<br>}</int></int></int></int></p>\n<p>int main(){<br>    while(~SI(N)){<br>        t=0;<br>        step=0;<br>        mp.clear();<br>        EdgeX.clear();<br>        EdgeY.clear();<br>        rep(i,N){<br>            scanf(“%d%d”,&amp;node.first,&amp;node.second);<br>            mp[node]=false;<br>            EdgeX[node.first].push_back(node.second);<br>            EdgeY[node.second].push_back(node.first);<br>        }<br>        map&lt;int,vector<int> &gt;::iterator it;<br>        for(it=EdgeX.begin();it!=EdgeX.end();it++){<br>            vector<int>&amp; Just=it-&gt;second;<br>            sort(Just.begin(),Just.end());<br>        }<br>        for(it=EdgeY.begin();it!=EdgeY.end();it++){<br>            vector<int>&amp; Just=it-&gt;second;<br>            sort(Just.begin(),Just.end());<br>        }<br>        if(floyd()){<br>            printf(“%d\\n”,step);<br>        }else{<br>            printf(“-1\\n”);<br>        }<br>    }<br>    return 0;<br>}`** </int></int></int></p>\n</blockquote>\n<p><strong>【简单修改后AC代码】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>pair&lt;int,int&gt; node;</strong> <strong>map&lt;pair&lt;int,int&gt;,int&gt; mp;</strong> <strong>map&lt;int,vector<int> &gt; EdgeX,EdgeY;</int></strong> <strong>int N,X,Y,step;</strong> <strong>int toward[4]={1,-2,-1,2},t=0;//右下左上</strong> <strong>bool floyd(){</strong> **    X=0,Y=0;** **    while(1){** **        if(toward[t]==1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;X){** **                    if(mp[make_pair(Just[i],Y)]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(Just[i],Y)]++;** **                    flag=1;** **                    X=Just[i]-1;** **                    step++;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==-2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            red(i,si-1,0){** **                if(Just[i]&lt;Y){** **                    if(mp[make_pair(X,Just[i])]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(X,Just[i])]++;** **                    Y=Just[i]+1;** **                    step++;** **                    flag=1;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==-1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            red(i,si-1,0){** **                if(Just[i]&lt;X){** **                    if(mp[make_pair(Just[i],Y)]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(Just[i],Y)]++;** **                    flag=1;** **                    X=Just[i]+1;** **                    step++;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;Y){** **                    if(mp[make_pair(X,Just[i])]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(X,Just[i])]++;** **                    Y=Just[i]-1;** **                    step++;** **                    flag=1;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }** **    }** <strong>}</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        t=0;** **        step=0;** **        mp.clear();** **        EdgeX.clear();** **        EdgeY.clear();** **        rep(i,N){** **            scanf(“%d%d”,&amp;node.first,&amp;node.second);** **            mp[node]=0;** **            EdgeX[node.first].push_back(node.second);** **            EdgeY[node.second].push_back(node.first);** **        }** **        map&lt;int,vector<int> &gt;::iterator it;** **        for(it=EdgeX.begin();it!=EdgeX.end();it++){** **            vector<int>&amp; Just=it-&gt;second;** **            sort(Just.begin(),Just.end());** **        }** **        for(it=EdgeY.begin();it!=EdgeY.end();it++){** **            vector<int>&amp; Just=it-&gt;second;** **            sort(Just.begin(),Just.end());** **        }** **        if(floyd()){** **            printf(“%d\\n”,step);** **        }else{** **            printf(“-1\\n”);** **        }** **    }** **    return 0;** <strong>}</strong></int></int></int></int></int></int></int></p>\n</blockquote>\n<p><strong>【跟着题解AC Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>pair&lt;int,int&gt; node;</strong> <strong>map&lt;pair&lt;int,int&gt;,bool&gt; mp;</strong> <strong>map&lt;int,vector<int> &gt; EdgeX,EdgeY;</int></strong> <strong>int N,X,Y,step;</strong> <strong>int toward[4]={1,-2,-1,2},t=0;//右下左上</strong> <strong>bool floyd(){</strong> **    X=0,Y=0;** **    while(step&lt;=4<em>N+1){*</em> **        int tmpx=-INF,tmpy=-INF;** **        if(toward[t]==1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size();** **            rep(i,si){** **                if(Just[i]&gt;X){** **                    tmpy=Y;** **                    if(tmpx!=-INF) tmpx=min(tmpx,Just[i]);** **                    else tmpx=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** **    //            if(mp[make_pair(tmpx,Y)]) return false;** **     //           mp[make_pair(tmpx,Y)]=true;** **                X=tmpx-1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==-2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&lt;Y){** **                    tmpx=X;** **                    flag=1;** **                    if(tmpy!=-INF) tmpy=max(tmpy,Just[i]);** **                    else tmpy=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** **  //              if(mp[make_pair(X,tmpy)]) return false;** ** //               mp[make_pair(X,tmpy)]=true;** **                Y=tmpy+1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==-1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&lt;X){** **                    flag=1;** **                    tmpy=Y;** **                    if(tmpx!=-INF) tmpx=max(tmpx,Just[i]);** **                    else tmpx=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** ** //               if(mp[make_pair(tmpx,Y)]) return false;** ** //               mp[make_pair(tmpx,Y)]=true;** **                X=tmpx+1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;Y){** **                    tmpx=X;** **                    flag=1;** **                    if(tmpy!=-INF) tmpy=min(tmpy,Just[i]);** **                    else tmpy=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** ** //              if(mp[make_pair(X,tmpy)]) return false;** **  //              mp[make_pair(X,tmpy)]=true;** **                Y=tmpy-1;** **                step++;** **                t=(t+1)%4;** **            }** **        }** **    }** **    return false;** <strong>}</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        t=0;** **        step=0;** **        mp.clear();** **        EdgeX.clear();** **        EdgeY.clear();** **        rep(i,N){** **            scanf(“%d%d”,&amp;node.first,&amp;node.second);** <strong>//            mp[node]=false;</strong> **            EdgeX[node.first].push_back(node.second);** **            EdgeY[node.second].push_back(node.first);** **        }** **        if(floyd()){** **            printf(“%d\\n”,step);** **        }else{** **            printf(“-1\\n”);** **        }** **    }** **    return 0;** <strong>}</strong></int></int></int></int></p>\n</blockquote>\n","text":"【类型】 模拟 【Tip】 我的代码感觉上很对…然而莫名其妙总WA.然后把代码改成网上搜的题解的思路,A了… 我一开始的思路是floyd判圈法,若会碰到同一个路障第二次,则一定无法逃出去. 这个思路是错的,因为有可能在同一个点转的方向不同,所以如果经过同一个点两次有可能逃出去. ","link":"","raw":null,"photos":[],"categories":[{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/categories/Floyd判圈法.json"},{"name":"VJ","slug":"Floyd判圈法/VJ","count":1,"path":"api/categories/Floyd判圈法/VJ.json"},{"name":"模拟","slug":"Floyd判圈法/VJ/模拟","count":1,"path":"api/categories/Floyd判圈法/VJ/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/tags/Floyd判圈法.json"},{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]}]}