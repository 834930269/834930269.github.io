{"name":"枚举","slug":"枚举","count":3,"postlist":[{"title":"Educational Codeforces Round 25 A","slug":"educational-codeforces-round-25-a-cpp","date":"2017-07-16T18:26:21.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/educational-codeforces-round-25-a-cpp.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题目以及连接】</strong></p>\n<h2><span id=\"a-binary-protocol\">A. Binary Protocol</span></h2><h5><span id=\"time-limit-per-test1-second\">time limit per test:1 second</span></h5><h5><span id=\"memory-limit-per-test256-megabytes\">memory limit per test:256 megabytes</span></h5><h5><span id=\"input-standard-input\">input: standard input</span></h5><h5><span id=\"output-standard-output\">output: standard output</span></h5><p>Polycarp has just invented a new binary protocol for data transmission. He is encoding positive integer decimal number to binary string using following algorithm:</p>\n<ul>\n<li>Each digit is represented with number of ‘1’ characters equal to the value of that digit (for 0 it is zero ones).</li>\n<li>Digits are written one by one in order corresponding to number and separated by single ‘0’ character.</li>\n</ul>\n<p>Though Polycarp learnt how to encode the numbers, he has no idea how to decode them back. Help him calculate the decoded number.</p>\n<p><strong>Input</strong></p>\n<p>The first line contains one integer number <em>n</em> (1 ≤ <em>n</em> ≤ 89) — length of the string <em>s</em>. The second line contains string <em>s</em> — sequence of ‘0’ and ‘1’ characters, number in its encoded format. It is guaranteed that the number corresponding to the string is positive and doesn’t exceed 109. The string always starts with ‘1’.</p>\n<p><strong>Output</strong></p>\n<p>Print the decoded number.</p>\n<p><strong>Examples</strong></p>\n<p><strong>Input</strong></p>\n<p>3<br>111</p>\n<p><strong>Output</strong></p>\n<p>3</p>\n<p><strong>Input</strong></p>\n<p>9<br>110011101</p>\n<p><strong>Output</strong></p>\n<p>2031 Link: <a href=\"http://codeforces.com/contest/825/problem/A\" target=\"_blank\" rel=\"noopener\">Codeforce Educational Codeforces Round 25 A</a> <strong>【题意】</strong> 给出一串二进制字符串,翻译成原来的数字.规则为数字间以单独的0为分隔符.多余的0当做一个0输出,最后有几个0输出几个0. (后面那个意思蒙出来的,英语渣,有点没搞懂最后一个条件是为什么). <strong>【题解】</strong> 逐位记录即可. <strong>【Source Code】</strong> github:<a href=\"https://github.com/834930269/Other_OJ/blob/master/codeforce/Educational%20Codeforces%20Round%2025%20%20A.cpp\" target=\"_blank\" rel=\"noopener\">Educational Codeforces Round 25 A.cpp –忽然发现–原来链接中有空格使用%20处理的.但是空格多了,复制的时候不会复制上%20..要手敲</a></p>\n<p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int n;<br>    while(~scanf(“%d”,&amp;n)){<br>        char digit,pre=’0’;<br>        int cnt=0;<br>        for(int i=0;i&lt;n;++i){<br>            cin&gt;&gt;digit;<br>            if(digit==’1’) cnt++;<br>            if(digit==’0’) {printf(“%d”,cnt);cnt=0;}<br>        }<br>        if(digit==’1’) printf(“%d”,cnt);<br>        if(digit==’0’) printf(“0”);<br>        printf(“\\n”);<br>    }<br>    return 0;<br>}</p>\n","text":"【题目以及连接】A. Binary Protocoltime limit per test:1 secondmemory limit per test:256 megabytesinput: standard inputoutput: standard outputPolycar","link":"","raw":null,"photos":[],"categories":[{"name":"Codeforce","slug":"Codeforce","count":6,"path":"api/categories/Codeforce.json"},{"name":"未分类","slug":"Codeforce/未分类","count":1,"path":"api/categories/Codeforce/未分类.json"},{"name":"枚举","slug":"Codeforce/未分类/枚举","count":1,"path":"api/categories/Codeforce/未分类/枚举.json"}],"tags":[{"name":"Codeforce","slug":"Codeforce","count":7,"path":"api/tags/Codeforce.json"},{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"}]},{"title":"玲珑杯 Round#18 A","slug":"llb-round18-a","date":"2017-07-15T10:23:43.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/llb-round18-a.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1143\" target=\"_blank\" rel=\"noopener\">1143 - 计算几何你瞎暴力</a></strong> <strong>【题解】</strong> <strong>用vis统计每个点上有多少教室.可以发现,最大的距离是30.</strong> <strong>然后枚举所有的点求出两点之间的距离以及所有的组合总数.</strong> <strong>1.如果两点是同一个点.先判断该点是否存在房子.如果存在,就用等差数列求和公式: N-1+N-2+…+1=(1+N-1)*(N-1)/2  计算出组合种数记录在d[0].</strong> <strong>2.如果两点不同一点,判断两点教室数都不为0,然后计算组合种数: S*S2 计算组合种数记录在d[dist(S,S2)].</strong> <strong>3.由于计算的时候每个点都在点一和点二计算过一次.所以最终统计的时候之前统计得值需要除以二.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20A.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 A.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;</p>\n<p>#define cle(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f<br>using namespace std;</p>\n<p>const int maxn=50000+10;<br>int T,n,q,d[1420];<br>char str[200];<br>long long vis[20][20][20];<br>bool vi[1420];</p>\n<p>int main(){<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        cle(d),cle(vis),cle(vi);<br>        scanf(“%d%d”,&amp;n,&amp;q);<br>        for(int i=0;i&lt;n;++i){<br>            int x,y,z;<br>            scanf(“%d%d%d”,&amp;x,&amp;y,&amp;z);<br>            vis[x][y][z]++;<br>        }<br>        for(int i=0;i&lt;=10;i++)<br>        {<br>            for(int j=0;j&lt;=10;j++)<br>            {<br>                for(int k=0;k&lt;=10;k++)<br>                {<br>                    for(int x=0;x&lt;=10;x++)<br>                    {<br>                        for(int y=0;y&lt;=10;y++)<br>                        {<br>                            for(int z=0;z&lt;=10;z++) {<br>                                int dis=abs(i-x)+abs(j-y)+abs(k-z);<br>                                if(i==x&amp;&amp;j==y&amp;&amp;k==z) {<br>                                    if(vis[i][j][k]-1&gt;=0){<br>                                        d[dis]+=(vis[i][j][k])<em>(vis[i][j][k]-1)/2;<br>                                        vi[dis]=true;<br>                                    }<br>                                }<br>                                else if(vis[i][j][k]</em>vis[x][y][z]&gt;0)<br>                                {<br>                                    d[dis]+=vis[i][j][k]<em>vis[x][y][z];<br>                                    vi[dis]=true;<br>                                }<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        for(int i=1;i&lt;=30;++i)d[i]=d[i-1]+d[i]/2;<br>        for(int i=0;i&lt;q;++i){<br>            int R;<br>            scanf(“%d”,&amp;R);<br>            R=min(30,R);<br>            printf(“%lld\\n”,d[R]);<br>        }<br>    }<br>    return 0;<br>}*</em></p>\n","text":"【Topic Link】 1143 - 计算几何你瞎暴力 【题解】 用vis统计每个点上有多少教室.可以发现,最大的距离是30. 然后枚举所有的点求出两点之间的距离以及所有的组合总数. 1.如果两点是同一个点.先判断该点是否存在房子.如果存在,就用等差数列求和公式: N-1+N-","link":"","raw":null,"photos":[],"categories":[{"name":"枚举","slug":"枚举","count":1,"path":"api/categories/枚举.json"},{"name":"玲珑杯","slug":"枚举/玲珑杯","count":1,"path":"api/categories/枚举/玲珑杯.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"UVa  11464","slug":"uva-11464","date":"2017-03-31T12:59:56.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-11464.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>gird 网格,格子</strong> <strong>so taht 以便</strong> <strong>The parity 奇偶校验</strong> <strong>even 有偶数意</strong> <strong>transformation 转化</strong> <strong>achieve 取得,获得,实现,成功</strong> <strong>requirement 要求</strong> <strong>indicates 表明</strong> <strong>character 性格,品质</strong> <strong>separated 分开,隔开</strong> <strong>instead 代替,反而,相反</strong> <strong>【题解】</strong> <strong>蓝书 P16</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<algorithm></algorithm></strong> <strong>using namespace std;</strong> <strong>const int INF=0x3f3f3f3f;</strong> <strong>const int maxn=20;</strong> <strong>int A[maxn][maxn],B[maxn][maxn],n,T,ca=1;</strong> <strong>int check(int s){</strong> **    memset(B,0,sizeof(B));** <strong>//先初始化第一行</strong> **    for(int i=0;i&lt;n;++i){** **        if(s &amp; (1&lt;&lt;i)) B[0][i]=1;//这句意思是判断每一位上是否是1** <strong>//即(1&lt;&lt;n)只有第n位是1,其他位都是0 为真即为1</strong> <strong>else if(A[0][i]==1) return INF;//1不能变成0</strong> **    }** **    for(int i=1;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            int sum=0;//元素B[i-1][0]的上,左,右元素之和** **            if(i&gt;1)sum+=B[i-2][j];** **            if(j&gt;0)sum+=B[i-1][j-1];** <strong>if(j&lt;n-1)sum+=B[i-1][j+1];</strong> **            B[i][j]=sum%2;//sum是偶数,=0,奇数,=1** **            if(A[i][j]==1 &amp;&amp; B[i][j]==0) return INF;** <strong>//不存在1-&gt;0的操作.</strong> <strong>}</strong> **    }** **    int cnt=0;** **    for(int i=0;i&lt;n;++i){** **        for(int j=0;j&lt;n;++j){** **            if(A[i][j]!=B[i][j])** <strong>cnt++;</strong> <strong>}</strong> <strong>}</strong> <strong>return cnt;</strong> <strong>}</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        printf(“Case %d: “,ca++);** **        scanf(“%d”,&amp;n);** **        for(int i=0;i&lt;n;++i)** **            for(int j=0;j&lt;n;++j)** **                scanf(“%d”,&amp;A[i][j]);** <strong>int ans=INF;</strong> **        for(int i=0;i&lt;(1&lt;&lt;n);++i)** <strong>ans=min(ans,check(i));</strong> **        if(ans==INF) ans=-1;** <strong>printf(“%d\\n”,ans);</strong> <strong>}</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 gird 网格,格子 so taht 以便 The parity 奇偶校验 even 有偶数意 transformation 转化 achieve 取得,获得,实现,成功 requirement 要求 indicates 表明 character 性格,品质 separ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"枚举","slug":"UVa/位操作/枚举","count":1,"path":"api/categories/UVa/位操作/枚举.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"}]}]}