{"name":"C#","slug":"C","count":6,"postlist":[{"title":"ASP.NET API2 设计 RESTful API 服务端解决跨域","slug":"asp-net-api2-ky-restful-api","date":"2017-11-26T10:16:55.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/asp-net-api2-ky-restful-api.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原理: 只需要在消息头中添加一句: Access-Control-Allow-Origin * 即可. 解决方案是直接在nuget中安装 Microsoft Asp.Net Web Api 2.2 Cross-Origin 然后在App-Start/WebApiConfig.cs下：</p>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web.Http;\nusing System.Web.Http.Cors;\n\nnamespace WAPI\n{\n    public static class WebApiConfig\n    {\n        public static void Register(HttpConfiguration config)\n        {\n            //跨域配置\n            config.EnableCors(new EnableCorsAttribute(&quot;*&quot;, &quot;*&quot;, &quot;*&quot;));\n            // Web API configuration and services\n\n            // Web API routes\n            config.MapHttpAttributeRoutes();\n\n            config.Routes.MapHttpRoute(\n                name: &quot;DefaultApi&quot;,\n                routeTemplate: &quot;api/{controller}/{id}&quot;,\n                defaults: new { id = RouteParameter.Optional }\n            );\n        }\n    }\n}</code></pre><p>即可.</p>\n","text":"原理: 只需要在消息头中添加一句: Access-Control-Allow-Origin * 即可. 解决方案是直接在nuget中安装 Microsoft Asp.Net Web Api 2.2 Cross-Origin 然后在App-Start/WebApiConfig.cs","link":"","raw":null,"photos":[],"categories":[{"name":"ajax","slug":"ajax","count":4,"path":"api/categories/ajax.json"},{"name":"ASP.Net","slug":"ajax/ASP-Net","count":3,"path":"api/categories/ajax/ASP-Net.json"},{"name":"C#","slug":"ajax/ASP-Net/C","count":1,"path":"api/categories/ajax/ASP-Net/C.json"},{"name":"RestFul_API","slug":"ajax/ASP-Net/C/RestFul-API","count":1,"path":"api/categories/ajax/ASP-Net/C/RestFul-API.json"}],"tags":[{"name":"ajax","slug":"ajax","count":4,"path":"api/tags/ajax.json"},{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"},{"name":"RestFul_API","slug":"RestFul-API","count":2,"path":"api/tags/RestFul-API.json"}]},{"title":"ASP.NET MVC Filter 登录限制-类Python装饰器","slug":"asp-net-mvc-filter-python","date":"2017-12-10T10:12:21.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/asp-net-mvc-filter-python.json","excerpt":"","keywords":null,"cover":null,"content":"<p>想必学过Flask编写Web服务端的都对 <strong>@login_required</strong> 很熟悉吧,一个语句决定了访问者是否有权限访问当前页面. 那么疑问来了,ASP.NET MVC中是否有类似于Python装饰器一类的语法呢? 答案是有的,如果仅仅是权限以及登录确认的判断的话,ASP.NET MVC 有一个 <strong>AuthorizeAttribute</strong> 类,这个类的结构以及用法可以替代 <strong>@login_required</strong>,接下来编写实现代码. 首先新建一个ASP.NET MVC 项目,新建一个Filter文件夹,该文件夹下存放网站允许访问一类的类. 新建<strong>MyAuthorizeAttribute</strong>类,继承<strong>AuthorizeAttribute</strong> 类,重写AuthorizeCore和HandleUnauthorizedRequest方法. 第一个方法是授权检察,第二个方法是权限判断失败时执行的操作. 接下来实现当时间分钟是偶数时允许登录.</p>\n<pre><code>//MyAuthorizeAttribute.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\n\nnamespace WebApplication3.Filter\n{\n    public class MyAuthorizeAttribute :AuthorizeAttribute\n    {\n        protected override bool AuthorizeCore(HttpContextBase httpContext)\n        {\n            return DateTime.Now.Minute % 2 == 0;  \n        }\n        protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext)\n        {\n            filterContext.HttpContext.Response.Redirect(&quot;/Home/ShowTip&quot;);\n\n            //base.HandleUnauthorizedRequest(filterContext);  \n        }  \n    }\n}\n\n\n//HomeController.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\nusing WebApplication3.Filter;\n\nnamespace WebApplication3.Controllers\n{\n    public class HomeController : Controller\n    {\n        public ActionResult Index()\n        {\n            return View();\n        }\n\n        [MyAuthorizeAttribute]\n        public ActionResult ShowDetails2()\n        {\n            return View();\n        }\n        public ActionResult ShowTip()\n        {\n            return View();\n        }  \n    }\n}</code></pre>","text":"想必学过Flask编写Web服务端的都对 @login_required 很熟悉吧,一个语句决定了访问者是否有权限访问当前页面. 那么疑问来了,ASP.NET MVC中是否有类似于Python装饰器一类的语法呢? 答案是有的,如果仅仅是权限以及登录确认的判断的话,ASP.NET ","link":"","raw":null,"photos":[],"categories":[{"name":"ASP.Net","slug":"ASP-Net","count":3,"path":"api/categories/ASP-Net.json"},{"name":"C#","slug":"ASP-Net/C","count":2,"path":"api/categories/ASP-Net/C.json"},{"name":"MVC","slug":"ASP-Net/C/MVC","count":1,"path":"api/categories/ASP-Net/C/MVC.json"},{"name":"Web","slug":"ASP-Net/C/MVC/Web","count":1,"path":"api/categories/ASP-Net/C/MVC/Web.json"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"},{"name":"MVC","slug":"MVC","count":1,"path":"api/tags/MVC.json"},{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"}]},{"title":"ASP.NET MVC 搭建博客 Song Of The Sea","slug":"asp-net-mvc-song-of-the-sea","date":"2017-12-26T01:01:15.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/asp-net-mvc-song-of-the-sea.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171225232801.jpg","content":"<h1 id=\"第五个博客上线了\"><a href=\"#第五个博客上线了\" class=\"headerlink\" title=\"第五个博客上线了!\"></a>第五个博客上线了!</h1><p>这次使用的是ASP.NET MVC + Bootstrap3 + SignalR + 百度地图api + ajax无刷新更新页面等等…. 目标: Demo : <a href=\"http://hsdog.be-sunshine.cn\" target=\"_blank\" rel=\"noopener\">http://hsdog.be-sunshine.cn</a> ASP搭建的一个博客(部分重构之前python写的博客,大部分新添加的内容):一只划水狗 但本网站仅供交流和娱乐学习用,因为没有对标签进行处理,所以很容易就会被攻陷的.回头有空了在添加标签过滤功能. :) 代码等回头有空的时候放上来~ 预览: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ截图20171225232801.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171225232801.jpg\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ截图20171225232601.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171225232601.jpg\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ截图20171225232333.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171225232333.jpg\" alt></a> <a href=\"http://hsdog.be-sunshine.cn\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171225232359.jpg\" alt></a> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ截图20171225232410.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171225232410.jpg\" alt></a></p>\n","text":"第五个博客上线了!这次使用的是ASP.NET MVC + Bootstrap3 + SignalR + 百度地图api + ajax无刷新更新页面等等…. 目标: Demo : http://hsdog.be-sunshine.cn ASP搭建的一个博客(部分重构之前python","link":"","raw":null,"photos":[],"categories":[{"name":"ajax","slug":"ajax","count":4,"path":"api/categories/ajax.json"},{"name":"ASP.Net","slug":"ajax/ASP-Net","count":3,"path":"api/categories/ajax/ASP-Net.json"},{"name":"Bootstrap","slug":"ajax/ASP-Net/Bootstrap","count":1,"path":"api/categories/ajax/ASP-Net/Bootstrap.json"},{"name":"C#","slug":"ajax/ASP-Net/Bootstrap/C","count":1,"path":"api/categories/ajax/ASP-Net/Bootstrap/C.json"},{"name":"JS","slug":"ajax/ASP-Net/Bootstrap/C/JS","count":1,"path":"api/categories/ajax/ASP-Net/Bootstrap/C/JS.json"},{"name":"MVC","slug":"ajax/ASP-Net/Bootstrap/C/JS/MVC","count":1,"path":"api/categories/ajax/ASP-Net/Bootstrap/C/JS/MVC.json"}],"tags":[{"name":"ajax","slug":"ajax","count":4,"path":"api/tags/ajax.json"},{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"},{"name":"Web","slug":"Web","count":7,"path":"api/tags/Web.json"}]},{"title":"ASP.Net 记录贴","slug":"asp-net-recode","date":"2017-09-01T10:01:47.000Z","updated":"2019-07-03T13:51:36.858Z","comments":true,"path":"api/articles/asp-net-recode.json","excerpt":"","keywords":null,"cover":null,"content":"<p>委派: 委托是方法的抽象，它存储的就是一系列具有相同签名和返回回类型的方法的地址。调用委托的时候，委托包含的所有方法将被执行。 1.委托类型的定义 委托是类型，就好像类是类型一样。与类一样，委托类型必须在被用来创建变量以及类型对象之前声明。</p>\n<pre><code>delegate void MyDel(int x);</code></pre><p>委托类型声明： （1） 以deleagate关键字开头。 （2）返回类型+委托类型名+参数列表。 2.声明委托变量</p>\n<pre><code>MyDel del1,del2;</code></pre><p>3.初始化委托变量</p>\n<pre><code>del1 = new MyDel( myInstObj.MyM1 );\ndel2 = new MyDel( SClass.OtherM2 );</code></pre><p>4.组合委托 委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表是两个操作数的委托调用列表的副本的连接。 委托是恒定的，操作数委托创建后不会被改变。委托组合拷贝的是操作数的副本。</p>\n<pre><code>MyDel del1 = myObj.MyMethod;\nMyDel del2 = SClass.OtherM2;\nMyDel del3 = del1 + del2;   //组合调用列表</code></pre><p>5.委托加减运算 可以使用+=运算符，为委托新增方法。 同样可以使用-=运算符，为委托移除方法。</p>\n<pre><code>MyDel del = myObj.MyMethod;\ndel += SClass.OtherM2; // 增加方法\ndel -= myObj.MyMethod; // 移除方法</code></pre><p>6.委托调用 委托调用跟方法调用类似。委托调用后，调用列表的每个方法将会被执行。 在调用委托前，应判断委托是否为空。调用空委托会抛出异常。</p>\n<pre><code>if(null != del)\n{\n     del();//委托调用\n}</code></pre><p>7.匿名方法 匿名方法是在初始化委托时内联声明的方法。 基本结构：</p>\n<pre><code>deleage( 参数 ) { 语句块 }</code></pre><p>例如：</p>\n<pre><code>delegate int MyDel (int x); //定义一个委托 \n\nMyDel del = delegate( int x){ return x; };</code></pre><p>8.Lambda表达式 Lambda运算符读作”goes to”。</p>\n<pre><code>MyDel del = delegate( int x) { return x; };//匿名方法\nMyDel del2 = (int x) =&gt; {return x;};//Lambda表达式\nMyDel del3 = x =&gt; {return x};//简写的Lambda表达式</code></pre>","text":"委派: 委托是方法的抽象，它存储的就是一系列具有相同签名和返回回类型的方法的地址。调用委托的时候，委托包含的所有方法将被执行。 1.委托类型的定义 委托是类型，就好像类是类型一样。与类一样，委托类型必须在被用来创建变量以及类型对象之前声明。delegate void MyDel(","link":"","raw":null,"photos":[],"categories":[{"name":"ASP.Net","slug":"ASP-Net","count":3,"path":"api/categories/ASP-Net.json"},{"name":"C#","slug":"ASP-Net/C","count":2,"path":"api/categories/ASP-Net/C.json"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","count":6,"path":"api/tags/ASP-NET.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"C# Fluent Interface","slug":"c-fluent-interface","date":"2017-08-29T01:46:17.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/c-fluent-interface.json","excerpt":"","keywords":null,"cover":null,"content":"<p>因为每个Enumerable所包含的LINQ拓展方法,都返回了IEnumerable,这也就代表可以使用串接的方式调用多个LINQ函数,然后实现多条件筛选. 例:</p>\n<pre><code>var query=list.Where(c=&gt; c&lt;10000).Where(c=&gt;c&gt;1000);</code></pre><p>或是提取需要的数据结构:</p>\n<pre><code>var query=list.Where(c=&gt;c&lt;10000).Select(c=&gt;new {id=c});</code></pre>","text":"因为每个Enumerable所包含的LINQ拓展方法,都返回了IEnumerable,这也就代表可以使用串接的方式调用多个LINQ函数,然后实现多条件筛选. 例:var query=list.Where(c=&gt; c&lt;10000).Where(c=&gt;c&gt;10","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"DotNet","slug":"dotnet","date":"2018-03-20T11:12:35.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/dotnet.json","excerpt":"","keywords":null,"cover":null,"content":"<pre><code>SQL:\n工厂模式创建DbCommand\n    /// &lt;summary&gt;\n    /// 创建新的连接对象\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static DbCommand CreateCommand()\n    {\n        string dataProviderName = BalloonShopConfiguration.DbProviderName;\n        string connectionString = BalloonShopConfiguration.DbConnectionString;\n        ///工厂模式下新建名字为dataProviderName的连接\n        DbProviderFactory factory = DbProviderFactories.GetFactory(dataProviderName);\n        DbConnection conn = factory.CreateConnection();\n        ///项数据工厂设置连接字符串\n        conn.ConnectionString = connectionString;\n        ///创建特定于某数据库的command对象\n        DbCommand comm = conn.CreateCommand();\n        comm.CommandType = CommandType.StoredProcedure;\n        return comm;\n    }\n\n执行查询:\n    /// &lt;summary&gt;\n    /// 执行查询语句\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;command&quot;&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static DataTable ExecuteSelectCommand(DbCommand command)\n    {\n        ///将返回的Datatable\n        DataTable table;\n        try\n        {\n            //执行该命令\n            command.Connection.Open();\n            DbDataReader dr = command.ExecuteReader();\n            table = new DataTable();\n            table.Load(dr);\n            dr.Close();\n        }\n        catch (Exception e)\n        {\n            Utilities.LogError(e);\n            throw;\n        }\n        finally\n        {\n            command.Connection.Close();\n        }\n        return table;\n    }</code></pre><blockquote>\n<p>返回Datatable是因为可以使用更少的时间</p>\n</blockquote>\n","text":"SQL:工厂模式创建DbCommand    /// &lt;summary&gt;    /// 创建新的连接对象    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static D","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]}]}