{"name":"算法学习","slug":"算法学习","count":6,"postlist":[{"title":"算法学习-图论相关一些基础","slug":"base-graph","date":"2017-03-21T23:58:25.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/base-graph.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png","content":"<p><strong>【先贴上大神的代码截图】</strong> <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/bfs-dfs.png\" alt></a>   <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/SFA.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/SFA.png\" alt=\"floyd&amp;spfa\"></a>   <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstring></cstring></strong> <strong>using namespace std;</strong> <strong>struct node{</strong> **    node <em>next;*</em> **    int where;** **    int cost;** <strong>}a[10001],*first[1001];</strong> <strong>bool b[1001];</strong> <strong>inline void dfs(int now){</strong> **    b[now]=true;** **    for(node <em>x=first[now];x;x=x-&gt;next)*</em> **        if(!b[x-&gt;where])** **            dfs(x-&gt;where);** <strong>}</strong> <strong>inline void bfs(int S){</strong> **    int c[1001];** **    c[1]=S;** **    for(int k=1,l=1,l&lt;=k;++l){** **        int m=c[1];** **        for(node <em>x=first[m];x;x=x-&gt;next)*</em> **            if(!b[x-&gt;where])** **                b[x-&gt;where]=true,** **                c[++k]=x-&gt;where;    ** **    }** <strong>}</strong> <strong>//floyd只是一个模板</strong> <strong>inline void floyd(){</strong> **    for(int k=1;k&lt;=n;++k)** **        for(int i=1;i&lt;=n;++i)** **            for(int j=1;j&lt;=n;++j)** **                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);** <strong>}</strong> <strong>//可以处理负边</strong> <strong>inline void spfa(int S,int T){</strong> **    int c[1001],dist[1001];** **    c[1]=S;** **    memset(dist,127,sizeof(dist));** **    dist[S]=0;** **    for(int k=1,l=1;l&lt;=k;++l){** **        int m=c[1];** **        b[m]=false;** **        for(node <em>x=first[m];x;x=x-&gt;next)*</em> **            if(dist[m]+x-&gt;cost&lt;dist[x-&gt;where])** **            {** **                dist[x-&gt;where]=dist[m]+x-&gt;cost;** **                if(!b[x-&gt;where])** **                    b[x-&gt;where]=true,** **                    c[++k]=x-&gt;where;** **            }** **    }**   <strong>}</strong> <strong>int main(){</strong> **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【先贴上大神的代码截图】  [Figure]    【Code】#include #include #include using namespace std; struct node{ **    node next;* **    int where;** **    int ","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"代码级调试器gdb","slug":"gdb","date":"2017-03-25T11:22:57.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/gdb.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【编译】 假如编译 UVa 1339.cpp这个文件 c++ 编译:g++ -g -o “UVa 1339” “UVa 1339.cpp” 注:必须有-g,才可以用gdb调试. 【调试】 gdb “UVa 1339.exe” 注：如果文件名有字符,空格之类的,断点调试可能出错.上面就是一个教训. 【其他教程】 <a href=\"http://blog.csdn.net/txl199106/article/details/38405581\" target=\"_blank\" rel=\"noopener\">gdb教程</a></p>\n","text":"【编译】 假如编译 UVa 1339.cpp这个文件 c++ 编译:g++ -g -o “UVa 1339” “UVa 1339.cpp” 注:必须有-g,才可以用gdb调试. 【调试】 gdb “UVa 1339.exe” 注：如果文件名有字符,空格之类的,断点调试可能出错.上","link":"","raw":null,"photos":[],"categories":[{"name":"算法学习","slug":"算法学习","count":4,"path":"api/categories/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"Tarjan 强连通分量算法","slug":"tarjan-scc-algorithm","date":"2018-01-17T10:03:54.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/tarjan-scc-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg","content":"<p>Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.</p>\n<h2 id=\"学习契机-HDU-6038\"><a href=\"#学习契机-HDU-6038\" class=\"headerlink\" title=\"学习契机: HDU 6038\"></a>学习契机: <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6038\" title=\"HDU 6038\" target=\"_blank\" rel=\"noopener\">HDU 6038</a></h2><p>首先介绍下:</p>\n<h2 id=\"强连通分量\"><a href=\"#强连通分量\" class=\"headerlink\" title=\"强连通分量:\"></a>强连通分量:</h2><p>画图以明志 -- <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" alt></a> <code>Tarjan</code>算法的时间复杂度是线性的,而kos算法则需要计算图的转置.该算法由Tarjan于1972年提出,是SCC<code>(Strongly Connected Componenet,强连通分量)</code>的第一个线性算法,Tarjan算法借助于DFS,但它并不需要靠遍历顺序(Kos算法的思想)来分离SCC,而是允许SCC并存于同一颗DFS树中,然后通过某种手段将他们分开.</p>\n<h2 id=\"DAG\"><a href=\"#DAG\" class=\"headerlink\" title=\"DAG:\"></a>DAG:</h2><p>如果把一个集合看成一个点,那么所有的SCC构成了一个SCC图.这个SCC图不会存在有向环,因此是一个DAG<code>(Directed Acyclic Graph,有向无环图)</code>. 那他喵的什么是DAG呢?我把上面的那个强连通分量图给DAG化: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" alt></a></p>\n<h2 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h2><p>考虑强连通分量C,设其中第一个被发现的点为x,则C中其他点都是x的后代.我们希望在x dfs访问完成后立即输出C.这样,就可以在一棵DFS树中区分开所有SCC了.因此,问题的关键是如何发现每个SCC的第一个点.</p>\n<h3 id=\"如何判断是否是SCC顶点\"><a href=\"#如何判断是否是SCC顶点\" class=\"headerlink\" title=\"如何判断是否是SCC顶点\"></a>如何判断是否是SCC顶点</h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" alt></a> 假设我们正在判断u是否为某SCC的第一个被发现节点.如果我们发现<code>从u的子节点出发可以达到u的祖先w,显然u就不是SCC的顶点.</code>反之,如果SCC最远的顶点可以到u,则u是SCC的顶点.图中虚线表示一条或多条边和点. 我们使用两个数组来记录每个节点的状态.pre[]和lowlink[]. 当递归回溯时如果这两个数组的值相同,则表明该节点为某SCC顶点.</p>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><p>见: <a href=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" title=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/keyboarderqq/article/details/71308102</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1 id=\"此致-画个图你就知道low数组的具体作用了\"><a href=\"#此致-画个图你就知道low数组的具体作用了\" class=\"headerlink\" title=\"此致:画个图你就知道low数组的具体作用了.\"></a>此致:画个图你就知道low数组的具体作用了.</h1>","text":"Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.学习契机: HDU 6038首先介绍下:强连通分量:画图以明志 --  [Figure]  假设我们正在判断u是否为某SCC的第","link":"","raw":null,"photos":[],"categories":[{"name":"Tarjan","slug":"Tarjan","count":1,"path":"api/categories/Tarjan.json"},{"name":"图论","slug":"Tarjan/图论","count":1,"path":"api/categories/Tarjan/图论.json"},{"name":"算法学习","slug":"Tarjan/图论/算法学习","count":1,"path":"api/categories/Tarjan/图论/算法学习.json"},{"name":"连通分量","slug":"Tarjan/图论/算法学习/连通分量","count":1,"path":"api/categories/Tarjan/图论/算法学习/连通分量.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]},{"title":"博弈论","slug":"game","date":"2018-01-24T03:05:58.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/game.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg","content":"<p>[toc]</p>\n<h1 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h1><h2 id=\"博弈树\"><a href=\"#博弈树\" class=\"headerlink\" title=\"博弈树\"></a>博弈树</h2><p>重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。</p>\n<h2 id=\"SG函数\"><a href=\"#SG函数\" class=\"headerlink\" title=\"SG函数\"></a>SG函数</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个状态,则两点间有一条有向边,这样就得到了一个状态图.</p>\n<h3 id=\"巴什博奕\"><a href=\"#巴什博奕\" class=\"headerlink\" title=\"巴什博奕\"></a>巴什博奕</h3><p>以巴什博奕为例,一共有n个物品,两人轮流取,一次最少取走1个最多去走m个，最后取光的人获胜。下图展示了n=6,m=3的时候的状态图,节点内的数字表示当前状态剩下的物品的个数. <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/1516761296597.jpg\" alt></a> 假设游戏不会出现平局,即状态图是无环图的话,所有的状态可以分为两种,P态和N态。P态表示该状态对于前一个玩家来说是必胜态,而N态表示该状态对于下一个玩家来说是必胜态。例如对于n=6,m=3的巴什博奕来说,0个物品显然是P态,而还剩1、2或3个物品的状态都是N态。 一个状态被称为终止状态,如果当前状态下游戏不能再继续进行,譬如巴什博奕种物品都已经被取光了,在大部分游戏规则中,终止状态都是P态,所以如果不加特殊说明,一下都假设P态为终止状态. 从定义可知,任意一个P态,他要么是终止状态,要么他所有可以转移到的状态都是N态,而对于任意一个N态,他至少有一个后继状态是P态.</p>\n<h3 id=\"SG函数-1\"><a href=\"#SG函数-1\" class=\"headerlink\" title=\"SG函数\"></a>SG函数</h3><p>SG函数是这样定义的:对于任意状态x,他的SG函数值g(x)=mex{g(y)|y是x的后续状态},其中mex是一个对于非负整数集合S的运算, mex(S)为S中没有出现的最小负整数 。对于一个终止状态,因为他没有后继状态,所以他的SG函数值是0. 还是以上面的巴什博奕为例: n=6,m=3.用Si表示还剩i个物品的状态。S0是终止状态,所以g(S0)=0。S1的唯一后继状态是S0,所以g(S1)=1,S2可以转移到S1和S0，所以g(S2)是2.因为S3可以转移到S0,S1,S2,所以g(S3)=3.对于S4来说,它可以转移到S1，S2，S3(1，2，3),所以g(S4)=0.以此类推可以知道g(S5)=1，g(S6)=2. 如果知道一个状态SG函数值,则可以快速的判断当前状态时P态还是N态.对于一个函数,如果状态值是0则是P态,否则就是N态. g(S4),P态,先手必败(后继都是N态);g(S5)，N态(后继有P态),先手必胜.</p>\n<h1 id=\"KuangBin介绍博弈\"><a href=\"#KuangBin介绍博弈\" class=\"headerlink\" title=\"KuangBin介绍博弈\"></a>KuangBin介绍博弈</h1><h2 id=\"（一）巴什博奕（Bash-Game）：\"><a href=\"#（一）巴什博奕（Bash-Game）：\" class=\"headerlink\" title=\"（一）巴什博奕（Bash Game）：\"></a>（一）巴什博奕（Bash Game）：</h2><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个， 后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果 n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的 取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十 个，谁能报到100者胜。</p>\n<h2 id=\"（二）威佐夫博奕（Wythoff-Game）：\"><a href=\"#（二）威佐夫博奕（Wythoff-Game）：\" class=\"headerlink\" title=\"（二）威佐夫博奕（Wythoff Game）：\"></a>（二）威佐夫博奕（Wythoff Game）：</h2><p>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示 两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6， 10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有 如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1 ，而 bk= ak + k &gt; ak -1 + k-1 = bk-1 &gt; ak-1 。所以性质1。成立。 2。任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其 他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由 于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了 奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局 势；如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab + ak个物体,变为奇异局 势（ ab – ak , ab – ak+ b – ak）；如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余 的数量a – ak 即可；如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k） ,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – a j 即可。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜 ；反之，则后拿者取胜。 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 奇妙的是其中出现了黄金分割数（1+√5）/2 = 1。618…,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。</p>\n<h3 id=\"威佐夫博弈的几点判断\"><a href=\"#威佐夫博弈的几点判断\" class=\"headerlink\" title=\"威佐夫博弈的几点判断:\"></a>威佐夫博弈的几点判断:</h3><h4 id=\"非奇异局势时-先手一方只需要将当前局势变成奇异局势即可必胜\"><a href=\"#非奇异局势时-先手一方只需要将当前局势变成奇异局势即可必胜\" class=\"headerlink\" title=\"非奇异局势时,先手一方只需要将当前局势变成奇异局势即可必胜\"></a>非奇异局势时,先手一方只需要将当前局势变成奇异局势即可必胜</h4><h4 id=\"奇异局势时-后手一方只需要将非奇异局势变成奇异局势必胜\"><a href=\"#奇异局势时-后手一方只需要将非奇异局势变成奇异局势必胜\" class=\"headerlink\" title=\"奇异局势时,后手一方只需要将非奇异局势变成奇异局势必胜\"></a>奇异局势时,后手一方只需要将非奇异局势变成奇异局势必胜</h4><h2 id=\"（三）尼姆博奕（Nimm-Game）：\"><a href=\"#（三）尼姆博奕（Nimm-Game）：\" class=\"headerlink\" title=\"（三）尼姆博奕（Nimm Game）：\"></a>（三）尼姆博奕（Nimm Game）：</h2><p>有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首 先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是 （0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一 下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情 形。 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示 这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结 果： 1 =二进制01 2 =二进制10 3 =二进制11 （+） ——————— 0 =二进制00 （注意不进位） 对于奇异局势（0，n，n）也一样，结果也是0。 任何奇异局势（a，b，c）都有a（+）b（+）c =0。 <strong>如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b &lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果: a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（a（+）b）即可。</strong> 例1。（14，21，39），14（+）21=27，39-27=12，所以从39中拿走12个物体即可达 到奇异局势（14，21，27）。 例2。（55，81，121），55（+）81=102，121-102=19，所以从121中拿走19个物品 就形成了奇异局势（55，81，102）。 例3。（29，45，58），29（+）45=48，58-48=10，从58中拿走10个，变为（29，4 5，48）。</p>\n<pre><code>例4。我们来实际进行一盘比赛看看：\n    甲:(7,8,9)-&gt;(1,8,9)奇异局势\n    乙:(1,8,9)-&gt;(1,8,4)\n    甲:(1,8,4)-&gt;(1,5,4)奇异局势\n    乙:(1,5,4)-&gt;(1,4,4)\n    甲:(1,4,4)-&gt;(0,4,4)奇异局势\n    乙:(0,4,4)-&gt;(0,4,2)\n    甲:(0.4,2)-&gt;(0,2,2)奇异局势\n    乙:(0,2,2)-&gt;(0,2,1)\n    甲:(0,2,1)-&gt;(0,1,1)奇异局势\n    乙:(0,1,1)-&gt;(0,1,0)\n    甲:(0,1,0)-&gt;(0,0,0)奇异局势\n    甲胜。</code></pre><h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><h3 id=\"斐波那契博弈\"><a href=\"#斐波那契博弈\" class=\"headerlink\" title=\"斐波那契博弈\"></a>斐波那契博弈</h3><p>1、问题模型： 有一堆个数为n的石子，游戏双方轮流取石子，满足： （1）先手不能在第一次把所有的石子取完； （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。 2、解决思路： 当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 证明：根据“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。如n=83 = 55+21+5+2，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，那么一定是先手取走这5颗石子中的最后一颗，同理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。 反证：如果n是Fibonacci数，如n=89：记先手一开始所取的石子数为y （1）若y&gt;=34颗（也就是89的向前两项），那么一定后手赢，因为89-34=55=34+21&lt;2*34。 （2）y&lt;34时剩下的石子数x介于55到89之间，它一定不是一个Fibonacci数，把x分解成Fibonacci数：x=55+f[i]+…+f[j]，若，如果f[j]&lt;=2y，那么对B就是面临x局面的先手，所以根据之前的分析，后手只要先取f[j]个即可，以后再按之前的分析就可保证必胜。</p>\n<h3 id=\"公平组合博弈（Impartial-Combinatori-Games）\"><a href=\"#公平组合博弈（Impartial-Combinatori-Games）\" class=\"headerlink\" title=\"公平组合博弈（Impartial Combinatori Games）\"></a>公平组合博弈（Impartial Combinatori Games）</h3><p>1、定义： （1）两人参与。 （2）游戏局面的状态集合是有限。 （3）对于同一个局面，两个游戏者的可操作集合完全相同 （4）游戏者轮流进行游戏。 （5）当无法进行操作时游戏结束，此时不能进行操作的一方算输。 （6）无论游戏如何进行，总可以在有限步数之内结束。 2、模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有公平组合游戏（Impartial Combinatori Games）的抽象模型。其实，任何一个ICG都可以通过把每个局势看成一个顶点，对每个局势和它的子局势连一条有向边来抽象成这个“有向图游戏”。 3、解决思路： 现在，假定我们给出两个游戏G1 和 G2。如果我们只知道单个游戏的P-状态和N-状态我们能够正确地玩好游戏和G1 + G2吗？答案是否定的。不难看出两个P-状态的和总是P-状态，P-状态和N-状态的和总是N-状态。但是两个N-状态的和既可能是P-状态也可能是N-状态。因此，只知道单个游戏的P-状态和N-状态是不够的。 为了正确地玩好游戏和我们需要推广P-状态和N-状态，它就是Sprague-Grudy函数（或者简称为g函数） 4、Sprague-Grudy定理： 令N = {0, 1, 2, 3, …} 为自然数的集合。Sprague-Grundy 函数给游戏中的每个状态分配了一个自然数。结点v的Grundy值等于没有在v的后继的Grundy值中出现的最小自然数. 形式上：给定一个有限子集 S ⊂ N,令mex S(最小排斥值)为没有出现在S中的最小自然数。定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。 5、性质： （1）所有的终结点所对应的顶点，其SG值为0，因为它的后继集合是空集——所有终结点是必败点（P点）。 （2）对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0——无论如何操作，从必败点（P点）都只能进入必胜点（N点）//对手走完又只能把N留给我们。 （3）对于一个g(x)!=0的顶点，必定存在一个后继点y满足g(y)=0——从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）//就是那种我们要走的方法。 6、应用： （1）可选步数为1-m的连续整数，直接取模即可，SG(x) = x % (m+1); （2）可选步数为任意步，SG(x) = x; （3）可选步数为一系列不连续的数，用mex(计算每个节点的值)</p>\n","text":"[toc]博弈论博弈树重点在于min和max状态间的关系,以及每个树节点的评分值.以及优化的Alpha-Beta剪枝.省略不写。SG函数基本概念在公平的组合游戏中(游戏规则对于两个玩家不加以区分),可以把所有有可能出现的状态看作是图的节点,如果从一个状态可以通过一步转移到达另一个","link":"","raw":null,"photos":[],"categories":[{"name":"博弈论","slug":"博弈论","count":3,"path":"api/categories/博弈论.json"},{"name":"算法学习","slug":"博弈论/算法学习","count":1,"path":"api/categories/博弈论/算法学习.json"}],"tags":[{"name":"博弈论","slug":"博弈论","count":9,"path":"api/tags/博弈论.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"数论","slug":"number-theory","date":"2018-02-06T07:59:57.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/number-theory.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>对于这一个知识点的学习,我大概会通过 《ACM国际大学生程序设计竞赛:知识与入门》 以及 lrj的蓝书以及《ACM/ICPC数论及应用》来学习.</p>\n</blockquote>\n<h1 id=\"素数\"><a href=\"#素数\" class=\"headerlink\" title=\"素数\"></a>素数</h1><h2 id=\"素数筛法\"><a href=\"#素数筛法\" class=\"headerlink\" title=\"素数筛法\"></a>素数筛法</h2><h3 id=\"艾氏筛法-O-nloglogn\"><a href=\"#艾氏筛法-O-nloglogn\" class=\"headerlink\" title=\"艾氏筛法(O(nloglogn))\"></a>艾氏筛法(O(nloglogn))</h3><blockquote>\n<p>通常使用艾氏筛法,而艾氏筛法的思想也可用于很多地方.</p>\n</blockquote>\n<h3 id=\"线性筛法\"><a href=\"#线性筛法\" class=\"headerlink\" title=\"线性筛法\"></a>线性筛法</h3><h4 id=\"伪码表述\"><a href=\"#伪码表述\" class=\"headerlink\" title=\"伪码表述\"></a>伪码表述</h4><blockquote>\n<p>算法: 线性的素数筛法 输出: 一个集合S,表示1~n以内的素数集合 具体流程:</p>\n<blockquote>\n<p>(1) 将S初始化为{2,…,n} (2) 维护当前确定的素数的列表L,并初始化为空 (3) 对于 2 到 n 的每一个i</p>\n<blockquote>\n<p>(3.1) 如果当前i∈S,将i加入L (3.2) 对于L中的每一个元素p</p>\n<blockquote>\n<p>(3.2.1) 若i×p&gt;n,结束循环 (3.2) (3.2.2) 将i×p移出S (3.2.3) 如果p整除i,结束循环 (3.2)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"代码-1亿数据量1s\"><a href=\"#代码-1亿数据量1s\" class=\"headerlink\" title=\"代码(1亿数据量1s)\"></a>代码(1亿数据量1s)</h4><blockquote>\n<p>实锤完毕…我的电脑竟然可以存下1亿的数组…</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100001000\nusing namespace std;\n\nbool valid[maxn];\nint prime[maxn];\n/*素数筛法 O(n),对于每个素数只标记一次*/\nvoid getPrime(int n,int &amp;tot,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint main(){\n    clock_t t1 = clock();\n    int tot=0;\n    getPrime(100000000,tot,prime);\n    clock_t t2 = clock();\n\n    cout&lt;&lt;tot&lt;&lt;endl;\n    cout&lt;&lt;prime[5760000]&lt;&lt;endl;\n    cout&lt;&lt;&quot;总运行时间为: &quot;&lt;&lt;(double)(t2-t1)/ CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;&lt;&lt;endl;\n    return 0;\n}</code></pre><h2 id=\"素数估计\"><a href=\"#素数估计\" class=\"headerlink\" title=\"素数估计\"></a>素数估计</h2><blockquote>\n<p>如果我们设Pi(x)表示不超过x的素数的个数.可以用</p>\n<blockquote>\n<p>x/lnx对Pi(x)进行估计</p>\n</blockquote>\n<p>不到万不得已别用,误差蛮大的</p>\n</blockquote>\n<h2 id=\"素数判定-Miller-Rabin\"><a href=\"#素数判定-Miller-Rabin\" class=\"headerlink\" title=\"素数判定(*Miller-Rabin)\"></a>素数判定(*Miller-Rabin)</h2><blockquote>\n<p>朴素的素数判定法是通过枚举从2到n^0.5内所有的整数,看他是否能整除n.时间复杂度为O(n^0.5) 此外有一个基于概率的常数时间的素数判定法</p>\n<blockquote>\n<p>Miller-Rabin素数判定</p>\n</blockquote>\n</blockquote>\n<h1 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h1><blockquote>\n<p>求gcd(a,b),欧几里得的一个结论是</p>\n<blockquote>\n<p>gcd(a,b)=gcd(b,a%b) 求得最后结果即可</p>\n</blockquote>\n</blockquote>\n<h2 id=\"gcd性质\"><a href=\"#gcd性质\" class=\"headerlink\" title=\"gcd性质\"></a>gcd性质</h2><pre><code> gcd(a,b)=gcd(b,a) （交换律）\ngcd(-a,b)=gcd(a,b)\ngcd(a,a)=|a|\ngcd(a,0)=|a|\ngcd(a,1)=1\ngcd(a,b)=gcd(b, a mod b)\ngcd(a,b)=gcd(b, a-b)\n如果有附加的一个自然数m,\n则: gcd(ma,mb)=m * gcd(a,b) (分配律)\ngcd(a+mb ,b)=gcd(a,b)\n如果m是a和b的最大公约数，\n则： gcd(a/m ,b/m)=gcd(a,b)/m\n在乘法函数中有：\ngcd(ab,m)=gcd(a,m) * gcd(b,m)\n两个整数的最大公约数主要有两种寻找方法：\n* 两数各分解质因数，然后取出同样有的质因数乘起来\n*辗转相除法（扩展版）\n和最小公倍数（lcm）的关系：\ngcd(a, b) * lcm(a, b) = ab\na与b有最大公约数，\n两个整数的最大公因子可用于计算两数的最小公倍数，或分数化简成最简分数。\n两个整数的最大公因子和最小公倍数中存在分配律：\n* gcd(a, lcm(b, c)) = lcm(gcd(a, b), gcd(a, c))\n* lcm(a, gcd(b, c)) = gcd(lcm(a, b), lcm(a, c))\n在坐标里，将点(0, 0)和(a, b)连起来，通过整数坐标的点的数目（除了(0, 0)一点之外）就是gcd(a, b)。</code></pre><h2 id=\"扩展欧几里得\"><a href=\"#扩展欧几里得\" class=\"headerlink\" title=\"扩展欧几里得\"></a>扩展欧几里得</h2><blockquote>\n<p>扩展算法可以求出两个整数x和y,使得ax+by=gcd(a,b)。在此前提下|x|+|y|取最小值。 对此证明: <a href=\"http://blog.csdn.net/qq_20200047/article/details/71159677\" title=\"http://blog.csdn.net/qq_20200047/article/details/71159677\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20200047/article/details/71159677</a></p>\n<blockquote>\n<p>即可以证明a和b的最大公约数可以写成a和b的线性表示.</p>\n</blockquote>\n</blockquote>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a,LL b){\n    return b ==0?a:gcd(b,a%b);\n}\n\n//求整数x和y,使得ax+by=d,在此前提下|x|+|y|取最小值.\n//即使a,b在int范围内,也可能超出int\nvoid exgcd(LL a,LL b,LL &amp;d,LL &amp;x,LL &amp;y){\n    if(!b){d=a;x=1;y=0;}\n    else {exgcd(b,a%b,d,y,x);y-=x*(a/b);}\n}\n\nint main(){\n\n    return 0;\n}</code></pre><h1 id=\"一些性质\"><a href=\"#一些性质\" class=\"headerlink\" title=\"一些性质\"></a>一些性质</h1><blockquote>\n<p>记(a,b)为gcd(a,b)</p>\n<blockquote>\n<p>则</p>\n<blockquote>\n<p>(a,b)=(b,a) 且 (a,b,c)=((a,b),c)=(a,(b,c))</p>\n</blockquote>\n</blockquote>\n<p>记[a,b]为lcm(a,b)</p>\n<blockquote>\n<p>有同上结论</p>\n</blockquote>\n<p>(a,b)*[a,b]=ab (gcd求lcm的由来)</p>\n</blockquote>\n<h1 id=\"唯一分解定理\"><a href=\"#唯一分解定理\" class=\"headerlink\" title=\"唯一分解定理\"></a>唯一分解定理</h1><blockquote>\n<p>简单说吧,对于任意一个整数,都可以化简成素数次幂乘积的形式.</p>\n</blockquote>\n<h2 id=\"确定正整数n的正约数个数\"><a href=\"#确定正整数n的正约数个数\" class=\"headerlink\" title=\"确定正整数n的正约数个数\"></a>确定正整数n的正约数个数</h2><blockquote>\n<p>由唯一分解定理得到的所有素数的幂可以推出约数个数 设第i个素数的幂为{ai}</p>\n<blockquote>\n<p>count=(a1+1)<em>(a2+1)</em>(a3+1)<em>…</em>(as+1)</p>\n</blockquote>\n</blockquote>\n<h2 id=\"而这玩意也有一个玄学快速分解算法\"><a href=\"#而这玩意也有一个玄学快速分解算法\" class=\"headerlink\" title=\"而这玩意也有一个玄学快速分解算法\"></a>而这玩意也有一个玄学快速分解算法</h2><h3 id=\"Pollard’s-Rho\"><a href=\"#Pollard’s-Rho\" class=\"headerlink\" title=\"Pollard’s Rho\"></a>Pollard’s Rho</h3><blockquote>\n<p>因为目前题目出现的概率很低,所以延迟学习,先学其他的.</p>\n</blockquote>\n<h1 id=\"不定方程\"><a href=\"#不定方程\" class=\"headerlink\" title=\"不定方程\"></a>不定方程</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>变量个数多于方程个数,并且只考虑整数解的方程被称之为不定方程。典型的二元一次不定式形式为ax+by=c,其中a、b、c皆为已知整数,a、b都不为0,x、y为未知数.</p>\n</blockquote>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><blockquote>\n<p>我们清楚以上方程的形式相当于前面提到过的扩展欧几里得式. 以下我们用python中的整除 ‘//‘ 代表数学记号整除 1.二元一次方程ax+by=c有解的充要条件:</p>\n<blockquote>\n<p>(a,b)//c 并且当(a,b)//c的时候该方程等价于</p>\n<blockquote>\n<p>(a/(a,b))*x+(b/(a,b))*y=(c/(a,b))</p>\n</blockquote>\n</blockquote>\n<p>2.假设二元一次不定方程ax+by=c有解,并且x0、y0为方程的一组解,则他的所有解可以表示为:</p>\n<blockquote>\n<p>x=x0-(b/(a,b))*t y=y0+(a/(a,b))*t t为任意整数</p>\n</blockquote>\n<p>3.不定方程非负解 暂略</p>\n</blockquote>\n<h1 id=\"同余方程与欧拉定理\"><a href=\"#同余方程与欧拉定理\" class=\"headerlink\" title=\"同余方程与欧拉定理\"></a>同余方程与欧拉定理</h1><h2 id=\"同余方程\"><a href=\"#同余方程\" class=\"headerlink\" title=\"同余方程\"></a>同余方程</h2><blockquote>\n<p>假设m≠0.若m//(a-b)则称a同余于b模m,记为</p>\n<blockquote>\n<p>a≡b(mod m)</p>\n<blockquote>\n<p>证:</p>\n<blockquote>\n<p>a=rm+d b=km+d a-b=(r-k)m mod m = 0</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"定理1\"><a href=\"#定理1\" class=\"headerlink\" title=\"定理1\"></a>定理1</h3><blockquote>\n<p>a≡b(mod m),当且仅当m//(a-b)</p>\n</blockquote>\n<h3 id=\"定理2\"><a href=\"#定理2\" class=\"headerlink\" title=\"定理2\"></a>定理2</h3><blockquote>\n<p>a≡b(mod m),当且仅当存在整数k,使得a=b+km</p>\n</blockquote>\n<h3 id=\"定理3\"><a href=\"#定理3\" class=\"headerlink\" title=\"定理3\"></a>定理3</h3><blockquote>\n<p>同余关系是等价关系,即满足以下三条:</p>\n<blockquote>\n<ol>\n<li>自反性 a≡a(mod m)</li>\n<li>对称性 a≡b(mod m),b≡a(mod m)</li>\n<li>传递性 a≡b(mod m),b≡c(mod m),则a≡c(mod m)</li>\n</ol>\n</blockquote>\n</blockquote>\n<h3 id=\"※剩余系\"><a href=\"#※剩余系\" class=\"headerlink\" title=\"※剩余系\"></a><strong>※</strong>剩余系</h3><blockquote>\n<p>指对于一个正整数n,一个整数集合中的数mod n所得的余数域.</p>\n</blockquote>\n<h4 id=\"完全剩余系\"><a href=\"#完全剩余系\" class=\"headerlink\" title=\"完全剩余系\"></a>完全剩余系</h4><blockquote>\n<p>如果一个整数集合的剩余系包含 1~n-1 所有n可能的余数,则该剩余系被称为完全剩余系,我们简记为 Zn.</p>\n<blockquote>\n<p>比如 Z6={0,1,2,3,4,5}</p>\n</blockquote>\n</blockquote>\n<h5 id=\"缩系\"><a href=\"#缩系\" class=\"headerlink\" title=\"缩系\"></a>缩系</h5><blockquote>\n<p>指在模n意义下完全剩余系中与n互素的剩余系,简记为Zn*.</p>\n</blockquote>\n<h4 id=\"Zn的同余等价类\"><a href=\"#Zn的同余等价类\" class=\"headerlink\" title=\"Zn的同余等价类\"></a>Zn的同余等价类</h4><blockquote>\n<p>Zn中的每个元素都代表所有与他同余的整数,比如n=5时,Z5中的元素”3”实际上代表了3,3+5,3+10…,所有这些整数除以5的余数都是3.</p>\n<blockquote>\n<p>我们把满足同余关系的所有整数看成一个同余等价类,比如 3,8,13,18 都属于”模5等于3” 这个同余等价类</p>\n</blockquote>\n</blockquote>\n<h4 id=\"※关于取余等式-k-a-b-的一些性质\"><a href=\"#※关于取余等式-k-a-b-的一些性质\" class=\"headerlink\" title=\"※关于取余等式 k=a%b 的一些性质\"></a><strong>※</strong>关于取余等式 k=a%b 的一些性质</h4><h5 id=\"即-a-b-n等-Zn同于等价类意义下四则运算\"><a href=\"#即-a-b-n等-Zn同于等价类意义下四则运算\" class=\"headerlink\" title=\"即(a+b)%n等,Zn同于等价类意义下四则运算\"></a>即(a+b)%n等,Zn同于等价类意义下四则运算</h5><blockquote>\n<p>加法</p>\n<blockquote>\n<p>(a+b)%n = ((a%n)+(b%n))%n</p>\n</blockquote>\n<p>减法</p>\n<blockquote>\n<p>(a-b)%n = ((a%n)-(b%n)+n)%n</p>\n</blockquote>\n<p>乘法</p>\n<blockquote>\n<p>ab%n=(a%n)(b%n)%n</p>\n</blockquote>\n<p>异或</p>\n<blockquote>\n<p>(a^b)%n=((a%n)^b)%n</p>\n</blockquote>\n</blockquote>\n<h4 id=\"※Zn意义下的除法-模乘法的逆、逆元\"><a href=\"#※Zn意义下的除法-模乘法的逆、逆元\" class=\"headerlink\" title=\"※Zn意义下的除法(模乘法的逆、逆元)\"></a><strong>※</strong>Zn意义下的除法(模乘法的逆、<strong>逆元</strong>)</h4><blockquote>\n<p>首先说下用处,通常在大整数 a/b 时,或者 c/d<em>p/x…但最后结果*</em>一定是整数**时,并且对ans%n,为了避免中间除法运算,我们会用逆元(刚开始学,只知道这些用途,如有缺漏,欢迎补充). 那么向下进行吧</p>\n<blockquote>\n<p>模乘法的逆:</p>\n<blockquote>\n<p>在某些情况下 Zn中的两个元素a和b满足 Zn意义下 ab=1,即ab≡1(mod n).比如</p>\n<blockquote>\n<p>在 Z15 中,7*13=1</p>\n<blockquote>\n<p>即(7*13)%15=1</p>\n</blockquote>\n</blockquote>\n<p>在这种情况下,我们称a和b互为乘法的逆,记为 b=a(-1),a=b(-1) [-1代表上标]. 这个逆的运算很像”倒数”,因为在剩余系中,模n意义下当a(-1)存在时,”除以”一个数a等价于乘以他的乘法逆a(-1),比如在 Z15 中 7(-1)=13,因此3/7=3*7(-1)=3*13=9</p>\n<blockquote>\n<p>这时我们会产生疑问,3/7甚至不是整数,怎么可能等于9? 请注意:</p>\n<blockquote>\n<p>1 我们是在模n意义下对除法进行运算. 2 剩余系中每个元素对应一个同余等价类, 3/7=9的实际含义是”假定有两个整数a和b,其中a/b是整数,且a和b除以15的余数分别为3和7,则a/b除以15的余数等于 9”</p>\n<blockquote>\n<p>比如a=528,b=22就是一例</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h5 id=\"除法逆元合理性证明\"><a href=\"#除法逆元合理性证明\" class=\"headerlink\" title=\"除法逆元合理性证明\"></a>除法逆元合理性证明</h5><blockquote>\n<p>设我们要求 （a / b） mod p 且 b * k ≡ 1 (mod p),即k为b的逆元</p>\n<blockquote>\n<p>注意这里我们可以用扩展欧几里得求出是否存在k,以及k的值 即 答案为 (a * k) mod p 因为 b * k ≡ 1 (mod p) 则有 b * k = p* x+1 得到 k = (p * x + 1) / b 将 k 代入(a * k) mod p</p>\n<blockquote>\n<p>得到： (a * (p * x + 1) / b) mod p =((a * p * x) / b + a / b) mod p =[((a * p * x) / b) mod p +(a / b)] mod p =[(p * ((a * x) / b)) mod p +(a / b)] mod p =(0 + (a / b)) mod p = (a/b) mod p</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"定理4\"><a href=\"#定理4\" class=\"headerlink\" title=\"定理4\"></a>定理4</h3><blockquote>\n<p>若a,b,c是整数,m是正整数,且 a≡b(mod m) ,则</p>\n<blockquote>\n<p>(1) a+c ≡ b+c(mod m) (2) a-c ≡ b-c(mod m) (3) ac ≡ bc(mod m)</p>\n</blockquote>\n</blockquote>\n<h3 id=\"定理5\"><a href=\"#定理5\" class=\"headerlink\" title=\"定理5\"></a>定理5</h3><blockquote>\n<p>设a,b,c,d为整数,m为正整数,若a≡b(mod m),c≡d(mod m)则(注: 一下定理两边值不一定相等,只是mod m相等):</p>\n<blockquote>\n<p>(1) ax+cy≡bx+dy(mod m) 其中x,y为任意整数,即同余式可以相加 (2) ac≡bd(mod m) 即同余式可以相乘 (3) a^n≡b^n(mod m) 由上面那个可以推得,n&gt;0 (4) f(a)≡f(b)(mod m) 其中f(x)为任一整数系数多项式</p>\n</blockquote>\n</blockquote>\n<h3 id=\"定理6\"><a href=\"#定理6\" class=\"headerlink\" title=\"定理6\"></a>定理6</h3><blockquote>\n<p>设a,b,c,d为整数,m为正整数,则</p>\n<blockquote>\n<p>(1) 若 a≡b(mod m),且d//m,则a≡b(mod d) (2) 若 a≡b(mod m),则gcd(a,m)≡gcd(b,m) (3) a≡b(mod mi)(1&lt;=i&lt;=n)同时成立,当且仅当 a≡b(mod[m1,m2,m3…mn])</p>\n</blockquote>\n</blockquote>\n<h3 id=\"定理7\"><a href=\"#定理7\" class=\"headerlink\" title=\"定理7\"></a>定理7</h3><blockquote>\n<p>若ac≡bc(mod m),且gcd(c,m)=d,则a≡b(mod m/d) 证:</p>\n<blockquote>\n<p>记 c=dc1,m=dm1,其中c1,m1互素</p>\n<blockquote>\n<p>由 ac≡bc(mod m) 得 m//(ac-bc) 即 dm1//d(a-b)c1 故 m1//(a-b)c1 由下面那个整除的性质,因为 m1,c1 互质 则 m1//(a-b) 得 a≡b(mod m1) 即 a≡b(mod m/d)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"整除的性质\"><a href=\"#整除的性质\" class=\"headerlink\" title=\"整除的性质\"></a>整除的性质</h4><blockquote>\n<p>若m | nk, 且m与k互素, 则m | n</p>\n</blockquote>\n<h1 id=\"欧拉函数\"><a href=\"#欧拉函数\" class=\"headerlink\" title=\"欧拉函数\"></a>欧拉函数</h1><blockquote>\n<p>以前写过一次: 连接: <a href=\"http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/\" title=\"http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/</a></p>\n</blockquote>\n","text":"对于这一个知识点的学习,我大概会通过 《ACM国际大学生程序设计竞赛:知识与入门》 以及 lrj的蓝书以及《ACM/ICPC数论及应用》来学习.素数素数筛法艾氏筛法(O(nloglogn))通常使用艾氏筛法,而艾氏筛法的思想也可用于很多地方.线性筛法伪码表述算法: 线性的素数筛法","link":"","raw":null,"photos":[],"categories":[{"name":"数论","slug":"数论","count":1,"path":"api/categories/数论.json"},{"name":"算法学习","slug":"数论/算法学习","count":1,"path":"api/categories/数论/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]},{"title":"手撸算法","slug":"review-datastructure","date":"2017-05-26T02:55:08.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/review-datastructure.json","excerpt":"","keywords":null,"cover":null,"content":"<p>[toc]</p>\n<blockquote>\n<p>楼教主的男人八题: <a href=\"https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html\" title=\"https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html\" target=\"_blank\" rel=\"noopener\">https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html</a></p>\n</blockquote>\n<p>远离之前的模板代码,从原理上开始手撸数据结构. <strong>代码均上传至github仓库.</strong></p>\n<h1 id=\"【Dijsktra-2017-5-26】\"><a href=\"#【Dijsktra-2017-5-26】\" class=\"headerlink\" title=\"【Dijsktra 2017/5/26】\"></a>【Dijsktra 2017/5/26】</h1><p>前向星+优先队列优化+路径回溯 <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Dijsktra/Dijsktra.cpp\" target=\"_blank\" rel=\"noopener\">Dijsktra.cpp</a></strong></p>\n<h1 id=\"【并查集-2017-5-27】\"><a href=\"#【并查集-2017-5-27】\" class=\"headerlink\" title=\"【并查集 2017/5/27】\"></a>【并查集 2017/5/27】</h1><p><strong>路径压缩,启发式rank优化,将rank较小的并到rank大的集合.</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Union-Find-Set/Union-Find.cpp\" target=\"_blank\" rel=\"noopener\">Union-Find-Set.cpp</a></strong></p>\n<h1 id=\"【树状数组-2017-6-21】\"><a href=\"#【树状数组-2017-6-21】\" class=\"headerlink\" title=\"【树状数组 2017/6/21】\"></a>【树状数组 2017/6/21】</h1><p><strong>lowbit() x&amp;(-x),前缀和,LA 4329</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.cpp\" target=\"_blank\" rel=\"noopener\">树状数组.cpp</a></strong></p>\n<h1 id=\"【快速排序-2017-11-4】\"><a href=\"#【快速排序-2017-11-4】\" class=\"headerlink\" title=\"【快速排序 2017/11/4】\"></a>【快速排序 2017/11/4】</h1><p><code>java</code></p>\n<pre><code>import java.util.Random;\n\npublic class Quick\n{\n    private static int cnt=0;\n    public static void sort(int[] a){\n        Random rand = new Random();\n        System.out.println(&quot;快排之前:&quot;);\n        for(int i=0;i&lt;20;++i){\n            a[i]=rand.nextInt(100);\n            System.out.print(a[i]+&quot; &quot;);\n        }\n        sort(a,0,a.length - 1);\n    }\n    public static void sort(int[] a,int lo,int hi){\n        if(hi &lt;= lo) return;\n        int j = partition(a,lo,hi);//切分\n        sort(a,lo,j-1);\n        sort(a,j+1,hi);\n    }\n    public static int partition(int[] a,int lo,int hi){\n        //将数组切分为a[lo..i-1],a[i],a[i+1..hi]\n        int i=lo,j=hi+1;//左右扫描指针\n        int pt=a[lo];//切分元素\n        while(true){\n            //扫描左右,检查扫描是否结束并交换元素\n            while(a[++i]&lt;pt)if(i==hi) break;//扫描到最左边都没找到大于等于pt的\n            while(a[--j]&gt;pt)if(j==lo) break;\n            if(i&gt;=j) break;//指针重合\n            swap(a,i,j);//没有问题,交换两值\n        }\n        swap(a,lo,j);//将作为基准的数放回正确的位置,切分为两部分,大于基准,小于基准\n        return j;\n    }\n    public static void swap(int[] a,int x,int y){\n        if(x == y) return;\n        a[x]=a[x]^a[y];\n        a[y]=a[y]^a[x];\n        a[x]=a[x]^a[y];\n        cnt++;\n        System.out.println(&quot;\\n第&quot;+cnt+&quot;次变化 &quot;+x+&quot; to &quot;+y+&quot; : &quot;);\n        for(int item: a){\n            System.out.print(item+&quot; &quot;);\n        }\n    }\n    public static void main(String[] args){\n        int[] a=new int[20];\n        sort(a);\n        System.out.println(&quot;\\n快排之后:&quot;);\n        for(int item: a){\n            System.out.print(item+&quot; &quot;);\n        }\n    }\n}</code></pre><p><code>C++</code></p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\nusing namespace std;\n\nint qpartition(int *a,int lo,int hi){\n    int v=a[lo];\n    int i=lo,j=hi+1;\n    while(true){\n        while(a[++i]&lt;v)if(i==hi)break;\n        while(a[--j]&gt;v)if(j==lo)break;\n        if(i&gt;=j)break;\n        swap(a[i],a[j]);\n    }\n    swap(a[lo],a[j]);\n    return j;\n}\n\nvoid qsort(int *a,int lo,int hi){\n    if(lo&gt;=hi) return;\n    int j=qpartition(a,lo,hi);\n    qsort(a,lo,j-1);\n    qsort(a,j+1,hi);\n}\n\nint main(){\n    srand((unsigned)time(NULL));\n    int a[20];\n    for(int i=0;i&lt;20;++i){\n        a[i]=rand()%100;\n        printf(&quot;%d &quot;,a[i]);\n    }\n    printf(&quot;\\n&quot;);\n    qsort(a,0,19);\n    for(int i=0;i&lt;20;++i){\n        printf(&quot;%d &quot;,a[i]);\n    }\n    return 0;\n}</code></pre><p><strong>Output:</strong></p>\n<pre><code>快排之前:\n29 41 75 80 82 60 0 51 10 57 26 5 84 70 60 78 10 29 11 56 \n第1次变化 1 to 18 : \n29 11 75 80 82 60 0 51 10 57 26 5 84 70 60 78 10 29 41 56 \n第2次变化 2 to 17 : \n29 11 29 80 82 60 0 51 10 57 26 5 84 70 60 78 10 75 41 56 \n第3次变化 3 to 16 : \n29 11 29 10 82 60 0 51 10 57 26 5 84 70 60 78 80 75 41 56 \n第4次变化 4 to 11 : \n29 11 29 10 5 60 0 51 10 57 26 82 84 70 60 78 80 75 41 56 \n第5次变化 5 to 10 : \n29 11 29 10 5 26 0 51 10 57 60 82 84 70 60 78 80 75 41 56 \n第6次变化 7 to 8 : \n29 11 29 10 5 26 0 10 51 57 60 82 84 70 60 78 80 75 41 56 \n第7次变化 0 to 7 : \n10 11 29 10 5 26 0 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第8次变化 1 to 6 : \n10 0 29 10 5 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第9次变化 2 to 4 : \n10 0 5 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第10次变化 0 to 3 : \n10 0 5 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第11次变化 0 to 2 : \n5 0 10 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第12次变化 0 to 1 : \n0 5 10 10 29 26 11 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第13次变化 4 to 6 : \n0 5 10 10 11 26 29 29 51 57 60 82 84 70 60 78 80 75 41 56 \n第14次变化 9 to 18 : \n0 5 10 10 11 26 29 29 51 41 60 82 84 70 60 78 80 75 57 56 \n第15次变化 8 to 9 : \n0 5 10 10 11 26 29 29 41 51 60 82 84 70 60 78 80 75 57 56 \n第16次变化 11 to 19 : \n0 5 10 10 11 26 29 29 41 51 60 56 84 70 60 78 80 75 57 82 \n第17次变化 12 to 18 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 70 60 78 80 75 84 82 \n第18次变化 13 to 14 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 60 70 78 80 75 84 82 \n第19次变化 10 to 13 : \n0 5 10 10 11 26 29 29 41 51 60 56 57 60 70 78 80 75 84 82 \n第20次变化 10 to 12 : \n0 5 10 10 11 26 29 29 41 51 57 56 60 60 70 78 80 75 84 82 \n第21次变化 10 to 11 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 78 80 75 84 82 \n第22次变化 16 to 17 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 78 75 80 84 82 \n第23次变化 15 to 16 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 84 82 \n第24次变化 18 to 19 : \n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 82 84 \n快排之后:\n0 5 10 10 11 26 29 29 41 51 56 57 60 60 70 75 78 80 82 84 </code></pre><h1 id=\"【动态规划-划分数-2017-11-16】\"><a href=\"#【动态规划-划分数-2017-11-16】\" class=\"headerlink\" title=\"【动态规划-划分数 2017/11/16】\"></a>【动态规划-划分数 2017/11/16】</h1><p><code>java</code> 动态转移方程： dp[i][j]: j的i划分数 j&gt;=i: dp[i][j]=dp[i-1][j]+dp[i][j-i] i&gt;j: dp[i][j]=dp[i-1][j] 即有一个划分数为0时的目标状态是dp[i-1][j]</p>\n<pre><code>import java.util.*;\npublic class stlin {\n    public static void main(String[] args){\n        Scanner in=new Scanner(System.in);\n        int n,m,M;\n        n=in.nextInt();\n        m=in.nextInt();\n        M=in.nextInt();\n        solve(n,m,M);\n    }\n    public static void solve(int n,int m,int M){\n        int[][] dp=new int[m+1][n+1]; \n        //递推式=&gt;dp[i][j]=dp[i-1][j](ai=0时对应的是i-1划分)+dp[i][j-i]()\n        dp[0][0]=1;\n        for(int i=1;i&lt;=m;++i){\n            for(int j=0;j&lt;=n;++j){\n                if(i&gt;j){\n                    dp[i][j]=dp[i-1][j];\n                }else{\n                    dp[i][j]=(dp[i-1][j]+dp[i][j-i])%M;\n                }\n            }\n        }\n        System.out.println(dp[m][n]);\n    }\n}</code></pre><h1 id=\"【矩阵链乘-2017-11-17】\"><a href=\"#【矩阵链乘-2017-11-17】\" class=\"headerlink\" title=\"【矩阵链乘 2017/11/17】\"></a>【矩阵链乘 2017/11/17】</h1><blockquote>\n<p>输入保证有效,例:</p>\n<blockquote>\n<p>6 30 35 35 15 15 5 5 10 10 20 20 25 结果: 15125</p>\n</blockquote>\n</blockquote>\n<p>从每隔两个开始计算,即自底向上的动态规划. 仔细想一下吧,计算三个的时候,两个已经计算完成了,计算四个的时候,两个和三个已经计算完成了. 比如求<code>((M1)(M2M3M4M5))</code>,你就不需要再去递归求解<code>M2M3M4M5</code>,直接查表就可以了.</p>\n<pre><code>import java.util.*;\n\npublic class VeDP {\n    public static final int MAXN=100;\n    public static final int INF=0x3f3f3f3f;\n    static int[] p=new int[MAXN+1];\n    static int[][] m=new int[MAXN+1][MAXN+1];\n    public static void main(String args[]){\n        Scanner cin=new Scanner(System.in);\n        int n;\n        n=cin.nextInt();\n        for(int i=1;i&lt;=n;++i){//因为中间肯定相同\n            p[i-1]=cin.nextInt();\n            p[i]=cin.nextInt();\n        }\n        for(int l=2;l&lt;=n;++l){\n            for(int i=1;i&lt;=n-l+1;++i){\n                int j=i+l-1;\n                m[i][j]=INF;\n                for(int k=i;k&lt;=j-1;++k){\n                    m[i][j]=Math.min(m[i][j],m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]);\n                }\n            }\n        }\n        System.out.println(m[1][n]);\n    }\n}</code></pre><h1 id=\"【LIS-2017-11-18】\"><a href=\"#【LIS-2017-11-18】\" class=\"headerlink\" title=\"【LIS 2017/11/18】\"></a>【LIS 2017/11/18】</h1><p>O(n^2) java: dp[j]:以c[j]为结尾的最长子序列长度.</p>\n<pre><code>//O(n^2)\nimport java.util.*;\npublic class LIS {\n    private static int[] c=new int[100000+1];\n    private static int[] dp=new int[100000+1];\n    public static void main(String[] args){\n        int n;\n        Scanner cin=new Scanner(System.in);\n        n=cin.nextInt();\n        for(int i=0;i&lt;n;++i){\n            c[i]=cin.nextInt();\n        }\n        /*\n         * dp[j]: 以c[j]为结尾从0...i的LIS \n         */\n        for(int i=1;i&lt;n;++i){\n            for(int j=0;j&lt;i;++j){\n                if(c[i]&gt;=c[j]){\n                    dp[i]=Math.max(dp[i],dp[j]+1);\n                }\n            }\n        }\n        System.out.println(dp[n-1]+1);\n    }\n}</code></pre><p>O(nlgn) c++: 二分搜索+dp 可以过51nod</p>\n<pre><code>//O(NlgN)\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=60000;\n\nint c[maxn],l[maxn];\nint n;\n\nint lis(){\n    l[0]=c[0];\n    int length=1;\n\n    for(int i=1;i&lt;n;++i){\n        if(l[length-1]&lt;c[i]){\n            l[length++]=c[i];\n        }else{\n            *lower_bound(l,l+length,c[i])=c[i];\n        }\n    }\n\n    return length;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%d&quot;,&amp;c[i]);\n    }\n\n    printf(&quot;%d&quot;,lis());\n    return 0;\n}</code></pre><h1 id=\"【2017-11-19-最大正方形】\"><a href=\"#【2017-11-19-最大正方形】\" class=\"headerlink\" title=\"【2017/11/19 最大正方形】\"></a>【2017/11/19 最大正方形】</h1><p>原题连接: <a href=\"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_A\" title=\"AOJ-Lagest Square\" target=\"_blank\" rel=\"noopener\">AOJ-Lagest Square</a> dp[i][j]为向左上方扩展最大的边长. dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1 Code C++:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=1500;\n\nint dp[maxn][maxn],G[maxn][maxn];\nint n,m;\n\nint main(){\n    int maxedge=0;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=0;i&lt;n;++i){\n        for(int j=0;j&lt;m;++j){\n            scanf(&quot;%d&quot;,&amp;G[i][j]);\n            if(G[i][j]==1)dp[i][j]=0;\n            else dp[i][j]=1,maxedge=1;\n        }\n    }\n    for(int i=1;i&lt;n;++i){\n        for(int j=1;j&lt;m;++j){\n            if(!G[i][j]){\n                dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;\n                maxedge=max(maxedge,dp[i][j]);\n            }\n        }\n    }\n    printf(&quot;%d\\n&quot;,maxedge*maxedge);\n    return 0;\n}</code></pre><h1 id=\"【2017-11-19-最大子矩阵】\"><a href=\"#【2017-11-19-最大子矩阵】\" class=\"headerlink\" title=\"【2017/11/19 最大子矩阵】\"></a>【2017/11/19 最大子矩阵】</h1><p>博客内写了题解 Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size,int buffer[]){\n    stack&lt;Rectangle&gt; S;\n    int maxv=0;\n    //通过后一位向前面的计算\n    //这里用到的DP大概是无参数getLargestRectangle里面的预处理\n    //这里用到的更多是思维吧,对每一行进行计算,最后求出最大值.\n    buffer[size]=0;\n\n    for(int i=0;i&lt;=size;++i){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height &lt; rect.height){\n                S.push(rect);\n            }else if(S.top().height &gt; rect.height){\n                int target=i;\n                while(!S.empty() &amp;&amp; S.top().height &gt;= rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    //printf(&quot;\\nmaxv: %d\\n&quot;,maxv);\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    //预处理每个点离他最近的上边未被污染地板的高度\n    for(int j=0;j&lt;W;++j){\n        for(int i=0;i&lt;H;++i){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i&gt;0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    /*\n    例:\n        0 0 1 0 0\n        1 0 0 0 0\n        0 0 0 1 0\n        0 0 0 1 0\n\n    After:\n        1 1 0 1 1\n        0 2 1 2 2\n        1 3 2 0 3\n        2 4 3 0 4\n    */\n    int maxv=0;\n    //传入两个值 W,列数,处理后T[i]第i行的首地址\n    for(int i=0;i&lt;H;++i){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(&quot;%d %d&quot;,&amp;H,&amp;W);\n    for(int i=0;i&lt;H;++i){\n        for(int j=0;j&lt;W;++j){\n            scanf(&quot;%d&quot;,&amp;buffer[i][j]);\n        }\n    }\n\n    printf(&quot;%d\\n&quot;,getLargestRectangle());\n    return 0;\n}</code></pre><h1 id=\"【2017-11-25-筛法求euler】\"><a href=\"#【2017-11-25-筛法求euler】\" class=\"headerlink\" title=\"【2017/11/25 筛法求euler】\"></a>【2017/11/25 筛法求euler】</h1><pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h1 id=\"【2018-1-8-开放式散列表】\"><a href=\"#【2018-1-8-开放式散列表】\" class=\"headerlink\" title=\"【2018/1/8 开放式散列表】\"></a>【2018/1/8 开放式散列表】</h1><pre><code>/*\n//alds1_4_c:Dictionary\n//算法:开放地址法散列表\n//Time: 2018/1/8 星期一\n*/\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nconst int M=1000003;\nconst int L=14;\n\nchar H[M][L];\n\n//对于每个字符返回的定义值\nint getChar(char ch){\n    if(ch==&apos;A&apos;) return 1;\n    if(ch==&apos;C&apos;) return 2;\n    if(ch==&apos;D&apos;) return 3;\n    if(ch==&apos;T&apos;) return 4;\n    return 0;\n}\n//对于字符串返回的初始散列值\nlong long getKey(char str[]){\n    long long len=strlen(str),sum=0,p=1;\n    for(int i=0;i&lt;len;++i){\n        sum+=p*getChar(str[i]);\n        //每次获取定义值后p*5,相当于转换成五进制,不会冲突\n        p*=5;\n    }\n    return sum;\n}\n\n//开放式散列值计算式: h(k,i)=(h1(k)+i*h2(k))%M\nint h1(int key){\n    return key%M;\n}\n//为了保证不会递归冲突(即往下算结果始终相同),必须使h2(key)与M互素\n//TLE最好的情况就是改这个函数= =\n//目前可以AC的: 1+(key%(M-1))\n//(1+key)%(M-1)\nint h2(int key){\n    return (1+key)%(M-1);\n}\n\n//查找\n//-1表示找到\n//h表示找到第一个可插入点\nint find(char str[]){\n    long long key=getKey(str),i,h;\n    for(i=0;;++i){\n        h=(h1(key)+i*h2(key))%M;\n        if(strcmp(H[h],str)==0) return -1;\n        else if(strlen(H[h])==0) return h;\n    }\n    return 0;\n}\n\n//插入\nvoid insert(char str[]){\n    int key=find(str);\n    if(key!=-1) strcpy(H[key],str);\n}\n\nint main(){\n    for(int i=0;i&lt;M;++i) H[M][0]=&apos;\\0&apos;;\n    char str[L],com[L];\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%s %s&quot;,com,str);\n\n        if(com[0]==&apos;i&apos;){\n            insert(str);\n        }else{\n            if(find(str)==-1)\n                printf(&quot;yes\\n&quot;);\n            else\n                printf(&quot;no\\n&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre><h1 id=\"【2018-1-17-强连通分量算法-Tarjan】\"><a href=\"#【2018-1-17-强连通分量算法-Tarjan】\" class=\"headerlink\" title=\"【2018/1/17 强连通分量算法 Tarjan】\"></a>【2018/1/17 强连通分量算法 Tarjan】</h1><p>详解Tarjan: <a href=\"http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/\" title=\"http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2018/01/17/tarjan-scc-algorithm/</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1 id=\"【2018-2-5-排列递推公式-容斥-组合数学】\"><a href=\"#【2018-2-5-排列递推公式-容斥-组合数学】\" class=\"headerlink\" title=\"【2018/2/5 排列递推公式+容斥 组合数学】\"></a>【2018/2/5 排列递推公式+容斥 组合数学】</h1><blockquote>\n<p>原题以及题解连接</p>\n<blockquote>\n<p><a href=\"http://be-sunshine.cn/index.php/2018/02/05/uva-11806/\" title=\"UVa 11806\" target=\"_blank\" rel=\"noopener\">UVa 11806</a></p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre><h1 id=\"【2018-2-6-O-n-素数筛法-线性筛法】\"><a href=\"#【2018-2-6-O-n-素数筛法-线性筛法】\" class=\"headerlink\" title=\"【2018/2/6 O(n)素数筛法 线性筛法】\"></a>【2018/2/6 O(n)素数筛法 线性筛法】</h1><blockquote>\n<p>一道例题: <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1431\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100001000\nusing namespace std;\n\nbool valid[maxn];\nint prime[maxn];\n/*素数筛法 O(n),对于每个素数只标记一次*/\nvoid getPrime(int n,int &amp;tot,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint main(){\n    clock_t t1 = clock();\n    int tot=0;\n    getPrime(100000000,tot,prime);\n    clock_t t2 = clock();\n\n    cout&lt;&lt;tot&lt;&lt;endl;\n    cout&lt;&lt;prime[5760000]&lt;&lt;endl;\n    cout&lt;&lt;&quot;总运行时间为: &quot;&lt;&lt;(double)(t2-t1)/ CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;&lt;&lt;endl;\n    return 0;\n}</code></pre><h1 id=\"【2018-3-10-逆元】\"><a href=\"#【2018-3-10-逆元】\" class=\"headerlink\" title=\"【2018/3/10 逆元】\"></a>【2018/3/10 逆元】</h1><h2 id=\"逆元递推式\"><a href=\"#逆元递推式\" class=\"headerlink\" title=\"逆元递推式\"></a>逆元递推式</h2><blockquote>\n<p>适用于较小数据的情况</p>\n</blockquote>\n<pre><code>LL inv[maxn];\nvoid init(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;\n    }\n}</code></pre><h2 id=\"欧拉定理求逆元\"><a href=\"#欧拉定理求逆元\" class=\"headerlink\" title=\"欧拉定理求逆元\"></a>欧拉定理求逆元</h2><blockquote>\n<p>如果mod p 不是素数时最好用这个,比较少见</p>\n</blockquote>\n<pre><code>long long euler(int p)  \n{  \n    long long ans=p,a=p;  \n    long long i;  \n    for(i=2;i*i&lt;=a;i++)  \n    {  \n        if(a%i==0)  \n        {  \n            ans=ans/i*(i-1);  \n            while(a%i==0)  \n                a/=i;  \n        }  \n    }  \n    if(a&gt;1)  \n        ans=ans/a*(a-1);  \n    return ans;  \n}  \n\nlong long eu=euler(mod)-1;  \n\nlong long inv(long long a)  \n{  \n    return Pow(a,eu);  \n}  </code></pre><h2 id=\"费马小定理求逆元\"><a href=\"#费马小定理求逆元\" class=\"headerlink\" title=\"费马小定理求逆元\"></a>费马小定理求逆元</h2><blockquote>\n<p>a^(p-1)≡1(mod p)</p>\n<blockquote>\n<p>a^(p-2)就是 a 关于p的逆元</p>\n<blockquote>\n<p>前提 a与b互素</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<pre><code>long long fast_mod(long long a,long long n,long long Mod){\n    long long ans=1;\n    while(n){\n        if(n&amp;1){\n            ans=(ans*a)%Mod;\n        }\n        a=(a*a)%Mod;\n        n&gt;&gt;=1;\n    }\n    return ans;\n} \n\n/*但p(即MOD)是素数时,inv[a]=fast_mod(a,p-2,p)*/</code></pre><h2 id=\"扩展欧几里得求逆元\"><a href=\"#扩展欧几里得求逆元\" class=\"headerlink\" title=\"扩展欧几里得求逆元\"></a>扩展欧几里得求逆元</h2><pre><code>void extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inverse(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}</code></pre><h2 id=\"费马小预处理阶乘逆元-一般用于直接求组合数\"><a href=\"#费马小预处理阶乘逆元-一般用于直接求组合数\" class=\"headerlink\" title=\"费马小预处理阶乘逆元(一般用于直接求组合数)\"></a>费马小预处理阶乘逆元(一般用于直接求组合数)</h2><pre><code>ll inv[maxn+10],fac[maxn+10];\n///预处理N!的逆元\n//费马小定理\n/*\n *假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡1（mod p）\n *根据这个性质我们可以知道 a的逆元为a^(p-2)\n */\nll fast_pow(ll a,ll b)\n{\n    ll ans=1;\n    while(b){\n        if(b&amp;1ll)ans=a*ans%MOD;\n        a=a*a%MOD;\n        b&gt;&gt;=1ll;\n    }\n    return ans;\n}\nvoid pre()\n{\n    inv[0]=1ll;\n    fac[0]=1ll;\n    for(int i=1;i&lt;=maxn;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=fast_pow(fac[i],MOD-2ll);\n    }\n}\nll C(ll a,ll b)\n{\n    return fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}</code></pre>","text":"[toc]楼教主的男人八题: https://wenku.baidu.com/view/cb87fe8cb9d528ea81c779d1.html远离之前的模板代码,从原理上开始手撸数据结构. 代码均上传至github仓库.【Dijsktra 2017/5/26】前向星+优先队列","link":"","raw":null,"photos":[],"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"算法学习","slug":"数据结构/算法学习","count":1,"path":"api/categories/数据结构/算法学习.json"}],"tags":[{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]}]}