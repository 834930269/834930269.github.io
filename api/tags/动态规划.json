{"name":"动态规划","slug":"动态规划","count":24,"postlist":[{"title":"51nod 1020 逆序排列","slug":"51nod-1020-reverse","date":"2018-03-05T04:50:19.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1020-reverse.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-DP-逆序数\"><a href=\"#Type-DP-逆序数\" class=\"headerlink\" title=\"Type:DP,逆序数\"></a>Type:DP,逆序数</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。 如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。 1-n的全排列中，逆序数最小为0（正序），最大为n*(n-1) / 2（倒序） 给出2个数n和k，求1-n的全排列中，逆序数为k的排列有多少种？ 例如：n = 4 k = 3。 1 2 3 4的排列中逆序为3的共有6个，分别是： 1 4 3 2 2 3 4 1 2 4 1 3 3 1 4 2 3 2 1 4 4 1 2 3 由于逆序排列的数量非常大，因此只需计算并输出该数 Mod 10^9 + 7的结果就可以了。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000) 第2 - T + 1行：每行2个数n，k。中间用空格分隔。（2 &lt;= n &lt;= 1000, 0 &lt;= k &lt;= 20000)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>共T行，对应逆序排列的数量 Mod (10^9 + 7)</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>1 4 3</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>6</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>考虑 dp[i][j] 表示 元素个数为 i 个时 逆序数为 j 的全排列个数为 dp[i][j] 个.</p>\n<blockquote>\n<p>设当前元素为 N ,则 N 可以放在原来 N-1 个元素的任意全排列的 N-i(i∈[0,N)) 上的位置.</p>\n<blockquote>\n<p>当 N 放在位置 N-i 上时,该排列的逆序数会增长 i (因为N最大,所以后面i个为逆序,前面为顺序),所以当我们想要找长度为 N ,逆序数为 k 的个数时,只需要找长度为 N-1 ,逆序数为 k-i 的全排列的个数即可.</p>\n<blockquote>\n<p>所以 dp[N][k] = lambda(dp[N-1][k-i] | i∈[0,N))</p>\n</blockquote>\n<p>复杂度为 O(k(N^2)) 会炸.</p>\n</blockquote>\n<p>考虑优化:</p>\n<blockquote>\n<p>① dp[N][k] = lambda(dp[N-1][k-i] | i∈[0,N)) ② dp[N][k-1] = lambda(dp[N-1][k-1-i] | i∈[0,N)) ①-②: dp[N][k]-dp[N][k-1] = dp[N-1][k]-dp[N-1][k-N] dp[N][k]=dp[N-1][k]-dp[N-1][k-N]+dp[N][k-1]</p>\n</blockquote>\n</blockquote>\n<p>得出递推公式:</p>\n<blockquote>\n<p>① dp[i][j]=1 j=0 ② dp[i][j]=dp[i-1][j]-dp[i-1][j-i]+dp[i][j-1]</p>\n</blockquote>\n<p>由题目的约束条件:</p>\n<blockquote>\n<p>逆序数最小为0（正序），最大为n*(n-1) / 2（倒序）</p>\n</blockquote>\n<p>故枚举逆序数只需要枚举到 i*(i-1)/2&amp;&amp;j\\&lt;20000即可 注意j-i不能&lt;0</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e9+7;\nint dp[1010][20010];\n\nvoid init(){\n    for(int i=1;i&lt;=1000;++i) dp[i][0]=1;\n    for(int i=2;i&lt;=1000;++i){\n        for(int j=1;j&lt;=i*(i-1)/2&amp;&amp;j&lt;=20000;++j){\n            dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n            if(j-i&gt;=0)dp[i][j]=(((dp[i][j]-dp[i-1][j-i])%mod)+mod)%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int n,k;\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n        printf(&quot;%d\\n&quot;,dp[n][k]);\n    }\n    return 0;\n}</code></pre>","text":"Type:DP,逆序数题目在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。 如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。 1-n的全排列中，逆序数最小为0（正序","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"全排列","slug":"51nod/全排列","count":1,"path":"api/categories/51nod/全排列.json"},{"name":"动态规划","slug":"51nod/全排列/动态规划","count":1,"path":"api/categories/51nod/全排列/动态规划.json"},{"name":"逆序数","slug":"51nod/全排列/动态规划/逆序数","count":1,"path":"api/categories/51nod/全排列/动态规划/逆序数.json"}],"tags":[{"name":"逆序数","slug":"逆序数","count":2,"path":"api/tags/逆序数.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"全排列","slug":"全排列","count":1,"path":"api/tags/全排列.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51nod 1055 最长等差数列","slug":"51nod-1055-llap","date":"2018-03-08T11:18:14.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1055-llap.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-动态规划-双向DP-思维-技巧\"><a href=\"#Type-动态规划-双向DP-思维-技巧\" class=\"headerlink\" title=\"Type: 动态规划,双向DP,思维,技巧\"></a>Type: 动态规划,双向DP,思维,技巧</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10 12 14 其中6 8 10 12 14最长，长度为5。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：N，N为正整数的数量(3 &lt;= N &lt;= 10000)。 第2 - N+1行：N个正整数。(2&lt;= A[i] &lt;= 10^9)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>最长等差数列的长度。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>10 1 3 5 6 8 9 10 12 13 14</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>5</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>数据范围可判是O(N^2) 一开始我一直在想如何把数字,即两个数之间的差用哈希存起来,来方便dp. 然后搜了题解发现是论文题. 被叫做LLAP问题 Length of the Longest Arithmetic Progressio</p>\n</blockquote>\n<h2 id=\"论文Link\"><a href=\"#论文Link\" class=\"headerlink\" title=\"论文Link:\"></a>论文Link:</h2><p><a href=\"https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/\" target=\"_blank\" rel=\"noopener\">https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/</a></p>\n<h2 id=\"论文解释\"><a href=\"#论文解释\" class=\"headerlink\" title=\"论文解释\"></a>论文解释</h2><blockquote>\n<p>这道题可以转化为:</p>\n<blockquote>\n<p>给与一个 排过序 的集合set,我们要求这个集合中的最长等差数列的长度.</p>\n</blockquote>\n<p>标重点: 序列是已排好序的 我们设 dp[i][j] 为以下标 i 和 j 两个元素开头的等差序列最长长度. 我们可以创建一个浮标 j 作为等差数列的中间值</p>\n<blockquote>\n<p>初始化一个 i=j-1,k=j+1.</p>\n<blockquote>\n<p>1.如果 set[i]+set[k] &lt; set[j]*2</p>\n<blockquote>\n<p>k++</p>\n</blockquote>\n<p>2.如果 set[i]+set[k] &gt; set[j]*2</p>\n<blockquote>\n<p>i–</p>\n</blockquote>\n<p>如果 set[i]+set[k]=set[j]*2</p>\n<blockquote>\n<p>则构成等差数列,我们只需要让</p>\n<blockquote>\n<p>dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1</p>\n</blockquote>\n<p>如果dp[j][k]=0的话,dp[i][j]直接=3就可以了,因为 i,j,k 三个刚好构成等差数列.否则等于 dp[j][k]+1</p>\n</blockquote>\n<p>计算完以后 i–,k++ 继续计算其他以 j 为第二个点的等差数列</p>\n</blockquote>\n<p>倒序计算,正序反过来即可</p>\n</blockquote>\n<p>另外: 还可以 直接将 dp 数组初始化为 2(因为每个数的等差数列至少为2). dp[i][j]=dp[j][k]+1 另外有一个小技巧: 如果int的取值范围不大,但是数组要开很大的时候,可以用 short int,比如这道题.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxn=10000;\n\nshort int dp[maxn][maxn];\nint Num[maxn],ans,N;\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;Num[i]);\n        }\n        sort(Num,Num+N);\n        ans=0;\n        for(int j=N-2;j&gt;=1;--j){\n            int i=j-1,k=j+1;\n            while(k&lt;N&amp;&amp;i&gt;=0){\n                if(Num[i]+Num[k]&gt;2*Num[j]){\n                    --i;\n                }else if(Num[i]+Num[k]&lt;2*Num[j]){\n                    ++k;\n                }else{\n                    dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1;\n                    ans=max(ans,(int)dp[i][j]);\n                    --i;++k;\n                }\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type: 动态规划,双向DP,思维,技巧题目N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"LLAP","slug":"51nod/LLAP","count":1,"path":"api/categories/51nod/LLAP.json"},{"name":"动态规划","slug":"51nod/LLAP/动态规划","count":1,"path":"api/categories/51nod/LLAP/动态规划.json"},{"name":"双向dp","slug":"51nod/LLAP/动态规划/双向dp","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp.json"},{"name":"思维","slug":"51nod/LLAP/动态规划/双向dp/思维","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LLAP","slug":"LLAP","count":1,"path":"api/tags/LLAP.json"},{"name":"双向dp","slug":"双向dp","count":1,"path":"api/tags/双向dp.json"}]},{"title":"51nod 1084 矩阵取数问题 V2","slug":"51nod-1084-jzqs-v2","date":"2018-03-05T15:06:34.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1084-jzqs-v2.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-DP-多路-进程-DP\"><a href=\"#Type-DP-多路-进程-DP\" class=\"headerlink\" title=\"Type:DP,多路(进程)DP\"></a>Type:DP,多路(进程)DP</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>一个M*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，先从左上走到右下，再从右下走到左上。第1遍时只能向下和向右走，第2遍时只能向上和向左走。两次如果经过同一个格子，则该格子的奖励只计算一次，求能够获得的最大价值。 例如：3 * 3的方格。 1 3 3 2 1 3 2 2 1 能够获得的最大价值为：17。1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 2 -&gt; 1。其中起点和终点的奖励只计算1次。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：2个数M N，中间用空格分隔，为矩阵的大小。(2 &lt;= M, N &lt;= 200) 第2 - N + 1行：每行M个数，中间用空格隔开，对应格子中奖励的价值。(1 &lt;= A[i,j] &lt;= 10000)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出能够获得的最大价值。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>3 3 1 3 3 2 1 3 2 2 1</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>17</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>一开始的想法是先走一遍取最大值,然后回溯到起点,把走过的地方置为 0,然后WA= =,发现是行不通的,因为两次都是最有没办法保证全局最优.</p>\n<blockquote>\n<p>然后搜了题解</p>\n</blockquote>\n<p>这里用到多进程dp,即我们用 dp[step][j][k] 代表当前走了 step 步,第一个走的人在第 j行,第二个走的人在第 k行时最大的经过路径之和. 如果 j==k 时,即两个人当前路径点重合了.我们只需要随便选取一个加到记忆化数组中即可. 而当我们多路dp时,两个人来到当前状态的方向可能是</p>\n<blockquote>\n<p>(1) 第一个人往下走,第二个人往下走 (2) 第一个人往下走,第二个人往右走 (3) 第一个人往右走,第二个人往下走 (4) 第一个人往右走,第二个人往右走</p>\n</blockquote>\n<p>我们只需要在遍历到每个状态时,对以上四个状态找最大值加上两个人当前地点的数字即可 答案是dp[M+N][N][N]</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=210;\nint N,M,A;\nint mp[maxn][maxn],dp[2*maxn][maxn][maxn];\n\nint main(){\n    ///读题bug,N是行,第二个读入\n    scanf(&quot;%d%d&quot;,&amp;M,&amp;N);\n    for(int i=1;i&lt;=N;++i){\n        for(int j=1;j&lt;=M;++j){\n            scanf(&quot;%d&quot;,&amp;mp[i][j]);\n        }\n    }\n    ///枚举步数\n    for(int i=2;i&lt;=N+M;++i){\n        ///枚举位于行数 i-j or k即为当前所处列(因为总步数为i(行数加列数和))\n        for(int j=1;j&lt;=N&amp;&amp;i-j&gt;=0;++j){\n            for(int k=1;k&lt;=N&amp;&amp;i-k&gt;=0;++k){\n                ///分为四种情况,下下,下右,右下,右右\n                if(k==j){\n                    //下下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+mp[j][i-j]);\n                    //下右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+mp[j][i-j]);\n                    //右下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+mp[j][i-j]);\n                    //右右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]+mp[j][i-j]);\n                }else{\n                    //下下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+mp[j][i-j]+mp[k][i-k]);\n                    //下右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+mp[j][i-j]+mp[k][i-k]);\n                    //右下\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+mp[j][i-j]+mp[k][i-k]);\n                    //右右\n                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]+mp[j][i-j]+mp[k][i-k]);\n                }\n            }\n        }\n    }\n    printf(&quot;%d\\n&quot;,dp[N+M][N][N]);\n    return 0;\n}</code></pre>","text":"Type:DP,多路(进程)DP题目一个M*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，先从左上走到右下，再从右下走到左上。第1遍时只能向下和向右走，第2遍时只能向上和向左走。两次如果经过同一个格子，则该格子的奖励只计算一次，求能够获得的最大价值。 例如：3 *","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"多进程dp","slug":"51nod/多进程dp","count":1,"path":"api/categories/51nod/多进程dp.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"多进程dp","slug":"多进程dp","count":1,"path":"api/tags/多进程dp.json"}]},{"title":"51nod 1201 整数划分","slug":"51nod-1201-int-pagi","date":"2018-03-06T01:33:53.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1201-int-pagi.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-DP-思维\"><a href=\"#Type-DP-思维\" class=\"headerlink\" title=\"Type:DP,思维\"></a>Type:DP,思维</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>将N分为若干个不同整数的和，有多少种不同的划分方式，例如：n = 6，{6} {1,5} {2,4} {1,2,3}，共4种。由于数据较大，输出Mod 10^9 + 7的结果即可。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>输入1个数N(1 &lt;= N &lt;= 50000)。</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出划分的数量Mod 10^9 + 7。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>6</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>4</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>首先我们可以由</p>\n<blockquote>\n<p>1+2+3+…+m=n 估算出 大概只有sqrt(2*n)个数字左右</p>\n</blockquote>\n<p>我们设当前状态为 dp[i][j]</p>\n<blockquote>\n<p>dp[i][j] 代表当前数字为 j ,被划分成了 i 部分. 状态转移推倒:</p>\n<blockquote>\n<p>我们假设已知所有 dp 的划分数序列. (1) 我们将 dp[i][j-i] 每个 划分数每个数字 +1 ,我们将得到 不存在1 的划分数. (2) 我们将 dp[i-1][j-i] 每个 划分数每个数字(共 i-1 个) +1 ,我们将得到 不存在1 的且长度为 i-1 ,和为 j-1 的划分数,然后我们将 1 放到划分数中,即得到全部 有1 的划分数.</p>\n</blockquote>\n<p>即 dp[i][j]=(dp[i][j-i]+dp[i-1][j-i])%mod</p>\n</blockquote>\n<p>正确性证明:</p>\n<blockquote>\n<p>假设已知 dp[i][j] 的全部序列. 我们只需要一直对每个数字 -1 就可以将所有序列置为 全0.</p>\n</blockquote>\n</blockquote>\n<h1 id=\"给一个例子自己倒着推一下也成立\"><a href=\"#给一个例子自己倒着推一下也成立\" class=\"headerlink\" title=\"给一个例子自己倒着推一下也成立\"></a>给一个例子自己倒着推一下也成立</h1><pre><code>组成1的 有 {1} \n\n组成2的 有 {2} \n\n组成3的 有 {1,2} {3}\n\n组成4的 有 {1,3} {4}\n\n组成5的 有 {1,4} {2,3} {5}\n\n组成6的 有 {1,5} {2,4} {1,2,3} {6}\n\n组成7的 有 {1,6} {2,5} {3,4} {1,2,4} {7}</code></pre><h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=50010;\nconst LL mod=1e9+7;\nint N;\nLL dp[330][maxn];\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;N);\n    dp[1][1]=1ll;\n    for(int i=2;i&lt;=N;++i){\n        for(int j=1;j&lt;=(int)sqrt(2*i);++j){\n            dp[j][i]=(dp[j][i-j]+dp[j-1][i-j])%mod;\n        }\n    }\n    LL ans=0;\n    for(int i=1;i&lt;=(int)sqrt(2*N);++i) ans=(ans+dp[i][N])%mod;\n    printf(&quot;%lld\\n&quot;,ans);\n    return 0;\n}</code></pre>","text":"Type:DP,思维题意将N分为若干个不同整数的和，有多少种不同的划分方式，例如：n = 6，{6} {1,5} {2,4} {1,2,3}，共4种。由于数据较大，输出Mod 10^9 + 7的结果即可。Input输入1个数N(1 &lt;= N &lt;= 50000)。Out","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51NOD 1241 特殊的排序","slug":"51nod-1241-tsds","date":"2018-03-08T10:57:18.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1241-tsds.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-动态规划-思维-最长等差数列-简化\"><a href=\"#Type-动态规划-思维-最长等差数列-简化\" class=\"headerlink\" title=\"Type:动态规划,思维,最长等差数列(简化)\"></a>Type:动态规划,思维,最长等差数列(简化)</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾部 =&gt; 1 2 3 4 5 这样就排好了，移动了2个元素。 给出一个1-N的排列，输出完成排序所需的最少移动次数。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：1个数N(2 &lt;= N &lt;= 50000)。 第2 - N + 1行：每行1个数，对应排列中的元素。</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出1个数，对应所需的最少移动次数。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>5 2 5 3 4 1</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>2</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>一开始会想到和逆序数有关,排序就是减少逆序数,所以会想到其中非逆序序列中最长的那个不用变化. 然后可以容易地证明剩余的数只需要移动一次即可到达正确的位置上</p>\n<blockquote>\n<p>比如 12346587 可以发现最长等差整数序列是 12345 而我们需要 12345678 第一次: 1234587 6 第二次: 1234586 7 第三次: 1234567 8 OK,往数列前面放的也一样</p>\n</blockquote>\n<p>那么我们的问题就是如何求最长等差数列(等差为1)了,</p>\n<blockquote>\n<p>因为等差为1,所以我们不难想到: dp[i] 为数字 i 的最长等差数列. 遍历Num[]数组的时候计算 dp 即可 dp[i]=dp[i-1]+1</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=50000+10;\n\nint dp[maxn],N,Num[maxn],max_;\n\nint main(){\n    while(cin&gt;&gt;N){\n        memset(dp,0,sizeof(dp));\n        dp[0]=0;\n        max_=1;\n        for(int i=1;i&lt;=N;++i){\n            cin&gt;&gt;Num[i];\n        }\n        for(int i=1;i&lt;=N;++i){\n            dp[Num[i]]=dp[Num[i]-1]+1;\n            max_=max(dp[Num[i]],max_);\n            //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;dp[Num[i]]&lt;&lt;endl;\n        }\n        cout&lt;&lt;N-max_&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:动态规划,思维,最长等差数列(简化)题目一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"思维","slug":"51nod/动态规划/思维","count":1,"path":"api/categories/51nod/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"51nod DP-矩阵取数问题","slug":"51nod-dp-study","date":"2016-12-24T14:22:05.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/51nod-dp-study.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x – 1, y) , f(x, y – 1) ) + A[x][y] 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<vector><br>using namespace std;<br>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    vector&lt;vector<int> &gt; ve(N+1,vector<int>(N+1,0)),dp(N+1,vector<int>(N+1,0));</int></int></int></vector></p>\n<pre><code>for(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        cin&gt;&gt;ve\\[i\\]\\[j\\];\n\nfor(int i=1;i&lt;=N;++i)\n    for(int j=1;j&lt;=N;++j)\n        dp\\[i\\]\\[j\\]=max(dp\\[i-1\\]\\[j\\],dp\\[i\\]\\[j-1\\])+ve\\[i\\]\\[j\\];\n\ncout&lt;&lt;dp\\[N\\]\\[N\\]&lt;&lt;endl;\n\nreturn 0;</code></pre><p>}</p>\n","text":"【矩阵取数问题】 给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。 【动态转移方程】 f(x, y) = max(f(x","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"算法学习","slug":"51nod/动态规划/算法学习","count":1,"path":"api/categories/51nod/动态规划/算法学习.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"第八届ACM省赛 K CF","slug":"acm-k-cf","date":"2018-01-18T07:35:38.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/acm-k-cf.json","excerpt":"","keywords":null,"cover":"http://acm.sdut.edu.cn/image/3903.png","content":"<h3 id=\"CF\"><a href=\"#CF\" class=\"headerlink\" title=\"CF\"></a>CF</h3><p><strong>sdut 3903</strong> Time Limit: 1000MS Memory Limit: 65536KB</p>\n<h4 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h4><p><img src=\"http://acm.sdut.edu.cn/image/3903.png\" alt> LYD loves codeforces since there are many Russian contests. In an contest lasting for <em>T</em> minutes there are <em>n</em> problems, and for the <em>i__th</em> problem you can get <em>a__i_−_d__i_∗_t__i</em> points, where <em>a__i</em> indicates the initial points, <em>d__i</em> indicates the points decreased per minute (count from the beginning of the contest), and <em>t__i</em> stands for the passed minutes when you solved the problem (count from the begining of the contest).<br>Now you know LYD can solve the <em>i__th</em> problem in <em>c__i</em> minutes. He can’t perform as a multi-core processor, so he can think of only one problem at a moment. Can you help him get as many points as he can?</p>\n<h4 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h4><p>The first line contains two integers <em>n</em>,<em>T</em>(0≤<em>n</em>≤2000,0≤<em>T</em>≤5000).<br>The second line contains <em>n</em> integers <em>a</em>1,<em>a</em>2,..,<em>a__n</em>(0&lt;<em>a__i_≤6000).<br>The third line contains _n</em> integers <em>d</em>1,<em>d</em>2,..,<em>d__n</em>(0&lt;<em>d__i_≤50).<br>The forth line contains _n</em> integers <em>c</em>1,<em>c</em>2,..,<em>c__n</em>(0&lt;_c__i_≤400).</p>\n<h4 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h4><p>Output an integer in a single line, indicating the maximum points LYD can get.</p>\n<h4 id=\"Example-Input\"><a href=\"#Example-Input\" class=\"headerlink\" title=\"Example Input\"></a>Example Input</h4><p>3 10<br>100 200 250<br>5 6 7<br>2 4 10</p>\n<h4 id=\"Example-Output\"><a href=\"#Example-Output\" class=\"headerlink\" title=\"Example Output\"></a>Example Output</h4><p>254</p>\n<h4 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a><strong>题意</strong></h4><p>有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题的分数便会减少 di ，而我们可以在 ci 时间内做出这道题而得到分数，求在时间 T 内最多可以获得的分数。</p>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a><strong>题解</strong></h4><p>首先可以感觉出这是道0-1背包问题,然后我们需要知道,当我们做题时,会一两个角度来选择题目,其一是选择做题速度最快的,其二是选择做分值降低速度最快的.那么我们的衡量标准就可以看成先做单位时间内做题最多的那道. 然后我们根据上述规则排一下序. 在用排序后的数组进行0-1背包.在背包过程中记录最大值,即为最后的结果.</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=3000;\n\nstruct pro{\n    int a,d,c;\n    //按单位时间内减少分值排序\n    bool operator &lt;(const pro &amp;pt)const{\n        return 1.0*d/c&gt;(1.0*pt.d/pt.c);\n    }\n};\n\nint n,T;\npro p[maxn];\nint dp[5010];\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;T)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].a);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].d);\n        }\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;p[i].c);\n        }\n        sort(p,p+n);\n        int mx=-1;\n        for(int i=0;i&lt;n;++i){\n            for(int j=T;j&gt;=0;--j){\n                if(j&gt;=p[i].c){\n                    dp[j]=max(dp[j],dp[j-p[i].c]+p[i].a-j*p[i].d);\n                }\n                mx=max(mx,dp[j]);\n            }\n        }\n        printf(&quot;%d\\n&quot;,mx);\n    }\n    return 0;\n}</code></pre>","text":"CFsdut 3903 Time Limit: 1000MS Memory Limit: 65536KBProblem Description [Figure] 2 4 10Example Output254题意有 n 道题目，每一道题都有一个初始分值 ai ，每个单位时间这道题","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"动态规划","slug":"Sdut/动态规划","count":2,"path":"api/categories/Sdut/动态规划.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/动态规划/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/动态规划/第八届ACM山东省赛.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"AOJ DPL_3 B Largest Rectangle","slug":"aoj-dpl-3-b-largest-rectangle","date":"2017-11-19T08:22:23.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-dpl-3-b-largest-rectangle.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Largest-Rectangle\"><a href=\"#Largest-Rectangle\" class=\"headerlink\" title=\"Largest Rectangle\"></a>Largest Rectangle</h1><p>Given a matrix (H × W) which contains only 1 and 0, find the area of the largest rectangle which only contains 0s.</p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>H W<br>c1,1 c1,2 … c1,W<br>c2,1 c2,2 … c2,W<br>:<br>cH,1 cH,2 … cH,W</p>\n<p>In the first line, two integers H and W separated by a space character are given. In the following H lines, ci,j, elements of the H × W matrix, are given.</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>Print the area (the number of 0s) of the largest rectangle.</p>\n<h2 id=\"Constraints\"><a href=\"#Constraints\" class=\"headerlink\" title=\"Constraints\"></a>Constraints</h2><ul>\n<li>1 ≤ H, W ≤ 1,400</li>\n</ul>\n<h2 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h2><p>4 5<br>0 0 1 0 0<br>1 0 0 0 0<br>0 0 0 1 0<br>0 0 0 1 0</p>\n<h2 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h2><p>6</p>\n<p>最大子矩阵(直方图)的变形. 首先需要把每一行都预处理成<code>距离第0行</code>的高度的表.然后每一行都相当于一个直方图,对每个直方图求可以围成的所有矩形面积,用<code>maxv维护</code>最大矩形的值.</p>\n<pre><code>例 处理前:\n    0 0 1 0 0\n    1 0 0 0 0\n    0 0 0 1 0\n    0 0 0 1 0\n\nAfter 处理后:\n    1 1 0 1 1\n    0 2 1 2 2\n    1 3 2 0 3\n    2 4 3 0 4</code></pre><p>Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size,int buffer[]){\n    stack&lt;Rectangle&gt; S;\n    int maxv=0;\n    //通过后一位向前面的计算\n    //这里用到的DP大概是无参数getLargestRectangle里面的预处理\n    //这里用到的更多是思维吧,对每一行进行计算,最后求出最大值.\n    buffer[size]=0;\n\n    for(int i=0;i&lt;=size;++i){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height &lt; rect.height){\n                S.push(rect);\n            }else if(S.top().height &gt; rect.height){\n                int target=i;\n                while(!S.empty() &amp;&amp; S.top().height &gt;= rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    //printf(&quot;\\nmaxv: %d\\n&quot;,maxv);\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    //预处理每个点离他最近的上边未被污染地板的高度\n    for(int j=0;j&lt;W;++j){\n        for(int i=0;i&lt;H;++i){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i&gt;0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    /*\n    例:\n        0 0 1 0 0\n        1 0 0 0 0\n        0 0 0 1 0\n        0 0 0 1 0\n\n    After:\n        1 1 0 1 1\n        0 2 1 2 2\n        1 3 2 0 3\n        2 4 3 0 4\n    */\n    int maxv=0;\n    //传入两个值 W,列数,处理后T[i]第i行的首地址\n    for(int i=0;i&lt;H;++i){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(&quot;%d %d&quot;,&amp;H,&amp;W);\n    for(int i=0;i&lt;H;++i){\n        for(int j=0;j&lt;W;++j){\n            scanf(&quot;%d&quot;,&amp;buffer[i][j]);\n        }\n    }\n\n    printf(&quot;%d\\n&quot;,getLargestRectangle());\n    return 0;\n}</code></pre>","text":"Largest RectangleGiven a matrix (H × W) which contains only 1 and 0, find the area of the largest rectangle which only contains 0s.InputH W<","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"动态规划","slug":"AOJ/动态规划","count":1,"path":"api/categories/AOJ/动态规划.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"动态规划模板","slug":"dynamic-muban","date":"2017-04-16T04:00:16.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/dynamic-muban.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【多重部分和问题】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=100000+10;</strong> <strong>int A[maxn],M[maxn],N,K;</strong> <strong>int dp[maxn];//滚动数组,当前第i个数在第j权下剩余的数量</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;N) &amp;&amp; N){** **        for(int i=0;i&lt;N;++i)** **            scanf(“%d%d”,&amp;A[i],&amp;M[i]);** **        cin&gt;&gt;K;** **        fill(dp,dp+maxn,-1);** **        dp[0]=0;** **        for(int i=0;i&lt;N;++i)** **            for(int j=0;j&lt;=K;++j){** **                if(dp[j]&gt;=0){** **                    dp[j]=M[i];** **                }else if(j&lt;A[i] || dp[j-A[i]]&lt;=0){** **                    dp[j]=-1;** **                }else{** **                    dp[j]=dp[j-A[i]]-1;** **                }** **            }** **        if(dp[K]&gt;=0) printf(“YES\\n”);** **        else puts(“NO”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【不等概率掷硬币】</strong></p>\n<blockquote>\n<p><strong>小Hi有一枚神奇的硬币。已知第i次投掷这枚硬币时，正面向上的概率是Pi。  ** **现在小Hi想知道如果总共投掷N次，其中恰好M次正面向上的概率是多少。</strong> <strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>double dp[1005][1005];</strong> <strong>int main(){</strong> <em>*    int n,m;** **    scanf(“%d%d”,&amp;n,&amp;m);** **    dp[0][0]=1.0;** **    for(int i=0;i&lt;n;++i){** **        double x;** **        scanf(“%lf”,&amp;x);** **        for(int j=0;j&lt;=i;++j){** **            dp[i+1][j]+=dp[i][j]</em>(1.0-x);** **            dp[i+1][j+1]+=dp[i][j]<em>x;*</em> **        }** **    }** **    printf(“%.6lf\\n”,dp[n][m]);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【LIS最长上升子序列】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>int A[30]={1,2,12,4,7,6,32,54,2,8784,23,212,54,59,85,2,6,542,35},N=19;</strong> <strong>int dp[20],maxmum=-INF;</strong> <strong>int main(){</strong> **    rep(i,N){** **        dp[i]=1;** **        rep(j,i){** **            if(A[j]&lt;A[i])** **                dp[i]=max(dp[i],dp[j]+1);** **        }** **        maxmum=max(maxmum,dp[i]);** **    }** **    rep(i,N){** **        printf(“%d “,dp[i]);** **    }** **    printf(“\\n%d\\n”,maxmum);** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【排除62和4-数位dp】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【多重部分和问题】#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=100000+10; int A[maxn],M[maxn],N,K; int dp[maxn];//滚动数组,当前第i个数在第j","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"模板","slug":"动态规划/模板","count":1,"path":"api/categories/动态规划/模板.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"动态规划","slug":"dynamic-program","date":"2018-03-13T13:24:32.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/dynamic-program.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>痛并不快乐着..</p>\n</blockquote>\n<h1 id=\"数位dp\"><a href=\"#数位dp\" class=\"headerlink\" title=\"数位dp\"></a>数位dp</h1><blockquote>\n<p>HDU 3555</p>\n<blockquote>\n<p>不要49</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n\nLL dp[20][3];\nint digit[20];\n\nLL dfs(int pos,int pre,int state,bool jud){\n    //cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;state&lt;&lt;endl;\n    ///数位递归到0则返回\n    if(pos==0)\n        return 1;\n    ///如果有数据就返回数据\n    if(!jud&amp;&amp;dp[pos][state]!=-1)\n        return dp[pos][state];\n\n    LL ans=0;\n    int ed=jud?digit[pos]:9;\n    //cout&lt;&lt;ed&lt;&lt;endl;\n    for(int i=0;i&lt;=ed;++i){\n        if(pre==4&amp;&amp;i==9)continue;\n        ans+=dfs(pos-1,i,i==4,jud&amp;&amp;i==ed);\n    }\n    if(!jud){///不取上界时,可以取满\n        dp[pos][state]=ans;\n    }\n    return ans;\n}\n\n///数字处理函数\nLL cal(LL x){\n    int pos=0;\n    while(x){\n        digit[++pos]=x%10;\n        x/=10;\n    }\n    return dfs(pos,0,0,true);\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    int T;\n    for(scanf(&quot;%d&quot;,&amp;T);T;T--){\n        LL n;\n        scanf(&quot;%lld&quot;,&amp;n);\n        printf(&quot;%lld\\n&quot;,n-cal(n)+1);\n    }\n    return 0;\n}</code></pre><blockquote>\n<p>HDU 2089</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000000+7;\nLL dp[20][3];\nint digit[20];\n\nLL dfs(int pos,int pre,int state,bool jud){\n    //cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;state&lt;&lt;endl;\n    ///数位递归到0则返回\n    if(pos==0)\n        return 1;\n    ///如果有数据就返回数据\n    if(!jud&amp;&amp;dp[pos][state]!=-1)\n        return dp[pos][state];\n\n    LL ans=0;\n    int ed=jud?digit[pos]:9;//这句是判断他的上界\n    //cout&lt;&lt;ed&lt;&lt;endl;\n    for(int i=0;i&lt;=ed;++i){\n        if(pre==6&amp;&amp;i==2)continue;\n        if(i==4)continue;\n        ans+=dfs(pos-1,i,i==6,jud&amp;&amp;i==ed);\n    }\n    if(!jud){///不取上界时,可以取满\n        dp[pos][state]=ans;\n    }\n    return ans;\n}\n\n///数字处理函数\nLL cal(LL x){\n    int pos=0;\n    //cout&lt;&lt;&quot;tx: &quot;;\n    while(x){\n        digit[++pos]=x%10;\n        //cout&lt;&lt;x%10&lt;&lt;endl;\n        x/=10;\n    }\n    return dfs(pos,0,0,true);\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    LL n,m;\n    while(~scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m) &amp;&amp; n+m){\n        printf(&quot;%lld\\n&quot;,cal(m)-cal(n-1));\n    }\n    return 0;\n}</code></pre>","text":"痛并不快乐着..数位dpHDU 3555不要49#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL dp[20][3];int digit[20];LL dfs(int pos,int ","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"数位DP","slug":"动态规划/数位DP","count":1,"path":"api/categories/动态规划/数位DP.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"}]},{"title":"HDU 2098","slug":"hdu-2098","date":"2017-04-18T04:25:02.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/hdu-2098.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>数位dp入门</strong> <strong>【Tip】</strong> <strong><a href=\"http://www.cnblogs.com/wenruo/p/4725005.html\" target=\"_blank\" rel=\"noopener\">一个blog</a></strong> <strong><a href=\"https://wenku.baidu.com/view/9de41d51168884868662d623.html\" target=\"_blank\" rel=\"noopener\">一个ppt</a></strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=7;</strong> <strong>int dp[maxn][10];</strong> <strong>int d[maxn],N,M;</strong> <strong>void init(){</strong> **    dp[0][0] = 1;** **    for (int i = 1; i &lt;= 7; ++i)** **        for (int j = 0; j &lt;= 9; ++j)** **            for (int k = 0; k &lt;= 9; ++k)** **                if (j != 4 &amp;&amp; !(j == 6 &amp;&amp; k == 2))** **                    dp[i][j] += dp[i - 1][k];** <strong>}</strong> <strong>int solve(int num){</strong> **    int ans=0,len=0;** **    while(num&gt;0){** **        d[++len]=num%10;** **        num/=10;** **    }** **    d[len+1]=0;** **    for(int i=len;i&gt;=1;–i){** **        for(int j=0;j&lt;d[i];++j){** **            if(j!=4 &amp;&amp; !(d[i+1]==6 &amp;&amp; j==2))** **                ans+=dp[i][j];** **        }** **        if(d[i]==4 || (d[i+1]==6 &amp;&amp; d[i]==2))** **            //已经出现4,62如,d[i]为4** **            //那么就不必再计算第i位为4的情况了.** **            break;** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF</strong> <strong>//      freopen(“out.txt”,”w”,stdout);</strong> <strong>//   #endif // DEF</strong> **    init();** **    while(~SII(N,M) &amp;&amp; N+M){** **        printf(“%d\\n”,solve(M+1)-solve(N));** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 数位dp入门 【Tip】 一个blog 一个ppt 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"动态规划","slug":"HDU/动态规划","count":1,"path":"api/categories/HDU/动态规划.json"},{"name":"数位DP","slug":"HDU/动态规划/数位DP","count":1,"path":"api/categories/HDU/动态规划/数位DP.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"}]},{"title":"LA 3882","slug":"la-3882","date":"2017-07-11T07:02:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3882.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3882\" target=\"_blank\" rel=\"noopener\">And Then There Was One</a></strong> <strong>【题解】</strong> <strong>假设问题是从n个人编号分别为0…n-1，取第k个，</strong> <strong>则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2…</strong> <strong>此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号</strong> <strong>把k号设置为0,则</strong> <strong>k 0</strong> <strong>k+1 1</strong> <strong>…</strong> <strong>0 n-k</strong> <strong>1 n-k+1</strong> <strong>假设已经求得了n-1个人情况下的最终胜利者保存在f[n-1]中，则毫无疑问，该胜利者还原到原来的真正编号即为 (f[n-1]+k)%n （因为第二轮重新编号的时候，相当于把每个人的编号都减了k，因此重新+k即可恢复到原来编号）。由此，我们可以想象，当最终只剩下一个人的时候，该人即为胜利者，此时重新编号，因为只有一个人，所以此时f[1]=0</strong> <strong>这样f[2]=(f[1]+k)%2,这样就可以求出最终胜利者在2个人的时候的情况下的编号，由递推公式f[n]=(f[n-1]+k)%n,可递推到最初编号序列中该胜利者的编号。</strong> <strong>因此用这个方法，只需一遍On的扫描，即可求出最终答案</strong> <strong>不过该题要求编号从1开始，只要把f[n]+1即可，同时，该题指定了第一个要删除的人必须为编号为m的人，其实也不难，求出f[n]之后，把原本编号为0的位置移到跟m只相距k的位置即可实现第一次删除的编号为m。所以最终 ans=(f[n]+1+m-k);</strong> <strong>当然因为m-k可能为负数，导致整个ans为负，这样其实最后+n即可解决。</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203882.cpp\" target=\"_blank\" rel=\"noopener\">LA 3882.cpp</a></strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=10000+10;<br>int f[maxn];<br>int main(){<br>    int n,k,m;<br>    while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n){<br>        ///最后一次变换只有一个点,所以最终点设为0<br>        ///每次去掉一个点以后重新编号,所以%i<br>        ///从底向上的方法<br>        f[1]=0;<br>        for(int i=2;i&lt;=n;++i)f[i]=(f[i-1]+k)%i;<br>        ///因为是从0编号,而题目要求从1编号,所以+1<br>        ///因为从0开始,而题目要求从m开始删除第k个<br>        ///所以第一次删除的下标应该是f[n]-k=第一次的起始下标<br>        ///0-k+m+1=真正的起始坐标,因为第一次需要将m设为0,从m开始重新编号<br>        int ans=(m-k+1+f[n])%n;<br>        ///因为m-k+1可能小于0,所以m-k+1+f[n]也可能小于0<br>        if(ans&lt;=0) ans+=n;<br>        printf(“%d\\n”,ans);<br>    }<br>    return 0;<br>}</strong></p>\n</blockquote>\n","text":"【Link】 And Then There Was One 【题解】 假设问题是从n个人编号分别为0…n-1，取第k个， 则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2… 此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号 把k号设置为","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"动态规划","slug":"LA/动态规划","count":1,"path":"api/categories/LA/动态规划.json"},{"name":"思维","slug":"LA/动态规划/思维","count":1,"path":"api/categories/LA/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"玲珑杯 R7 D-Pick Up Coin","slug":"linglong-r7-d-pick-up-coin","date":"2016-12-24T13:51:29.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/linglong-r7-d-pick-up-coin.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:</p>\n<p>dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }</p>\n<p>  【Code】(不会,代码搁置,回头看)</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int Q[1010];<br>int dp[1005][1005];<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int n;<br>    cin&gt;&gt;n;<br>    while(n–){<br>        int M;<br>        cin&gt;&gt;M;<br>        for(int i=1;i&lt;=M;++i)<br>            cin&gt;&gt;Q[i];<br>        Q[0]=Q[M+1]=1;<br>        for(int i=0;i&lt;=M+1;++i)<br>            for(int j=0;j&lt;=M+1;++j)<br>                dp[i][j]=0;<br>        for(int len=1;len&lt;=M;++len)<br>                for(int i=1,j=i+len-1;j&lt;=M;++i,++j)<br>                    for(int k=i;k&lt;=j;++k)<br>                        dp[i][j]=max(dp[i][j],dp[i][k-1]+dp[k+1][j]+Q[k]*Q[i-1]*Q[j+1]);</algorithm></p>\n<pre><code>        cout&lt;&lt;dp\\[1\\]\\[M\\]&lt;&lt;endl;\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }  【Code】(不会,代码搁置,回头看)#incl","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"OpenJudge \t程序设计与算法（二）第五周作业(2017春季)","slug":"openjudge-two","date":"2017-03-03T05:38:27.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/openjudge-two.json","excerpt":"","keywords":null,"cover":null,"content":"<p>–动态规划 【1:拦截导弹】 【Code】</p>\n<blockquote>\n<p><strong><em>#include&lt;bits/stdc++.h&gt;</em></strong> <strong><em>using namespace std;</em></strong> <strong><em>const int maxn=70;</em></strong> <strong><em>int a[maxn],N;</em></strong> <strong><em>int maxlen[maxn],m=-1;</em></strong> <strong><em>int main(){</em></strong> <strong>_    cin&gt;&gt;N;_</strong> <strong>_    for(int i=1;i&lt;=N;++i){_</strong> <strong>_        cin&gt;&gt;a[i]; maxlen[i]=1;_</strong> <strong>_    }_</strong> <strong>_    for(int i=2;i&lt;=N;++i)_</strong> <strong>_        for(int j=1;j&lt;i;++j)_</strong> <strong>_            if(a[i]&lt;=a[j]){_</strong> <strong>_                maxlen[i]=max(maxlen[i],maxlen[j]+1);_</strong> <strong>_                if(maxlen[i]&gt;m) m=maxlen[i];_</strong> <strong>_            }_</strong> <strong>_    cout&lt;&lt;m&lt;&lt;endl;_</strong> <strong>_    return 0;_</strong> <strong><em>}</em></strong></p>\n</blockquote>\n<p>最长上升序列问题,目前对动规的理解走到了明白1.动规是逆着的递归.2.动规是通过从尾开始动态的更改所有的最忧解,从而找到所需要的最优解.</p>\n","text":"–动态规划 【1:拦截导弹】 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=70; int a[maxn],N; int maxlen[maxn],m=-1; int main(){","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"POJ 3356 AGTC","slug":"poj-3356-agtc","date":"2017-01-07T09:16:52.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-3356-agtc.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 动态规划:编辑距离 【题目来源】 <a href=\"http://poj.org/problem?id=3356\" target=\"_blank\" rel=\"noopener\">POJ-3356-AGTC</a> 【思路来源】 <a href=\"http://www.cnblogs.com/dongsheng/archive/2013/05/27/3102498.html\" target=\"_blank\" rel=\"noopener\">可笑痴狂</a> 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==A[i]，这样做的话， 至少需要 dp[i - 1][j] + 1步操作，即 dp[i][j] = dp[i - 1][j] + 1。 ②、我们可以删除 B[j]，这样的话，B[1…j] 变为A[1…i] 需要 dp[i][j - 1]步， 即 dp[i][j] = dp[i][j - 1] + 1。 ③、我们也可以考虑修改 B[j]，使它变为A[j]，但是如果 B[j]本来就等于 A[i]的话， 那修改其实相当于用了 0步，如果 B[j] != A[i] 的话，那修改相当于用了 1步。 所以 dp[i][j] = dp[i - 1][j - 1] + （A[i] == B[j] ? 0, 1）。 决策： 决策就很简单了，从上面三种状态转移中选择一个最小值就可以了。 处理边界： 处理好边界非常重要，这里需要注意的是对dp[0][0….m],dp[0…..n][0]的初始化， 可以这样看，dp[0][i],就是说A[1…n]是一个空串，而B[1…m]十个长度为i的串， 很显然B串变为A串就是删除i个核苷酸。 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<string></string></p>\n<p>#include<cstring><br>using namespace std;<br>char s1[1005],s2[1005];<br>int dp[1005][1005];<br>int s1l,s2l;</cstring></p>\n<p>int DP(){<br>        for(int i=0;i&lt;s1l;++i){<br>            for(int j=0;j&lt;s2l;++j){<br>                if(s1[i]==s2[j])<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]);<br>                else<br>                    dp[i+1][j+1]=min(min(dp[i+1][j]+1,dp[i][j+1]+1),dp[i][j]+1);<br>            }<br>        }<br>    return dp[s1l][s2l];<br>}</p>\n<p>void init(){<br>    memset(dp,0,sizeof(dp));<br>    int tmp=max(s1l,s2l);<br>    for(int i=1;i&lt;=tmp;++i)<br>        dp[i][0]=dp[0][i]=i;<br>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;s1l&gt;&gt;s1){<br>        cin&gt;&gt;s2l&gt;&gt;s2;<br>        init();<br>        cout&lt;&lt;DP()&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 动态规划:编辑距离 【题目来源】 POJ-3356-AGTC 【思路来源】 可笑痴狂 【思路】 状态转移方程： 有三种情况可以导致我们上面设计的状态会发生转移。我们现在来看A[i] 和 B[j] ， ①、我们可以在 B[j]后面插入一个核苷酸（即一个字符）ch，ch==","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"编辑距离","slug":"动态规划/编辑距离","count":1,"path":"api/categories/动态规划/编辑距离.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"编辑距离","slug":"编辑距离","count":1,"path":"api/tags/编辑距离.json"}]},{"title":"玲珑杯 Round#18 C","slug":"round18-c","date":"2017-07-15T10:45:01.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/round18-c.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1146\" target=\"_blank\" rel=\"noopener\">1146 - 图论你先敲完模板</a></strong> <strong>【题解】</strong> <strong>首先我们可以想到一个简单的dp方程</strong> <strong>dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a</strong> <strong>1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算.</strong> <strong>所以我们可以从i-1往回(1)递推,如果某一点距离差大于30.则直接退出循环即可.</strong> <strong>最终结果为dp[n].且结果需要用long long存.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20C.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 C.cpp</a></strong></p>\n<hr>\n<p> **#include&lt;bits/stdc++.h&gt;</p>\n<p>#define fill(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f</p>\n<p>#pragma comment(linker, “/STACK:102400000,102400000”)<br>using namespace std;<br>const int maxn=100000+10;<br>int n;<br>long long dp[maxn],a,dt[100000+10];<br>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%lld”,&amp;n,&amp;a);<br>        for(int i=1;i&lt;=n;++i){<br>            dp[i]=1000000000000000000;<br>            scanf(“%lld”,&amp;dt[i]);<br>            for(int j=i-1;j&gt;=1;–j){<br>                long long t;<br>                if(dt[i]-dt[j]&gt;30)break;<br>                if(dp[j]!=1000000000000000000) t=dp[j];<br>                else t=0;<br>                dp[i]=min(dp[i],t+(1&lt;&lt;(dt[i]-dt[j]))+a);<br>            }<br>        }<br>        printf(“%lld\\n”,dp[n]);<br>    }<br>    return 0;<br>}**</p>\n","text":"【Topic Link】 1146 - 图论你先敲完模板 【题解】 首先我们可以想到一个简单的dp方程 dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a 1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算. 所","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"第七届山东省ACM/ICPC  F  Feed the monkey","slug":"shandongacmacmicpc-f-feed-the-monkey","date":"2017-04-18T08:49:52.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/shandongacmacmicpc-f-feed-the-monkey.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>DP</strong> <strong>【题目链接】</strong> <strong><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565</a></strong> <strong>【题解】</strong> <strong>用dp[i][j][k][t]表示剩余i个第一种物品,j个第二种物品,k个第三种物品.以第t种物品为结尾的安排饲养表的种数.</strong> <strong>递归的思想来合并所有的情况,不过是减了所有的重复枝.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>const ll mod=1000000007;</strong> <strong>const int maxn=55;</strong> <strong>ll dp[maxn][maxn][maxn][4];</strong> <strong>int N1,N2,N3,D1,D2,D3,T;</strong> <strong>int main(){</strong> **    while(~SI(T)){** **        while(T–){** **            cle(dp,0);** **            SIII(N1,N2,N3);** **            SIII(D1,D2,D3);** **            red(i,N1,0) red(j,N2,0) red(k,N3,0){** **                rez(s,1,min(i,D1)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i-s][j][k][0]=(dp[i-s][j][k][0]+1)%mod;** **                    else** **                        dp[i-s][j][k][0]=((dp[i-s][j][k][0]+dp[i][j][k][1])%mod+dp[i][j][k][2])%mod;** **                }** **                rez(s,1,min(j,D2)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i][j-s][k][1]=(dp[i][j-s][k][1]+1)%mod;** **                    else** **                        dp[i][j-s][k][1]=((dp[i][j-s][k][1]+dp[i][j][k][0])%mod+dp[i][j][k][2])%mod;** **                }** **                rez(s,1,min(k,D3)){** **                    if(i==N1 &amp;&amp; j==N2 &amp;&amp; k==N3)** **                        dp[i][j][k-s][2]=(dp[i][j][k-s][2]+1)%mod;** **                    else** **                        dp[i][j][k-s][2]=((dp[i][j][k-s][2]+dp[i][j][k][0])%mod+dp[i][j][k][1])%mod;** **                }** **            }** **            ll ans=0;** **            ans=((dp[0][0][0][0]+dp[0][0][0][1])%mod+dp[0][0][0][2])%mod;** **            printf(“%lld\\n”,ans);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 DP 【题目链接】 http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1761/pid/3565 【题解】 用dp[i][j][k][t]表示剩余i个第一种物品,j","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"动态规划","slug":"Sdut/动态规划","count":2,"path":"api/categories/Sdut/动态规划.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/动态规划/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/动态规划/第七届ACM山东省赛.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"UVa 1025","slug":"uva-1025","date":"2016-12-25T13:49:54.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/uva-1025.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策 2:搭乘往右开的车(如果有)。 决策 3:搭乘往左开的车(如果有)。 【Code】 P268 A Spy in the Metro  </p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;<br>const int inf=0x3f3f3f3f;<br>int N,T,LN,RN,kase=0;<br>bool has_train[205][55][2];<br>int dp[205][55],ti[55];</cstring></p>\n<p>void solve(){</p>\n<pre><code>for(int i=1;i&lt;N;++i) dp\\[T\\]\\[i\\]=inf;\ndp\\[T\\]\\[N\\]=0;\n\nfor(int i=T-1;i&gt;=0;i--)\n    for(int j=1;j&lt;=N;++j){\n        dp\\[i\\]\\[j\\]=dp\\[i+1\\]\\[j\\]+1;//等待一个单位\n        if(j&lt;N&amp;&amp;has_train\\[i\\]\\[j\\]\\[0\\]&amp;&amp;i+ti\\[j\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j\\]\\]\\[j+1\\]);//右\n        if(j&gt;1&amp;&amp;has_train\\[i\\]\\[j\\]\\[1\\]&amp;&amp;i+ti\\[j-1\\]&lt;=T)\n            dp\\[i\\]\\[j\\]=min(dp\\[i\\]\\[j\\],dp\\[i+ti\\[j-1\\]\\]\\[j-1\\]);//左\n    }\n\n    cout&lt;&lt;&quot;Case Number &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;;\n    if(dp\\[0\\]\\[1\\]&gt;=inf) cout&lt;&lt;&quot;impossible\\\\n&quot;;\n    else cout&lt;&lt;dp\\[0\\]\\[1\\]&lt;&lt;&quot;\\\\n&quot;;</code></pre><p>}</p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    while(cin&gt;&gt;N&amp;&amp;N){<br>        cin&gt;&gt;T;</p>\n<pre><code>    memset(has\\_train,0,sizeof(has\\_train));\n\n    for(int i=1;i&lt;=N-1;++i)\n        cin&gt;&gt;ti\\[i\\];\n    cin&gt;&gt;LN;//左端点向右开的车\n    for(int i=1;i&lt;=LN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=1;j&lt;=N-1;++j){\n            if(start&lt;=T)has_train\\[start\\]\\[j\\]\\[0\\]=true;//第t秒第j个站点有车\n            start+=ti\\[j\\];\n        }\n    }\n\n    cin&gt;&gt;RN;//右端点向左开的车\n    for(int i=1;i&lt;=RN;++i){\n        int start;\n        cin&gt;&gt;start;\n        for(int j=N-1;j&gt;=1;--j){\n               if(start&lt;=T) has_train\\[start\\]\\[j+1\\]\\[1\\]=true;//第t秒第j个站点有车总共N个站台,往回走\n                start+=ti\\[j\\];\n        }\n    }\n    solve();\n\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【分析】 时间是单向流逝的,是一个天然的序,影响到决策的只有当前时间和所处的车站,所以可以用d(i,j)表示时刻i,你在车站j(编号为1-n)，最少还需要等待多长时间,边界条件是d(T,n)=0,其他d(T,i)(i不等于n)为正无穷。有如下三种决策. 决策 1: 等1分钟 决策","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"},{"name":"算法学习","slug":"UVa/动态规划/算法学习","count":1,"path":"api/categories/UVa/动态规划/算法学习.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10635 + NlogN-LIS","slug":"uva-10635-nlogn-lis","date":"2017-07-12T16:36:41.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10635-nlogn-lis.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Problem Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10635\" target=\"_blank\" rel=\"noopener\">Prince and Princess</a></strong> <strong>【题意】</strong> <strong>有两个长度分别为p+1和q+1的序列,每个序列中的各个元素互不相同,切都是1~n²之间的整数.两个序列的第一个元素都是1,求出A和B的最长公共子序列长度.</strong> <strong>【题解】</strong> <strong>本体是LCS问题,但规模达到了250²=62500,O(pq)的算法显然太慢.所以考虑把A重新按照下标编号,然后输入B的时候判断B中的整数在A中的位置,不存在则为0或者不记录.然后就转换为了求B得最长单增子序列LIS问题.然后用O(nlog(n))的解法解决.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVa%2010635.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10635.cpp</a></strong></p>\n<hr>\n<p>*<em>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=250</em>250+10;<br>const int INF=0x3f3f3f3f;<br>int S[maxn],g[maxn],d[maxn];///LIS所需<br>int num[maxn]; ///num[x]为整数x的编号,num[x]=0表示在A中未出现过<br>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    for(int kase=1;kase&lt;=T;++kase){<br>        int N,p,q,x;<br>        scanf(“%d%d%d”,&amp;N,&amp;p,&amp;q);<br>        fill(num,num+maxn,0);<br>        for(int i=1;i&lt;=p+1;++i){<br>            scanf(“%d”,&amp;x);<br>            num[x]=i;<br>        }<br>        int n=0;<br>        for(int i=0;i&lt;q+1;++i){<br>            scanf(“%d”,&amp;x);<br>            if(num[x]) S[n++]=num[x];<br>        }</p>\n<pre><code>    ///O(nlog(n))求解S\\[0\\]到S\\[n-1\\]的LIS\n    for(int i=1;i&lt;=n;++i){\n        g\\[i\\]=INF;\n    }\n    int ans=0;\n    for(int i=0;i&lt;n;++i){\n        int k=lower_bound(g+1,g+n+1,S\\[i\\])-g;///在g\\[1\\]~g\\[n\\]中查找\n        d\\[i\\]=k;///k是长度\n        g\\[k\\]=S\\[i\\];///g数组记录长度为k的目前最末(最大)元素大小\n        ans=max(ans,d\\[i\\]);\n    }\n    printf(&quot;Case %d: %d\\\\n&quot;,kase,ans);\n}\nreturn 0;</code></pre><p>}**</p>\n","text":"【Problem Link】 Prince and Princess 【题意】 有两个长度分别为p+1和q+1的序列,每个序列中的各个元素互不相同,切都是1~n²之间的整数.两个序列的第一个元素都是1,求出A和B的最长公共子序列长度. 【题解】 本体是LCS问题,但规模达到了25","link":"","raw":null,"photos":[],"categories":[{"name":"LIS","slug":"LIS","count":1,"path":"api/categories/LIS.json"},{"name":"UVa","slug":"LIS/UVa","count":1,"path":"api/categories/LIS/UVa.json"},{"name":"动态规划","slug":"LIS/UVa/动态规划","count":1,"path":"api/categories/LIS/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"LIS","slug":"LIS","count":1,"path":"api/tags/LIS.json"}]},{"title":"UVa 10755","slug":"uva-10755","date":"2017-04-08T08:04:53.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-10755.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>最大子长方体和,降维.</strong> <strong>【题解】</strong> <strong>蓝书P56</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i)</strong> <strong>using namespace std;</strong> <strong>typedef long long LL;</strong> <strong>const int maxn=30;</strong> <strong>const LL INF=1LL&lt;&lt;60;</strong> <strong>LL S[maxn][maxn][maxn];</strong> <strong>void expand(int i,int&amp; b0,int&amp; b1,int&amp; b2){</strong> **    b0=i&1; i&gt;&gt;=1;** **    b1=i&1; i&gt;&gt;=1;** **    b2=i&1;** <strong>}</strong> <strong>int sign(int b0,int b1,int b2){</strong> **    return (b0+b1+b2)%2==1?1:-1;** <strong>}</strong> <strong>LL sum(int x1,int x2,int y1,int y2,int z1,int z2){</strong> **    int dx=x2-x1+1,dy=y2-y1+1,dz=z2-z1+1;** **    LL s=0;** **    for(int i=0;i&lt;8;++i){** **        int b0,b1,b2;** **        expand(i,b0,b1,b2);** **        s-=S[x2-b0*dx][y2-b1*dy][z2-b2*dz]*sign(b0,b1,b2);** **    }** **    return s;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int a,b,c,b0,b1,b2;** **        scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c);** **        memset(S,0,sizeof(S));** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    scanf(“%lld”,&amp;S[x][y][z]);** **        for(int x=1;x&lt;=a;++x)** **            for(int y=1;y&lt;=b;++y)** **                for(int z=1;z&lt;=c;++z)** **                    for(int i=1;i&lt;=7;++i){** **                        //001 010 011 100 101 110 111三种位移** **                        expand(i,b0,b1,b2);** **                        //递推求和,sign()-&gt;加 or 减; expand()-&gt;状态** **                        S[x][y][z]+=S[x-b0][y-b1][z-b2]<em>sign(b0,b1,b2);*</em> **                    }** **        LL ans=-INF;** **        for(int x1=1;x1&lt;=a;++x1)** **            for(int x2=x1;x2&lt;=a;++x2)** **                for(int y1=1;y1&lt;=b;++y1)** **                    for(int y2=y1;y2&lt;=b;++y2){** **                        LL M=0;** **                        //对于每次求某个x1,x2,y1,y2区间上的最大子长方体和** **                        //M等价于寻找z区间上(1-z)中最小的子矩阵** **                        for(int z=1;z&lt;=c;++z){** **                            LL s=sum(x1,x2,y1,y2,1,z);** **                            ans=max(ans,s-M);** **                            M=min(M,s);** **                        }** **                    }** **                    printf(“%lld\\n”,ans);** **                    if(T) printf(“\\n”);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 最大子长方体和,降维. 【题解】 蓝书P56 【Code】#include #include #include #include #define FOR(i,s,t) for(int i=(s);i&lt;=(t);++i) using namespace std; t","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10859","slug":"uva-10859","date":"2017-07-18T07:52:02.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/uva-10859.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10859\" target=\"_blank\" rel=\"noopener\">Placing Lampposts</a></strong> <strong>【题意】</strong> <strong>给你一个ｎ个点ｍ条边的无向无环图，在尽量少的节点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。</strong> <strong>在灯的总数最小的前提下，被两盏灯同时被照亮的边数应该尽量大。</strong> <strong>【题解】</strong> <strong>树形dp,Lrj P70。</strong> <strong>这题教会了我一个很有用的技巧：有两个所求的值要优化，比如让a尽量小，ｂ也尽量小</strong> <strong>那么可以转化为让 M*a+b尽量小，其中Ｍ应该是一个比“a的最大值和b的最小值之差”还要大的数</strong> <strong>最终的答案为ans/M, ans%M</strong> <strong>回到这题，要求放的灯总数最小，被两盏灯同时照亮的边数尽量大。</strong> <strong>因为每条边要么被一盏灯照亮，要么被两盏灯照亮，所以可以转换为：</strong> <strong>求：放的灯总数量最少，被一盏灯照亮的边数尽量少。</strong> <strong>就可以变成球 M*a+b 的最小值，ａ为放置的灯数量，ｂ为被一盏灯照的边数</strong> <strong>f[u][1]表示u点放灯时的整个子树最小值</strong> <strong>f[u][0]表示u点不放灯时的整个子树最小值</strong> <strong>如果u放，那么u个子结点可以选择放，也可以不放，选择其中较小的值。如果选的是不照，就要增加一条只有一个灯照的边</strong> <strong>如果u不放，那么其子结点就必须选择要放，而且每条边都只有一个灯照</strong> <strong>【Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVA%2010859.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10859.cpp</a></strong></p>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int T,n,m,vis[2000][2],d[2000][2];<br>vector Graph[1010];</p>\n<p>int dp(int i,int j,int f){<br>    if(vis[i][j]) return d[i][j];<br>    vis[i][j]=1;<br>    int&amp; ans=d[i][j];</p>\n<pre><code>ans=2000;\nfor(int k=0;k&lt;Graph\\[i\\].size();++k)** \n    if(Graph\\[i\\]\\[k\\]!=f) \n       ans+=dp(Graph\\[i\\]\\[k\\],1,i); \nif(!j &amp;&amp; f&gt;=0)  ans++;\n\nif(j || f&lt;0){\n    int sum=0;\n    for(int k=0;k&lt;Graph\\[i\\].size();++k) \n       if(Graph\\[i\\]\\[k\\]!=f) \n          sum+=dp(Graph\\[i\\]\\[k\\],0,i); \n    if(f&gt;=0) sum++;\n    ans=min(ans,sum);\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d”,&amp;n,&amp;m);<br>        for(int i=0;i&lt;n;++i) Graph[i].clear();<br>        for(int i=0;i&lt;m;++i){<br>            int x,y;<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            Graph[x].push_back(y);<br>            Graph[y].push_back(x);<br>        }<br>        memset(vis,0,sizeof(vis));<br>        int ans=0;<br>        for(int i=0;i&lt;n;++i){<br>            if(!vis[i][0])///新的一棵树<br>                ans+=dp(i,0,-1);<br>        }<br>        printf(“%d %d %d\\n”,ans/2000,m-ans%2000,ans%2000);<br>    }<br>    return 0;<br>}</p>\n","text":"【Topic Link】 Placing Lampposts 【题意】 给你一个ｎ个点ｍ条边的无向无环图，在尽量少的节点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。 在灯的总数最小的前提下，被两盏灯同时被照亮的边数应该尽量大。 【题解】 树形dp,Lrj P7","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"树形dp","slug":"UVa/树形dp","count":1,"path":"api/categories/UVa/树形dp.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"树形dp","slug":"树形dp","count":1,"path":"api/tags/树形dp.json"}]},{"title":"UVa 10891","slug":"uva-10891","date":"2017-07-13T16:42:55.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10891.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10891\" target=\"_blank\" rel=\"noopener\">Game of Sum</a></strong> <strong>【题意】</strong> <strong>给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B).</strong> <strong>【题解】</strong> <strong>因为任意时刻游戏的状态都是连续子序列.</strong> <strong>用d(i,j)表示原序列的第i~j个元素组成的子序列.在双方都采取最优策略的情况下,先手得分的最大值.</strong> <strong>状态转移时,我们考虑从左取和从右取多少个.等价于枚举给对方剩下怎样的子序列.是(k,end)(begin&lt;k&lt;=end),还是(begin,k)(begin&lt;=k&lt;end).</strong> <strong>状态转移方程:d(begin,end)=sum(begin,end)-min{d(begin+1,end),d(begin+2,end),…,d(end,end), d(begin,end-1),d(begin,end-2),…,d(begin,begin),0}</strong> <strong>0代表全取完,所以不需要边界处理.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/UVa%2010891.cpp\" target=\"_blank\" rel=\"noopener\">UVa 10891.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=100+20;<br>int A[maxn],vis[maxn][maxn],S[maxn],d[maxn][maxn];</p>\n<p>int dp(int b,int e){<br>    if(vis[b][e]) return d[b][e];///记忆化搜索<br>    vis[b][e]=1;<br>    int m=0;<br>    ///从b-&gt;e选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b+1;k&lt;=e;++k) m=min(m,dp(k,e)); ///从e-&gt;b选最小的结果,然后d[b][e]选sum(b,e)-m<br>    for(int k=b;k&lt;e;++k) m=min(m,dp(b,k));<br>    d[b][e]=S[e]-S[b-1]-m;<br>    return d[b][e];<br>}</p>\n<p>int main(){<br>    int n;S[0]=0;<br>    while(~scanf(“%d”,&amp;n) &amp;&amp; n){<br>        for(int i=1;i&lt;=n;++i){**<br> <strong>scanf(“%d”,&amp;A[i]);</strong><br> <strong>S[i]=S[i-1]+A[i];</strong><br> <strong>}</strong><br> <strong>memset(vis,0,sizeof(vis));</strong><br> <strong>printf(“%d\\n”,2*dp(1,n)-S[n]);///=&gt;dp(1,n)-(S[n]-dp(1,n))<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Game of Sum 【题意】 给你一个序列的数,两个玩家A,B.每次A,B都需要从这个序列的两端取连续的数,保证他们每次都用最优的策略.A先手,求游戏结束后sum(A)-sum(B). 【题解】 因为任意时刻游戏的状态都是连续子序列. 用d(i,j)","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11825","slug":"uva-11825","date":"2017-07-14T16:41:09.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-11825.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-11825\" target=\"_blank\" rel=\"noopener\">Hackers’ Crackdown</a></strong> <strong>【题意】</strong> <strong>有N台机器，每台机器上有N个服务</strong> <strong>你可以对每台机器选择关闭他以及和他相邻的机器的一种服务</strong> <strong>当所有机器不能运行一个服务时，就是摧毁了一种服务</strong> <strong>问你最多能摧毁多少个服务</strong> <strong>【题解】</strong> <strong>就是把n台电脑看成n个集合,每个集合的成员就是这台电脑,以及和这台电脑相邻的电脑;</strong> <strong>我们就是要求把这些集合合并成尽量多的大集合,使每个集合都等于全集;也就是因为最开始的小集合,我们可以让它里面全部电脑的某一项服务全部失误,那如果合并成一个大集合,则这个大集合的某一项服务可以全部失效;所以能合并成几个等于全集的大集合,就可以让几项服务失效;</strong> <strong>【Tip】</strong> <strong>状态压缩,异或操作是相同得0,不同得1.LRJ这道题的位运算用的好…</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2011825.cpp\" target=\"_blank\" rel=\"noopener\">Uva 11825.cpp</a></strong></p>\n<hr>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int N,T,P[1&lt;&lt;17],f[1&lt;&lt;17],cover[1&lt;&lt;17],ca=1;<br>int main(){<br>    while(~scanf(“%d”,&amp;N),N){<br>        ///初始化第i台计算机的相邻集合<br>        for(int i=0;i&lt;N;++i){<br>            int n,m;<br>            scanf(“%d”,&amp;n);<br>            P[i]=1&lt;&lt;i;<br>            for(int j=0;j&lt;n;++j){<br>                scanf(“%d”,&amp;m);<br>                P[i] |= 1&lt;&lt;m;<br>            }<br>        }<br>        ///S是N个计算机的所有组合的集合,二进制表示,cover[S]是集合的并<br>        for(int S=0;S&lt;(1&lt;&lt;N);++S){<br>            cover[S]=0;<br>            for(int i=0;i&lt;N;++i){<br>                if(S &amp; (1&lt;&lt;i)) cover[S] |= P[i];///第i台机器选/不选<br>            }<br>        }<br>        f[0]=0;<br>        int ALL=(1&lt;&lt;N)-1;///全集二进制表示<br>        for(int S=1;S&lt;(1&lt;&lt;N);++S){<br>            f[S]=0;<br>            ///筛出S的子集进行动态规划<br>            for(int S0=S;S0;S0=(S0-1)&amp;S){<br>                if(cover[S0]==ALL)///如果子集S的子集的并是全集<br>                    f[S]=max(f[S],f[S^S0]+1);<br>            }<br>        }<br>        printf(“Case %d: %d\\n”,ca++,f[ALL]);<br>    }<br>    return 0;<br>}</strong></p>\n","text":"【Topic Link】 Hackers’ Crackdown 【题意】 有N台机器，每台机器上有N个服务 你可以对每台机器选择关闭他以及和他相邻的机器的一种服务 当所有机器不能运行一个服务时，就是摧毁了一种服务 问你最多能摧毁多少个服务 【题解】 就是把n台电脑看成n个集合,每","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"位操作","slug":"UVa/位操作","count":2,"path":"api/categories/UVa/位操作.json"},{"name":"动态规划","slug":"UVa/位操作/动态规划","count":1,"path":"api/categories/UVa/位操作/动态规划.json"},{"name":"状态压缩","slug":"UVa/位操作/动态规划/状态压缩","count":1,"path":"api/categories/UVa/位操作/动态规划/状态压缩.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}]},{"title":"UVa 437","slug":"uva-437","date":"2017-04-16T14:34:35.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-437.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>DAG上的DP</strong> <strong>下面的代码一是转换成最长单增子序列LIS做的</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=300;</strong> <strong>struct star{</strong> **    int a,b,c;** **    bool operator&lt;(const star &amp;A)const{** **        return a==A.a?b&lt;A.b:a&lt;A.a;** **    }** <strong>};</strong> <strong>star S[maxn];</strong> <strong>int N,kase=1;</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        int x,y,z,k=0;** **        rep(i,N){** **            SIII(x,y,z);** **            S[k].a=x;S[k].b=y;S[k++].c=z;** **            S[k].a=x;S[k].c=y;S[k++].b=z;** **            S[k].b=x;S[k].a=y;S[k++].c=z;** **            S[k].b=x;S[k].c=y;S[k++].a=z;** **            S[k].c=x;S[k].b=y;S[k++].a=z;** **            S[k].c=x;S[k].a=y;S[k++].b=z;** **        }** **        sort(S,S+k);** **        int ans=-INF,dp[maxn];** **        rep(i,k){** **            dp[i]=S[i].c;** **            rep(j,i){** **                if(S[j].a&lt;S[i].a &amp;&amp; S[j].b&lt;S[i].b){** **                    dp[i]=max(dp[i],dp[j]+S[i].c);** **                }** **            }** **            ans=max(ans,dp[i]);** **        }** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>代码二</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=30+5;</strong> <strong>int N,kase=1,blocks[maxn][3],d[maxn][3];</strong> <strong>void get_dimensions(int* v,int b,int dim){</strong> **    int idx=0;** **    rep(i,3) if(i!=dim) v[idx++]=blocks[b][i];** <strong>}</strong> <strong>int dp(int i,int j){</strong> **    int&amp; ans=d[i][j];** **    if(ans&gt;0) return ans;** **    ans=0;** **    int v[2],v2[2];** **    get_dimensions(v,i,j);** **    rep(a,N) rep(b,3){** **        get_dimensions(v2,a,b);** **        if(v2[0]&lt;v[0] &amp;&amp; v2[1]&lt;v[1]) ans=max(ans,dp(a,b));** **    }** **    ans+=blocks[i][j];** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    while(SI(N)&amp;&amp;N){** **        rep(i,N){** **            rep(j,3) SI(blocks[i][j]);** **            sort(blocks[i],blocks[i]+3);** **        }** **        cle(d,0);** **        int ans=0;** **        rep(i,N) rep(j,3) ans=max(ans,dp(i,j));** **        printf(“Case %d: maximum height = %d\\n”,kase++,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 DAG上的DP 下面的代码一是转换成最长单增子序列LIS做的 【Code】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"动态规划","slug":"UVa/动态规划","count":4,"path":"api/categories/UVa/动态规划.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}