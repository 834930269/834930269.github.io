{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"postlist":[{"title":"POJ 2195","slug":"poj-2195","date":"2017-04-17T15:49:19.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-2195.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>SPFA 最小费用最大流</strong> <strong>【Tip】</strong> <strong>注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<vector></vector></strong> <strong>#include<queue></queue></strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>//最多房子/人为100</strong> <strong>//最大节点数为100+100+2</strong> <strong>//最大边数为(100+100+100*100)*2=20400;AC!</strong> <strong>const int maxn=300,maxm=20410;</strong> <strong>int max_num,home_sum;</strong> <strong>char s[maxn];</strong> <strong>typedef struct{</strong> **    int x,y;** <strong>}point;</strong> <strong>point man[maxn+10],home[maxn+10];</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];** **    int nume;** **    int src,sink;//源点,汇点** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        queue<int> que;** **        que.push(src);** **        cle(dist,INF);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    int mincostflow(){** **        int cur=0;//原板子有一个ans=0** **        while(Spfa()){** **            cur+=augment();** **     //     cout&lt;&lt;cur&lt;&lt;endl;** **          //原板子  if(cur&gt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>}mcmf;</strong> <strong>int main(){</strong> <strong>#ifndef ONLINE_JUDGE</strong> **    freopen(“in.txt”, “r”, stdin);** **    freopen(“out.txt”, “w”, stdout);** <strong>#endif</strong> **    int N,M;** **    while(~SII(N,M) &amp;&amp; N+M){** **        getchar();** **        mcmf.init();** **        max_num=home_sum=0;** **        rez(i,1,N){** **            gets(s);** **            rep(j,M){** **                if(s[j]==’m’){** **                    man[max_num].x=i;** **                    man[max_num++].y=j+1;** **                }else if(s[j]==’H’){** **                    home[home_sum].x=i;** **                    home[home_sum++].y=j+1;** **                }** **            }** **        }** **        mcmf.src=0;** **        mcmf.sink=2<em>max_num+1;*</em> **        rep(i,max_num){** **            mcmf.Addedge(0,i+1,1,0);** **            mcmf.Addedge(max_num+i+1,mcmf.sink,1,0);** **            rep(j,home_sum)** **                mcmf.Addedge(i+1,max_num+j+1,1,abs(man[i].x-home[j].x)+abs(man[i].y-home[j].y));** **        }** **    //    rep(i,mcmf.nume){** **    //        printf(“%d %d %d %d\\n”,mcmf.e[i].v,mcmf.e[i].f,mcmf.e[i].w,mcmf.e[i].nxt);** **     //   }** **        printf(“%d\\n”,mcmf.mincostflow());** **    }** **    return 0;** <strong>}</strong></int></p>\n</blockquote>\n","text":"【类型】 SPFA 最小费用最大流 【Tip】 注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数. 【Code】#include  #include #include #include #include #include #i","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"最大流","slug":"POJ/最大流","count":2,"path":"api/categories/POJ/最大流.json"},{"name":"最小费用最大流","slug":"POJ/最大流/最小费用最大流","count":1,"path":"api/categories/POJ/最大流/最小费用最大流.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"最大流","slug":"最大流","count":2,"path":"api/tags/最大流.json"},{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"path":"api/tags/最小费用最大流.json"}]},{"title":"UVa 1658","slug":"uva-1658","date":"2017-04-18T02:19:05.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-1658.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>SPFA最小费用最大流,构图</strong> <strong>【Tip】</strong> <strong>这道题说每个节点只能访问一次,所以只需要把每个节点分为两个节点i和i’,且这两个节点的容量为1,费用为0.然后题目要求求两条不相交的路径使得权和最小,所以只需要求1~v的流量为2的最小费用即可.添加一个超级节点0-&gt;1和超级节点v-&gt;2*v+1.且这两条边的容量为2,费用为0.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=5000,maxm=50000;</strong> <strong>int v,e;</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];//maxm最大边数** **    int nume;** **    int src,sink;** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    queue<int> que;** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        while(!que.empty()) que.pop();** **        que.push(src);** **        cle(dist,63);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    ll mincostflow(){** **        ll cur=0;** **        while(Spfa()){** **            cur+=augment();** **  //          if(cur&lt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>};</strong> <strong>int main(){</strong> **    while(~SII(v,e)){** **        MCMF mcmf;** **        mcmf.init();** **        mcmf.src=1;** **        mcmf.sink=2<em>v+1;*</em> **        int a,b,c;** **        rez(i,2,v-1)** **            mcmf.Addedge(i,i+v,1,0);** **        mcmf.Addedge(0,1,2,0);//限制流量为2** **        mcmf.Addedge(v,2<em>v+1,2,0);*</em> **        rep(i,e){** **            SIII(a,b,c);** **            if(a!=1 &amp;&amp; a!=v)** **                mcmf.Addedge(a+v,b,1,c);** **            else mcmf.Addedge(a,b,1,c);** **        }** **        printf(“%lld\\n”,mcmf.mincostflow());** **    }** **    return 0;** <strong>}</strong></int></p>\n</blockquote>\n","text":"【类型】 SPFA最小费用最大流,构图 【Tip】 这道题说每个节点只能访问一次,所以只需要把每个节点分为两个节点i和i’,且这两个节点的容量为1,费用为0.然后题目要求求两条不相交的路径使得权和最小,所以只需要求1~v的流量为2的最小费用即可.添加一个超级节点0-&gt;1和超","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"最小费用最大流","slug":"UVa/最小费用最大流","count":1,"path":"api/categories/UVa/最小费用最大流.json"}],"tags":[{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"path":"api/tags/最小费用最大流.json"}]}]}