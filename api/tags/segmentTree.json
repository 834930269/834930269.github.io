{"name":"segmentTree","slug":"segmentTree","count":2,"postlist":[{"title":"2017多校训练2 HDU 6047 Maximum Sequence","slug":"2017-hdu-6047-maximum-sequence","date":"2017-07-29T04:51:07.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6047-maximum-sequence.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6047\" title=\"Maximum Sequence\" target=\"_blank\" rel=\"noopener\">Maximum Sequence</a> 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,记录每个i到maxindex(A)的最大值,然后动态更新. github: 1.线段树法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003_Range_Tree.cpp\" title=\"1003_Range_Tree.cpp\" target=\"_blank\" rel=\"noopener\">1003_Range_Tree.cpp</a> 2.暴力动态更新法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003.cpp\" title=\"1003.cpp\" target=\"_blank\" rel=\"noopener\">1003.cpp</a></p>\n<pre><code>///线段树法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst int maxnode=2000050;\n\nint b[maxnode],N;\nint maxv[maxnode];\n\nvoid build(int o,int l,int r){\n    if(l==r){\n        if(l&gt;N) return;///预先分配2*N个结点\n        scanf(&quot;%d&quot;,&amp;maxv[o]);maxv[o]-=l;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(o&lt;&lt;1,l,mid);\n    build(o&lt;&lt;1|1,mid+1,r);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint query(int o,int l,int r,int ll,int rr){\n    if(l&gt;=ll&amp;&amp;r&lt;=rr) return maxv[o];\n    int ma=-1,mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=ll) ma=max(ma,query(o&lt;&lt;1,l,mid,ll,rr));\n    if(rr&gt;mid) ma=max(ma,query(o&lt;&lt;1|1,mid+1,r,ll,rr));\n    return ma;\n}\n\nvoid update(int o,int l,int r,int p,int val){\n    if(l==r){\n        maxv[o]=val;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    if(p&lt;=mid)update(o&lt;&lt;1,l,mid,p,val);\n    else update(o&lt;&lt;1|1,mid+1,r,p,val);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        build(1,1,2*N);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        LL ans=0;\n        for(int i=N+1;i&lt;=2*N;++i){\n            int k=query(1,1,2*N,b[i-N],i-1);\n            update(1,1,2*N,i,k-i);\n            ans=(ans+k)%mod;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n\n///HDU 6047 暴力动态更新法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=500000+50;\nconst int mod=1e9+7;\nint N;\nint a[maxn],b[maxn],maxa[maxn];\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=1;i&lt;=N;++i){\n            int aa;\n            scanf(&quot;%d&quot;,&amp;aa);\n            a[i]=aa-i;\n        }\n        maxa[N]=a[N];\n        for(int i=N-1;i&gt;=1;--i) maxa[i]=max(maxa[i+1],a[i]);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        long long ans=0;\n        ans=(ans+maxa[b[1]])%mod;\n        int t=maxa[b[1]]-N-1;\n        for(int i=2;i&lt;=N;++i){\n            maxa[b[i]]=max(maxa[b[i]],t);\n            ans=(ans+maxa[b[i]])%mod;\n            t=max(t,maxa[b[i]]-N-1);\n        }\n        printf(&quot;%lld\\n&quot;,ans%mod);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: :point_right:Maximum Sequence 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"segmentTree","slug":"2017多校/segmentTree","count":1,"path":"api/categories/2017多校/segmentTree.json"},{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"path":"api/categories/2017多校/segmentTree/思维.json"},{"name":"线段树","slug":"2017多校/segmentTree/思维/线段树","count":1,"path":"api/categories/2017多校/segmentTree/思维/线段树.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"算法学习-线段树","slug":"segment-tree","date":"2017-03-18T11:04:39.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/segment-tree.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/03/QQ%E6%88%AA%E5%9B%BE20170318190105.png","content":"<p>【概念】 线段树是擅长处理区间的,且是一颗完美二叉树(Perfect Binary Tree),树上每一个节点都维护一个区间,根维护的是整个区间,每个节点维护的是父亲的区间二等分后的其中一个子区间。当有n个元素时,对区间的操作可以在O(log n)的时间内完成. 以下我们以实现了Range Minimum Query(RMQ,范围最小值查询)操作的线段树为例,进行说明. 【基于线段树的RMQ的结构】 下面要建立的线段树在给定数列a0,a1,a2,….,an-1的情况下,可以在O(log n)时间内完成如下两种操作.</p>\n<ul>\n<li>给定s和t,求as,as+1,…,at的最小值.                                                                         ΘωΘ~</li>\n<li>给定i和x,把ai的值改成x.</li>\n</ul>\n<p>递归建树,在建树时只需要按从下到上的顺序分别取左右儿子的值中的较小者就可以了.(回溯实现) 【基于线段树的RMQ的查询】 如果要求a0,…,a6的最小值。我们只需要求[a0,a3],[a4,a5],[a6]这三个区间中的最小值即可。 要求某个区间的最小值,向下面这样递归处理就可以了.</p>\n<ul>\n<li>如果所查询的区间和当前节点对应的区间完全没有交集,那么就返回一个不影响答案的值(例如INT_MAX)。</li>\n<li>如果所查询的区间完全包含了当前节点对应的区间,那么就返回当前节点的值.</li>\n<li>以上两种情况都不满足的话,就对两个儿子递归处理,返回两个结果中的较小者.</li>\n</ul>\n<p>【基于线段树的RMQ的值的更新】 在更新a0(a0:5-&gt;2)的值时,需要重新计算a0往上的所有父节点的值.–即,在更新ai的值时,需要对包含i的所有区间对应的节点的值重新计算。在更新时,可以从下面的节点开始向上不断更新,把每个节点的值更新为左右两个儿子的值的较小者就可以了. 【实现】 为了简单起见,在建立线段树时,把数列所有的值都初始化为INT_MAX(limits.h文件中).此外,query的参数中不只传入节点的编号,还传入了节点对应的区间.</p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<climits></climits></strong> <strong>using namespace std;</strong> <strong>const int MAX_N=1&lt;&lt;17;</strong> <strong>//存储线段树的全局数组</strong> <strong>int n,dat[2*MAX_N-1];</strong> <strong>//initialize</strong> <strong>void init(int n_){</strong> <em>*    /*为了简便起见,把元素扩大到2的幂–满二叉树</em>/<em>* **    n=1;** **    while(n&lt;n_) n</em>=2;<em>* **    /*把所有的值都设为INT_MAX</em>/<em>* **    for(int i=0;i&lt;2<em>n-1;++i)dat[i]=INT_MAX;*</em> <strong>}</strong> *<em>/</em>把第k个值(0-indexed)更新为a</em>/<em>* <strong>void updata(int k,int a){</strong> **    /*叶子节点</em>/<em>* **    k+=n-1;** **    dat[k]=a;** **    /*向上更新</em>/<em>* **    while(k&gt;0){** **        k=(k-1)/2;** <strong>dat[k]=min(dat[k*2+1],dat[k*2+2]);</strong> **    }** <strong>}</strong> **/\\</em> 查询<em>* <strong>*求[a,b)的最小值</strong> <strong>*后面的参数是为了计算起来方便而传入的</strong> <strong>*k是节点的编号,l(英文字母),r表示这个节点对应的是[l,r)区间</strong> <strong>*在外部调用时,用query(a,b,0，0，n)</strong> <strong>*这里n为换算成满二叉树后的叶子节点数,如n_=10，n=16</strong> <strong>*/</strong> <strong>int query(int a,int b,int k,int l,int r){</strong> **    /*如果[a,b]和[1,r]不相交,则返回INT_MAX</em>/<em>* **    if(r&lt;=a||b&lt;=l) return INT_MAX;** **    /*如果[a,b]完全包含[1，r],则返回当前节点的值</em>/<em>* **    if(a&lt;=l &amp;&amp; r&lt;=b) return dat[k];** **    else{** **        /*否则返回两个儿子中值的较小者</em>/** **        int v1=query(a,b,k<em>2+1,l,(l+r)/2);*</em> **        int v2=query(a,b,k<em>2+2,(l+r)/2,r);*</em> <strong>return min(v1,v2);</strong> <strong>}</strong> <strong>}</strong> <strong>int main(){</strong> <strong>init(10);//区间为[a0,a9]</strong> **    updata(5,-10);** **    updata(2,-20);** **    updata(0,2);** <strong>cout&lt;&lt;”[0,1) min: “&lt;&lt;query(0,1,0,0,16)&lt;&lt;endl;</strong> **    cout&lt;&lt;”[2,3) min: “&lt;&lt;query(2,3,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[5,6) min: “&lt;&lt;query(5,6,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[0,9) min: “&lt;&lt;query(0,9,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[0,4) min: “&lt;&lt;query(0,4,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[2,7) min: “&lt;&lt;query(2,7,0,0,16)&lt;&lt;endl;** **    cout&lt;&lt;”[3,7) min: “&lt;&lt;query(3,7,0,0,16)&lt;&lt;endl;** **    for(int i=0;i&lt;=32;++i)** <strong>cout&lt;&lt;”deg “&lt;&lt;i&lt;&lt;” = “&lt;&lt;dat[i]&lt;&lt;endl;</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n<p>【Tip】</p>\n<ol>\n<li>query中的n是叶子节点总数,不是区间的上界.</li>\n<li>query查询的是[a,b)半开半闭区间,如,a0=2,想查a0,就必须查[0,1).</li>\n<li>查询和建树/更新都是从下标0开始的.</li>\n</ol>\n<p>【运行结果】 <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/03/QQ截图20170318190105.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/QQ%E6%88%AA%E5%9B%BE20170318190105.png\" alt></a>   【果断要画图啊】 以上代码建好的树是这样的(渣画质莫介意…): <img src=\"http://be-sunshine.cn/wp-content/uploads/2017/03/IMG_20170318_185245_1489834380376-1.jpg\" alt></p>\n","text":"【概念】 线段树是擅长处理区间的,且是一颗完美二叉树(Perfect Binary Tree),树上每一个节点都维护一个区间,根维护的是整个区间,每个节点维护的是父亲的区间二等分后的其中一个子区间。当有n个元素时,对区间的操作可以在O(log n)的时间内完成. 以下我们以实现了","link":"","raw":null,"photos":[],"categories":[{"name":"segmentTree","slug":"segmentTree","count":1,"path":"api/categories/segmentTree.json"},{"name":"算法学习","slug":"segmentTree/算法学习","count":1,"path":"api/categories/segmentTree/算法学习.json"}],"tags":[{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"}]}]}