{"name":"最大流","slug":"最大流","count":2,"postlist":[{"title":"POJ 1273","slug":"poj-1273","date":"2017-04-17T12:39:14.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-1273.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>最大流Dinic</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<vector></vector></strong> <strong>#include<queue></queue></strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 1e9;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>const int maxn=300;</strong> <strong>int N,M;</strong> <strong>//弧,从from到to的容量为cap,流量为flow的弧当cap=0时,意味此边是反向弧</strong> <strong>//当且仅当flow&lt;cap时,该弧存在于残量网络中</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int from,int to,int cap,int flow):from(from),to(to),cap(cap),flow(flow){}** **    int from,to,cap,flow;** <strong>};</strong> <strong>struct Dinic{</strong> **    int n,m,s,t; //节点数,边数(包括反向弧),源点编号,汇点编号** **    vector<edge> edges;//边表。edges[e]和edges[e^1]互为反向弧。** **    vector<int> G[maxn]; //邻接表,G[i][j]表示节点i的第j条边在e数组中的序号** **    bool vis[maxn]; //BFS使用** **    int d[maxn]; //从起点到i的距离** **    int cur[maxn]; //当前弧的下标** **    //插入弧,原图中的一条弧对应于两个Edge结构体,一个是这条弧本身,另一个是他的反向弧** **    //根据插入顺序不难看出,edges[0]和edges[1]互为反向弧,edges[2]和edges[3]** **    //一般的,edges[e]和edges[e^1]互为反向弧** **    void AddEdge(int from,int to,int cap){** **        edges.push_back((Edge){from,to,cap,0});** **        edges.push_back((Edge){to,from,0,0});** **        m=edges.size();** **        G[from].push_back(m-2);** **        G[to].push_back(m-1);** **    }** **    bool BFS(){** **        cle(vis,0);** **        queue<int> Q;** **        Q.push(s);** **        d[s]=0;** **        vis[s]=1;** **        while(!Q.empty()){** **            int x=Q.front();Q.pop();** **            for(int i=0;i&lt;G[x].size();++i){** **                Edge&amp; e=edges[G[x][i]];** **                if(!vis[e.to] &amp;&amp; e.cap&gt;e.flow){//只考虑残量网络中的狐** **                    vis[e.to]=1;** **                    d[e.to]=d[x]+1;** **                    Q.push(e.to);** **                }** **            }** **        }** **        return vis[t];** **    }** **    int DFS(int x,int a){** **        if(x==t || a==0) return a;** **        int flow=0,f;** **        for(int&amp; i=cur[x];i&lt;G[x].size();++i){//从上次考虑的弧** **            Edge&amp; e=edges[G[x][i]];** **            if(d[x]+1==d[e.to] &amp;&amp; (f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){** **                e.flow+=f;** **                edges[G[x][i]^1].flow-=f;** **                flow+=f;** **                a-=f;** **                if(a==0) break;** **            }** **        }** **        return flow;** **    }** **    int Maxflow(int s,int t){** **        this-&gt;s=s;this-&gt;t=t;** **        int flow=0;** **        while(BFS()){** **            cle(cur,0);** **            flow+=DFS(s,INF);** **        }** **        return flow;** **    }** <strong>};</strong> <strong>int main(){</strong> **    while(~SII(N,M)){** **        Dinic dinic;** **        dinic.n=M;** **        rep(i,N){** **            int a,b,c;** **            SIII(a,b,c);** **            dinic.AddEdge(a,b,c);** **        }** **        printf(“%d\\n”,dinic.Maxflow(1,M));** **    }** **    return 0;** <strong>}</strong></int></int></edge></p>\n</blockquote>\n","text":"【类型】 最大流Dinic 【Code】#include  #include #include #include #include #include #include using namespace std; typedef long long ll; const int INF","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"最大流","slug":"POJ/最大流","count":2,"path":"api/categories/POJ/最大流.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"最大流","slug":"最大流","count":2,"path":"api/tags/最大流.json"}]},{"title":"POJ 2195","slug":"poj-2195","date":"2017-04-17T15:49:19.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-2195.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>SPFA 最小费用最大流</strong> <strong>【Tip】</strong> <strong>注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include <iostream></iostream></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<vector></vector></strong> <strong>#include<queue></queue></strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>/*  ////////////////////////   C o d i n g  S p a c e   ////////////////////////  */</strong> <strong>//最多房子/人为100</strong> <strong>//最大节点数为100+100+2</strong> <strong>//最大边数为(100+100+100*100)*2=20400;AC!</strong> <strong>const int maxn=300,maxm=20410;</strong> <strong>int max_num,home_sum;</strong> <strong>char s[maxn];</strong> <strong>typedef struct{</strong> **    int x,y;** <strong>}point;</strong> <strong>point man[maxn+10],home[maxn+10];</strong> <strong>struct Edge</strong> <strong>{</strong> **    Edge(){}** **    Edge(int a,int b,int c,int d):v(a),f(b),w(c),nxt(d){}** **    int v,f,w,nxt;** <strong>};</strong> <strong>struct MCMF{</strong> **    int n,lmt;** **    int g[maxn+10];** **    Edge e[maxm+10];** **    int nume;** **    int src,sink;//源点,汇点** **    void init(){** **        nume=1;** **        cle(g,0);** **    }** **    void Addedge(int u,int v,int c,int w){//u-&gt;v,容量为c费用为w的边** **        e[++nume]=(Edge){v,c,w,g[u]};** **        g[u]=nume;** **        e[++nume]=(Edge){u,0,-w,g[v]};** **        g[v]=nume;** **    }** **    bool inQue[maxn+10];** **    int dist[maxn+10];** **    int prev[maxn+10],pree[maxn+10];** **    bool Spfa(){** **        queue<int> que;** **        que.push(src);** **        cle(dist,INF);** **        dist[src]=0;** **        inQue[src]=true;** **        while(!que.empty()){** **            int u=que.front();** **            que.pop();** **            for(int i=g[u];i;i=e[i].nxt){** **                if(e[i].f&gt;0 &amp;&amp; dist[u]+e[i].w&lt;dist[e[i].v]){** **                    dist[e[i].v]=dist[u]+e[i].w;** **                    prev[e[i].v]=u;** **                    pree[e[i].v]=i;** **                    if(!inQue[e[i].v]){** **                        inQue[e[i].v]=true;** **                        que.push(e[i].v);** **                    }** **                }** **            }** **            inQue[u]=false;** **        }** **        if(dist[sink]&lt;INF) return true; else return false;** **    }** **    int augment(){** **        int u=sink;** **        int delta=INF;** **        while(u!=src){** **            if(e[pree[u]].f&lt;delta) delta=e[pree[u]].f;** **            u=prev[u];** **        }** **        u=sink;** **        while(u!=src){** **            e[pree[u]].f-=delta;** **            e[pree[u]^1].f+=delta;** **            u=prev[u];** **        }** **        return dist[sink]<em>delta;*</em> **    }** **    int mincostflow(){** **        int cur=0;//原板子有一个ans=0** **        while(Spfa()){** **            cur+=augment();** **     //     cout&lt;&lt;cur&lt;&lt;endl;** **          //原板子  if(cur&gt;ans) ans=cur;** **        }** **        return cur;** **    }** <strong>}mcmf;</strong> <strong>int main(){</strong> <strong>#ifndef ONLINE_JUDGE</strong> **    freopen(“in.txt”, “r”, stdin);** **    freopen(“out.txt”, “w”, stdout);** <strong>#endif</strong> **    int N,M;** **    while(~SII(N,M) &amp;&amp; N+M){** **        getchar();** **        mcmf.init();** **        max_num=home_sum=0;** **        rez(i,1,N){** **            gets(s);** **            rep(j,M){** **                if(s[j]==’m’){** **                    man[max_num].x=i;** **                    man[max_num++].y=j+1;** **                }else if(s[j]==’H’){** **                    home[home_sum].x=i;** **                    home[home_sum++].y=j+1;** **                }** **            }** **        }** **        mcmf.src=0;** **        mcmf.sink=2<em>max_num+1;*</em> **        rep(i,max_num){** **            mcmf.Addedge(0,i+1,1,0);** **            mcmf.Addedge(max_num+i+1,mcmf.sink,1,0);** **            rep(j,home_sum)** **                mcmf.Addedge(i+1,max_num+j+1,1,abs(man[i].x-home[j].x)+abs(man[i].y-home[j].y));** **        }** **    //    rep(i,mcmf.nume){** **    //        printf(“%d %d %d %d\\n”,mcmf.e[i].v,mcmf.e[i].f,mcmf.e[i].w,mcmf.e[i].nxt);** **     //   }** **        printf(“%d\\n”,mcmf.mincostflow());** **    }** **    return 0;** <strong>}</strong></int></p>\n</blockquote>\n","text":"【类型】 SPFA 最小费用最大流 【Tip】 注意一下边数会远大于顶点数,若边数开的太小则一定会TLE或RE.代码中有算这道题的最大边数和最大节点数. 【Code】#include  #include #include #include #include #include #i","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"最大流","slug":"POJ/最大流","count":2,"path":"api/categories/POJ/最大流.json"},{"name":"最小费用最大流","slug":"POJ/最大流/最小费用最大流","count":1,"path":"api/categories/POJ/最大流/最小费用最大流.json"}],"tags":[{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"最大流","slug":"最大流","count":2,"path":"api/tags/最大流.json"},{"name":"最小费用最大流","slug":"最小费用最大流","count":2,"path":"api/tags/最小费用最大流.json"}]}]}