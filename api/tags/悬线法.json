{"name":"悬线法","slug":"悬线法","count":3,"postlist":[{"title":"51nod 1158","slug":"51nod-1158","date":"2018-03-18T10:32:44.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1158.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type悬线法单调栈未学用悬线法做的\">Type:悬线法,单调栈(未学,用悬线法做的)</span></h1><h1><span id=\"提示\">提示</span></h1><blockquote>\n<p>蓝书P51，最大子矩阵 O(mn)</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn=510;\nint m,n;\nint mat[maxn][maxn],up[maxn][maxn],left[maxn][maxn],right[maxn][maxn];\n\nvoid print(){\n    printf(&quot;Up:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,up[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n    printf(&quot;Left:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,left[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n    printf(&quot;Right:\\n&quot;);\n    for(int i=1;i&lt;=m;++i){\n        for(int j=1;j&lt;=n;++j){\n            printf(&quot;%d &quot;,right[i][j]);\n        }\n        puts(&quot;&quot;);\n    }\n}\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)){\n        for(int i=1;i&lt;=m;++i){\n            for(int j=1;j&lt;=n;++j){\n                scanf(&quot;%d&quot;,&amp;mat[i][j]);\n            }\n        }\n        int ans=0;\n        for(int i=1;i&lt;=m;++i){\n            int lo=0,ro=n;\n            for(int j=1;j&lt;=n;++j){///从右往左扫描,维护up和left\n                if(!mat[i][j]){\n                    up[i][j]=left[i][j]=0;lo=j;\n                }else{\n                    up[i][j]=up[i-1][j]+1;\n                    left[i][j]=max(left[i-1][j],lo+1);\n                }\n            }\n            for(int j=n;j&gt;=1;--j){///维护right\n                if(!mat[i][j]){\n                    right[i][j]=n+1;ro=j-1;\n                }else{\n                    right[i][j]=i==1?ro:min(right[i-1][j],ro);\n                    ans=max(ans,up[i][j]*(right[i][j]-left[i][j]+1));\n                }\n            }\n        }\n        //print();\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type:悬线法,单调栈(未学,用悬线法做的)提示蓝书P51，最大子矩阵 O(mn)Code#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=510;int m,n;","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"悬线法","slug":"51nod/悬线法","count":1,"path":"api/categories/51nod/悬线法.json"}],"tags":[{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"}]},{"title":"LA 3029","slug":"la-3029","date":"2017-04-05T13:07:21.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3029.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>扫描线,悬线法</strong> <strong>【题解】</strong> <strong>蓝书P50</strong> <strong><a href=\"http://blog.csdn.net/qq415200973/article/details/11377199\" target=\"_blank\" rel=\"noopener\">扫描方程的解释</a></strong> <strong>我对代码的理解放在代码里了.</strong> <strong>如果为满：left[i][j]=0,right[i][j]=n,up[i][j]=0,这里是为了下一行的比较做准备。可以模拟试一试。</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>using namespace std;</strong> <strong>const int maxn=1000;</strong> <strong>int mat[maxn][maxn],up[maxn][maxn],left[maxn][maxn],right[maxn][maxn];</strong> <strong>int readchar(){</strong> <em>*    int a=getchar();** **    while(a!=’F’ &amp;&amp; a!=’R’) a=getchar();** **    return a;** <strong>}</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int m,n;** **        scanf(“%d%d”,&amp;m,&amp;n);** **        for(int i=0;i&lt;m;++i)** **            for(int j=0;j&lt;n;++j){** **                int ch=getchar();** **                while(ch!=’F’ &amp;&amp; ch!=’R’) ch=getchar();** **                mat[i][j]=ch==’F’?0:1;** **            }** **        int ans=0;** **        for(int i=0;i&lt;m;++i){//从上到下逐行处理** **            int lo=-1,ro=n;** **            for(int j=0;j&lt;n;++j)//从左向右处理** **                if(mat[i][j]==1){left[i][j]=up[i][j]=0;lo=j;}** **                else{** **                    up[i][j]=i==0?1:up[i-1][j]+1;** **                    //lo存的是左边界的下标,而不是到左边将诶有多少空地** **                    //这里,每次遇到障碍(1)时,lo就等于j(重新开始计算左边界)** **                    //然后,left[i][j]存的是当前矩阵的右边界** **                    //这里是lo+1,而不是lo++,所以lo的值在碰到障碍前一直不变** **                    //因为受到上一行的影响,所以需要在上一行和本行中选取一个最大** **                    //下标的左边界.** **                    left[i][j]=i==0?lo+1:max(left[i-1][j],lo+1);** **                }** **            for(int j=n-1;j&gt;=0;–j)//从右往左扫描,维护right并更新答案** **                if(mat[i][j]==1){right[i][j]=n;ro=j;}** **                //为啥等于n捏？？？** **                //为了使其下一行若是空格,作比较的时候,会发现上一行的下标一定是最大的** **                //从而不影响下一行右边界的计算** **                else{** **                    right[i][j]=i==0?ro-1:min(right[i-1][j],ro-1);** **                    ans=max(ans,up[i][j]</em>(right[i][j]-left[i][j]+1));** **                }** **        }** **        printf(“%d\\n”,ans<em>3);*</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 扫描线,悬线法 【题解】 蓝书P50 扫描方程的解释 我对代码的理解放在代码里了. 如果为满：left[i][j]=0,right[i][j]=n,up[i][j]=0,这里是为了下一行的比较做准备。可以模拟试一试。 【Code】#include #include us","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"悬线法","slug":"LA/思维/悬线法","count":1,"path":"api/categories/LA/思维/悬线法.json"}],"tags":[{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"}]},{"title":"第14届浙江省赛By Tusimple","slug":"14zojby-tusimple","date":"2017-04-22T11:57:29.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/14zojby-tusimple.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【网赛链接】</strong> <strong><a href=\"http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=364\" target=\"_blank\" rel=\"noopener\">第14届浙江省赛By Tusimple</a></strong> <strong>【A】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N,a1,T;</strong> <strong>int Kobayashi[4]={1,0,1,-1},Kscore;</strong> <strong>int Tohru[4]={0,1,1,-1},Tscore;</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        while(N–){** **            SI(T);** **            Kscore=0;** **            Tscore=0;** **            rep(i,T){** **                SI(a1);** **                Kscore+=Kobayashi[a1-1];** **                Tscore+=Tohru[a1-1];** **            }** **            if(Kscore&gt;Tscore)** **                puts(“Kobayashi”);** **            else if(Tscore&gt;Kscore)** **                puts(“Tohru”);** **            else** **                puts(“Draw”);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【B】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>const int maxn=20000+10;</strong> <strong>int T,N,fk,Orz,flag,cnt;</strong> <strong>int score[maxn],scomp[maxn];</strong> <strong>int main(){</strong> **    while(~SI(T)){** **        while(T–){** **            fill(score,score+4000,0);** **            Orz=flag=0;** **            SI(N);** **            if(N&gt;13 || N&lt;10){** **                rep(i,N){** **                    SI(fk);** **                }** **                puts(“No”);continue;** **            }** **            rep(i,N){** **                SI(fk);** **                if(fk&lt;=0){** **                    flag=1;** **                }else{** **                    score[fk]++;** **                }** **                scomp[i]=fk;** **            }** **            if(flag){** **                puts(“No”);** **            }else{** **                if(score[1]&lt;2){** **                    puts(“No”);** **                    continue;** **                }else{** **                    sort(scomp,scomp+N);** **                    rez(i,1,N-2){** **                        if(scomp[i]-scomp[i-1]&gt;2){** **                            puts(“No”);** **                            flag=1;** **                            break;** **                        }** **                    }** **                    if(!flag) puts(“Yes”);** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【C】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int T,n,q,c;</strong> <strong>map&lt;string,int&gt; mp;</strong> <strong>map&lt;string,int&gt;::iterator ite;</strong> <strong>map&lt;int,vector<string> &gt; res;</string></strong> <strong>string st;</strong> <strong>inline int readt(int N){</strong> **    int ans=0,tit;** **    rep(i,N){** **        SI(tit);** **        ans+=(1&lt;&lt;N-i-1) &amp; (tit&lt;&lt;N-i-1);** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        //测试数据可能出现重复的名字和情况,所以要初始化** **        mp.clear();** **        res.clear();** **        SII(n,q);** **        SI(c);** **        rep(i,c){** **            cin&gt;&gt;st;** **            mp[st]=0;** **        }** **        rep(i,q){** **            int nu;** **            SI(nu);** **            rep(j,nu){** **                cin&gt;&gt;st;** **                mp[st]+=(1&lt;&lt;q-i-1);** **            }** **        }** **        for(ite=mp.begin();ite!=mp.end();ite++){** **            res[ite-&gt;second].push_back(ite-&gt;first);** **        }** **        rep(i,n){** **            int index=readt(q);** **            if(res.find(index)==res.end()){** **                puts(“Let’s go to the library!!”);** **            }else{** **                vector<string>&amp; t=res[index];** **                if(t.size()&gt;1){** **                    puts(“Let’s go to the library!!”);** **                }else{** **                    cout&lt;&lt;t[0]&lt;&lt;”\\n”;** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></string></p>\n</blockquote>\n<p><strong>【D】</strong> <strong>因为样例用的是m=3…所以我就一直卡在z&gt;=3……然后比赛结束以后发现了…好亏啊</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct Star{</strong> **    int left,right;** **    bool operator&lt;(const Star MM) const{** **        return left&lt;MM.left;** **    }** <strong>}A[500],B[500];</strong> <strong>int n,m,x,y,T,s,e;</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        SII(n,m);SII(x,y);** **        rep(i,x){** **            SII(s,e);** **            A[i].left=s;** **            A[i].right=e;** **        }** **        rep(i,y){** **            SII(s,e);** **            B[i].left=s;** **            B[i].right=e;** **        }** **        sort(A,A+x);** **        sort(B,B+y);** **        int ans=0;** **        rep(i,x){** **            s=A[i].left;** **            e=A[i].right;** **            int z=0;** **            rep(j,y){** **                if(B[j].left&gt;A[i].right) break;** **                z+=(min(B[j].right,A[i].right)-max(A[i].left,B[j].left)+1);** **                    if(z&gt;=m){** **                        ans+=z-m+1;** **                        z=0;** **                    }else{** **                        z=0;** **                    }** **            }** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【网赛链接】 第14届浙江省赛By Tusimple 【A】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define ","link":"","raw":null,"photos":[],"categories":[{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/categories/ZOJ.json"},{"name":"位操作","slug":"ZOJ/位操作","count":1,"path":"api/categories/ZOJ/位操作.json"},{"name":"悬线法","slug":"ZOJ/位操作/悬线法","count":1,"path":"api/categories/ZOJ/位操作/悬线法.json"},{"name":"模拟","slug":"ZOJ/位操作/悬线法/模拟","count":1,"path":"api/categories/ZOJ/位操作/悬线法/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/tags/ZOJ.json"}]}]}