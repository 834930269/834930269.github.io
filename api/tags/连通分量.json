{"name":"连通分量","slug":"连通分量","count":2,"postlist":[{"title":"AOJ \tALDS1_11_D Connected Components","slug":"1464","date":"2017-11-19T13:15:58.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/1464.json","excerpt":"","keywords":null,"cover":null,"content":"<p>MathJax.Hub.Config({ tex2jax: { inlineMath: [[“$”,”$”], [“\\(“,”\\)“]], processEscapes: true }});</p>\n<h1><span id=\"connected-components\">Connected Components</span></h1><p>Write a program which reads relations in a SNS (Social Network Service), and judges that given pairs of users are reachable each other through the network.</p>\n<h2><span id=\"input\">Input</span></h2><p>In the first line, two integer $n$ and $m$ are given. $n$ is the number of users in the SNS and $m$ is the number of relations in the SNS. The users in the SNS are identified by IDs $0, 1, …, n-1$. In the following $m$ lines, the relations are given. Each relation is given by two integers $s$ and $t$ that represents $s$ and $t$ are friends (and reachable each other). In the next line, the number of queries $q$ is given. In the following $q$ lines, $q$ queries are given respectively. Each query consists of two integers $s$ and $t$ separated by a space character.</p>\n<h2><span id=\"output\">Output</span></h2><p>For each query, print “yes” if $t$ is reachable from $s$ through the social network, “no” otherwise.</p>\n<h2><span id=\"constraints\">Constraints</span></h2><ul>\n<li>$2 \\leq n \\leq 100,000$</li>\n<li>$0 \\leq m \\leq 100,000$</li>\n<li>$1 \\leq q \\leq 10,000$</li>\n</ul>\n<h2><span id=\"sample-input\">Sample Input</span></h2><p>10 9<br>0 1<br>0 2<br>3 4<br>5 7<br>5 6<br>6 7<br>6 8<br>7 8<br>8 9<br>3<br>0 1<br>5 9<br>1 3</p>\n<h2><span id=\"sample-output\">Sample Output</span></h2><p>yes<br>yes<br>no</p>\n<p>求连通分量,对每一个连通分量进行染色.不在同一个联通分量的肯定无法联系.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;stack&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int maxn=100000;\nconst int NIL=-1;\nint n;\nvector&lt;int&gt; G[maxn];\nint color[maxn];\n\nvoid dfs(int r,int c){\n    stack&lt;int&gt; S;\n    S.push(r);\n    color[r]=c;\n    while(!S.empty()){\n        int u=S.top();S.pop();\n        for(int i=0;i&lt;G[u].size();++i){\n            int v=G[u][i];\n            if(color[v]==NIL){\n                color[v]=c;\n                S.push(v);\n            }\n        }\n    }\n}\n\nvoid setColor(){\n    int id=1;\n    for(int i=0;i&lt;n;++i){\n        color[i]=NIL;\n    }\n    for(int u=0;u&lt;n;++u){\n        if(color[u]==NIL) dfs(u,id++);\n    }\n}\n\nint main(){\n    int s,t,m,q;\n\n    cin&gt;&gt;n&gt;&gt;m;\n\n    for(int i=0;i&lt;m;++i){\n        cin&gt;&gt;s&gt;&gt;t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n\n    setColor();\n\n    cin&gt;&gt;q;\n    for(int i=0;i&lt;q;++i){\n        cin&gt;&gt;s&gt;&gt;t;\n        if(color[s]==color[t]){\n            puts(&quot;yes&quot;);\n        }else{\n            puts(&quot;no&quot;);\n        }\n    }\n\n    return 0;\n}</code></pre>","text":"MathJax.Hub.Config({ tex2jax: { inlineMath: [[“$”,”$”], [“\\(“,”\\)“]], processEscapes: true }});Connected ComponentsWrite a program which rea","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"图论","slug":"AOJ/图论","count":1,"path":"api/categories/AOJ/图论.json"},{"name":"连通分量","slug":"AOJ/图论/连通分量","count":1,"path":"api/categories/AOJ/图论/连通分量.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"}]},{"title":"Tarjan 强连通分量算法","slug":"tarjan-scc-algorithm","date":"2018-01-17T10:03:54.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/tarjan-scc-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg","content":"<p>Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.</p>\n<h2><span id=\"学习契机-hdu-6038\">学习契机: </span></h2><p>首先介绍下:</p>\n<h2><span id=\"强连通分量\">强连通分量:</span></h2><p>画图以明志 -- <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/05/Tarjan.jpg\" alt></a> <code>Tarjan</code>算法的时间复杂度是线性的,而kos算法则需要计算图的转置.该算法由Tarjan于1972年提出,是SCC<code>(Strongly Connected Componenet,强连通分量)</code>的第一个线性算法,Tarjan算法借助于DFS,但它并不需要靠遍历顺序(Kos算法的思想)来分离SCC,而是允许SCC并存于同一颗DFS树中,然后通过某种手段将他们分开.</p>\n<h2><span id=\"dag\">DAG:</span></h2><p>如果把一个集合看成一个点,那么所有的SCC构成了一个SCC图.这个SCC图不会存在有向环,因此是一个DAG<code>(Directed Acyclic Graph,有向无环图)</code>. 那他喵的什么是DAG呢?我把上面的那个强连通分量图给DAG化: <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/DAG.jpg\" alt></a></p>\n<h2><span id=\"算法流程\">算法流程</span></h2><p>考虑强连通分量C,设其中第一个被发现的点为x,则C中其他点都是x的后代.我们希望在x dfs访问完成后立即输出C.这样,就可以在一棵DFS树中区分开所有SCC了.因此,问题的关键是如何发现每个SCC的第一个点.</p>\n<h3><span id=\"如何判断是否是scc顶点\">如何判断是否是SCC顶点</span></h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/Tj.jpg\" alt></a> 假设我们正在判断u是否为某SCC的第一个被发现节点.如果我们发现<code>从u的子节点出发可以达到u的祖先w,显然u就不是SCC的顶点.</code>反之,如果SCC最远的顶点可以到u,则u是SCC的顶点.图中虚线表示一条或多条边和点. 我们使用两个数组来记录每个节点的状态.pre[]和lowlink[]. 当递归回溯时如果这两个数组的值相同,则表明该节点为某SCC顶点.</p>\n<h2><span id=\"证明\">证明</span></h2><p>见: <a href=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" title=\"http://blog.csdn.net/keyboarderqq/article/details/71308102\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/keyboarderqq/article/details/71308102</a></p>\n<h2><span id=\"代码\">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=100000+10;\n\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\nstack&lt;int&gt; S;\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\nvoid dfs(int u){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            if(x==u)break;\n        }\n    }\n}\n\nvoid Tarjan(int n){\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i);\n    }\n}\n\nint main(){\n    //边数\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;++i){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        addAdge(u,v);\n    }\n\n    Tarjan(n);\n\n    printf(&quot;SCC个数: %d\\n&quot;,scc_cnt);\n\n    for(int i=0;i&lt;n;++i){\n        printf(&quot;点 %d 的 SCC 编号是: %d\\n&quot;,i,sccno[i]);\n    }\n    return 0;\n}\n/*\n6 6\n\n1 0\n0 4\n4 5\n5 1\n1 2\n2 3\n*/</code></pre><h1><span id=\"此致画个图你就知道low数组的具体作用了\">此致:画个图你就知道low数组的具体作用了.</span></h1>","text":"Lrj中还说了一种求强连通分量的算法: Kosaraju算法. 但Tarjan算法的常数比Kos小,所以作为常用算法,我们直接学习Tarjan算法即可.学习契机: 首先介绍下:强连通分量:画图以明志 --  [Figure]  假设我们正在判断u是否为某SCC的第一个被发现节点.","link":"","raw":null,"photos":[],"categories":[{"name":"Tarjan","slug":"Tarjan","count":1,"path":"api/categories/Tarjan.json"},{"name":"图论","slug":"Tarjan/图论","count":1,"path":"api/categories/Tarjan/图论.json"},{"name":"算法学习","slug":"Tarjan/图论/算法学习","count":1,"path":"api/categories/Tarjan/图论/算法学习.json"},{"name":"连通分量","slug":"Tarjan/图论/算法学习/连通分量","count":1,"path":"api/categories/Tarjan/图论/算法学习/连通分量.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"连通分量","slug":"连通分量","count":2,"path":"api/tags/连通分量.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"},{"name":"Tarjan","slug":"Tarjan","count":2,"path":"api/tags/Tarjan.json"}]}]}