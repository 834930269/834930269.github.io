{"name":"玲珑杯","slug":"玲珑杯","count":5,"postlist":[{"title":"玲珑杯 R7 C-Duplicate Numbers","slug":"linglong-r7-c-duplicate-numbers","date":"2016-12-24T12:41:59.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/linglong-r7-c-duplicate-numbers.json","excerpt":"","keywords":null,"cover":null,"content":"<p>problem:1073 用map维护.</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<set></set></p>\n<p>#include<map><br>using namespace std;<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int N;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        int M,flag=0;<br>        cin&gt;&gt;M;<br>        map&lt;int,int&gt; ma;<br>        for(int i=0;i&lt;M;++i){<br>            int n;<br>            cin&gt;&gt;n;<br>            ma[n]++;<br>            if(flag==0 &amp;&amp; ma[n]&gt;1) flag=1;<br>        }<br>        if(flag){<br>                map&lt;int,int&gt;::iterator it;<br>                for(it=ma.begin();it-&gt;second&lt;=1;it++){}<br>                    cout&lt;<it->first;<br>                    it++;<br>                for(;it!=ma.end();it++)<br>                    if(it-&gt;second&gt;1)<br>                        cout&lt;&lt;” “&lt;<it->first;<br>                cout&lt;&lt;endl;<br>        }else{<br>            cout&lt;&lt;”none”&lt;&lt;endl;<br>        }<br>    }</it-></it-></map></p>\n<pre><code>return 0;</code></pre><p>}</p>\n","text":"problem:1073 用map维护.#include#include#include#include<br>using namespace std;<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int N","link":"","raw":null,"photos":[],"categories":[{"name":"玲珑杯","slug":"玲珑杯","count":2,"path":"api/categories/玲珑杯.json"}],"tags":[{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"玲珑杯 R7 D-Pick Up Coin","slug":"linglong-r7-d-pick-up-coin","date":"2016-12-24T13:51:29.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/linglong-r7-d-pick-up-coin.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:</p>\n<p>dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }</p>\n<p>  【Code】(不会,代码搁置,回头看)</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int Q[1010];<br>int dp[1005][1005];<br>int main(){<br>    ios::sync_with_stdio(false);<br>    int n;<br>    cin&gt;&gt;n;<br>    while(n–){<br>        int M;<br>        cin&gt;&gt;M;<br>        for(int i=1;i&lt;=M;++i)<br>            cin&gt;&gt;Q[i];<br>        Q[0]=Q[M+1]=1;<br>        for(int i=0;i&lt;=M+1;++i)<br>            for(int j=0;j&lt;=M+1;++j)<br>                dp[i][j]=0;<br>        for(int len=1;len&lt;=M;++len)<br>                for(int i=1,j=i+len-1;j&lt;=M;++i,++j)<br>                    for(int k=i;k&lt;=j;++k)<br>                        dp[i][j]=max(dp[i][j],dp[i][k-1]+dp[k+1][j]+Q[k]*Q[i-1]*Q[j+1]);</algorithm></p>\n<pre><code>        cout&lt;&lt;dp\\[1\\]\\[M\\]&lt;&lt;endl;\n}\n\nreturn 0;</code></pre><p>}</p>\n","text":"【题解】 区间动态规划, dp[i,j]表示捡起 i~j 区间的硬币, 有:dp[i,j] = max{ dp[i+1,k-1] + dp[k+1, j-1] + value[i] x value[k] x value[j] }  【Code】(不会,代码搁置,回头看)#incl","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"玲珑杯 R8 E","slug":"llb-r8-e","date":"2017-01-14T16:11:16.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/llb-r8-e.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【Code】 签到题.</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;</cstring></p>\n<p>typedef long long LL;<br>LL sum[100010];<br>LL a[100010];<br>LL maxn[10000];<br>LL b[100010];<br>LL n,q,ca=1;</p>\n<p>void solve(){<br>    char str;<br>    getchar();<br>    for(int i=1;i&lt;=n;++i){<br>        str=’\\0’;<br>        LL res;<br>        while(str!=’ ‘ &amp;&amp; str!=’\\n’){<br>            scanf(“%c”,&amp;str);<br>            if((str==’ ‘ || str==’\\n’) &amp;&amp; !a[i]){ str=’\\0’;continue;}<br>            if((str==’ ‘ || str==’\\n’) &amp;&amp; a[i])break;<br>            sum[i]+=(str-‘0’);<br>            res=a[i]*10+str-‘0’;<br>            a[i]=res;<br>        }<br>        if(maxn[sum[i]]){<br>            b[i]=maxn[sum[i]];<br>            if(maxn[sum[i]]&lt;a[i])<br>                maxn[sum[i]]=a[i];<br>        }else{<br>            maxn[sum[i]]=a[i];<br>        }<br>    }<br>    while(q–){<br>        LL j;<br>        scanf(“%lld”,&amp;j);<br>        if(b[j]&gt;0 &amp;&amp; j&gt;0 &amp;&amp; j&lt;=n)<br>            printf(“%lld\\n”,b[j]);<br>        else<br>            printf(“-1\\n”);<br>    }<br>}</p>\n<p>int main(){<br>    LL T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        memset(maxn,0,sizeof(maxn));<br>        memset(b,0,sizeof(maxn));<br>        memset(a,0,sizeof(maxn));<br>        memset(sum,0,sizeof(maxn));<br>        printf(“Case #%d:\\n”,ca++);<br>        scanf(“%lld %lld”,&amp;n,&amp;q);<br>        solve();<br>    }<br>    return 0;<br>}</p>\n","text":"【Code】 签到题.#include#include#include#include<br>using namespace std;typedef long long LL;<br>LL sum[100010];<br>LL a[100010];<br>LL maxn[1000","link":"","raw":null,"photos":[],"categories":[{"name":"玲珑杯","slug":"玲珑杯","count":2,"path":"api/categories/玲珑杯.json"}],"tags":[{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"玲珑杯 Round#18 A","slug":"llb-round18-a","date":"2017-07-15T10:23:43.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/llb-round18-a.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1143\" target=\"_blank\" rel=\"noopener\">1143 - 计算几何你瞎暴力</a></strong> <strong>【题解】</strong> <strong>用vis统计每个点上有多少教室.可以发现,最大的距离是30.</strong> <strong>然后枚举所有的点求出两点之间的距离以及所有的组合总数.</strong> <strong>1.如果两点是同一个点.先判断该点是否存在房子.如果存在,就用等差数列求和公式: N-1+N-2+…+1=(1+N-1)*(N-1)/2  计算出组合种数记录在d[0].</strong> <strong>2.如果两点不同一点,判断两点教室数都不为0,然后计算组合种数: S*S2 计算组合种数记录在d[dist(S,S2)].</strong> <strong>3.由于计算的时候每个点都在点一和点二计算过一次.所以最终统计的时候之前统计得值需要除以二.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20A.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 A.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;</p>\n<p>#define cle(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f<br>using namespace std;</p>\n<p>const int maxn=50000+10;<br>int T,n,q,d[1420];<br>char str[200];<br>long long vis[20][20][20];<br>bool vi[1420];</p>\n<p>int main(){<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        cle(d),cle(vis),cle(vi);<br>        scanf(“%d%d”,&amp;n,&amp;q);<br>        for(int i=0;i&lt;n;++i){<br>            int x,y,z;<br>            scanf(“%d%d%d”,&amp;x,&amp;y,&amp;z);<br>            vis[x][y][z]++;<br>        }<br>        for(int i=0;i&lt;=10;i++)<br>        {<br>            for(int j=0;j&lt;=10;j++)<br>            {<br>                for(int k=0;k&lt;=10;k++)<br>                {<br>                    for(int x=0;x&lt;=10;x++)<br>                    {<br>                        for(int y=0;y&lt;=10;y++)<br>                        {<br>                            for(int z=0;z&lt;=10;z++) {<br>                                int dis=abs(i-x)+abs(j-y)+abs(k-z);<br>                                if(i==x&amp;&amp;j==y&amp;&amp;k==z) {<br>                                    if(vis[i][j][k]-1&gt;=0){<br>                                        d[dis]+=(vis[i][j][k])<em>(vis[i][j][k]-1)/2;<br>                                        vi[dis]=true;<br>                                    }<br>                                }<br>                                else if(vis[i][j][k]</em>vis[x][y][z]&gt;0)<br>                                {<br>                                    d[dis]+=vis[i][j][k]<em>vis[x][y][z];<br>                                    vi[dis]=true;<br>                                }<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        for(int i=1;i&lt;=30;++i)d[i]=d[i-1]+d[i]/2;<br>        for(int i=0;i&lt;q;++i){<br>            int R;<br>            scanf(“%d”,&amp;R);<br>            R=min(30,R);<br>            printf(“%lld\\n”,d[R]);<br>        }<br>    }<br>    return 0;<br>}*</em></p>\n","text":"【Topic Link】 1143 - 计算几何你瞎暴力 【题解】 用vis统计每个点上有多少教室.可以发现,最大的距离是30. 然后枚举所有的点求出两点之间的距离以及所有的组合总数. 1.如果两点是同一个点.先判断该点是否存在房子.如果存在,就用等差数列求和公式: N-1+N-","link":"","raw":null,"photos":[],"categories":[{"name":"枚举","slug":"枚举","count":1,"path":"api/categories/枚举.json"},{"name":"玲珑杯","slug":"枚举/玲珑杯","count":1,"path":"api/categories/枚举/玲珑杯.json"}],"tags":[{"name":"枚举","slug":"枚举","count":3,"path":"api/tags/枚举.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]},{"title":"玲珑杯 Round#18 C","slug":"round18-c","date":"2017-07-15T10:45:01.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/round18-c.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Topic Link】</strong> <strong><a href=\"http://www.ifrog.cc/acm/problem/1146\" target=\"_blank\" rel=\"noopener\">1146 - 图论你先敲完模板</a></strong> <strong>【题解】</strong> <strong>首先我们可以想到一个简单的dp方程</strong> <strong>dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a</strong> <strong>1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算.</strong> <strong>所以我们可以从i-1往回(1)递推,如果某一点距离差大于30.则直接退出循环即可.</strong> <strong>最终结果为dp[n].且结果需要用long long存.</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LingLong/Round%2318%20C.cpp\" target=\"_blank\" rel=\"noopener\">Round#18 C.cpp</a></strong></p>\n<hr>\n<p> **#include&lt;bits/stdc++.h&gt;</p>\n<p>#define fill(x) memset(x,0,sizeof(x))</p>\n<p>#define INF 0x3f3f3f3f</p>\n<p>#pragma comment(linker, “/STACK:102400000,102400000”)<br>using namespace std;<br>const int maxn=100000+10;<br>int n;<br>long long dp[maxn],a,dt[100000+10];<br>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%lld”,&amp;n,&amp;a);<br>        for(int i=1;i&lt;=n;++i){<br>            dp[i]=1000000000000000000;<br>            scanf(“%lld”,&amp;dt[i]);<br>            for(int j=i-1;j&gt;=1;–j){<br>                long long t;<br>                if(dt[i]-dt[j]&gt;30)break;<br>                if(dp[j]!=1000000000000000000) t=dp[j];<br>                else t=0;<br>                dp[i]=min(dp[i],t+(1&lt;&lt;(dt[i]-dt[j]))+a);<br>            }<br>        }<br>        printf(“%lld\\n”,dp[n]);<br>    }<br>    return 0;<br>}**</p>\n","text":"【Topic Link】 1146 - 图论你先敲完模板 【题解】 首先我们可以想到一个简单的dp方程 dp[i]=min(dp[j]+2^(dis[i]−dis[j]))+a 1.然后我们发现这个如果dis[i]−dis[j]&gt;30的时候,决策为从i到j分开走更划算. 所","link":"","raw":null,"photos":[],"categories":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/categories/动态规划.json"},{"name":"玲珑杯","slug":"动态规划/玲珑杯","count":2,"path":"api/categories/动态规划/玲珑杯.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"玲珑杯","slug":"玲珑杯","count":5,"path":"api/tags/玲珑杯.json"}]}]}