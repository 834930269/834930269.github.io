{"name":"概率论","slug":"概率论","count":4,"postlist":[{"title":"概率论","slug":"lazy","date":"2018-03-12T11:53:37.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/lazy.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>Gay绿论</p>\n</blockquote>\n<h1><span id=\"条件概率\">条件概率</span></h1><h1><span id=\"全概率\">全概率</span></h1>","text":"Gay绿论条件概率全概率","link":"","raw":null,"photos":[],"categories":[{"name":"概率论","slug":"概率论","count":1,"path":"api/categories/概率论.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"}]},{"title":"UVa 11021","slug":"uva-11021","date":"2018-03-13T01:56:34.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/uva-11021.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type-概率\">Type: 概率</span></h1><h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>有点难以理解题解的递推式,把那句f(i-1)表示i-1天后全部死亡改成f(i-1)表示i-1天后一个不生的概率可能更好理解一点吧 不知道怎么证明这个式子,思维还是不强</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1010;\n\ndouble f[maxn],P[maxn];;\nint n,k,m,T;\n\nint main(){\n    cin&gt;&gt;T;\n    for(int i=1;i&lt;=T;++i){\n        cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;\n        for(int j=0;j&lt;n;++j) cin&gt;&gt;P[j];\n        f[0]=0;f[1]=P[0];\n        for(int j=2;j&lt;=m;++j){\n            f[j]=0;\n            for(int t=0;t&lt;n;++t){\n                f[j]+=(P[t]*pow(f[j-1],t));\n            }\n        }\n        printf(&quot;Case #%d: %.7lf\\n&quot;,i,pow(f[m],k));\n    }\n    return 0;\n}</code></pre>","text":"Type: 概率题解有点难以理解题解的递推式,把那句f(i-1)表示i-1天后全部死亡改成f(i-1)表示i-1天后一个不生的概率可能更好理解一点吧 不知道怎么证明这个式子,思维还是不强Code#include&lt;bits/stdc++.h&gt;using namespac","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11181 + UVa 10491","slug":"uva-11181-uva-10491","date":"2017-01-15T15:14:56.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-11181-uva-10491.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 第一题:dfs 全概率 回溯 第二题:全概率 【Tip】 条件概率: P(A|B)=P(AB)|P(B).  P(A|B)指.在事件B的前提下,发生A的概率. P(AB)指两个时间A和B同时发生的概率.P(AB)=P(A)P(B). 全概率: P(A)=P(A|B1)_P(B1)+P(A|B2)_P(B2)+…+P(A|Bn)*P(Bn). 【Code】 11181:</p>\n<blockquote>\n<p><em>#include &lt;stdio.h&gt;</em> <em>#include &lt;string.h&gt;</em> <em>const int N = 30;</em> <em>int n;</em> <em>double p[N], ans[N];</em> <em>double dfs(int c, int k, double pi) {</em> _    if (c &gt; n) return k ? 0 : pi;_ _    double sum = 0;_ _       if (k) {_ _        sum += dfs(c + 1, k - 1, pi * p[c]);//选择_ _        ans[c] += sum;_ _    }_ _    sum += dfs(c + 1, k, pi * (1 - p[c])); //回溯_ _    return sum;_ <em>}</em> <em>int main () {</em> _    int r, cas = 1;_ _    while (scanf(“%d%d”, &amp;n, &amp;r), n + r) {_ _        for (int i = 1; i &lt;= n; i++)_ _            scanf(“%lf”, &amp;p[i]);_ _        memset(ans, 0, sizeof(ans));_ _        printf(“Case %d:\\n”, cas++);_ _        double P = dfs(1, r, 1);_ _        for (int i = 1; i &lt;= n; i++)_ _            printf(“%.6lf\\n”, ans[i] / P);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>10491：</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>using namespace std;</em> <em>int main(){</em> _    int a,b,c;_ _    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c){_ _        printf(“%.5lf\\n”,1.0<em>(a*b+b\\</em>(b-1))/((a+b-c-1)*(a+b)));_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n","text":"【类型】 第一题:dfs 全概率 回溯 第二题:全概率 【Tip】 条件概率: P(A|B)=P(AB)|P(B).  P(A|B)指.在事件B的前提下,发生A的概率. P(AB)指两个时间A和B同时发生的概率.P(AB)=P(A)P(B). 全概率: P(A)=P(A|B1)_","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1636","slug":"uva-1636","date":"2017-01-14T16:07:54.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/uva-1636.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 概率论 【思路】 水题一发. 紫书 P326.</p>\n<blockquote>\n<p>第一个</p>\n<blockquote>\n<p>A: 第二枪无子弹 B: 第一枪无子弹 第二种情况是随机转到0的概率是多大</p>\n<blockquote>\n<p>即 0的个数/n</p>\n</blockquote>\n<p>P(A|B)=P(AB) / P(B) = 00个数/0个数</p>\n</blockquote>\n</blockquote>\n<p>【Code】</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    char str[200];\n    while(scanf(&quot;%s&quot;,str)!=EOF){\n        int a=0,b=0;\n        int len=strlen(str);\n        for(int i=0;i&lt;len;++i){\n            if(str[i]==&apos;0&apos;){\n                b++;\n                if(str[(i+1)%len]==&apos;0&apos;) a++;\n            }\n        }\n        if(a*len==b*b) printf(&quot;EQUAL\\n&quot;);\n        if(a*len&gt;b*b) printf(&quot;SHOOT\\n&quot;);\n        if(a*len&lt;b*b) printf(&quot;ROTATE\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"【类型】 概率论 【思路】 水题一发. 紫书 P326.第一个A: 第二枪无子弹 B: 第一枪无子弹 第二种情况是随机转到0的概率是多大即 0的个数/nP(A|B)=P(AB) / P(B) = 00个数/0个数【Code】#include&lt;iostream&gt;#inc","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"概率论","slug":"UVa/概率论","count":3,"path":"api/categories/UVa/概率论.json"},{"name":"算法学习","slug":"UVa/概率论/算法学习","count":1,"path":"api/categories/UVa/概率论/算法学习.json"}],"tags":[{"name":"概率论","slug":"概率论","count":4,"path":"api/tags/概率论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}