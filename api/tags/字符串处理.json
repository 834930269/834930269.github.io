{"name":"字符串处理","slug":"字符串处理","count":7,"postlist":[{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） C KMP-Next数组","slug":"5-c-kmp","date":"2018-02-27T12:23:59.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/5-c-kmp.json","excerpt":"","keywords":null,"cover":null,"content":"<p>[toc]</p>\n<blockquote>\n<p>Next数组</p>\n</blockquote>\n<h1><span id=\"自己写的卡在9500的代码\">自己写的卡在%95.00的代码</span></h1><p>我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nmap&lt;int,int&gt; ex;\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=1;i&lt;=len;++i){\n        printf(&quot;%d &quot;,Next[i]);\n    }\n}\n\nvoid solve(){\n    ex.clear();\n    getNext();\n    //print();\n    int bef=Next[len],now,max_len=0;\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    while(bef!=0){\n        now=bef;\n        bef=Next[bef];\n    }\n\n    for(int i=1;i&lt;=len;++i){\n        if(Next[i] &amp;&amp; Next[i]%now==0){\n            int k=Next[i]/now;\n            for(int j=1;j&lt;=k;++j){\n                ex[j*now]++;\n            }\n        }\n    }\n    map&lt;int,int&gt;::iterator it;\n    for(it=ex.begin();it!=ex.end();it++){\n        if(it-&gt;second&gt;1) max_len=max(max_len,it-&gt;first);\n    }\n    if(max_len){\n        max_len=min(max_len,Next[len]);\n        for(int i=0;i&lt;max_len;++i){\n            printf(&quot;%c&quot;,str[i]);\n        }\n    }else printf(&quot;Just a legend&quot;);\n    printf(&quot;\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1><span id=\"ac代码\">AC代码</span></h1><blockquote>\n<p>AC代码</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1001000;\nint Next[maxn],len;\nchar str[maxn];\n\nint exist[maxn];\n\nvoid getNext(){\n    Next[0]=-1;\n    int k=-1;\n    int j=0;\n    while(j&lt;len){\n        if(k==-1 || str[j]==str[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid solve(){\n    memset(exist,0,sizeof(exist));\n    getNext();\n    int bef=Next[len];\n    if(bef==0){\n        printf(&quot;Just a legend\\n&quot;);\n        return;\n    }\n    //忽略第一个和最后一个\n    for(int i=2;i&lt;len;++i){\n        exist[Next[i]]++;\n    }\n\n    while(bef&gt;0){\n        if(exist[bef]){\n            for(int i=0;i&lt;bef;++i){\n                printf(&quot;%c&quot;,str[i]);\n            }\n            printf(&quot;\\n&quot;);\n            return;\n        }\n        bef=Next[bef];\n    }\n    printf(&quot;Just a legend\\n&quot;);\n}\n\nint main(){\n    while(cin&gt;&gt;str){\n        len=strlen(str);\n        solve();\n    }\n    return 0;\n}</code></pre><h1><span id=\"当然还有一种方法是比较特别的比较直观把每个可能子串kmp一下如果匹配成功了就直接输出就好了\">当然,还有一种方法是比较特别的(比较直观),把每个可能子串KMP一下,如果匹配成功了,就直接输出就好了</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nchar a[1000005],b[1000005];\nint next[1000006];\nvoid getnext(char *c)\n{\n    next[0]=next[1]=0;\n    int i,j,len=strlen(c);\n    for(i=1,j=0;i&lt;len;i++)\n    {\n        while(c[i]!=c[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(c[i]==c[j])j++;\n        next[i+1]=j;\n    }\n}\nint kmp(char *o,char *f)\n{\n    int cont=0;\n    int i,j,len1=strlen(o),len2=strlen(f);\n    for(i=0,j=0;i&lt;len1;i++)\n    {\n        while(o[i]!=f[j]&amp;&amp;j!=0)\n            j=next[j];\n        if(o[i]==f[j])j++;\n        if(j==len2)\n        {\n            cont++;\n            j=next[j];\n        }\n    }\n    return cont;\n}\nint main()\n{\n    int i;\n    scanf(&quot;%s&quot;,a);\n    getnext(a);\n    int len=next[strlen(a)];\n    if(len==0)\n    {\n        printf(&quot;Just a legend\\n&quot;);\n        return 0;\n    }\n    for(i=0;i&lt;len;i++)\n        b[i]=a[i];\n    b[i]=&apos;\\0&apos;;\n    int cont=kmp(a,b);\n    while(cont&lt;3)\n    {\n        len=next[len];\n        if(len==0)break;\n        for(i=0;i&lt;len;i++)\n            b[i]=a[i];\n        b[i]=&apos;\\0&apos;;\n        cont=kmp(a,b);\n    }\n    if(cont&gt;=3&amp;&amp;len)printf(&quot;%s\\n&quot;,b);\n    else printf(&quot;Just a legend\\n&quot;);\n    return 0;\n}</code></pre><p>1<br>=</p>\n<p>2<br>=</p>\n","text":"[toc]Next数组自己写的卡在%95.00的代码我自己写的代码,至今想不通漏了什么情况,被卡在%95.00…#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1001000;int Next[max","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"字符串处理","slug":"KMP/字符串处理","count":1,"path":"api/categories/KMP/字符串处理.json"},{"name":"牛客练习赛","slug":"KMP/字符串处理/牛客练习赛","count":1,"path":"api/categories/KMP/字符串处理/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"}]},{"title":"HDU 2222","slug":"hdu-2222","date":"2018-03-10T13:20:19.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/hdu-2222.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type-ac自动机\">Type: AC自动机</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你几个子串,再给你一个主串,问你有多少个子串在主串中出现过.</p>\n</blockquote>\n<h1><span id=\"输入\">输入</span></h1><blockquote>\n<p>T,N,接下来N行输入N个字符串,最后一行输入一个主串.</p>\n</blockquote>\n<h1><span id=\"输出\">输出</span></h1><blockquote>\n<p>一个整数,有多少子串可以在主串中被匹配到</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>注意,每个子串可能是相同的,所以我们不能在尾节点记录子串的下标,而应该记录子串的个数.最后加进去即可</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    int ch[maxn][sigma_size];\n    int f[maxn],last[maxn];\n    int cnt[maxn],val[maxn];\n    int siz;\n\n    int ans;\n\n    void init(){\n        siz=ans=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///表示以第u棵节点为字符串最后一个字符节点的个数\n       ///如果想存储该节点代表的是哪个字符串.即存储该字符串的下标\n       ///val[u]=v;(v是下标)\n       ///但是这样存储就会出现无法统计之前有多少个重复字符串\n       ///比如这道题如果输入\n       ///3\n       ///sha\n       ///sha\n       ///sha\n       ///shashasha\n       ///则用第一种方法最后结果是3\n       ///但用第二种方法只能匹配一次sha\n       val[u]++;\n    }\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        if(u){\n            if(!cnt[u]) ans+=val[u],cnt[u]=1;\n            add(last[u]);\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i]);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre>","text":"Type: AC自动机题意给你几个子串,再给你一个主串,问你有多少个子串在主串中出现过.输入T,N,接下来N行输入N个字符串,最后一行输入一个主串.输出一个整数,有多少子串可以在主串中被匹配到题解注意,每个子串可能是相同的,所以我们不能在尾节点记录子串的下标,而应该记录子串的个数","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"HDU","slug":"AC自动机/HDU","count":2,"path":"api/categories/AC自动机/HDU.json"},{"name":"字符串处理","slug":"AC自动机/HDU/字符串处理","count":2,"path":"api/categories/AC自动机/HDU/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]},{"title":"HDU 5880","slug":"hdu-5880","date":"2018-03-11T03:46:16.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/hdu-5880.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type-ac自动机\">Type: AC自动机</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你N个子串,一个主串,让你过滤掉在主串中出现过的子串.被过滤掉的用*表示</p>\n<blockquote>\n<p>每个子串是由小写字母组成</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>AC自动机,一开始被两个样例卡住了</p>\n<blockquote>\n<p>1- 子串： abcd bc 主串: abcef 匹配不到 bc 2- 子串: a ab abc abcd 主串: aabcd 匹配不到 abcd</p>\n<blockquote>\n<p>第一种情况是因为当你遍历到abcd这条路径的c节点时,如果因为下一个是f就判断为失配并且不继续向下走,则就无法再匹配到bc.</p>\n<blockquote>\n<p>解决方法,在每次判断到失配的时候,新开一个函数从开始失配的节点 这里是 c ,从这个节点开始找他的失陪路径,知道找到 第一个尾节点 或 根节点 就停止,目标串即为最长被匹配串,不需要再去匹配他的子串了.</p>\n</blockquote>\n<p>第二种情况是因为一开始写代码每次循环时直接将u查找到了根节点,所以如果一个子串前面是另一个串的子串,那么将永远无法匹配到另一个子串.</p>\n<blockquote>\n<p>解决方法,不改动u,借助临时变量来更改u达到查找子串的目的.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            if(!isalpha(s[i])){\n                u=0;\n                continue;\n            }\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            /*\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                p=f[p];\n            }\n            */\n            add(u,i);\n        }\n    }\n\n    void print(){\n        for(int i=0;i&lt;tot_len;++i){\n            if(cle[i]) putchar(&apos;*&apos;);\n            else putchar(str[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str,i+1);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(str);\n        tot_len=strlen(str);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(str);\n        aho.print();\n    }\n    return 0;\n}</code></pre>","text":"Type: AC自动机题意给你N个子串,一个主串,让你过滤掉在主串中出现过的子串.被过滤掉的用*表示每个子串是由小写字母组成题解AC自动机,一开始被两个样例卡住了1- 子串： abcd bc 主串: abcef 匹配不到 bc 2- 子串: a ab abc abcd 主串: a","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"HDU","slug":"AC自动机/HDU","count":2,"path":"api/categories/AC自动机/HDU.json"},{"name":"字符串处理","slug":"AC自动机/HDU/字符串处理","count":2,"path":"api/categories/AC自动机/HDU/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]},{"title":"LA 4670","slug":"la-4670","date":"2018-03-11T06:59:12.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/la-4670.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"typeac自动机\">Type:AC自动机</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你一堆子串和一个主串</p>\n<blockquote>\n<p>问你在主串中出现次数最多的子串有哪些,最后结果按字典序排列</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=11000;\nconst int maxm=152;\nconst int maxt=1e6+6;\n\nint T,N,tot_len;\nchar str[maxm][80],tot[maxt];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cnt[maxn],val[maxn];\n    bool vis[maxn][sigma_size];\n\n    int siz,root,max_time;\n\n    vector&lt;string&gt; ans;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        for(int i=0;i&lt;sigma_size;++i){\n            vis[siz][i]=false;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        ans.clear();\n        for(int i=0;i&lt;maxn;++i) val[i]=cnt[i]=0;\n        siz=0;root=0;max_time=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                if(!vis[p][c]){\n                    cnt[val[p]]++;\n                    max_time=max(cnt[val[p]],max_time);\n                    p=f[p];\n                    vis[p][c]=true;\n                }\n            }\n        }\n    }\n\n    void print(){\n        printf(&quot;%d\\n&quot;,max_time);\n        for(int i=1;i&lt;=N;++i){\n            if(cnt[i]==max_time){\n                ans.push_back(str[i]);\n            }\n        }\n        sort(ans.begin(),ans.end());\n        for(int i=0;i&lt;ans.size();++i){\n            cout&lt;&lt;ans[i]&lt;&lt;endl;\n        }\n    }\n}aho;\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        aho.init();\n        for(int i=1;i&lt;=N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(tot);\n        tot_len=strlen(tot);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(tot);\n        aho.print();\n    }\n    return 0;\n}</code></pre>","text":"Type:AC自动机题意给你一堆子串和一个主串问你在主串中出现次数最多的子串有哪些,最后结果按字典序排列Code#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=11000;const int maxm","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"LA","slug":"AC自动机/LA","count":1,"path":"api/categories/AC自动机/LA.json"},{"name":"字符串处理","slug":"AC自动机/LA/字符串处理","count":1,"path":"api/categories/AC自动机/LA/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"POJ 1961","slug":"poj-1961","date":"2018-02-25T05:26:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-1961.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVALive-3026\" title=\"https://vjudge.net/problem/UVALive-3026\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-3026</a></p>\n<h1><span id=\"type-kmp-next数组\">Type: KMP-Next数组</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><h2><span id=\"前置\">前置</span></h2><h3><span id=\"关于next数组\">关于Next数组</span></h3><blockquote>\n<p>(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符进行再次匹配. (2) j=Next[k]表示第 j 个字符和第 k 个字符一样. (3) j=Next[k]表示前 j 个字符和后 j 个字符一样</p>\n<blockquote>\n<p>即 1<del>j-1 和 k-j+1</del>k 这两个子串相等</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"正文\">正文</span></h2><blockquote>\n<p>即我们求出该字符串的Next数组后我们可以判断当前 (i-Next[i]) 是否能被 i 整除.</p>\n<blockquote>\n<p>即 i%(i-Next[i]) 是否等于0.</p>\n<blockquote>\n<p>i-Next[i]为该子串的长度,如果可以整除则证明该子串为循环节,循环节长度为 i-Next[i] ,循环次数为 i/(i-Next[i]).</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nchar ts[maxn];\nint n,kase=1;\nint Next[maxn];\nvoid getNext(){\n    int j=0,k=-1;\n    Next[0]=-1;\n    while(j&lt;n){\n        if(k==-1 || ts[j]==ts[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\nvoid print(){\n    for(int i=1;i&lt;=n;++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(!n)break;\n        scanf(&quot;%s&quot;,ts);\n        getNext();\n        //print();\n        printf(&quot;Test case #%d\\n&quot;,kase++);\n        for(int i=2;i&lt;=n;++i){\n            if(Next[i]&lt;=0) continue;\n            if(i%(i-Next[i])==0){\n                printf(&quot;%d %d\\n&quot;,i,i/(i-Next[i]));\n            }\n        }\n        printf(&quot;\\n&quot;);\n        getchar();\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVALive-3026Type: KMP-Next数组题意给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度题解前置关于Next数组(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"LA","slug":"KMP/LA","count":1,"path":"api/categories/KMP/LA.json"},{"name":"POJ","slug":"KMP/LA/POJ","count":1,"path":"api/categories/KMP/LA/POJ.json"},{"name":"字符串处理","slug":"KMP/LA/POJ/字符串处理","count":1,"path":"api/categories/KMP/LA/POJ/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"POJ 3094","slug":"poj-3094","date":"2017-04-03T07:28:10.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/poj-3094.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Tip】</strong> <strong>字符串处理问题</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define fill(x) memset(x,0,sizeof(x))</strong> <strong>using namespace std;</strong> <strong>const int maxn=400;</strong> <strong>int mp[255],sum;</strong> <strong>char str[maxn];</strong> <strong>inline void init(){</strong> <strong>fill(mp);</strong> **    for(int i=0;i&lt;=26;++i)** <strong>mp[i+’A’]=i+1;</strong> <strong>}</strong> <strong>int main(){</strong> **    init();** **    for(;;){** **        scanf(“\\n%[^\\n]“,str);** <strong>sum=0;</strong> **        if(str[0]==’#’) break;** **        for(int i=1;str[i-1]!=’\\0’;++i)** <strong>sum+=mp[str[i-1]]*i;</strong> <strong>printf(“%d\\n”,sum);</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【Tip】 字符串处理问题 【Code】#include&lt;bits/stdc++.h&gt; #define fill(x) memset(x,0,sizeof(x)) using namespace std; const int maxn=400; int mp[255]","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"字符串处理","slug":"POJ/字符串处理","count":1,"path":"api/categories/POJ/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"字符串算法","slug":"charset-algorithm","date":"2018-02-24T10:32:39.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/charset-algorithm.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png","content":"<h1><span id=\"trie\">Trie</span></h1><blockquote>\n<p>这个…不想写了</p>\n</blockquote>\n<h1><span id=\"kmp\">KMP</span></h1><blockquote>\n<p>朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)</p>\n</blockquote>\n<h2><span id=\"next数组\">Next数组</span></h2><blockquote>\n<p>对于KMP而言最重要的莫过于这个Next数组了.</p>\n<blockquote>\n<p>Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.</p>\n</blockquote>\n<p>构造方法:</p>\n<blockquote>\n<p>Next[i]=max{j | j\\&lt;i 且N[1..j]=N[i-j+1..i]}</p>\n<blockquote>\n<p>即Next[i]球的试串P[1..i]的一个最长的前缀P[1..j],这个前缀同时也是他的后缀。当这个前缀找不到的时候,Next[i]=0</p>\n</blockquote>\n</blockquote>\n<p>例如:</p>\n<blockquote>\n<p>模式串 P = ababc</p>\n<blockquote>\n<p>则Next[4]=2,因为ab不仅是abab的前缀,也是他的后缀. 而Next[5]=0，因为无法找到ababc(P[1..5])的一个前缀同时又是他的后缀.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3><span id=\"附上一张图\">附上一张图</span></h3><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/02/bVDOro.png\" alt></a></p>\n<h2><span id=\"匹配时逻辑\">匹配时逻辑</span></h2><blockquote>\n<p>KMP 在匹配时同时维护两个下标 i 和 j ,表示当前模式串 P 的前 j 个字符与主串 T 在位置 i 前的 j 个字符匹配,即 P[1..j]=T[i-j..i-1]。 当算法尝试对 T[i] 和 P[j+1] 匹配中遇到不相同的字符,就会通过Next数组进行跳跃。</p>\n</blockquote>\n<h2><span id=\"算法实现\">算法实现</span></h2><h3><span id=\"next数组\">Next数组</span></h3><h4><span id=\"代码\">代码</span></h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(cin&gt;&gt;T){\n        getNext();\n        print();\n    }\n    return 0;\n}</code></pre><h4><span id=\"几组数据\">几组数据</span></h4><pre><code>ababc\nNext: -1 0 0 1 2\n\nabcdef\nNext: -1 0 0 0 0 0\n\nabcdabce\nNext: -1 0 0 0 0 1 2 3\n\nabcabcabc\nNext: -1 0 0 0 1 2 3 4 5\n\nabcdabcabcd\nNext: -1 0 0 0 0 1 2 3 1 2 3</code></pre><h3><span id=\"kmp-返回第一个匹配的下标\">KMP - 返回第一个匹配的下标</span></h3><h4><span id=\"主程\">主程</span></h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000+7;\nint Next[maxn];\nstring S,T;//S主串,T子串\n\nvoid getNext(){\n    int k=-1,len=T.length();\n    int j=0;\n    Next[0]=-1;\n    while(j&lt;len){\n        //如果有相同前缀\n        if(k==-1 || T[j]==T[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\n\nvoid print(){\n    for(int i=0;i&lt;T.length();++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint KMP_index(){\n    int i=0,j=0,slen=S.length(),tlen=T.length();\n    getNext();\n    while(i&lt;slen &amp;&amp; j&lt;tlen){\n        if(j==-1 || S[i]==T[j]){\n            i++;\n            j++;\n        }else j=Next[j];\n    }\n    if(j==tlen) return i-tlen;\n    else return -1;\n}\n\nint main(){\n    while(cin&gt;&gt;S&gt;&gt;T){\n        int ans=KMP_index();\n        if(ans==-1) cout&lt;&lt;&quot;Failed!&quot;&lt;&lt;endl;\n        else cout&lt;&lt;&quot;Succesed!String T was matched in index &quot;&lt;&lt;ans&lt;&lt;&quot;.&quot;&lt;&lt;endl;\n        print();\n    }\n    return 0;\n}</code></pre><h4><span id=\"两组数据\">两组数据</span></h4><pre><code>IN[0]: jashdjashdjabababcabcsdas\nIN[1]: abcabc\nOUT[0]: Succesed!String T was matched in index 15.\nOUT[1]: -1 0 0 0 1 2\nIN[2]: jashdjashdjabababcabcsdas\nIN[3]: abcabcd\nOUT[2]: Failed!\nOUT[3]: -1 0 0 0 1 2 3</code></pre><h1><span id=\"ac-corasick-自动机\">AC-Corasick 自动机</span></h1><blockquote>\n<p>思想是KMP+Trie,在Trie上建立失配指针.</p>\n<blockquote>\n<p>常用于主串匹配多个字符串</p>\n</blockquote>\n</blockquote>\n<h2><span id=\"尾节点记录字符串下标的ac自动机\">尾节点记录字符串下标的AC自动机</span></h2><blockquote>\n<p>优点是可以直接输出字符串.</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2><span id=\"尾节点记录可重复子串在总串中出现次数\">尾节点记录可重复子串在总串中出现次数</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    int ch[maxn][sigma_size];\n    int f[maxn],last[maxn];\n    int cnt[maxn],val[maxn];\n    int siz;\n\n    int ans;\n\n    void init(){\n        siz=ans=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///表示以第u棵节点为字符串最后一个字符节点的个数\n       ///如果想存储该节点代表的是哪个字符串.即存储该字符串的下标\n       ///val[u]=v;(v是下标)\n       ///但是这样存储就会出现无法统计之前有多少个重复字符串\n       ///比如这道题如果输入\n       ///3\n       ///sha\n       ///sha\n       ///sha\n       ///shashasha\n       ///则用第一种方法最后结果是3\n       ///但用第二种方法只能匹配一次sha\n       val[u]++;\n    }\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) continue;\n                Q.push(u);\n                int v=f[k];\n                while(v &amp;&amp; !ch[v][c]) v=f[v];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        if(u){\n            if(!cnt[u]) ans+=val[u],cnt[u]=1;\n            add(last[u]);\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i]);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2><span id=\"失配函数优化\">失配函数优化</span></h2><blockquote>\n<p>接下来都基于第一个代码进行优化,可以复刻到第二个代码上</p>\n<blockquote>\n<p>即将失配记录转变成 一条确定的边连到Trie中(这样应该就不能被称之为树了)</p>\n</blockquote>\n<p>if(!u) continue; =&gt;</p>\n<blockquote>\n<p>if(!u) {ch[k][c]=ch[f[k]][c];continue;} 删掉适配函数BFS中的 while()</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[10010][60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组\n    int f[maxn],last[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数\n    int siz;\n\n    int all_su;///记录总共有多少不可重复子串\n\n    void init(){\n        siz=all_su=0;\n        memset(ch,0,sizeof(ch));\n        memset(val,0,sizeof(val));\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s,int v){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=++siz;\n            u=ch[u][c];\n       }\n       ///尾节点记录字符串在str数组的下标\n       val[u]=v;\n    }\n\n    //Fail树\n    void getFail(){\n        queue&lt;int&gt; Q;\n        f[0]=0;\n        ///遍历取出第一个节点所有的前向字符\n        for(int c=0;c&lt;sigma_size;++c){\n            int u=ch[0][c];\n            if(u){\n                f[u]=last[u]=0;\n                Q.push(u);\n            }\n        }\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                int u=ch[k][c];\n                if(!u) {ch[k][c]=ch[f[k]][c];continue;}\n                Q.push(u);\n                int v=f[k];\n                f[u]=ch[v][c];\n                last[u]=val[f[u]]?f[u]:last[f[u]];\n            }\n        }\n    }\n\n    ///统计\n    void add(int u){\n        for(;u;u=last[u]){\n            if(!cnt[val[u]]) all_su++;\n            printf(&quot;\\n%s\\n&quot;,str[val[u]-1]);\n            cnt[val[u]]++;\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        memset(cnt,0,sizeof(cnt));\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            if(val[u]) add(u);\n            else if(last[u]) add(last[u]);\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i+1);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.all_su);\n    }\n    return 0;\n}</code></pre><h2><span id=\"mle和tle优化内存优化\">MLE和TLE优化–内存优化</span></h2><blockquote>\n<p>听说之前网络赛的时候就有道AC自动机的题,然后普通的模板总是MLE. 少了一半的时间,一半的内存</p>\n<blockquote>\n<p>意在每次不全初始化,每多一个节点初始化一次</p>\n</blockquote>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=(int)500005;\nconst int max_tot=(int)1e6+6;\n\nint T,N;\nchar str[60],tot[max_tot];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n    static const char first_caractar=&apos;a&apos;;\n    ///Trie树\n    int ch[maxn][sigma_size];\n    ///后缀相关数组fail,last\n    int f[maxn];\n    ///个数信息,尾节点记录信息\n    int cnt[maxn],val[maxn];\n    ///总节点个数,根节点编号\n    int siz,root;\n\n    int ans;\n\n    int newNode(){\n        memset(ch[siz],0,sizeof(ch[siz]));\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        ans=0;siz=0;root=newNode();\n    }\n\n    int ord(char c){\n        return c-first_caractar;\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    //Fail树,build\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    ///多模式匹配\n    void Find(char *s){\n        int u=0,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n        }\n        aho.getFail();\n        scanf(&quot;%s&quot;,tot);\n        aho.Find(tot);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h2><span id=\"但是以上自动机识别形如aababcabcd这类子串会出问题在刷题时发现的下面重新用新的方法来解决这个问题建议用下面的ac自动机\">但是以上自动机识别形如a,ab,abc,abcd这类子串会出问题,在刷题时发现的,下面重新用新的方法来解决这个问题,建议用下面的AC自动机</span></h2><h3><span id=\"hdu-2222上面的那些题修改\">HDU 2222，上面的那些题,修改</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root,ans;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n        ans=0;\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]++;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            int p=u;\n            while(p &amp;&amp; val[p]){\n                ans+=val[p];\n                val[p]=0;\n                p=f[p];\n            }\n        }\n    }\n\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        gets(str);\n        tot_len=strlen(str);\n        aho.Find(str);\n        printf(&quot;%d\\n&quot;,aho.ans);\n    }\n    return 0;\n}</code></pre><h3><span id=\"hdu-5880青岛区域赛网赛\">HDU 5880,青岛区域赛网赛</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=1000000+6;\n\nint T,N,tot_len;\nchar str[maxn],len[maxn];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cle[maxn],val[maxn];\n\n    int siz,root;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        for(int i=0;i&lt;maxn;++i) val[i]=0;\n\n        siz=0;root=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void add(int u,int i){\n        while(u){\n            if(val[u]){\n                int t=len[val[u]];\n                for(int r=0;r&lt;t;++r){\n                    cle[i-r]=1;\n                }\n                return;\n            }\n            u=f[u];\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;tot_len;++i) cle[i]=0;\n        for(int i=0;i&lt;n;++i){\n            if(!isalpha(s[i])){\n                u=0;\n                continue;\n            }\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n            /*\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                p=f[p];\n            }\n            */\n            add(u,i);\n        }\n    }\n\n    void print(){\n        for(int i=0;i&lt;tot_len;++i){\n            if(cle[i]) putchar(&apos;*&apos;);\n            else putchar(str[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n}aho;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        aho.init();\n        scanf(&quot;%d&quot;,&amp;N);\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%s&quot;,str);\n            aho.insert(str,i+1);\n            len[i+1]=strlen(str);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(str);\n        tot_len=strlen(str);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(str);\n        aho.print();\n    }\n    return 0;\n}</code></pre><h1><span id=\"后缀数组\">后缀数组</span></h1><h1><span id=\"后缀自动机\">后缀自动机</span></h1>","text":"Trie这个…不想写了KMP朴素的对比字符串算法复杂度是O(mn)的.这样一来对两串比较长的字符串就显得略微低效了. KMP算法的时间复杂度也不过O(m+n)Next数组对于KMP而言最重要的莫过于这个Next数组了.Next数组最大的作用在于当匹配失败时,需要跳转到哪个下标.构","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"KMP","slug":"AC自动机/KMP","count":1,"path":"api/categories/AC自动机/KMP.json"},{"name":"字符串处理","slug":"AC自动机/KMP/字符串处理","count":1,"path":"api/categories/AC自动机/KMP/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"}]}]}