{"name":"线段树","slug":"线段树","count":4,"postlist":[{"title":"2017多校训练2 HDU 6047 Maximum Sequence","slug":"2017-hdu-6047-maximum-sequence","date":"2017-07-29T04:51:07.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6047-maximum-sequence.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6047\" title=\"Maximum Sequence\" target=\"_blank\" rel=\"noopener\">Maximum Sequence</a> 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,记录每个i到maxindex(A)的最大值,然后动态更新. github: 1.线段树法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003_Range_Tree.cpp\" title=\"1003_Range_Tree.cpp\" target=\"_blank\" rel=\"noopener\">1003_Range_Tree.cpp</a> 2.暴力动态更新法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003.cpp\" title=\"1003.cpp\" target=\"_blank\" rel=\"noopener\">1003.cpp</a></p>\n<pre><code>///线段树法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst int maxnode=2000050;\n\nint b[maxnode],N;\nint maxv[maxnode];\n\nvoid build(int o,int l,int r){\n    if(l==r){\n        if(l&gt;N) return;///预先分配2*N个结点\n        scanf(&quot;%d&quot;,&amp;maxv[o]);maxv[o]-=l;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(o&lt;&lt;1,l,mid);\n    build(o&lt;&lt;1|1,mid+1,r);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint query(int o,int l,int r,int ll,int rr){\n    if(l&gt;=ll&amp;&amp;r&lt;=rr) return maxv[o];\n    int ma=-1,mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=ll) ma=max(ma,query(o&lt;&lt;1,l,mid,ll,rr));\n    if(rr&gt;mid) ma=max(ma,query(o&lt;&lt;1|1,mid+1,r,ll,rr));\n    return ma;\n}\n\nvoid update(int o,int l,int r,int p,int val){\n    if(l==r){\n        maxv[o]=val;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    if(p&lt;=mid)update(o&lt;&lt;1,l,mid,p,val);\n    else update(o&lt;&lt;1|1,mid+1,r,p,val);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        build(1,1,2*N);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        LL ans=0;\n        for(int i=N+1;i&lt;=2*N;++i){\n            int k=query(1,1,2*N,b[i-N],i-1);\n            update(1,1,2*N,i,k-i);\n            ans=(ans+k)%mod;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n\n///HDU 6047 暴力动态更新法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=500000+50;\nconst int mod=1e9+7;\nint N;\nint a[maxn],b[maxn],maxa[maxn];\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=1;i&lt;=N;++i){\n            int aa;\n            scanf(&quot;%d&quot;,&amp;aa);\n            a[i]=aa-i;\n        }\n        maxa[N]=a[N];\n        for(int i=N-1;i&gt;=1;--i) maxa[i]=max(maxa[i+1],a[i]);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        long long ans=0;\n        ans=(ans+maxa[b[1]])%mod;\n        int t=maxa[b[1]]-N-1;\n        for(int i=2;i&lt;=N;++i){\n            maxa[b[i]]=max(maxa[b[i]],t);\n            ans=(ans+maxa[b[i]])%mod;\n            t=max(t,maxa[b[i]]-N-1);\n        }\n        printf(&quot;%lld\\n&quot;,ans%mod);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: :point_right:Maximum Sequence 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"segmentTree","slug":"2017多校/segmentTree","count":1,"path":"api/categories/2017多校/segmentTree.json"},{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"path":"api/categories/2017多校/segmentTree/思维.json"},{"name":"线段树","slug":"2017多校/segmentTree/思维/线段树","count":1,"path":"api/categories/2017多校/segmentTree/思维/线段树.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"第五届山东省ACM","slug":"five-shandong-acm","date":"2018-04-18T05:52:29.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/five-shandong-acm.json","excerpt":"","keywords":null,"cover":null,"content":"<p>D<br>=</p>\n<h2><span id=\"类型-线段树-区间更新\">类型: 线段树 区间更新</span></h2><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxn=100000*4;\ntypedef long long LL;\nint N,Q,T;\n\nLL lazy[maxn];\nLL sum[maxn];\nbool flag[maxn];\n\nvoid init(){\n    memset(lazy,0,sizeof(lazy));\n    memset(sum,0,sizeof(sum));\n    memset(flag,false,sizeof(flag));\n}\n\nvoid PushDown(int p,int m){\n    if(flag[p]){\n        lazy[p&lt;&lt;1]=lazy[p&lt;&lt;1|1]=0;\n        sum[p&lt;&lt;1]=sum[p&lt;&lt;1|1]=sum[p]=0;\n        flag[p&lt;&lt;1]=flag[p&lt;&lt;1|1]=true;\n        flag[p]=false;\n    }\n    if(lazy[p]){\n        lazy[p&lt;&lt;1]+=lazy[p];\n        lazy[p&lt;&lt;1|1]+=lazy[p];\n        sum[p&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[p];\n        sum[p&lt;&lt;1|1]+=(m&gt;&gt;1)*lazy[p];\n        lazy[p]=0;\n    }\n}\n\nvoid update(int p,int l,int r,int c,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]+=c;\n        sum[p]+=(LL)(r-l+1)*c;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) update(p&lt;&lt;1,l,mid,c,L,R);\n    if(R&gt;mid) update(p&lt;&lt;1|1,mid+1,r,c,L,R);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nLL Query(int p,int l,int r,int L,int R){\n    if(L&lt;=l &amp;&amp; r&lt;=R)\n        return sum[p];\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    LL ret=0;\n    if(L&lt;=mid) ret+=Query(p&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid) ret+=Query(p&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\n\nvoid setf(int p,int l,int r,int L,int R,int c){\n\n    if(L&lt;=l &amp;&amp; r&lt;=R){\n        lazy[p]=0;\n        sum[p]=0;\n        flag[p]=true;\n        return;\n    }\n    PushDown(p,r-l+1);\n    int mid=(l+r)&gt;&gt;1;\n    if(L&lt;=mid) setf(p&lt;&lt;1,l,mid,L,R,c);\n    if(R&gt;mid) setf(p&lt;&lt;1|1,mid+1,r,L,R,c);\n    sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];\n}\n\nint main(){\n    cin&gt;&gt;T;\n    while(T--){\n        init();\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n        int t,l,r,last=0;\n        LL ans=0;\n        for(int i=1;i&lt;=Q;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;t,&amp;l,&amp;r);\n            ///先更新全部区间的值\n            update(1,1,N,t-last,1,N);\n            ///然后查询所需区间内的和\n            ans+=Query(1,1,N,l,r);\n            ///最后将所需区间内的值置为0\n            setf(1,1,N,l,r,0);\n            last=t;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"D<br>=类型: 线段树 区间更新#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const in","link":"","raw":null,"photos":[],"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"线段树","slug":"数据结构/线段树","count":1,"path":"api/categories/数据结构/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"POJ 2991","slug":"poj-2991","date":"2017-08-05T14:44:10.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/poj-2991.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树 题目连接: :earth_asia:<a href=\"http://poj.org/problem?id=2991\" title=\"Crane\" target=\"_blank\" rel=\"noopener\">POJ-Crane</a> 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子区间的向量+右子区间的向量。 求一个向量（x0,y0）逆时针旋转B度后的向量有一个公式： x1= x0 * cosB - y0 * sinB y1 = x0 * sinB + y0 * cosB 顺时针就把-B代入： x1= x0 * cosB + y0 * sinB y1 = -x0 * sinB + y0 * cosB github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-2991.CPP\" title=\"POJ 2991.cpp\" target=\"_blank\" rel=\"noopener\">POJ 2991.cpp</a> Code:</p>\n<pre><code>#define _USE_MATH_DEFINES///使用math库中的定义\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;math.h&gt;\nusing namespace std;\n\nconst int ST_SIZE=(1&lt;&lt;15)-1;\nconst int MAX_N=10010;\nconst int MAX_C=10010;\n\nint N,C;\nint L[MAX_N];\nint S[MAX_C],A[MAX_N];\n\ndouble vx[ST_SIZE],vy[ST_SIZE]; ///各节点的向量\ndouble ang[ST_SIZE]; ///各节点的角度\n\ndouble prv[MAX_N];\n\n///初始化线段树\nvoid init(int k,int l,int r){\n    ang[k]=vx[k]=0.0;\n    if(r-l==1){\n        ///叶子结点\n        vy[k]=L[l];\n    }else{\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        init(chl,l,(l+r)&gt;&gt;1);\n        init(chr,(l+r)&gt;&gt;1,r);\n        vy[k]=vy[chl]+vy[chr];\n    }\n}\n\n///把s和s+1的角度变为a\n///v是节点编号,l,r表示当前结点对应的是[l,r]区间\nvoid update(int s,double a,int k,int l,int r){\n    if(s&lt;=l) return;\n    else if(s&lt;r){\n        int chl=(k&lt;&lt;1)+1,chr=(k&lt;&lt;1)+2;\n        int m=(l+r)&gt;&gt;1;\n        update(s,a,chl,l,m);\n        update(s,a,chr,m,r);\n        if(s&lt;=m) ang[k]+=a;\n\n        double s=sin(ang[k]),c=cos(ang[k]);\n        vx[k]=vx[chl]+(c*vx[chr]-s*vy[chr]);\n        vy[k]=vy[chl]+(s*vx[chr]+c*vy[chr]);\n    }\n}\n\nvoid solve(){\n    init(0,0,N);\n    for(int i=0;i&lt;C;++i){\n        int s=S[i];\n        double a=A[i]/360.0*2*M_PI;///把角度换算成弧度\n        update(s,a-prv[s],0,0,N);\n        prv[s]=a;\n\n        printf(&quot;%.2f %.2f\\n&quot;,vx[0],vy[0]);\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;C)==2){\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;L[i]);\n            prv[i]=M_PI;///180°的弧度值\n        }\n        for(int i=0;i&lt;C;++i)\n            scanf(&quot;%d%d&quot;,&amp;S[i],&amp;A[i]);\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树 题目连接: :earth_asia:POJ-Crane 题意: 有一个为N节的机械手，每次可以让某个关节点旋转到某一角度，问旋转操作结束之后最末端节点的坐标。 题解: 线段树区间更新。 结点值保存该区间的向量及旋转角（注意他给出的不是旋转角）一个区间的向量值=左子","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3468","slug":"poj-3468","date":"2017-08-07T11:10:00.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/poj-3468.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:<a href=\"https://vjudge.net/problem/POJ-3468\" title=\"POJ-3468\" target=\"_blank\" rel=\"noopener\">POJ-3468</a> 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问a<del>b这段数的和，‘C a b c’是把a</del>b这段数都加上c。 题解: 区间问题,首先想到线段树,这里我们建两个线段树.data,datb. data用来维护区间所更新的值. datb则用来维护区间的和. 计算的时候只需要 每部分的区间和 + 每部分更新的值 即为最终答案.(百度说这叫Lazy思想.) github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/blob/master/poj/%E7%BA%BF%E6%AE%B5%E6%A0%91/poj-3468.cpp\" title=\"POJ-3468.cpp\" target=\"_blank\" rel=\"noopener\">POJ-3468.cpp</a> Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n///区间更新\ntypedef long long ll;\n\nconst int DAT_SIZE=(1&lt;&lt;18)-1;\nconst int MAX_N=100000+10;\nconst int MAX_Q=100000+10;\n\nint N,Q;\nint A[MAX_N];\nchar T[MAX_Q];\nint L[MAX_Q],R[MAX_Q],X[MAX_Q];\n\n///线段树,a维护区间应加值,b维护区间和\nll data[DAT_SIZE],datb[DAT_SIZE];\n\n///对区间[a,b]同时加x\n///k是节点编号,对应的区间是[l,r)\nvoid add(int a,int b,int x,int k,int l,int r){\n    if(a&lt;=l&amp;&amp;r&lt;=b){\n        data[k]+=x;\n    }else if(l&lt;b &amp;&amp; a&lt;r){\n        datb[k]+=(min(b,r)-max(a,l))*x;\n        add(a,b,x,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        add(a,b,x,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n    }\n}\n\n///计算[a,b)的和\nll sum(int a,int b,int k,int l,int r){\n    if(b&lt;=l || a&gt;=r){\n        return 0;\n    }else if(a&lt;=l &amp;&amp; r&lt;=b){\n        return data[k]*(r-l)+datb[k];\n    }else{\n        ll res=(min(b,r)-max(a,l))*data[k];\n        res+=sum(a,b,(k&lt;&lt;1)+1,l,(l+r)&gt;&gt;1);\n        res+=sum(a,b,(k&lt;&lt;1)+2,(l+r)&gt;&gt;1,r);\n        return res;\n    }\n}\n\n///下标0开头的线段树初始化\n///开区间[a,b)\nvoid solve(){\n    for(int i=0;i&lt;N;++i){\n        add(i,i+1,A[i],0,0,N);\n//        printf(&quot;\\nadd: %d -&gt; %d\\n&quot;,i,A[i]);\n    }\n    for(int i=0;i&lt;Q;++i){\n        if(T[i]==&apos;C&apos;){\n            add(L[i],R[i]+1,X[i],0,0,N);\n        }else{\n            printf(&quot;%lld\\n&quot;,sum(L[i],R[i]+1,0,0,N));\n        }\n    }\n}\n\nint main(){\n    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;Q)==2){\n        memset(data,0,sizeof(data));\n        memset(datb,0,sizeof(datb));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;A[i]);\n        }\n        ///区间是[0...N)所以要减一\n        for(int i=0;i&lt;Q;++i){\n            scanf(&quot;%*c%c&quot;,&amp;T[i]);\n            if(T[i]==&apos;C&apos;){\n                scanf(&quot;%d%d%d&quot;,&amp;L[i],&amp;R[i],&amp;X[i]);\n                L[i]-=1;R[i]-=1;\n            }else{\n                scanf(&quot;%d%d&quot;,&amp;L[i],&amp;R[i]);\n                L[i]-=1;R[i]-=1;\n            }\n        }\n        solve();\n    }\n    return 0;\n}</code></pre>","text":"类型: 线段树区间更新. 题目连接: POJ炸了,用virtual judge的链接 :earth_africa:POJ-3468 题意: 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问ab这段数的和，‘C a b c’是把ab这段数都加上c。 题解: 区间问题,首先想","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"线段树","slug":"POJ/线段树","count":2,"path":"api/categories/POJ/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]}]}