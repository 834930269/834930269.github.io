{"name":"树状数组","slug":"树状数组","count":3,"postlist":[{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） A 逆序数","slug":"2018-5-a","date":"2018-02-25T10:40:31.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/2018-5-a.json","excerpt":"","keywords":null,"cover":null,"content":"<p>链接：<a href=\"https://www.nowcoder.com/acm/contest/77/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/acm/contest/77/A</a> 来源：牛客网</p>\n<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。比如一个序列为4 5 1 3 2， 那么这个序列的逆序数为7，逆序对分别为(4, 1), (4, 3), (4, 2), (5, 1), (5, 3), (5, 2),(3, 2)。</p>\n<h1 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述:\"></a>输入描述:</h1><p>第一行有一个整数n(1 &lt;= n &lt;= 100000), 然后第二行跟着n个整数，对于第i个数a[i]，(0 &lt;= a[i] &lt;= 100000)。</p>\n<h1 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述:\"></a>输出描述:</h1><p>输出这个序列中的逆序数</p>\n<h1 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h1><h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><p>5 4 5 1 3 2</p>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p>7</p>\n<h1 id=\"两种方法求逆序数\"><a href=\"#两种方法求逆序数\" class=\"headerlink\" title=\"两种方法求逆序数\"></a>两种方法求逆序数</h1><h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100010;\n\nint seq[maxn],N;\nint temp[maxn];\nLL cnt;\n//归并排序求逆序数\nvoid merge_sort(int arr[],int l,int r){\n    if(l==r)return;\n    int mid=((l+r)&gt;&gt;1);\n    merge_sort(arr,l,mid);\n    merge_sort(arr,mid+1,r);\n    int i=l,j=mid+1;\n    for(int k=l;k&lt;=r;++k){\n        if(j&gt;r || (i&lt;=mid &amp;&amp; arr[i]&lt;arr[j]))temp[k]=arr[i++];\n        else temp[k]=arr[j++],cnt+=mid-i+1;\n        //如果a[i]&gt;a[j]则逆序数加上mid+1-i,即剩下的前面个数\n    }\n    for(i=l;i&lt;=r;++i)arr[i]=temp[i];\n}\n\nint main(){\n    cin&gt;&gt;N;\n    for(int i=0;i&lt;N;++i){\n        cin&gt;&gt;seq[i];\n    }\n    cnt=0;\n    merge_sort(seq,0,N-1);\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n}</code></pre><h2 id=\"树状数组\"><a href=\"#树状数组\" class=\"headerlink\" title=\"树状数组\"></a>树状数组</h2>","text":"链接：https://www.nowcoder.com/acm/contest/77/A 来源：牛客网题目描述在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。比如一个序列为4 5 1 3","link":"","raw":null,"photos":[],"categories":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/categories/树状数组.json"},{"name":"牛客练习赛","slug":"树状数组/牛客练习赛","count":2,"path":"api/categories/树状数组/牛客练习赛.json"},{"name":"逆序数","slug":"树状数组/牛客练习赛/逆序数","count":1,"path":"api/categories/树状数组/牛客练习赛/逆序数.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"逆序数","slug":"逆序数","count":2,"path":"api/tags/逆序数.json"}]},{"title":"2018年全国多校算法寒假训练营练习比赛（第五场） H,F,B","slug":"2018-5-h","date":"2018-02-25T10:46:49.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/2018-5-h.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>H,和B是树状数组.F是水题,其实前两个也算水(模板)了.</p>\n<blockquote>\n<p>需要提的是,H用的是树状数组的区间更新和区间查询.</p>\n</blockquote>\n</blockquote>\n<p>H<br>=</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define lowbit(i) (i &amp; (-i))\n\nusing namespace std;\ntypedef long long LL;\nconst int Nmax = 100100;\nint N,Q;\nLL delta[Nmax];//delta的前缀和\nLL deltai[Nmax];//delta*i的前缀和\nLL sum[Nmax];//原始前缀和\n\nLL query(LL *arr,int pos){\n    LL temp=0ll;\n    while(pos&gt;0){\n        temp+=arr[pos];\n        pos-=lowbit(pos);\n    }\n    return temp;\n}\n\nvoid update(LL *arr,int pos,int x){\n    while(pos&lt;=N){\n        arr[pos]+=x;\n        pos+=lowbit(pos);\n    }\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);\n    LL nw;\n    char opt;\n    for(int i=1;i&lt;=N;++i){\n        scanf(&quot;%lld&quot;,&amp;nw);\n        sum[i]=sum[i-1]+nw;\n    }\n    while(Q--){\n        getchar();\n        scanf(&quot;%c&quot;,&amp;opt);\n        if(opt==&apos;C&apos;){\n            int l,r,x;\n            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x);\n            update(delta, l, x);\n            update(delta, r+1, -x);\n            update(deltai, l, x * l);\n            update(deltai, r+1, -x * (r+1));\n        }else{\n            int l,r;\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            LL suml = sum[l - 1] + l * query(delta, l - 1) - query(deltai, l - 1);\n            LL sumr = sum[r] + (r + 1) * query(delta, r) - query(deltai, r);\n            printf(&quot;%lld\\n&quot;, sumr - suml);\n        }\n    }\n    return 0;\n}</code></pre><p>B<br>=</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define lowbit(i) (i&amp;(-i))\nusing namespace std;\ntypedef long long LL;\nconst int maxn=100100;\nLL Tree[maxn];\n\nvoid add(int x,int value){\n    for(int i=x;i&lt;=maxn;i+=lowbit(i)){\n        Tree[i]+=value;\n    }\n}\n\nLL get(int x){\n    LL sum=0ll;\n    for(int i=x;i;i-=lowbit(i)){\n        sum+=Tree[i];\n    }\n    return sum;\n}\n\nint main(){\n    int n,m;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;++i){\n        LL q;\n        scanf(&quot;%lld&quot;,&amp;q);\n        add(i,q);\n    }\n    for(int i=0;i&lt;m;++i){\n        int ck;\n        scanf(&quot;%d&quot;,&amp;ck);\n        if(ck==1){\n            int x,k;\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;k);\n            add(x,k);\n        }else{\n            int l,r;\n            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n            printf(&quot;%lld\\n&quot;,get(r)-get(l-1));\n        }\n    }\n    return 0;\n}</code></pre><p>F<br>=</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint n;\nint main(){\n    while(cin&gt;&gt;n){\n        while(n/10){\n            int nn=0;\n            while(n&gt;0){\n                nn+=(n%10);\n                n/=10;\n            }\n            n=nn;\n        }\n        cout&lt;&lt;n&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"H,和B是树状数组.F是水题,其实前两个也算水(模板)了.需要提的是,H用的是树状数组的区间更新和区间查询.H<br>=#include&lt;bits/stdc++.h&gt;#define lowbit(i) (i &amp; (-i))using namespace std","link":"","raw":null,"photos":[],"categories":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/categories/树状数组.json"},{"name":"牛客练习赛","slug":"树状数组/牛客练习赛","count":2,"path":"api/categories/树状数组/牛客练习赛.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"}]},{"title":"LA 4329","slug":"la-4329","date":"2017-06-21T04:08:50.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-4329.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-4329\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-4329</a></strong> <strong>【thought】</strong> <strong>考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的.</strong> <strong>那么1 ~ (i-1)中有  (i-sm[i]-1)  个比A[i]能力大的,(i+1) ~ N 中有  (N-i-sl[i])  个比A[i]能力大的.</strong> <strong>根据乘法原理 对于第i个人做裁判有 sl[i]<em>(i-sm[i]-1)+sm[i]</em>(N-i-sl[i]) 中比赛可能,因为每个人做裁判,所以最后结果为每个人做裁判的情况和.</strong> <strong>考虑 T=1_19998+2_19997+3_19996+…+19998_1 爆int,故用long long 存.</strong> <strong>【Type】</strong> <strong>树状数组,lowbit()</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong> <strong>【溢出int测试】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329test.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong></p>\n","text":"【Link】 https://vjudge.net/problem/UVALive-4329 【thought】 考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的. 那么1 ~ (i-1)中有 ","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"树状数组","slug":"LA/树状数组","count":1,"path":"api/categories/LA/树状数组.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]}]}