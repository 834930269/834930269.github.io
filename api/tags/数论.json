{"name":"数论","slug":"数论","count":28,"postlist":[{"title":"2018全国多校算法寒假练习赛(三) A","slug":"2018qgs-a","date":"2018-02-08T10:09:44.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/2018qgs-a.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/02/1169018-20180203122824531-2079198459.png","content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://www.nowcoder.net/acm/contest/75/A\" title=\"https://www.nowcoder.net/acm/contest/75/A\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/75/A</a></p>\n<h1 id=\"Type-数论-Stirling公式\"><a href=\"#Type-数论-Stirling公式\" class=\"headerlink\" title=\"Type: 数论-Stirling公式\"></a>Type: 数论-Stirling公式</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个n,问你n!的八进制位数是多少.</p>\n</blockquote>\n<h1 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h1><blockquote>\n<p>有t(1<del>1000000)组数据 每组数据大小为 0</del>1000000</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>由以上数据范围我们知道不能乱搞(暴力或者打表都会爆)了. 这里提第一个点:</p>\n<blockquote>\n<p>求数M的K进制位数,答案就是</p>\n<blockquote>\n<p>logK(M)+1</p>\n</blockquote>\n</blockquote>\n<p>第二点:</p>\n<blockquote>\n<p>n! 近似公式 - Stirling公式 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/02/1169018-20180203122824531-2079198459.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/02/1169018-20180203122824531-2079198459.png\" alt></a></p>\n</blockquote>\n<p>结合这两点不难得出下列公式:</p>\n<blockquote>\n<p>log8(n!) = M =log8(sqrt(2*pi*n))+log8((n/e)^n) =log8(sqrt(2*pi*n))+log8((n/e)^n) =log8(sqrt(2*pi*n))+n*log8(n/e) =ln(sqrt(2*pi*n))/ln(8)+n*ln(n/e)/ln(8)</p>\n</blockquote>\n<p>常数时间就可以求出来了.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n//M_PI,M_E\nint main(){\n    int t,n;\n    cin&gt;&gt;t;\n    for(int i=0;i&lt;t;++i){\n        scanf(&quot;%d&quot;,&amp;n);\n        if(n==0){\n            printf(&quot;1\\n&quot;);\n            continue;\n        }\n        double ans=log(sqrt(2*M_PI*n))/log(8)+n*log(n/M_E)/log(8);\n        printf(&quot;%d\\n&quot;,(int)ans+1);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://www.nowcoder.net/acm/contest/75/AType: 数论-Stirling公式题意给你一个n,问你n!的八进制位数是多少.数据范围有t(11000000)组数据 每组数据大小为 01000000题解由以上数据范围我们知道不能乱搞(","link":"","raw":null,"photos":[],"categories":[{"name":"Stirling公式","slug":"Stirling公式","count":1,"path":"api/categories/Stirling公式.json"},{"name":"数论","slug":"Stirling公式/数论","count":1,"path":"api/categories/Stirling公式/数论.json"},{"name":"牛客练习赛","slug":"Stirling公式/数论/牛客练习赛","count":1,"path":"api/categories/Stirling公式/数论/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"Stirling公式","slug":"Stirling公式","count":1,"path":"api/tags/Stirling公式.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"}]},{"title":"2018全国多校算法寒假练习赛(三) G","slug":"2018qs-g","date":"2018-02-08T08:58:44.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/2018qs-g.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://www.nowcoder.net/acm/contest/75/G\" title=\"https://www.nowcoder.net/acm/contest/75/G\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/75/G</a></p>\n<h1 id=\"type-容斥定理-1-n整数倍定理\"><a href=\"#type-容斥定理-1-n整数倍定理\" class=\"headerlink\" title=\"type: 容斥定理,1~n整数倍定理\"></a>type: 容斥定理,1~n整数倍定理</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个n(1<del>1e18 long long 范围内),问你1</del>n中不为2,5,1,,13倍数的数有多少个.</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>1.我忘了一个定理:</p>\n<blockquote>\n<p>设求: 1~n之间有多少个数是给定的x的倍数?</p>\n<blockquote>\n<p>答案为 n/x</p>\n</blockquote>\n</blockquote>\n<p>有了以上那个定理就好求了,设条件 A 为1<del>n中2的倍数,B 为1</del>n中5的倍数,C,D. 则答案就是:</p>\n<blockquote>\n<p>|(<del>A)∩(</del>B)∩(<del>C)∩(</del>D)|</p>\n</blockquote>\n<p>标准容斥,情况只有2^4-1=15种,写代码吧</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n\nvoid solve(LL N){\n    LL ans=N;\n    LL k[4]={2,5,11,13};\n    for(int seq=1;seq&lt;16;++seq){\n        LL reg=1;\n        int d=0;\n        if(seq&amp;1) reg*=k[0],d++;\n        if(seq&amp;2) reg*=k[1],d++;\n        if(seq&amp;4) reg*=k[2],d++;\n        if(seq&amp;8) reg*=k[3],d++;\n        if(d&amp;1) ans-=(N/reg);\n        else ans+=(N/reg);\n    }\n    printf(&quot;%lld\\n&quot;,ans);\n}\n\nint main(){\n    LL n;\n    while(cin&gt;&gt;n){\n        solve(n);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://www.nowcoder.net/acm/contest/75/Gtype: 容斥定理,1~n整数倍定理题意给你一个n(11e18 long long 范围内),问你1n中不为2,5,1,,13倍数的数有多少个.题解1.我忘了一个定理:设求: 1~n之间有","link":"","raw":null,"photos":[],"categories":[{"name":"容斥原理","slug":"容斥原理","count":1,"path":"api/categories/容斥原理.json"},{"name":"数论","slug":"容斥原理/数论","count":1,"path":"api/categories/容斥原理/数论.json"},{"name":"牛客练习赛","slug":"容斥原理/数论/牛客练习赛","count":1,"path":"api/categories/容斥原理/数论/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"}]},{"title":"51nod 1040 最大公约数之和","slug":"51nod-1040-max-gcd-sum","date":"2018-03-04T14:51:10.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1040-max-gcd-sum.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-欧拉函数-gcd性质-思维\"><a href=\"#Type-欧拉函数-gcd性质-思维\" class=\"headerlink\" title=\"Type:欧拉函数,gcd性质,思维\"></a>Type:欧拉函数,gcd性质,思维</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15</p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>1个数N(N &lt;= 10^9)</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>公约数之和</p>\n<h2 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h2><p>6</p>\n<h2 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h2><p>15</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><blockquote>\n<p>N&lt;=10^9,所以肯定无法暴力枚举 考虑我们要求 lambda(gcd(i,N) | i∈[1,N])</p>\n<blockquote>\n<p>我们可以知道: 对于每个数N,他的约数范围在[1<del>N]之间,即我们可以将问题转化为(设约数为Ni,1</del>N中约数为Ni个数为Mi):</p>\n<blockquote>\n<p>lambda(Ni*Mi)</p>\n</blockquote>\n<p>假设我们已经得到了Ni,问题就在于我们如何求出Mi 设i为1~N中任意数:</p>\n<blockquote>\n<p>(1) Mi=count(gcd(i,N)=Ni | i∈[1<del>N]) =count(gcd(i/Ni,N/Ni)=1 | i∈[1</del>N])</p>\n<blockquote>\n<p>即我们只需要求出1~N中与N/Ni互素的数的个数即可</p>\n<blockquote>\n<p>即 euler(N/Ni)</p>\n</blockquote>\n</blockquote>\n<p>(2) Mi=euler(N/Ni)</p>\n</blockquote>\n<p>ans=lambda(Ni*euler(N/Ni))</p>\n</blockquote>\n<p>然后有一个小性质,即 i*i&lt;=N时,我们枚举到sqrt(i)同时求出 N/i ,枚举完所有的 i 即枚举完所有 1~N 内 N 的约数.</p>\n</blockquote>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nLL N;\n\nLL euler(LL n){\n    LL res=n,a=n;\n    for(LL i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            res=res/i*(i-1);\n            while(a%i==0)a/=i;\n        }\n    }\n    if(a&gt;1)res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        LL ans=0;\n        for(LL i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                ans+=(i*euler(N/i));\n                if(i*i!=N){\n                    ans+=((N/i)*euler(i));\n                }\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type:欧拉函数,gcd性质,思维题目给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15Input1个数N(N &lt;= 10^9)Output公约数之和Input示例","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"思维","slug":"51nod/思维","count":1,"path":"api/categories/51nod/思维.json"},{"name":"数论","slug":"51nod/思维/数论","count":1,"path":"api/categories/51nod/思维/数论.json"},{"name":"欧拉函数","slug":"51nod/思维/数论/欧拉函数","count":1,"path":"api/categories/51nod/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"51nod 1120 机器人走方格 V3","slug":"51nod-1120-rm-v3","date":"2018-03-07T12:59:38.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1120-rm-v3.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png","content":"<h1 id=\"Type-Lucas-Catalan序列-逆元\"><a href=\"#Type-Lucas-Catalan序列-逆元\" class=\"headerlink\" title=\"Type:Lucas+Catalan序列+逆元\"></a>Type:Lucas+Catalan序列+逆元</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>输入一个数N(2 &lt;= N &lt;= 10^9)。</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出走法的数量 Mod 10007。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>4</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>10</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>画图会发现就是一个Catalan序列, 但我一开始没理解题意,原来只是不能跨过斜线,但可以在斜线上走…</p>\n<blockquote>\n<p>在Excel中画了一下,因为两边是对称的,所以我们只需要求一边,将最终的答案*2即可.</p>\n</blockquote>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/03/QQ%E6%88%AA%E5%9B%BE20180307205702.png\" alt></p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=10007;\n\nLL Pow(LL a,LL b,LL p){\n    LL ans=1;\n    while(b){\n        if(b&amp;1)\n        {\n            b--;\n            ans=(ans*a)%p;\n        }\n        b&gt;&gt;=1;\n        a=(a*a)%p;\n    }\n    return ans;\n}\n\nLL Comb(LL a,LL b,LL p)\n{\n    if(a &lt; b) return 0;\n    if(a == b) return 1;\n    if(b &gt; a-b) b = a-b;\n    LL ans = 1, ca = 1, cb = 1;\n    for(LL i=0; i&lt;b; ++i)\n    {\n        ca = (ca*(a-i))%p;\n        cb = (cb*(b-i))%p;\n    }\n    ans = (ca*Pow(cb, p-2,p))%p;\n    return ans;\n}\nLL Lucas(LL n, LL m, LL p)\n{\n    LL ans = 1;\n    while(n &amp;&amp; m &amp;&amp; ans)\n    {\n        ans = (ans * Comb(n%p, m%p, p))%p;\n        n /= p;\n        m /= p;\n    }\n    ///如果等于0则返回1\n    return ans==0?1:ans;\n}\n\nvoid extgcd(LL a,LL b,LL&amp; d,LL&amp; x,LL&amp; y){\n    if(!b){ d=a; x=1; y=0;}\n    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }\n}\nLL inv(LL a,LL n){\n    LL d,x,y;\n    extgcd(a,n,d,x,y);\n    return d==1?(x+n)%n:-1;\n}\n\nint main(){\n    LL N;\n    while(cin&gt;&gt;N){\n        N=N-1;\n        LL d1,d2;\n        LL x=Lucas(2*N,N,mod);\n        LL d=inv(N+1,mod);\n        //cout&lt;&lt;&quot;Lucas: &quot;&lt;&lt;x&lt;&lt;endl;\n        //cout&lt;&lt;&quot;Inv: &quot;&lt;&lt;d&lt;&lt;endl;\n        cout&lt;&lt;2*x*d%mod&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:Lucas+Catalan序列+逆元题目N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10007的结果。Input输入一个","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"Catalan","slug":"51nod/Catalan","count":1,"path":"api/categories/51nod/Catalan.json"},{"name":"Lucas","slug":"51nod/Catalan/Lucas","count":1,"path":"api/categories/51nod/Catalan/Lucas.json"},{"name":"数论","slug":"51nod/Catalan/Lucas/数论","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论.json"},{"name":"组合数学","slug":"51nod/Catalan/Lucas/数论/组合数学","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学.json"},{"name":"逆元","slug":"51nod/Catalan/Lucas/数论/组合数学/逆元","count":1,"path":"api/categories/51nod/Catalan/Lucas/数论/组合数学/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"Catalan","slug":"Catalan","count":1,"path":"api/tags/Catalan.json"},{"name":"Lucas","slug":"Lucas","count":1,"path":"api/tags/Lucas.json"}]},{"title":"51nod 1225 余数之和","slug":"51nod-1225-yszh","date":"2018-03-12T10:04:08.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1225-yszh.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-逆元-数论-思维-同余定理\"><a href=\"#Type-逆元-数论-思维-同余定理\" class=\"headerlink\" title=\"Type:逆元,数论,思维,同余定理\"></a>Type:逆元,数论,思维,同余定理</h1><h1 id=\"直接上代码-题解在代码中-这道题有点耗时间-但挺有趣的\"><a href=\"#直接上代码-题解在代码中-这道题有点耗时间-但挺有趣的\" class=\"headerlink\" title=\"直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的\"></a>直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nLL N;\n/*打表\nvoid Table(int NN){\n    for(int i=1;i&lt;=NN;++i){\n        printf(&quot;%04d-%04d &quot;,i,NN%i);\n    }\n}\n*/\nLL fast_mod(LL a,LL n,LL Mod){\n    LL ans=1;\n    while(n){\n        if(n&amp;1){\n            ans=(ans*a)%Mod;\n        }\n        a=(a*a)%Mod;\n        n&gt;&gt;=1;\n    }\n    return ans;\n}\n\nLL inv2=fast_mod(2,mod-2,mod);\n///对照算法\nLL hh(){\n    LL n=N;\n    LL ans;\n    ans=n%mod*(n%mod)%mod;\n    for(LL t,r,i=1;i&lt;=n;++i) {\n        t=n/i;\n        r=n/t;\n        ans=ans-((r-i+1)%mod*((r+i)%mod))%mod*inv2%mod*t%mod;\n        while(ans&lt;0) ans+=mod;\n        i=r;\n    }\n    return ans;\n}\n\n///本来想的是计算当前N/i相同的数量--结果为:\n///(N-tmp*i)/i 即计算在 N-当前数字*(N/i)后还有多少个数字可以\n///整分给(N/i),由于这个方法利用了除法,所以处理除法溢出有点麻烦\n///1e9左右就炸掉了\n///乘法溢出也很麻烦\n\n///最好的方法就是 N/tmp 理解为最后一个除以 N 等于 tmp 的数字是几\n\n///式子: F[N]=N*N-Sigma(N/i*i | i∈[1,N])\n///其中 括号内的式子的 N/i 有sqrt(n)个不同的值\n///证: 设 tmp=100/i 则 tmp*i=100 故 Count(tmp)&lt;=sqrt(100)\n///并且可以看出 相同的 N/i 对应的 i 是连续的.\n///即我们可以用等差数列求和公式来求 当 tmp=N/i 时 i 的和\n///用等差数列求和时/2用 2的逆元来做\\\n\n///自己坐着坐着就莫名其妙和他一样了= =\nLL solve(){\n    LL ans=N%mod*(N%mod)%mod;\n    for(LL i=1;i&lt;=N;){\n        LL tmp=N/i;\n        LL t=N/tmp;\n        tmp=((i+t)%mod*((t-i+1)%mod))%mod*inv2%mod*tmp%mod;\n        ans=(ans%mod-tmp%mod+mod)%mod;\n        i=t+1;\n    }\n    return ans;\n}\n\nvoid dui_pai(){\n    for(LL i=1;i&lt;=1000000;++i){\n        N=i;\n        if(hh()!=solve()) printf(&quot;%lld Faild\\n&quot;,N);\n    }\n    puts(&quot;Done&quot;);\n}\n\nint main(){\n    //dui_pai();\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        printf(&quot;%lld\\n&quot;,solve());\n    }\n    return 0;\n}</code></pre>","text":"Type:逆元,数论,思维,同余定理直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL mod=1e9+7;LL N;/","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"同余定理","slug":"51nod/同余定理","count":1,"path":"api/categories/51nod/同余定理.json"},{"name":"数论","slug":"51nod/同余定理/数论","count":1,"path":"api/categories/51nod/同余定理/数论.json"},{"name":"逆元","slug":"51nod/同余定理/数论/逆元","count":1,"path":"api/categories/51nod/同余定理/数论/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"}]},{"title":"AOJ NTL_1_D Euler's Phi Function & 欧拉函数相关","slug":"aoj-ntl-1-d-eulers-phi-function","date":"2017-11-25T07:35:20.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-ntl-1-d-eulers-phi-function.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg","content":"<p>欧拉函数: 提供1到N中与N互质的数的个数.</p>\n<h2 id=\"定义和简单性质\"><a href=\"#定义和简单性质\" class=\"headerlink\" title=\"定义和简单性质\"></a>定义和简单性质</h2><p>欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. <strong>对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).</strong></p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><blockquote>\n<p>1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(q-1)</p>\n<blockquote>\n<p>欧拉函数是积性函数,但不是完全积性函数.</p>\n</blockquote>\n</blockquote>\n<p>证明： 函数的积性即： 若m,n互质,则φ(mn)=φ(m)φ(n).由“m,n互质”可知m,n无公因数,所以: φ(m)φ(n)=m(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)·n(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 其中p1,p2,p3…pn为m的质因数,p1’,p2’,p3’…pn’为n的质因数,而m,n无公因数,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 互不相同,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 均为mn的质因数且为mn质因数的全集,所以: φ(mn)=mn(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 所以: φ(mn)=φ(m)φ(n). 即φ(mn)=φ(n)*φ(m)只在(n,m)=1时成立(n与m互质).</p>\n<blockquote>\n<p>2.对于一个正整数N的素数幂分解N=P1^q1_P2^q2_…*Pn^qn.</p>\n</blockquote>\n<pre><code>则 φ(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn).</code></pre><blockquote>\n<p>3.除了N=2,φ(N)都是偶数. 4.设N为正整数,∑φ(d)=N (d|N)(d是N的质因数).</p>\n</blockquote>\n<p>根据性质二,我们可以在O(sqrt(n))的时间内暴力求出一个数的欧拉函数值. 如果我们要求1000000以内所有数的欧拉函数,怎么办. 上面的方法复杂度将高达O(N*sqrt(N)). 暴力方法:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int a[10]={2,10,100,1000,5,7,9,11,12,13};\n    for(int i=0;i&lt;10;++i)\n        cout&lt;&lt;euler(a[i])&lt;&lt;endl;\n    return 0;\n}</code></pre><p>结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" alt></a> 我们可以将这个方法和筛法求素数的想法结合,试用筛法求出1~n内各个数字的euler(n). φ(n)=n_（1-1/p1)(1-1/p2)….(1-1/pk) 其中p1、p2…pk为n的所有素因子(这个素因子是由整数素分得来的)。 比如：φ(12)=12_(1-1/2)(1-1/3)=4。 比如求10以内所有数的φ值：</p>\n<blockquote>\n<p>1.设一数组phi[11]，赋初值phi[1]=1,phi[2]=2…phi[10]=10 2.然后从2开始循环</p>\n<blockquote>\n<p>把2的倍数的φ值<em>(1-1/2)，则phi[2]=2_1/2=1,phi[4]=4_1/2=2,phi[6]=6_1/2=3….； 再是3，3的倍数的φ值</em>(1-1/3)，则phi[3]=3_2/3=2,phi[6]=3*2/3=2，phi[9]=…..； 再5，再7…因为对每个素数都进行如此操作，因此任何一个n都得到了φ(n)=n*（1-1/p1)(1-1/p2)….(1-1/pk)的运算</p>\n</blockquote>\n</blockquote>\n<p>代码如下:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h2 id=\"AOJ-NTL-1-D-Euler’s-Phi-Function\"><a href=\"#AOJ-NTL-1-D-Euler’s-Phi-Function\" class=\"headerlink\" title=\"AOJ NTL_1_D Euler’s Phi Function\"></a>AOJ NTL_1_D Euler’s Phi Function</h2><p>这道题数值范围是1e10,没超过int.而且只需要求一个数的euler. O(lgn)暴力即可.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;euler(n)&lt;&lt;endl;\n\n    return 0;\n}</code></pre>","text":"欧拉函数: 提供1到N中与N互质的数的个数.定义和简单性质欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. 对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).性质1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"},{"name":"欧拉函数","slug":"AOJ/数论/欧拉函数","count":1,"path":"api/categories/AOJ/数论/欧拉函数.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"山东省第八届ACM省赛 fireworks","slug":"fireworks","date":"2018-02-18T12:54:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/fireworks.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>迟来的祝福,新年快乐.</p>\n</blockquote>\n<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><blockquote>\n<p>要登录</p>\n</blockquote>\n<p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" title=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.html</a></p>\n<h1 id=\"Type-杨辉三角-lt-组合数学-逆元\"><a href=\"#Type-杨辉三角-lt-组合数学-逆元\" class=\"headerlink\" title=\"Type: 杨辉三角&lt;-组合数学,逆元\"></a>Type: 杨辉三角&lt;-组合数学,逆元</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>假设x位置有一个烟花,则每秒烟花都会分裂到x+1与x-1这两个位置. 给你n个烟花的初始位置xi和个数ci,问你T秒后,位置w上的烟花个数有多少个.</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>画一下样例的图会发现很像杨辉三角,我们可以将每个初始点分开计算,最后的结果就是所有初始点分裂后落在目标点的烟花个数和. 但我们发现它们的初始值大小与杨辉三角不同,并且比杨辉三角多了许多0, 然后我们考虑如何解决这两个情况.</p>\n<blockquote>\n<p>(1) 初始值ci,因为只有一个初始点,这点和杨辉三角一样.所以答案是</p>\n<blockquote>\n<p>ans(原杨辉三角在该位置的结果)*ci</p>\n</blockquote>\n<p>(2) 中间有0,这点好想,我们只需要通过推导公式将实际坐标转换为逻辑坐标即可.</p>\n</blockquote>\n<p>然后我们分情况讨论,我们在图上可以发现</p>\n<blockquote>\n<p>(1) 当 <code>分裂次数</code> 与 <code>目标位置和原位置的距离差</code> 同奇偶时该位置结果为0. (2) 当距离大于T+1时(即杨辉三角第T行值的个数),永远不可能分裂到.</p>\n</blockquote>\n<p>因为只需要考虑最后一次分裂的结果,所以只需要计算杨辉三角第T行即可,即 C(T,0<del>T) 预处理组合公式我们用 <code>组合数学</code> 性质4那个公式. 所以我们需要预处理一下1</del>1e5的逆元,将除法转换为乘法. 最后答案就是</p>\n<blockquote>\n<p>ans=Sigma(i=1~n,c*C[实际位置] | 根据情况忽略i)</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int MOD = 1e9+7;\nconst int maxn = 1e5+7;\n\nLL C[maxn];\n///逆元\nLL inv[maxn];\nvoid init_(){\n    inv[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        inv[i]=(MOD-MOD/i)*1ll*inv[MOD%i]%MOD;\n    }\n}\n\n///快速幂模求逆元,调动方式quick_mod(i,MOD-2)\n//这里我们用预处理.\nLL quick_mod(LL x, int n){\n    LL ret = 1;\n    while(n){\n        if(n &amp; 1) ret = ret * x % MOD;\n        x = x * x %MOD;\n        n &gt;&gt;= 1;\n    }\n    return ret;\n}\n\nvoid init(int t){\n    C[0]=1;\n    for(int i=1;i&lt;=t;++i){\n        C[i]=C[i-1]*(t-i+1)*1ll%MOD*inv[i]%MOD;\n        //printf(&quot;Num: %d %lld, INV: %lld\\n&quot;,i,C[i],inv[i]);\n    }\n}\n//判断是否同奇同偶\nbool same(int x,int y){\n    if((x&amp;1)^(y&amp;1)) return false;\n    return true;\n}\n\nint query(int t,int d){\n    if(t&amp;1){\n        return t/2-d/2;\n    }\n    return t/2+(d-1)/2;\n}\n\nint main(){\n    init_();\n    int n,T,w;\n    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;T,&amp;w)){\n        init(T);\n        LL ans=0;\n        for(int i=1;i&lt;=n;++i){\n            int x,c;\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;c);\n            int dist=abs(x-w);\n            if(!same(T+1,dist) &amp;&amp; dist&lt;T+1){\n                ans=(ans+c*C[query(T+1,dist)]%MOD)%MOD;\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n\n    return 0;\n}</code></pre>","text":"迟来的祝福,新年快乐.Link要登录http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3895.htmlType: 杨辉三角&lt;-组合数学,逆元题意假设x位置有一个烟花,则每秒","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"二项式定理","slug":"Sdut/二项式定理","count":1,"path":"api/categories/Sdut/二项式定理.json"},{"name":"数论","slug":"Sdut/二项式定理/数论","count":1,"path":"api/categories/Sdut/二项式定理/数论.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛.json"},{"name":"组合数学","slug":"Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学","count":1,"path":"api/categories/Sdut/二项式定理/数论/第八届ACM山东省赛/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"HDU 1021","slug":"hdu-1021","date":"2018-02-09T12:25:13.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1021.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/HDU-1021\" title=\"https://vjudge.net/problem/HDU-1021\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-1021</a></p>\n<h1 id=\"Type-数论-同余定理和余数性质-找规律也可以\"><a href=\"#Type-数论-同余定理和余数性质-找规律也可以\" class=\"headerlink\" title=\"Type: 数论,同余定理和余数性质,找规律也可以\"></a>Type: 数论,同余定理和余数性质,找规律也可以</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11</p>\n<blockquote>\n<p>问:</p>\n<blockquote>\n<p>给你一个数n,如果f(n)整除3,则输出yes,否则no.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>(1) 暴力输出一波会发现如果 n%4==2,则输出yes (2) 正解:</p>\n<blockquote>\n<p>问题可以转换成 f(n)%3 是否等于0 那么我们只需要记录下每个 f(n)%3 的值即可 f(n)≡(f(n-1)+f(n-2))(mod 3) n&gt;=2 f(n)=((f(n-1)%3)+(f(n-2)%3))%3</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><h2 id=\"1-找规律\"><a href=\"#1-找规律\" class=\"headerlink\" title=\"1-找规律\"></a>1-找规律</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(n%4==2){\n            printf(&quot;yes\\n&quot;);\n        }else{\n            printf(&quot;no\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre><h2 id=\"2-正解\"><a href=\"#2-正解\" class=\"headerlink\" title=\"2-正解\"></a>2-正解</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nint m[maxn];\n\nvoid init(){\n    m[0]=7,m[1]=11;\n    for(int i=2;i&lt;=1000000;++i){\n        m[i]=((m[i-1]%3)+(m[i-2]%3))%3;\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        printf(&quot;%s\\n&quot;,(!m[n])?&quot;yes&quot;:&quot;no&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-1021Type: 数论,同余定理和余数性质,找规律也可以题意f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11问:给你一个数n,如果f(n)整除3,则输出yes,否则no.题解(1) 暴力输出","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 1431","slug":"hdu-1431","date":"2018-02-06T14:37:53.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1431.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1431\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>\n<h1 id=\"type-二分-线性素数筛\"><a href=\"#type-二分-线性素数筛\" class=\"headerlink\" title=\"type: 二分,线性素数筛\"></a>type: 二分,线性素数筛</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>先用线筛打1000W的表,然后二分查找a的下标,暴力a到b内素数是否是回文数即可.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=10000000+10;\nint a,b,tot=0;\n\nbool valid[maxn];\nint prime[maxn];\nvoid init(int n,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint query(int len,int key){\n    int left=1;\n    int right=len;\n    int mid;\n    while(left&lt;=right){\n        mid=(left+right)&gt;&gt;1;\n        if(key&lt;prime[mid]){\n            right=mid-1;\n        }else if(key&gt;prime[mid]){\n            left=mid+1;\n        }else return mid;\n    }\n    return -1;\n}\n\nbool check(int n){\n    if((n/10)==0) return true;\n    int str[20];\n    int len=0,l=n;\n    for(;l&gt;0;){\n        ++len;\n        str[len]=l%10;\n        l/=10;\n    }\n    for(int i=1;i&lt;=len;++i){\n        if(str[i]!=str[len-i+1]) return false;\n    }\n    return true;\n}\n\nint main(){\n    init(10000000,prime);\n    while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b)){\n        int id=query(tot,a);\n        for(int i=id;prime[i]&lt;=b &amp;&amp; prime[i];++i){\n            if(check(prime[i])){\n                printf(&quot;%d\\n&quot;,prime[i]);\n            }\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttp://acm.hdu.edu.cn/showproblem.php?pid=1431type: 二分,线性素数筛题意题目很清楚,求a到b之间的回文素数,打印出来. 注意题目给的a,b范围为10000000,所以不能用朴素艾筛.题解先用线筛打1000W的表,然后二分","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"二分搜索","slug":"HDU/二分搜索","count":1,"path":"api/categories/HDU/二分搜索.json"},{"name":"数论","slug":"HDU/二分搜索/数论","count":1,"path":"api/categories/HDU/二分搜索/数论.json"},{"name":"线性素数筛法","slug":"HDU/二分搜索/数论/线性素数筛法","count":1,"path":"api/categories/HDU/二分搜索/数论/线性素数筛法.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"二分搜索","slug":"二分搜索","count":3,"path":"api/tags/二分搜索.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2035","slug":"hdu-2035","date":"2018-02-11T08:47:36.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2035.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/HDU-2035\" title=\"https://vjudge.net/problem/HDU-2035\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2035</a></p>\n<h1 id=\"Type-同余定理\"><a href=\"#Type-同余定理\" class=\"headerlink\" title=\"Type: 同余定理\"></a>Type: 同余定理</h1><h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>可以将提议理解为 ans%1000</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1000;\nint main(){\n    int A,B;\n    while(cin&gt;&gt;A&gt;&gt;B&amp;&amp;A+B){\n        int ans=1;\n        for(int i=1;i&lt;=B;++i){\n            ans=((ans%mod)*(A%mod))%mod;\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-2035Type: 同余定理题解可以将提议理解为 ans%1000Code#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=1000;","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2099","slug":"hdu-2099","date":"2016-12-26T09:54:51.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/hdu-2099.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【暴力水+整除】 因为数据量不大. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int main(){<br>    int a,b;<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>        if(a==0&amp;&amp;b==0)<br>            break;<br>        int flag=0;<br>        for(int i=0;i&lt;=99;++i)<br>        {<br>            if((i+a*100)%b==0)<br>                if(i&lt;10)<br>                    flag==0?flag=1,cout&lt;&lt;”0”&lt;&lt;i:cout&lt;&lt;” 0”&lt;&lt;i;<br>                else<br>                    flag==0?flag=1,cout&lt;&lt;i:cout&lt;&lt;” “&lt;&lt;i;<br>        }<br>        cout&lt;&lt;endl;<br>    }<br>    return 0;<br>}</algorithm></p>\n","text":"【暴力水+整除】 因为数据量不大. 【Code】#include#include<br>using namespace std;<br>int main(){<br>    int a,b;<br>    while(cin&gt;&gt;a&gt;&gt;b){<br>    ","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"算法学习","slug":"HDU/算法学习","count":1,"path":"api/categories/HDU/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2588 GCD","slug":"hdu-2588-gcd","date":"2017-11-25T11:45:09.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/hdu-2588-gcd.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 数论-欧拉函数-折半枚举 原题连接: <a href=\"https://vjudge.net/problem/HDU-2588\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2588</a></p>\n<blockquote>\n<p>题意</p>\n<blockquote>\n<p>输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.</p>\n</blockquote>\n<p>题解</p>\n<blockquote>\n<p>首先无法枚举X求GCD(X,N) 我们考虑 (X,N) = (q*d,b*d) 其中d是X,N的最大公约数. 可以知道 b&gt;=q 且 b与q互质①. 所以就转换成了对每个这样的d求 euler(b)(见①) 且 d&gt;=M 的个数. 也就转换成了枚举d求euler(b)之和.但是这仍是O(TNlgN)复杂度的. 所以我们采用折半枚举的做法,因为要枚举的是d,而d*b在sqrt(N)之后就变成了b*d了.所以我们可以只需要枚举sqrt(N)个数,将b,d都看做b即可.</p>\n</blockquote>\n</blockquote>\n<p>Code:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    for(int i=0;i&lt;T;++i){\n        int ans=0;\n        int N,M;\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;M);\n        for(int i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                if(i&gt;=M)\n                    ans+=euler(N/i);\n                if((N/i)!=i &amp;&amp; (N/i)&gt;=M)\n                ///如果==i且&gt;=M的话证明i&gt;=M,而不需要计算两次,所以排除掉\n                    ans+=euler(i);\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"类型: 数论-欧拉函数-折半枚举 原题连接: https://vjudge.net/problem/HDU-2588题意输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.题解首先无法枚举X求GCD(X,N) 我们考","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"数论","slug":"HDU/数论","count":1,"path":"api/categories/HDU/数论.json"},{"name":"欧拉函数","slug":"HDU/数论/欧拉函数","count":1,"path":"api/categories/HDU/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"NEFU 115","slug":"nefu-115","date":"2016-12-26T10:35:46.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/nefu-115.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 斐波那契+lcm+循环节&lt;-找规律 【题目来源】 <a href=\"http://acm.nefu.edu.cn/JudgeOnline/problemShow.php?problem_id=115\" target=\"_blank\" rel=\"noopener\">NEFU-115-斐波那契的整除</a> 【分析】</p>\n<p>输入数据有若干组，每组数据包含一个整数n（1&lt; n &lt;1000000000）。</p>\n<p>从这句中我们得以看出暴力不是一个好方法,考虑循环节,发现当n%4==0时f(n)能被3整除;n%6==0时,f(n)能被4整除;然后由lcm得出f(n)能被12整除,当且仅当n%12==0(lcm(4,6)). 【验证】 打印发现循环节为 3 4 3 12</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>typedef long long LL;<br>int main(){<br>    LL a,b,c;<br>    a=1,b=1;<br>    for(int i=3;i&lt;=50;++i){<br>        c=a+b,a=b,b=c,cout&lt;&lt;i&lt;&lt;”: “&lt;&lt;c&lt;&lt;” “;<br>        if(c%3==0)cout&lt;&lt;” 3”;<br>        if(c%4==0)cout&lt;&lt;” 4”;<br>        cout&lt;&lt;endl;<br>    }<br>    return 0;<br>}</algorithm></p>\n<p>【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;<br>int main(){<br>    int n;<br>    while(cin&gt;&gt;n){<br>        if(!(n%12))<br>            cout&lt;&lt;”YES\\n”;<br>        else if(!(n%4))<br>            cout&lt;&lt;”3\\n”;<br>        else if(!(n%6))<br>            cout&lt;&lt;”4\\n”;<br>        else<br>            cout&lt;&lt;”NO\\n”;<br>    }<br>    return 0;<br>}</algorithm></p>\n","text":"【类型】 斐波那契+lcm+循环节&lt;-找规律 【题目来源】 NEFU-115-斐波那契的整除 【分析】输入数据有若干组，每组数据包含一个整数n（1&lt; n &lt;1000000000）。从这句中我们得以看出暴力不是一个好方法,考虑循环节,发现当n%4==0时f(n)能","link":"","raw":null,"photos":[],"categories":[{"name":"NEFU","slug":"NEFU","count":1,"path":"api/categories/NEFU.json"},{"name":"数论","slug":"NEFU/数论","count":1,"path":"api/categories/NEFU/数论.json"},{"name":"算法学习","slug":"NEFU/数论/算法学习","count":1,"path":"api/categories/NEFU/数论/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"nefu","slug":"nefu","count":1,"path":"api/tags/nefu.json"}]},{"title":"数论 -  幂乘以及取模相关推导","slug":"number-theory-pow-and-mod","date":"2017-11-25T06:21:18.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/number-theory-pow-and-mod.json","excerpt":"","keywords":null,"cover":null,"content":"<p>幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.</p>\n<blockquote>\n<p>mod相关</p>\n<blockquote>\n<p>:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由如下</p>\n</blockquote>\n</blockquote>\n<pre><code>设a除以M的余数和商分别为ar,aq.\nb除以M的余数和商分别为br,bq.\na*b =(aq*M+ar)*(bq*M+br)\n    =aq*bq*M^2+ar*bq*M+aq*br*M+ar*br\n    =(aq*bq*M^+ar*bq+aq*br)*M+ar*br\n\n故 (a*b)%M = ar*br\n             = a%M*b%M</code></pre><blockquote>\n<blockquote>\n<p>:arrow_forward:除法相对复杂,具体可以通过费小马定理求解.</p>\n</blockquote>\n</blockquote>\n<p>幂乘模板题: <code>NTL_1_B:Power</code></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst ull md=1000000007;\n\nll mod_pow(ull x,ull n,ull mod){\n    ull res=1;\n    while(n&gt;0){\n        if(n&amp;1) res=res*x%mod;\n        x=x*x%mod;\n        n&gt;&gt;=1;\n    }\n    return res;\n}\n\nint main(){\n    ull m,n;\n    scanf(&quot;%llu %llu&quot;,&amp;m,&amp;n);\n    printf(&quot;%lld\\n&quot;,mod_pow(m,n,md));\n    return 0;\n}</code></pre>","text":"幂乘都很熟悉了.将n的乘法降为lgn的乘法次数.mod相关:arrow_forward:计算加法时,每项加一次执行一次%M :arrow_forward:计算减法时,给被减数加上M之后先算减法后算%M :arrow_forward:计算乘法时,每相乘一次执行一次%M,这样做的理由","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"}]},{"title":"POJ 1061","slug":"poj-1061","date":"2017-01-13T15:53:30.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-1061.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 扩展欧几里得 【思路】 根据题意得方程:设跳t次遇见 (1) (x+mt)-(y+nt)=kL(因为一定是整数解(因为是整数解,所以符合扩欧)) (2)移项得:(n-m)t+kL=x-y &lt;=&gt; at+bL=z (3)扩欧定理中:a,b互质,只有整数解. (4)尝试z mod gcd(a,b)是否为0,如果为0则有解,不为0,则无解. (5)最后解得的t可能存在t&lt;0. (6)最后留下的一个疑问.为什么要 mod L/gcd(a,b)? 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm><br>using namespace std;</algorithm></p>\n<p>typedef long long LL;</p>\n<p>LL gcd(LL a,LL b){<br>    if(b==0)return a;<br>    else return gcd(b,a%b);<br>}</p>\n<p>void exgcd(LL a,LL b,LL &amp;x,LL &amp;y){<br>    if(!b) x=1,y=0;<br>    else {exgcd(b,a%b,y,x); y-=x<em>(a/b);}<br>}<br>int main(){<br>    long long x,y,m,n,L,d,K,t,a,z,b;<br>    cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;L;<br>    if(m==n){<br>        cout&lt;&lt;”Impossible\\n”;<br>        return 0;<br>    }<br>    a=n-m;<br>    z=x-y;<br>    b=L;<br>    d=gcd(a,b);<br>    if((x-y)%d){<br>        cout&lt;&lt;”Impossible\\n”;<br>        return 0;<br>    }<br>    a/=d;<br>    b/=d;<br>    z/=d;<br>    exgcd(a,b,t,K);<br>    K</em>=z;//z=(x-y)/gcd(a,b)-&gt;即扩大倍数k,这句等价于KL<br>    t*=z;//狮子等比扩大z倍;<br>    t=(t%b+b)%b;<br>    cout&lt;&lt;t&lt;&lt;”\\n”;<br>    return 0;<br>}</p>\n","text":"【类型】 扩展欧几里得 【思路】 根据题意得方程:设跳t次遇见 (1) (x+mt)-(y+nt)=kL(因为一定是整数解(因为是整数解,所以符合扩欧)) (2)移项得:(n-m)t+kL=x-y &lt;=&gt; at+bL=z (3)扩欧定理中:a,b互质,只有整数解. (","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"扩展欧几里得","slug":"UVa/扩展欧几里得","count":1,"path":"api/categories/UVa/扩展欧几里得.json"},{"name":"数论","slug":"UVa/扩展欧几里得/数论","count":1,"path":"api/categories/UVa/扩展欧几里得/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"POJ 2407","slug":"poj-2407","date":"2018-02-12T09:09:54.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2407.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/POJ-2407\" title=\"https://vjudge.net/problem/POJ-2407\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2407</a></p>\n<h1 id=\"Type-欧拉函数\"><a href=\"#Type-欧拉函数\" class=\"headerlink\" title=\"Type: 欧拉函数\"></a>Type: 欧拉函数</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>求小于n 且与n互质的数的个数</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>简单欧拉,但因为是十亿的数据量,所以不能预处理</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint phi(int n){\n    int ans=n;\n    for(int i=2;i*i&lt;=n;++i){\n        if(n%i==0){\n            ans=ans-ans/i;\n            while(n%i==0){\n                n/=i;\n            }\n        }\n    }\n    if(n&gt;1){\n        ans=ans-ans/n;\n    }\n    return ans;\n}\n\nint main(){\n    int n;\n    while(cin&gt;&gt;n&amp;&amp;n){\n        cout&lt;&lt;phi(n)&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2407Type: 欧拉函数题意求小于n 且与n互质的数的个数题解简单欧拉,但因为是十亿的数据量,所以不能预处理Code#include&lt;cstdio&gt;#include&lt;algorithm&g","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2478","slug":"poj-2478","date":"2018-02-12T09:44:15.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2478.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/POJ-2478\" title=\"https://vjudge.net/problem/POJ-2478\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2478</a></p>\n<h1 id=\"Type-欧拉函数\"><a href=\"#Type-欧拉函数\" class=\"headerlink\" title=\"Type: 欧拉函数\"></a>Type: 欧拉函数</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5} 其中分子与分母互质.</p>\n<blockquote>\n<p>目标是求Fn中的最简分数有多少个</p>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>仔细观察会发现因为所有分数分子分母都是互素的 设n为分母,相同分母n的最简分数的个数就等于与n互质的数的个数. 分母从2开始计数</p>\n<blockquote>\n<p>答案就是2~n的phi(k)的和</p>\n<blockquote>\n<p>注意和斐波那契一样,Farey序列也会超过long long</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000000+100;\nLL phi[maxn];\nLL Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(LL i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(LL j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){\n        printf(&quot;%lld\\n&quot;,Farey[n]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2478Type: 欧拉函数题意F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3090","slug":"poj-3090","date":"2018-02-12T11:54:27.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-3090.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/POJ-3090\" title=\"https://vjudge.net/problem/POJ-3090\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-3090</a></p>\n<h1 id=\"Type-欧拉函数\"><a href=\"#Type-欧拉函数\" class=\"headerlink\" title=\"Type: 欧拉函数\"></a>Type: 欧拉函数</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原题转换成该范围内有多少个点的 x与y互质</p>\n<blockquote>\n<p>这个与poj2478这道题求法一样,有一点不同的是,(x,y)存在的同时也会存在(y,x) 并且会同时存在(1,0)(0,1)(1,1)这三个点,所以答案是</p>\n</blockquote>\n<p>Farey[n]*2+3</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000+100;\nint phi[maxn];\nint Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n,kase=1,t;\n    scanf(&quot;%d&quot;,&amp;t);\n    while(t--){\n        scanf(&quot;%d&quot;,&amp;n);\n        printf(&quot;%d %d %d\\n&quot;,kase++,n,Farey[n]*2+3);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-3090Type: 欧拉函数题意第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?题解想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"UVa 10375","slug":"uva-10375","date":"2017-01-08T14:19:03.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10375.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,素数筛法 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10375\" target=\"_blank\" rel=\"noopener\">UVa-10375-Choose and divide</a> 【唯一分解定理】 任何一个大于1的自然数<em>N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N</em>=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为素数，其中指数ai是正整数。这样的分解称为<em>N</em>的标准分解式. 【思路】 根据题意得: 给定p q r s 求 ①.(p!<em>s!</em>(r-s)!)/(r!<em>q!</em>(p-q)!) 暴力会炸,至于为啥.</p>\n<p>10000! 总位数：35660位,要不要试试？</p>\n<p>1.先筛10000以内的素数. 2.数组e表示当前结果的唯一分解式中各个素数的指数,prime数组第i位的指数是多少.如:e={1，0，2，0，0，0 …}表示pow(2,1)*pow(5,2)=50 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath></cmath></p>\n<p>#define MAXN 10000<br>using namespace std;</p>\n<p>int prime[MAXN];<br>bool is_prime[MAXN];<br>int primesize=0,p,q,r,s;</p>\n<p>int e[MAXN];</p>\n<p>void sieve(){<br>    memset(is_prime,1,sizeof(is_prime));<br>    is_prime[1]=is_prime[0]=false;<br>    for(int i=0;i&lt;MAXN;++i){<br>        if(is_prime[i]){<br>            prime[primesize++]=i;<br>            for(int j=i*2;j&lt;MAXN;j+=i)<br>                is_prime[j]=false;<br>        }<br>    }<br>}</p>\n<p>//乘以或除以n,d=1表示乘,d=-1表示除<br>void add_integer(int n,int d){<br>    for(int i=0;i&lt;primesize;++i){<br>        while(n%prime[i]==0){//必须是while<br>            n/=prime[i];<br>            e[i]+=d;<br>        }<br>        if(n==1)break;//提前终止循环,节约时间<br>    }<br>}</p>\n<p>void add_factorial(int n,int d){<br>    for(int i=1;i&lt;=n;++i)<br>        add_integer(i,d);<br>}</p>\n<p>int main(){<br>    sieve();<br>    while(cin&gt;&gt;p&gt;&gt;q&gt;&gt;r&gt;&gt;s){<br>        memset(e,0,sizeof(e));<br>        //以下一串表示上面的公式①的分子和分母.<br>        add_factorial(p,1);<br>        add_factorial(s,1);<br>        add_factorial(r-s,1);<br>        add_factorial(q,-1);<br>        add_factorial(r,-1);<br>        add_factorial(p-q,-1);<br>        double ans=1;<br>        for(int i=0;i&lt;primesize;++i)<br>            ans*=pow(prime[i],e[i]);<br>        printf(“%.5lf\\n”,ans);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,素数筛法 【题目来源】 UVa-10375-Choose and divide 【唯一分解定理】 任何一个大于1的自然数N,如果N不为质数(素数)_，那么N可以唯一分解成有限个质数的乘积_N=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10791","slug":"uva-10791","date":"2017-01-09T05:11:28.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10791.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-10791\" target=\"_blank\" rel=\"noopener\">UVa-10791-Minimum Sum LCM</a> 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因子(一定是素数)加到最后的结果中. 其过程等同于素数筛法,先筛2^a1,再筛3^a2 …其筛出的ai不为0的因子的底数一定是素数.因为  *唯一分解定理:一个数可以分解为若干素数的幂相乘的形式. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cmath><br>using namespace std;<br>typedef long long LL;</cmath></p>\n<p>int main(){<br>    ios::sync_with_stdio(false);<br>    LL N;<br>    int lam=1;<br>    while(cin&gt;&gt;N){<br>        if(N&lt;=0)break;<br>        LL sum=0,cnt=0;<br>        for(int i=2;i&lt;=sqrt(N);++i){<br>            if(N%i==0){<br>                LL mut=1;<br>                cnt++;<br>                while(N%i==0){<br>                    N/=i;<br>                    mut*=i;<br>                }<br>                sum+=mut;<br>            }<br>        }<br>        if(N&gt;1 || cnt==0){<br>            //这里的N是计算以后偶剩下的N,这个N一定是一个素数,直接加即可<br>            sum+=N;<br>            cnt++;<br>        }<br>        if(cnt==1) sum++;<br>       printf(“Case %d: %lld\\n”,lam++,sum);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,约数判断,分解质因数 【题目来源】 UVa-10791-Minimum Sum LCM 【Tip】 一开始一直TLE,后来发现需要优化成用小于等于√N 的质数来求N的因子(并非一定是质因子),最后剩下一个约分过后的N,如果N&gt;1,则将N作为最后一个因","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"唯一分解定理","slug":"UVa/唯一分解定理","count":2,"path":"api/categories/UVa/唯一分解定理.json"},{"name":"数论","slug":"UVa/唯一分解定理/数论","count":2,"path":"api/categories/UVa/唯一分解定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10820","slug":"uva-10820","date":"2017-01-11T15:47:56.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-10820.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 欧拉函数值,素数筛法,打表 【题目来源】 算法竞赛入门 P322 例题10-7 <a href=\"https://vjudge.net/problem/UVA-10820\" target=\"_blank\" rel=\"noopener\">UVa-10820-Send a Table</a> 【思路】 运用素数筛法的思想对1~50000内的数打表得到每个数的欧拉phi函数值. 然后处理表,使得从3开始往后每个phi[i]都等于前面的phi[i]的和加上phi[i]. 题目说可以通过f(x,y)计算f(x_k,y_k)即其意思就是要求的表内x,y必须互素. 其答案是2*f(n)+1,特判n=1. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cmath><br>using namespace std;<br>int phi[50010]={0};</cmath></p>\n<p>void init(){<br>    int n=50003;<br>    for(int i=2;i&lt;=n;++i) phi[i]=0;<br>    phi[1]=1;<br>    for(int i=2;i&lt;=n;++i)<br>        if(!phi[i])<br>            for(int j=i;j&lt;=n;j+=i){<br>                if(!phi[j])<br>                    phi[j]=j;<br>                phi[j]=phi[j]/i*(i-1);<br>            }<br>    for(int i=3;i&lt;=n;++i)<br>        phi[i]+=phi[i-1];<br>}</p>\n<p>int main(){<br>    init();<br>    int M;<br>    while(scanf(“%d”,&amp;M),M){<br>        M==1?printf(“1\\n”):printf(“%d\\n”,2*phi[M]+1);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 欧拉函数值,素数筛法,打表 【题目来源】 算法竞赛入门 P322 例题10-7 UVa-10820-Send a Table 【思路】 运用素数筛法的思想对1~50000内的数打表得到每个数的欧拉phi函数值. 然后处理表,使得从3开始往后每个phi[i]都等于前面的p","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"欧拉函数","slug":"UVa/数论/欧拉函数","count":1,"path":"api/categories/UVa/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11401","slug":"uva-11401","date":"2018-02-04T10:10:32.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11401.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11401\" title=\"https://vjudge.net/problem/UVA-11401\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11401</a></p>\n<h1 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h1><p>组合数学,加法原理,三角形三边定理</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>考虑三角形三边定理.</p>\n<blockquote>\n<p>设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条边. 则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边) 考虑y的取值,确定z的取值.</p>\n<blockquote>\n<p>y∈[1,x-1] 当y取1时,z无值.当y取2时,z有唯一值x-1 当y取3时,z可以取(x-1),(x-2). 故y取x-1时,z可以取的种数为x-2种.</p>\n<blockquote>\n<p>根据等差数列求和公式: 总种类数Sn = 0+1+2+…+(x-2)</p>\n</blockquote>\n<p>Sn = (x-2)(x-1)/2(种) 但这个值并不等于c(x) 因为:</p>\n<blockquote>\n<p>1.对于每个三角形都计数了两遍 =&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2 2.以上的计算方式存在y=z的情况 (这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z) =&gt; 比如x=7 y=4时,z就可以取到4</p>\n<blockquote>\n<p>对于第二种问题的解决很简单. 对于每个x考虑y==z的情况: 设t为c(x)中y=z时的情况总数: 则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.</p>\n</blockquote>\n<p>故t=(x-1)-(x/2+1)+1=x-1-(int)x/2</p>\n</blockquote>\n</blockquote>\n<p>故c(x)=(Sn-t)/2</p>\n<blockquote>\n<p>又因为c(x)是最长边为x时的种类数.</p>\n</blockquote>\n<p>故设f(n)为最长边不超过n时的种类数 根据加法原理,因为互无交集 故 f(n)=c(1)+c(2)+c(3)+…+c(n)</p>\n</blockquote>\n<p>化成递推: f(n)=f(n-1)+c(n)</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11401\ntype: 组合数学,加法原理,三角形三边定理\n题意: 给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形\n\n题解:\n考虑三角形三边定理.\n设c(x)为以x为最长边的可拼成三角形的数目.\n设y,z为另外两条边.\n则 z+y&gt;x =&gt; x-y&lt;z 即 x-y&lt;z&lt;x (没有等于号则代表不考虑等边)\n考虑y的取值,确定z的取值.\ny∈[1,x-1]\n当y取1时,z无值.当y取2时,z有唯一值x-1\n当y取3时,z可以取(x-1),(x-2).\n故y取x-1时,z可以取的种数为x-2种.\n根据等差数列求和公式:\n总种类数Sn\n= 0+1+2+...+(x-2)\n= (x-2)(x-1)/2(种)\n但这个值并不等于c(x)\n因为:\n1.对于每个三角形都计数了两遍\n=&gt; 因为y=2时 z=x-1,而最后一项为y=x-1,则z一定有一种会取到2\n2.以上的计算方式存在y=z的情况\n(这种情况下每个特例只会出现一次,因为只有确定y的条件下才可能出现y=z)\n=&gt; 比如x=7 y=4时,z就可以取到4\n对于第二种问题的解决很简单.\n对于每个x考虑y==z的情况:\n设t为c(x)中y=z时的情况总数:\n则因为当且仅当y∈[(x/2+1),x-1]时存在y=z的可能.\n故t=(x-1)-(x/2+1)+1=x-1-(int)x/2\n故c(x)=(Sn-t)/2\n又因为c(x)是最长边为x时的种类数.\n故设f(n)为最长边不超过n时的种类数\n根据加法原理,因为互无交集\n故 f(n)=c(1)+c(2)+c(3)+...+c(n)\n化成递推: f(n)=f(n-1)+c(n)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nlong long sum[maxn];\nint n;\ninline void init(){\n    long long Sn,Cn,t;\n    memset(sum,0,sizeof(sum));\n    for(long long i=4;i&lt;=1000000;++i){\n        Sn=(i-2)*(i-1)/2;\n        t=i-1-i/2;\n        Cn=(Sn-t)&gt;&gt;1;\n        int id=(int)i;\n        sum[id]=sum[id-1]+Cn;\n    }\n}\nint main(){\n    init();\n    while(cin&gt;&gt;n){\n        if(n&lt;3)break;\n        cout&lt;&lt;sum[n]&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11401type组合数学,加法原理,三角形三边定理题意给你N个长度为1~N的杆子,问你能用这N个杆子拼成多少个不同的三角形题解考虑三角形三边定理.设c(x)为以x为最长边的可拼成三角形的数目.y,z为另外两条","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11426","slug":"uva-11426","date":"2018-02-12T08:37:59.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11426.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11426\" title=\"https://vjudge.net/problem/UVA-11426\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11426</a></p>\n<h1 id=\"Type-数论-欧拉函数-递推-思维\"><a href=\"#Type-数论-欧拉函数-递推-思维\" class=\"headerlink\" title=\"Type: 数论,欧拉函数,递推,思维\"></a>Type: 数论,欧拉函数,递推,思维</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n∈[1,4000000]</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>首先我们应该清楚</p>\n<blockquote>\n<p>4000000的数据,用暴力 - 对每个gcd求值相加复杂度是i*j*O(gcd) 你懂就行,这么大的复杂度肯定爆炸.</p>\n</blockquote>\n<p>所以我们第一想法肯定是预处理.</p>\n<blockquote>\n<p>我们设 f(n) 为 (1,n)+(2,n)+(3,n)+…+(n-1,n) 则 S(n)=f(1)+f(2)+…+f(n)</p>\n<blockquote>\n<p>通过这个公式我们就可以递推出所有的 S(n)</p>\n<blockquote>\n<p>S(n)=S(n-1)+f(n)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>然后我们的问题就转化成了求f(n)</p>\n<blockquote>\n<p>首先我们会自然地想到,与n互素的答案是1.即(k,n)的结果都是n的约数</p>\n<blockquote>\n<p>我们可以按照这个约数来进行分类, 用 g(n,i)表示满足gcd(x,n)=i 且 x\\&lt;n 的正整数x的个数 则: f(n)=Sum(i*g(n,i) | i是n的约数,g(n,i)是1~n中gcd(k,n)=i的k的个数)</p>\n<blockquote>\n<p>然后我们注意到: -gcd(x,n)=i -则gcd(x/i,n/i)=1 -即x/i与n/i互质</p>\n</blockquote>\n<p>然后我们就可以将 g(n,i) 看做1~n中与 n/i 互质的数的个数,即</p>\n</blockquote>\n<p>g(n,i) = phi(n/i) 然后我们预处理phi[maxn],预处理完以后处理f(n),这里如果用二重循环依然是接受不了的 所以我们沿用筛法的思想对f[maxn]数组进行预处理,遇到i 是 k 的约数时,直接f[k]+=(i*phi[n/i])</p>\n</blockquote>\n<p>最后预处理S[maxn]即可</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\n我们要求:\nG=Sigma(i=1~N) Sigma(j=i+1~N) GCD(i,j)\nN&lt;=4000000，这样的范围二次循环+GCD肯定是不行的\n所以我们考虑\nf(n)=Sigma(i=1~n-1) gcd(i,n)\n则\nG(n)=Sigma(i=1~n) f(i)\n=G(n-1)+f(n)\n所以我们的问题转换为如何求f(n)\n\n即k都是n的约数\n可以按照约数进行分类,用g(n,i)表示满足 (x,n)=i且x&lt;n的正整数x的个数\n则 f(n)=sum(i\\*g(n,i)|i是n的约数)\n\n再重提: g(n,i)代表满足(x,n)=i,且x&lt;n的正整数x的个数\n\n我们知道,如果 (a,n)=k\n则 (a/k,n/k)=1\n\n所以我们可以理解为g(n,i)代表的是x/i与n/i互质的数的个数\n即满足条件的x/i 有 phi(n/i)个\ng(n,i)=phi(n/i)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=4000000+10;\nLL phi[maxn];\n\nLL f[maxn];\n\nLL g[maxn];\nvoid phi_table(){\n    for(int i=2;i&lt;maxn;++i) phi[i]=0;\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nvoid init(){\n    phi_table();\n    memset(f,0,sizeof(f));\n    for(int i=1;i&lt;maxn;++i){\n        for(int j=i*2;j&lt;maxn;j+=i){\n            f[j]+=(i*phi[j/i]);\n        }\n    }\n    memset(g,0,sizeof(g));\n    for(int i=1;i&lt;maxn;++i) g[i]=g[i-1]+f[i];\n}\n\nint main(){\n    init();\n    int k;\n    while(~scanf(&quot;%d&quot;,&amp;k) &amp;&amp; k){\n        printf(&quot;%lld\\n&quot;,g[k]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11426Type: 数论,欧拉函数,递推,思维题意输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"数论","slug":"UVa/思维/数论","count":1,"path":"api/categories/UVa/思维/数论.json"},{"name":"欧拉函数","slug":"UVa/思维/数论/欧拉函数","count":1,"path":"api/categories/UVa/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11538","slug":"uva-11538","date":"2018-02-04T04:55:35.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11538.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"题目连接：\"><a href=\"#题目连接：\" class=\"headerlink\" title=\"题目连接：\"></a>题目连接：</h1><p><a href=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" title=\"https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087\" target=\"_blank\" rel=\"noopener\">https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087</a> PS: 蓝书P105，书上有一个错误的地方,Sigma(1<del>n-1) i(i-1)那里书上得到的结果是2*Sigma(1</del>n-1) i(i-1)的结果.我在代码中标注了.</p>\n<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link:\"></a>Link:</h1><p><a href=\"https://vjudge.net/problem/UVA-11538\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11538</a> type: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意:\"></a>题意:</h1><p>有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解:\"></a>题解:</h1><blockquote>\n<p>分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线</p>\n<blockquote>\n<p>同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1) 同一列: 合同一行类似,结果是nm(n-1) 同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)</p>\n<blockquote>\n<p>可以观测到所有’/‘方向的斜线长度为: 1,2,3,…,n,n,n,n-1,n-2…,2,1 其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可) 其中每条斜线上的取法种数 = i<em>(i-1) diagonal=Sigma(1~n-1) i(i-1) =&gt; i==1时确实是0种可能,因为皇后是放在块内而不是点上的. 则 All_diagonal = 2(2*diagonal+(m-n+1)*n</em>(n-1)) =&gt; 这里的乘2是因为有两种斜线’/‘和’\\‘的可能 其中</p>\n<blockquote>\n<p>diagonal =Sigma(1<del>n-1) i^2 - Sigma(1</del>n-1) i =n(n-1)(2n-1)/6 - n(n-1)/2 =n(n-1)(2n-4)/6 All_diagonal = 2(2<em>(n(n-1)(2n-4)/6)+(m-n+1)*n\\</em>(n-1)) = 2n(n-1)(3m-n-1)/3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>这三种情况互不相交,最终答案就等于三者和.</p>\n</blockquote>\n<p>Code:</p>\n<pre><code>/*\nLink: https://vjudge.net/problem/UVA-11538\ntype: 组合数学,乘法/加法原理,以及初中数学n^2和=n(n+1)(2n+1)/6\n\n题意: 有N×M大小的棋盘,问,给你两个皇后,使他们可以互相攻击对方的可能有多少种.\n\n题解: 分为三个方向,第一个方向为同一行,第二个方向为同一列,第三个方向为同一斜线\n\n同一行: 对于白皇后有nm种取法,每种取法中黑皇后有(m-1)种取法,所以结果是nm(m-1)\n同一列: 合同一行类似,结果是nm(n-1)\n同一斜线: 画图观察,假设n&lt;=m,(n&gt;m可以不用看,因为等价于n&lt;=m转置)\n    可以观测到所有&apos;/&apos;方向的斜线长度为: 1,2,3,...,n,n,n,n-1,n-2...,2,1\n    其中n的个数 = 总条数-2×(n-1) = m+n-1-2n+2 = m-n+1(m&gt;n时反过来即可)\n    其中每条斜线上的取法种数 = i*(i-1)\n    diagonal=Sigma(1~n-1) i(i-1)   =&gt;   i==1时确实是0种可能,因为皇后是放在块内而不是点上的.\n    则   All_diagonal = 2(2*diagonal+(m-n+1)*n*(n-1))  =&gt; 这里的乘2是因为有两种斜线&apos;/&apos;和&apos;\\&apos;的可能\n    其中diagonal=Sigma(1~n-1) i^2 - Sigma(1~n-1) i  =&gt;n方和展开公式,等差数列求和\n                =n(n-1)(2n-1)/6 - n(n-1)/2\n                =n(n-1)(2n-4)/6\n\n        All_diagonal = 2(2*(n(n-1)(2n-4)/6)+(m-n+1)*n*(n-1))\n                     = 2n(n-1)(3m-n-1)/3\n\n这三种情况互不相交,最终答案就等于三者和.\n*/\n\n//Code\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nunsigned long long N,M;\nint main(){\n    while(cin&gt;&gt;N&gt;&gt;M){\n        if(N==0&amp;&amp;M==0)break;\n        unsigned long long row=N*M*(M-1);\n        unsigned long long column=N*M*(N-1);\n\n        if(N&gt;M) swap(N,M);\n        cout&lt;&lt;row+column+2*N*(N-1)*(3*M-N-1)/3&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"题目连接：https://odzkskevi.qnssl.com/865929a003dafabd8556e993f05c6637?v=1517622087 PS: 蓝书P105，书上有一个错误的地方,Sigma(1n-1) i(i-1)那里书上得到的结果是2*Sigma(1n-","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11806","slug":"uva-11806","date":"2018-02-05T09:48:17.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11806.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11806\" title=\"https://vjudge.net/problem/UVA-11806\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11806</a></p>\n<h1 id=\"Type\"><a href=\"#Type\" class=\"headerlink\" title=\"Type:\"></a>Type:</h1><blockquote>\n<p>组合数学,排列预处理,容斥原理,减法取模公式</p>\n</blockquote>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,</p>\n<blockquote>\n<p>问最上边,最左边,最下边,最右边都有石子的种数为多少?</p>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>我们可以将问题转化为:</p>\n<blockquote>\n<p>全集|S|-至少有一条边上没有棋子的种类个数. 并且我们可以发现,当四条边上都没有棋子时的种类个数为</p>\n<blockquote>\n<p>C((m-2)*(n-2),k).</p>\n</blockquote>\n<p>我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,D为下边没有石子. 则(我们设~A为非A集合):</p>\n<blockquote>\n<p>ans=|(<del>A)∩(</del>B)∩(<del>C)∩(</del>D)|</p>\n</blockquote>\n<p>可以发现就是容斥原理 至于每个集合的计算,在图中就相当于少了一行或一列, 即:</p>\n<blockquote>\n<p>C(row*column,k)</p>\n</blockquote>\n<p>因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能 即 可以用四位2进制表示</p>\n<blockquote>\n<p>0000 0001 0010</p>\n</blockquote>\n<p>我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行)) 等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0</p>\n</blockquote>\n<p>答案为全部的和.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11806\nType: 组合数学,排列预处理,容斥原理,减法取模公式\n题意: 给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,\n问最上边,最左边,最下边,最右边都有石子的种数为多少?\n\n题解:\n我们可以将问题转化为:\n全集|S|-至少有一条边上没有棋子的种类个数.\n并且我们可以发现,当四条边上都没有棋子时的种类个数为\nC((m-2)*(n-2),k).\n我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,\nD为下边没有石子.\n则(我们设~A为非A集合):\nans=|(~A)∩(~B)∩(~C)∩(~D)|\n可以发现就是容斥原理\n至于每个几何的计算,在图中就相当于少了一行或一列,\n即:\nC(row*column,k)\n因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能\n即 可以用四位2进制表示\n0000\n0001\n0010\n我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行))\n等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0\n答案为全部的和.\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11806Type:组合数学,排列预处理,容斥原理,减法取模公式题意给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,问最上边,最左边,最下边,最右边都有石子的种数为多少?题解我们可以将","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"容斥原理","slug":"UVa/容斥原理","count":1,"path":"api/categories/UVa/容斥原理.json"},{"name":"数论","slug":"UVa/容斥原理/数论","count":1,"path":"api/categories/UVa/容斥原理/数论.json"},{"name":"组合数学","slug":"UVa/容斥原理/数论/组合数学","count":1,"path":"api/categories/UVa/容斥原理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1262","slug":"uva-1262","date":"2017-01-13T15:45:11.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1262.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 组合数学 【题目来源】 <a href=\"https://vjudge.net/problem/UVA-1262\" target=\"_blank\" rel=\"noopener\">UVa-1262-Password</a> 【思路】 见紫书P323例10-8 【WA Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring><br>using namespace std;</cstring></p>\n<p>char m[8][8];<br>char a[8][8];<br>int reg[8][8]={0},n;</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=reg[i][0];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=reg[i][0];<br>        j=n/tot;<br>        printf(“%c”,reg[i][j+1]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    cin&gt;&gt;N;<br>    while(N–){<br>        memset(reg,0,sizeof(reg));<br>        int flag=1;<br>        cin&gt;&gt;n;<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>for(int i=1;i&lt;=6;++i)\n        scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\nfor(int j=1;j&lt;=5;++j)\n    for(int t=1;t&lt;=6;++t)\n        for(int i=1;i&lt;=6;++i)\n            if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\]){\n                reg\\[j\\]\\[++reg\\[j\\]\\[0\\]\\]=a\\[t\\]\\[j\\];\n                break;\n            }\n\nfor(int t=1;t&lt;=5;++t){\n    if(reg\\[t\\]\\[0\\]==0) flag=0;\n    sort(&amp;reg\\[t\\]\\[1\\],&amp;reg\\[t\\]\\[reg\\[t\\]\\[0\\]+1\\]);\n}</code></pre><p> /*<br>        for(int t=1;t&lt;=5;++t){<br>            for(int q=1;q&lt;=reg[t][0];++q)<br>                printf(“%c “,reg[t][q]);<br>            printf(“\\n”);<br>        }<br>        */</p>\n<pre><code>    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n<p>【AC Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<vector><br>using namespace std;</vector></p>\n<p>char m[10][10];<br>char a[10][10];<br>int n,k[10];<br>vector<char> v[10];</char></p>\n<p>bool init(){</p>\n<p>}</p>\n<p>void solve(){<br>    int tot=1,j;<br>    for(int i=1;i&lt;=5;++i)<br>        tot<em>=k[i];<br>    if(n&gt;tot){<br>        printf(“NO\\n”);<br>        return;<br>    }<br>    n–;<br>    for(int i=1;i&lt;=5;++i){<br>        tot/=k[i];<br>        j=n/tot;<br>        printf(“%c”,v[i][j]);<br>        n-=j</em>tot;<br>    }<br>    printf(“\\n”);<br>}</p>\n<p>int main(){<br>    int N;<br>    scanf(“%d”,&amp;N);<br>    while(N–){<br>        for(int i=1;i&lt;=5;++i) v[i].clear();<br>        int flag=1;<br>        scanf(“%d”,&amp;n);<br>        for(int i=1;i&lt;=6;++i)<br>                scanf(“%s”,&amp;m[i][1]);</p>\n<pre><code>    for(int i=1;i&lt;=6;++i)\n            scanf(&quot;%s&quot;,&amp;a\\[i\\]\\[1\\]);\n\n    for(int j=1;j&lt;=5;++j)\n        for(int t=1;t&lt;=6;++t)\n            for(int i=1;i&lt;=6;++i)\n                if(a\\[t\\]\\[j\\]==m\\[i\\]\\[j\\])\n                    v\\[j\\].push_back(a\\[t\\]\\[j\\]);\n\n    for(int i=1;i&lt;=5;++i){\n        if(v\\[i\\].empty()){\n            flag=0;\n            break;\n        }\n        sort(v\\[i\\].begin(),v\\[i\\].end());\n        unique(v\\[i\\].begin(),v\\[i\\].end());\n        k\\[i\\]=0;\n        while(k\\[i\\]&lt;v\\[i\\].size()-1 &amp;&amp; v\\[i\\]\\[k\\[i\\]+1\\]&gt;v\\[i\\]\\[k\\[i\\]\\]) k\\[i\\]++;\n        k\\[i\\]++;\n    }\n\n    if(flag==0) {printf(&quot;NO\\\\n&quot;); continue;}\n    solve();\n}\nreturn 0;</code></pre><p>}</p>\n","text":"【类型】 组合数学 【题目来源】 UVa-1262-Password 【思路】 见紫书P323例10-8 【WA Code】#include#include#include#include<br>using namespace std;char m[8][8];<br>char ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"数论","slug":"UVa/数论","count":4,"path":"api/categories/UVa/数论.json"},{"name":"组合数学","slug":"UVa/数论/组合数学","count":3,"path":"api/categories/UVa/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 1635","slug":"uva-1635","date":"2017-01-10T11:13:32.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/uva-1635.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 <a href=\"https://vjudge.net/problem/UVA-1635\" target=\"_blank\" rel=\"noopener\">UVa-1635-Irrelevant Elements</a> 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)<em>(n-k+1)/k. 即 C[i]=C[i-1]</em>(n-i+1)/i. 注意,应该先乘再除,因为C[i-1]/i可能不是整数.但结果一定是整数.而且,因为二项式是递归乘法,所以有时可能会溢出long long,这题就是个例子. 【思路】 因为C(n,i)可能会爆long long,所以先对m做唯一分解，分解成若干素数,并记录每个素数的指数.然后以此计算m的唯一分解式中哥哥素因子在C(n-1,i-1)中的指数即可完成判断.这些指数依然可以用上面那个递推式递推,并且不会涉及高精度. 【参考】 <a href=\"http://blog.csdn.net/u014800748/article/details/43927205\" target=\"_blank\" rel=\"noopener\">Hengjie Yang</a> 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cmath></cmath></p>\n<p>#include<cstring><br>using namespace std;<br>typedef long long LL;<br>LL C[100005];<br>int prime[101][2];<br>int fac_c[100];<br>int N,M;</cstring></p>\n<p>int initM(int m){<br>    int primenum=0;<br>    for(int i=2;i&lt;=sqrt(m);++i){<br>        if(m%i==0){<br>            prime[++primenum][0]=i;<br>            prime[primenum][1]=0;<br>            while(m%i==0){<br>                prime[primenum][1]++;<br>                m/=i;<br>            }<br>        }<br>    }<br>    if(m&gt;1){<br>        prime[++primenum][0]=m;<br>        prime[primenum][1]=1;<br>    }<br>    return primenum;<br>}</p>\n<p>bool check(int m,int k,int primenum){<br>    int a=m-k;<br>    int b=k;<br>    for(int i=1;i&lt;=primenum;++i){<br>        for(;a%prime[i][0]==0;a/=prime[i][0],fac_c[i]++);<br>        for(;b%prime[i][0]==0;b/=prime[i][0],fac_c[i]–);<br>    }<br>    for(int i=1;i&lt;=primenum;++i)<br>        if(prime[i][1]&gt;fac_c[i])<br>        return false;<br>    return true;<br>}</p>\n<p>int main(){<br>    while(cin&gt;&gt;N&gt;&gt;M){<br>        int primenum=initM(M);//唯一分解M,防止爆LL<br>        memset(fac_c,0,sizeof(fac_c));<br>        int cnt=0;//无关数个数<br>        for(int i=1;i&lt;N;++i){<br>            //0~(n-1),这个是组合数C(m,n)的n.  m=n-1 index=i+1<br>            if(check(N,i,primenum))<br>                C[cnt++]=i+1;<br>        }<br>        printf(“%d\\n”,cnt);<br>        for(int i=0;i&lt;cnt;++i)<br>            printf(i==(cnt-1)?”%d\\n”:”%d “,C[i]);<br>    }<br>    return 0;<br>}</p>\n","text":"【类型】 唯一分解定理,二项式定理(组合数学) 【题目来源】 算法竞赛入门经典P320 例题10-6 UVa-1635-Irrelevant Elements 【Tip】 二项式定理展开式:C(n,k)=C(n,k-1)(n-k+1)/k. 即 C[i]=C[i-1](n-i+1","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"二项式定理","slug":"UVa/二项式定理","count":1,"path":"api/categories/UVa/二项式定理.json"},{"name":"唯一分解定理","slug":"UVa/二项式定理/唯一分解定理","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理.json"},{"name":"数论","slug":"UVa/二项式定理/唯一分解定理/数论","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论.json"},{"name":"组合数学","slug":"UVa/二项式定理/唯一分解定理/数论/组合数学","count":1,"path":"api/categories/UVa/二项式定理/唯一分解定理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"数论","slug":"number-theory","date":"2018-02-06T07:59:57.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/number-theory.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>对于这一个知识点的学习,我大概会通过 《ACM国际大学生程序设计竞赛:知识与入门》 以及 lrj的蓝书以及《ACM/ICPC数论及应用》来学习.</p>\n</blockquote>\n<h1 id=\"素数\"><a href=\"#素数\" class=\"headerlink\" title=\"素数\"></a>素数</h1><h2 id=\"素数筛法\"><a href=\"#素数筛法\" class=\"headerlink\" title=\"素数筛法\"></a>素数筛法</h2><h3 id=\"艾氏筛法-O-nloglogn\"><a href=\"#艾氏筛法-O-nloglogn\" class=\"headerlink\" title=\"艾氏筛法(O(nloglogn))\"></a>艾氏筛法(O(nloglogn))</h3><blockquote>\n<p>通常使用艾氏筛法,而艾氏筛法的思想也可用于很多地方.</p>\n</blockquote>\n<h3 id=\"线性筛法\"><a href=\"#线性筛法\" class=\"headerlink\" title=\"线性筛法\"></a>线性筛法</h3><h4 id=\"伪码表述\"><a href=\"#伪码表述\" class=\"headerlink\" title=\"伪码表述\"></a>伪码表述</h4><blockquote>\n<p>算法: 线性的素数筛法 输出: 一个集合S,表示1~n以内的素数集合 具体流程:</p>\n<blockquote>\n<p>(1) 将S初始化为{2,…,n} (2) 维护当前确定的素数的列表L,并初始化为空 (3) 对于 2 到 n 的每一个i</p>\n<blockquote>\n<p>(3.1) 如果当前i∈S,将i加入L (3.2) 对于L中的每一个元素p</p>\n<blockquote>\n<p>(3.2.1) 若i×p&gt;n,结束循环 (3.2) (3.2.2) 将i×p移出S (3.2.3) 如果p整除i,结束循环 (3.2)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"代码-1亿数据量1s\"><a href=\"#代码-1亿数据量1s\" class=\"headerlink\" title=\"代码(1亿数据量1s)\"></a>代码(1亿数据量1s)</h4><blockquote>\n<p>实锤完毕…我的电脑竟然可以存下1亿的数组…</p>\n</blockquote>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100001000\nusing namespace std;\n\nbool valid[maxn];\nint prime[maxn];\n/*素数筛法 O(n),对于每个素数只标记一次*/\nvoid getPrime(int n,int &amp;tot,int ans[maxn]){\n    memset(valid,true,sizeof(valid));\n    for(int i=2;i&lt;=n;++i){\n        if(valid[i]){\n            tot++;\n            ans[tot]=i;\n        }\n        for(int j=1;((j&lt;=tot) &amp;&amp; (i*ans[j]&lt;=n));++j){\n            valid[i*ans[j]]=false;\n            if(i%ans[j]==0) break;\n        }\n    }\n}\n\nint main(){\n    clock_t t1 = clock();\n    int tot=0;\n    getPrime(100000000,tot,prime);\n    clock_t t2 = clock();\n\n    cout&lt;&lt;tot&lt;&lt;endl;\n    cout&lt;&lt;prime[5760000]&lt;&lt;endl;\n    cout&lt;&lt;&quot;总运行时间为: &quot;&lt;&lt;(double)(t2-t1)/ CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;&lt;&lt;endl;\n    return 0;\n}</code></pre><h2 id=\"素数估计\"><a href=\"#素数估计\" class=\"headerlink\" title=\"素数估计\"></a>素数估计</h2><blockquote>\n<p>如果我们设Pi(x)表示不超过x的素数的个数.可以用</p>\n<blockquote>\n<p>x/lnx对Pi(x)进行估计</p>\n</blockquote>\n<p>不到万不得已别用,误差蛮大的</p>\n</blockquote>\n<h2 id=\"素数判定-Miller-Rabin\"><a href=\"#素数判定-Miller-Rabin\" class=\"headerlink\" title=\"素数判定(*Miller-Rabin)\"></a>素数判定(*Miller-Rabin)</h2><blockquote>\n<p>朴素的素数判定法是通过枚举从2到n^0.5内所有的整数,看他是否能整除n.时间复杂度为O(n^0.5) 此外有一个基于概率的常数时间的素数判定法</p>\n<blockquote>\n<p>Miller-Rabin素数判定</p>\n</blockquote>\n</blockquote>\n<h1 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h1><blockquote>\n<p>求gcd(a,b),欧几里得的一个结论是</p>\n<blockquote>\n<p>gcd(a,b)=gcd(b,a%b) 求得最后结果即可</p>\n</blockquote>\n</blockquote>\n<h2 id=\"gcd性质\"><a href=\"#gcd性质\" class=\"headerlink\" title=\"gcd性质\"></a>gcd性质</h2><pre><code> gcd(a,b)=gcd(b,a) （交换律）\ngcd(-a,b)=gcd(a,b)\ngcd(a,a)=|a|\ngcd(a,0)=|a|\ngcd(a,1)=1\ngcd(a,b)=gcd(b, a mod b)\ngcd(a,b)=gcd(b, a-b)\n如果有附加的一个自然数m,\n则: gcd(ma,mb)=m * gcd(a,b) (分配律)\ngcd(a+mb ,b)=gcd(a,b)\n如果m是a和b的最大公约数，\n则： gcd(a/m ,b/m)=gcd(a,b)/m\n在乘法函数中有：\ngcd(ab,m)=gcd(a,m) * gcd(b,m)\n两个整数的最大公约数主要有两种寻找方法：\n* 两数各分解质因数，然后取出同样有的质因数乘起来\n*辗转相除法（扩展版）\n和最小公倍数（lcm）的关系：\ngcd(a, b) * lcm(a, b) = ab\na与b有最大公约数，\n两个整数的最大公因子可用于计算两数的最小公倍数，或分数化简成最简分数。\n两个整数的最大公因子和最小公倍数中存在分配律：\n* gcd(a, lcm(b, c)) = lcm(gcd(a, b), gcd(a, c))\n* lcm(a, gcd(b, c)) = gcd(lcm(a, b), lcm(a, c))\n在坐标里，将点(0, 0)和(a, b)连起来，通过整数坐标的点的数目（除了(0, 0)一点之外）就是gcd(a, b)。</code></pre><h2 id=\"扩展欧几里得\"><a href=\"#扩展欧几里得\" class=\"headerlink\" title=\"扩展欧几里得\"></a>扩展欧几里得</h2><blockquote>\n<p>扩展算法可以求出两个整数x和y,使得ax+by=gcd(a,b)。在此前提下|x|+|y|取最小值。 对此证明: <a href=\"http://blog.csdn.net/qq_20200047/article/details/71159677\" title=\"http://blog.csdn.net/qq_20200047/article/details/71159677\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20200047/article/details/71159677</a></p>\n<blockquote>\n<p>即可以证明a和b的最大公约数可以写成a和b的线性表示.</p>\n</blockquote>\n</blockquote>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a,LL b){\n    return b ==0?a:gcd(b,a%b);\n}\n\n//求整数x和y,使得ax+by=d,在此前提下|x|+|y|取最小值.\n//即使a,b在int范围内,也可能超出int\nvoid exgcd(LL a,LL b,LL &amp;d,LL &amp;x,LL &amp;y){\n    if(!b){d=a;x=1;y=0;}\n    else {exgcd(b,a%b,d,y,x);y-=x*(a/b);}\n}\n\nint main(){\n\n    return 0;\n}</code></pre><h1 id=\"一些性质\"><a href=\"#一些性质\" class=\"headerlink\" title=\"一些性质\"></a>一些性质</h1><blockquote>\n<p>记(a,b)为gcd(a,b)</p>\n<blockquote>\n<p>则</p>\n<blockquote>\n<p>(a,b)=(b,a) 且 (a,b,c)=((a,b),c)=(a,(b,c))</p>\n</blockquote>\n</blockquote>\n<p>记[a,b]为lcm(a,b)</p>\n<blockquote>\n<p>有同上结论</p>\n</blockquote>\n<p>(a,b)*[a,b]=ab (gcd求lcm的由来)</p>\n</blockquote>\n<h1 id=\"唯一分解定理\"><a href=\"#唯一分解定理\" class=\"headerlink\" title=\"唯一分解定理\"></a>唯一分解定理</h1><blockquote>\n<p>简单说吧,对于任意一个整数,都可以化简成素数次幂乘积的形式.</p>\n</blockquote>\n<h2 id=\"确定正整数n的正约数个数\"><a href=\"#确定正整数n的正约数个数\" class=\"headerlink\" title=\"确定正整数n的正约数个数\"></a>确定正整数n的正约数个数</h2><blockquote>\n<p>由唯一分解定理得到的所有素数的幂可以推出约数个数 设第i个素数的幂为{ai}</p>\n<blockquote>\n<p>count=(a1+1)<em>(a2+1)</em>(a3+1)<em>…</em>(as+1)</p>\n</blockquote>\n</blockquote>\n<h2 id=\"而这玩意也有一个玄学快速分解算法\"><a href=\"#而这玩意也有一个玄学快速分解算法\" class=\"headerlink\" title=\"而这玩意也有一个玄学快速分解算法\"></a>而这玩意也有一个玄学快速分解算法</h2><h3 id=\"Pollard’s-Rho\"><a href=\"#Pollard’s-Rho\" class=\"headerlink\" title=\"Pollard’s Rho\"></a>Pollard’s Rho</h3><blockquote>\n<p>因为目前题目出现的概率很低,所以延迟学习,先学其他的.</p>\n</blockquote>\n<h1 id=\"不定方程\"><a href=\"#不定方程\" class=\"headerlink\" title=\"不定方程\"></a>不定方程</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>变量个数多于方程个数,并且只考虑整数解的方程被称之为不定方程。典型的二元一次不定式形式为ax+by=c,其中a、b、c皆为已知整数,a、b都不为0,x、y为未知数.</p>\n</blockquote>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><blockquote>\n<p>我们清楚以上方程的形式相当于前面提到过的扩展欧几里得式. 以下我们用python中的整除 ‘//‘ 代表数学记号整除 1.二元一次方程ax+by=c有解的充要条件:</p>\n<blockquote>\n<p>(a,b)//c 并且当(a,b)//c的时候该方程等价于</p>\n<blockquote>\n<p>(a/(a,b))*x+(b/(a,b))*y=(c/(a,b))</p>\n</blockquote>\n</blockquote>\n<p>2.假设二元一次不定方程ax+by=c有解,并且x0、y0为方程的一组解,则他的所有解可以表示为:</p>\n<blockquote>\n<p>x=x0-(b/(a,b))*t y=y0+(a/(a,b))*t t为任意整数</p>\n</blockquote>\n<p>3.不定方程非负解 暂略</p>\n</blockquote>\n<h1 id=\"同余方程与欧拉定理\"><a href=\"#同余方程与欧拉定理\" class=\"headerlink\" title=\"同余方程与欧拉定理\"></a>同余方程与欧拉定理</h1><h2 id=\"同余方程\"><a href=\"#同余方程\" class=\"headerlink\" title=\"同余方程\"></a>同余方程</h2><blockquote>\n<p>假设m≠0.若m//(a-b)则称a同余于b模m,记为</p>\n<blockquote>\n<p>a≡b(mod m)</p>\n<blockquote>\n<p>证:</p>\n<blockquote>\n<p>a=rm+d b=km+d a-b=(r-k)m mod m = 0</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"定理1\"><a href=\"#定理1\" class=\"headerlink\" title=\"定理1\"></a>定理1</h3><blockquote>\n<p>a≡b(mod m),当且仅当m//(a-b)</p>\n</blockquote>\n<h3 id=\"定理2\"><a href=\"#定理2\" class=\"headerlink\" title=\"定理2\"></a>定理2</h3><blockquote>\n<p>a≡b(mod m),当且仅当存在整数k,使得a=b+km</p>\n</blockquote>\n<h3 id=\"定理3\"><a href=\"#定理3\" class=\"headerlink\" title=\"定理3\"></a>定理3</h3><blockquote>\n<p>同余关系是等价关系,即满足以下三条:</p>\n<blockquote>\n<ol>\n<li>自反性 a≡a(mod m)</li>\n<li>对称性 a≡b(mod m),b≡a(mod m)</li>\n<li>传递性 a≡b(mod m),b≡c(mod m),则a≡c(mod m)</li>\n</ol>\n</blockquote>\n</blockquote>\n<h3 id=\"※剩余系\"><a href=\"#※剩余系\" class=\"headerlink\" title=\"※剩余系\"></a><strong>※</strong>剩余系</h3><blockquote>\n<p>指对于一个正整数n,一个整数集合中的数mod n所得的余数域.</p>\n</blockquote>\n<h4 id=\"完全剩余系\"><a href=\"#完全剩余系\" class=\"headerlink\" title=\"完全剩余系\"></a>完全剩余系</h4><blockquote>\n<p>如果一个整数集合的剩余系包含 1~n-1 所有n可能的余数,则该剩余系被称为完全剩余系,我们简记为 Zn.</p>\n<blockquote>\n<p>比如 Z6={0,1,2,3,4,5}</p>\n</blockquote>\n</blockquote>\n<h5 id=\"缩系\"><a href=\"#缩系\" class=\"headerlink\" title=\"缩系\"></a>缩系</h5><blockquote>\n<p>指在模n意义下完全剩余系中与n互素的剩余系,简记为Zn*.</p>\n</blockquote>\n<h4 id=\"Zn的同余等价类\"><a href=\"#Zn的同余等价类\" class=\"headerlink\" title=\"Zn的同余等价类\"></a>Zn的同余等价类</h4><blockquote>\n<p>Zn中的每个元素都代表所有与他同余的整数,比如n=5时,Z5中的元素”3”实际上代表了3,3+5,3+10…,所有这些整数除以5的余数都是3.</p>\n<blockquote>\n<p>我们把满足同余关系的所有整数看成一个同余等价类,比如 3,8,13,18 都属于”模5等于3” 这个同余等价类</p>\n</blockquote>\n</blockquote>\n<h4 id=\"※关于取余等式-k-a-b-的一些性质\"><a href=\"#※关于取余等式-k-a-b-的一些性质\" class=\"headerlink\" title=\"※关于取余等式 k=a%b 的一些性质\"></a><strong>※</strong>关于取余等式 k=a%b 的一些性质</h4><h5 id=\"即-a-b-n等-Zn同于等价类意义下四则运算\"><a href=\"#即-a-b-n等-Zn同于等价类意义下四则运算\" class=\"headerlink\" title=\"即(a+b)%n等,Zn同于等价类意义下四则运算\"></a>即(a+b)%n等,Zn同于等价类意义下四则运算</h5><blockquote>\n<p>加法</p>\n<blockquote>\n<p>(a+b)%n = ((a%n)+(b%n))%n</p>\n</blockquote>\n<p>减法</p>\n<blockquote>\n<p>(a-b)%n = ((a%n)-(b%n)+n)%n</p>\n</blockquote>\n<p>乘法</p>\n<blockquote>\n<p>ab%n=(a%n)(b%n)%n</p>\n</blockquote>\n<p>异或</p>\n<blockquote>\n<p>(a^b)%n=((a%n)^b)%n</p>\n</blockquote>\n</blockquote>\n<h4 id=\"※Zn意义下的除法-模乘法的逆、逆元\"><a href=\"#※Zn意义下的除法-模乘法的逆、逆元\" class=\"headerlink\" title=\"※Zn意义下的除法(模乘法的逆、逆元)\"></a><strong>※</strong>Zn意义下的除法(模乘法的逆、<strong>逆元</strong>)</h4><blockquote>\n<p>首先说下用处,通常在大整数 a/b 时,或者 c/d<em>p/x…但最后结果*</em>一定是整数**时,并且对ans%n,为了避免中间除法运算,我们会用逆元(刚开始学,只知道这些用途,如有缺漏,欢迎补充). 那么向下进行吧</p>\n<blockquote>\n<p>模乘法的逆:</p>\n<blockquote>\n<p>在某些情况下 Zn中的两个元素a和b满足 Zn意义下 ab=1,即ab≡1(mod n).比如</p>\n<blockquote>\n<p>在 Z15 中,7*13=1</p>\n<blockquote>\n<p>即(7*13)%15=1</p>\n</blockquote>\n</blockquote>\n<p>在这种情况下,我们称a和b互为乘法的逆,记为 b=a(-1),a=b(-1) [-1代表上标]. 这个逆的运算很像”倒数”,因为在剩余系中,模n意义下当a(-1)存在时,”除以”一个数a等价于乘以他的乘法逆a(-1),比如在 Z15 中 7(-1)=13,因此3/7=3*7(-1)=3*13=9</p>\n<blockquote>\n<p>这时我们会产生疑问,3/7甚至不是整数,怎么可能等于9? 请注意:</p>\n<blockquote>\n<p>1 我们是在模n意义下对除法进行运算. 2 剩余系中每个元素对应一个同余等价类, 3/7=9的实际含义是”假定有两个整数a和b,其中a/b是整数,且a和b除以15的余数分别为3和7,则a/b除以15的余数等于 9”</p>\n<blockquote>\n<p>比如a=528,b=22就是一例</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h5 id=\"除法逆元合理性证明\"><a href=\"#除法逆元合理性证明\" class=\"headerlink\" title=\"除法逆元合理性证明\"></a>除法逆元合理性证明</h5><blockquote>\n<p>设我们要求 （a / b） mod p 且 b * k ≡ 1 (mod p),即k为b的逆元</p>\n<blockquote>\n<p>注意这里我们可以用扩展欧几里得求出是否存在k,以及k的值 即 答案为 (a * k) mod p 因为 b * k ≡ 1 (mod p) 则有 b * k = p* x+1 得到 k = (p * x + 1) / b 将 k 代入(a * k) mod p</p>\n<blockquote>\n<p>得到： (a * (p * x + 1) / b) mod p =((a * p * x) / b + a / b) mod p =[((a * p * x) / b) mod p +(a / b)] mod p =[(p * ((a * x) / b)) mod p +(a / b)] mod p =(0 + (a / b)) mod p = (a/b) mod p</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"定理4\"><a href=\"#定理4\" class=\"headerlink\" title=\"定理4\"></a>定理4</h3><blockquote>\n<p>若a,b,c是整数,m是正整数,且 a≡b(mod m) ,则</p>\n<blockquote>\n<p>(1) a+c ≡ b+c(mod m) (2) a-c ≡ b-c(mod m) (3) ac ≡ bc(mod m)</p>\n</blockquote>\n</blockquote>\n<h3 id=\"定理5\"><a href=\"#定理5\" class=\"headerlink\" title=\"定理5\"></a>定理5</h3><blockquote>\n<p>设a,b,c,d为整数,m为正整数,若a≡b(mod m),c≡d(mod m)则(注: 一下定理两边值不一定相等,只是mod m相等):</p>\n<blockquote>\n<p>(1) ax+cy≡bx+dy(mod m) 其中x,y为任意整数,即同余式可以相加 (2) ac≡bd(mod m) 即同余式可以相乘 (3) a^n≡b^n(mod m) 由上面那个可以推得,n&gt;0 (4) f(a)≡f(b)(mod m) 其中f(x)为任一整数系数多项式</p>\n</blockquote>\n</blockquote>\n<h3 id=\"定理6\"><a href=\"#定理6\" class=\"headerlink\" title=\"定理6\"></a>定理6</h3><blockquote>\n<p>设a,b,c,d为整数,m为正整数,则</p>\n<blockquote>\n<p>(1) 若 a≡b(mod m),且d//m,则a≡b(mod d) (2) 若 a≡b(mod m),则gcd(a,m)≡gcd(b,m) (3) a≡b(mod mi)(1&lt;=i&lt;=n)同时成立,当且仅当 a≡b(mod[m1,m2,m3…mn])</p>\n</blockquote>\n</blockquote>\n<h3 id=\"定理7\"><a href=\"#定理7\" class=\"headerlink\" title=\"定理7\"></a>定理7</h3><blockquote>\n<p>若ac≡bc(mod m),且gcd(c,m)=d,则a≡b(mod m/d) 证:</p>\n<blockquote>\n<p>记 c=dc1,m=dm1,其中c1,m1互素</p>\n<blockquote>\n<p>由 ac≡bc(mod m) 得 m//(ac-bc) 即 dm1//d(a-b)c1 故 m1//(a-b)c1 由下面那个整除的性质,因为 m1,c1 互质 则 m1//(a-b) 得 a≡b(mod m1) 即 a≡b(mod m/d)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"整除的性质\"><a href=\"#整除的性质\" class=\"headerlink\" title=\"整除的性质\"></a>整除的性质</h4><blockquote>\n<p>若m | nk, 且m与k互素, 则m | n</p>\n</blockquote>\n<h1 id=\"欧拉函数\"><a href=\"#欧拉函数\" class=\"headerlink\" title=\"欧拉函数\"></a>欧拉函数</h1><blockquote>\n<p>以前写过一次: 连接: <a href=\"http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/\" title=\"http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/\" target=\"_blank\" rel=\"noopener\">http://be-sunshine.cn/index.php/2017/11/25/aoj-ntl_1_d-eulers-phi-function/</a></p>\n</blockquote>\n","text":"对于这一个知识点的学习,我大概会通过 《ACM国际大学生程序设计竞赛:知识与入门》 以及 lrj的蓝书以及《ACM/ICPC数论及应用》来学习.素数素数筛法艾氏筛法(O(nloglogn))通常使用艾氏筛法,而艾氏筛法的思想也可用于很多地方.线性筛法伪码表述算法: 线性的素数筛法","link":"","raw":null,"photos":[],"categories":[{"name":"数论","slug":"数论","count":1,"path":"api/categories/数论.json"},{"name":"算法学习","slug":"数论/算法学习","count":1,"path":"api/categories/数论/算法学习.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"算法学习","slug":"算法学习","count":6,"path":"api/tags/算法学习.json"}]}]}