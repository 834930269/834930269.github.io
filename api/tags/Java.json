{"name":"Java","slug":"Java","count":21,"postlist":[{"title":"Java 8 默认方法","slug":"java-8-default","date":"2018-01-13T08:27:04.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-8-default.json","excerpt":"","keywords":null,"cover":null,"content":"<p>在之前的学习中,Java 的接口只能声明抽象方法(不写abstract的那种). 但在Java 8 中,接口也可以实现有方法体的方法.被称之为默认方法. 但需要注意,在默认方法中,需要使用 <code>default</code> 关键字. Like this:</p>\n<pre><code>package charactor;\n\npublic interface Mortal {\n    public void die();\n\n    default public void revive() {\n        System.out.println(&quot;本英雄复活了&quot;);\n    }\n}</code></pre>","text":"在之前的学习中,Java 的接口只能声明抽象方法(不写abstract的那种). 但在Java 8 中,接口也可以实现有方法体的方法.被称之为默认方法. 但需要注意,在默认方法中,需要使用 default 关键字. Like this:package charactor;publ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 类与对象","slug":"java-class-object","date":"2018-01-12T12:08:47.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-class-object.json","excerpt":"","keywords":null,"cover":null,"content":"<p>这里仅记录学习过程中与其他语言相差较大的部分.</p>\n<pre><code>//简单类\npublic class Hero {\n    String name;//姓名\n    float hp;//血量\n    float armor;//护甲\n    int moveSpeed;//移动速度\n    // 方法名和类名一样（包括大小写）\n    // 没有返回类型\n    public Hero() {\n        System.out.println(&quot;实例化一个对象的时候，必然调用构造方法&quot;);\n    }\n\n    //构造方法重载\n    //带一个参数的构造方法\n    public Hero(String heroname){ \n        name = heroname;\n    }\n\n    //带两个参数的构造方法\n    public Hero(String heroname,float herohp){ \n        this.name = heroname;\n        this.hp = herohp;\n    }\n\n    //复活\n    //这里一个问题,传进来的引用指向哪个示例?\n    public void revive(Hero h){\n        h = new Hero(&quot;提莫&quot;,383);\n    }\n\n    public static void main(String[] args){\n        //创建一个对象\n        new Hero();\n        //创建一个引用来指向这个对象\n        Hero h = new Hero(&quot;提莫&quot;,383);    \n        //挂了\n        h.hp -=400;\n        //复活\n        h.revive(h);\n        System.out.println(h.hp);\n        //输出 -17.0,证明指向的实例没变\n    }\n}\n\n\n\n//类继承\n//物品类\npublic class Item{\n    String name;\n    int price;\n}\n\n\n\n//武器类,继承Item\npublic class Weapon extends Item{\n    int damage;//攻击力\n    public static void main(String[] args){\n        Weapon  infinityEdge= new Weapon();\n        infinityEdge.damage = 65; //damage属性在类Weapon中新设计的\n\n        infinityEdge.name = &quot;无尽之刃&quot;;//name属性，是从Item中继承来的，就不需要重复设计了\n        infinityEdge.price = 3600;      \n    }\n}</code></pre><p>Java属性初始化与其他相比不同的几个方式: 1.对象属性(实例化后的类)</p>\n<pre><code>//块初始化\n\npackage charactor;\n\npublic class Hero {\n    //直接初始化\n    public String name = &quot;some hero&quot;; //声明该属性的时候初始化\n    protected float hp;\n    //块初始化\n    float maxHP;\n\n    {\n        maxHP = 200; //初始化块\n    }  \n    //构造方法初始化\n    public Hero(){\n        hp = 100; //构造方法中初始化\n    }\n}</code></pre><p>2.类属性初始化</p>\n<pre><code>package charactor;\n\npublic class Hero {\n    public String name;\n    protected float hp;\n    float maxHP;\n\n    //物品栏的容量\n    public static int itemCapacity=8; //声明的时候 初始化\n\n    //通过静态块初始化\n    static{\n        itemCapacity = 6;//静态初始化块 初始化\n    }\n\n    public Hero(){\n\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Hero.itemCapacity);\n    }\n\n}</code></pre>","text":"这里仅记录学习过程中与其他语言相差较大的部分.//简单类public class Hero {    String name;//姓名    float hp;//血量    float armor;//护甲    int moveSpeed;//移动速度    // 方法名和类","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 枚举类","slug":"java-enum","date":"2018-01-12T12:53:52.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-enum.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Enum,也是个类 因为是常量,所以一般大写</p>\n<pre><code>public enum Season {\n    SPRING,SUMMER,AUTUMN,WINTER\n}</code></pre><p>测试:</p>\n<pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        Season season = Season.SPRING;\n        switch (season) {\n        case SPRING:\n            System.out.println(&quot;春天&quot;);\n            break;\n        case SUMMER:\n            System.out.println(&quot;夏天&quot;);\n            break;\n        case AUTUMN:\n            System.out.println(&quot;秋天&quot;);\n            break;\n        case WINTER:\n            System.out.println(&quot;冬天&quot;);\n            break;\n        }\n    }\n}</code></pre><p>可以使用foreach:</p>\n<pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        for (Season s : Season.values()) {\n            System.out.println(s);\n        }\n    }\n}</code></pre>","text":"Enum,也是个类 因为是常量,所以一般大写public enum Season {    SPRING,SUMMER,AUTUMN,WINTER}测试:public class HelloWorld {    public static void main(String[] a","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 接口","slug":"java-interface","date":"2018-01-12T13:20:38.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-interface.json","excerpt":"","keywords":null,"cover":null,"content":"<p>接口(interface)的继承需要使用实现(implements)关键词,可以多继承 首先我们新建一个AD类型英雄的接口:</p>\n<pre><code>package charactor;\n\npublic interface AD {\n    //声明一个接口方法\n    //物理伤害\n    public void physicAttack();\n}</code></pre><p>然后我们新建一个AD英雄:</p>\n<pre><code>package charactor;\n\npublic class ADHero extends Hero implements AD{\n    @Override\n    public void physicAttack(){\n        System.out.print(&quot;进行物理攻击&quot;);\n    }\n}</code></pre><p>然后我们新建一个AP类型英雄的接口:</p>\n<pre><code>package charactor;\n\npublic interface AP {\n    public void magicAttack();\n}</code></pre><p>然后我们实现一个AP英雄:</p>\n<pre><code>package charactor;\n\npublic class APHero extends Hero implements AP{\n    @Override\n    public void magicAttack(){\n        System.out.println(&quot;魔法攻击&quot;);\n    }\n}</code></pre><p>然后我们实现一个既可以魔法攻击,又可以物理攻击的英雄:</p>\n<pre><code>package charactor;\n\npublic class ADAPHero extends Hero implements AD,AP{\n    @Override\n    public void physicAttack(){\n        System.out.println(&quot;物理攻击&quot;);\n    }\n    public void magicAttack(){\n        System.out.println(&quot;魔法攻击&quot;);\n    }\n}</code></pre>","text":"接口(interface)的继承需要使用实现(implements)关键词,可以多继承 首先我们新建一个AD类型英雄的接口:package charactor;public interface AD {    //声明一个接口方法    //物理伤害    public void","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 包","slug":"java-package","date":"2018-01-12T12:24:34.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-package.json","excerpt":"","keywords":null,"cover":"http://stepimagewm.how2j.cn/612.png","content":"<p>首先我在这里贴一下四种修饰词的作用域: <a href=\"http://stepimagewm.how2j.cn/612.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://stepimagewm.how2j.cn/612.png\" alt></a> 比如我们将hero类放在 <code>包</code>:<code>charactor</code> 下</p>\n<pre><code>package charactor;\n\npublic class Hero {\n\n    String name; //姓名\n\n    float hp; //血量\n\n    float armor; //护甲\n\n    int moveSpeed; //移动速度\n\n    public Hero(){\n\n    }\n\n    public Hero(String name,float hp){\n        this.name = name;\n        this.hp = hp;\n    }\n\n    //复活\n    public void revive(Hero h){\n        h = new Hero(&quot;提莫&quot;,383);\n    }\n}</code></pre><p>我们将武器放在 <code>包</code>:<code>property</code> 中:</p>\n<pre><code>//Item.java\npackage property;\n\n//类继承\n//物品类\npublic class Item{\n    String name;\n    int price;\n}\n\n//Weapon.java\npackage property;\n\npublic class Weapon extends Item{\n    int damage;//攻击力\n}</code></pre><p>当你想引用其他包中的类时,需要使用 <code>import</code> <code>包名.类名</code></p>\n<pre><code>package charactor;\n//Weapon类在其他包里，使用必须进行import\nimport property.Weapon;\n\npublic class Hero {\n\n    String name; //姓名\n\n    float hp; //血量\n\n    float armor; //护甲\n\n    int moveSpeed; //移动速度\n\n    public Hero(){\n\n    }\n\n    public Hero(String name,float hp){\n        this.name = name;\n        this.hp = hp;\n    }\n\n    //复活\n    public void revive(Hero h){\n        h = new Hero(&quot;提莫&quot;,383);\n    }\n    //装备一把武器\n    public void equip(Weapon w){\n\n    }\n}</code></pre><h1 id=\"包与包之间的关系\"><a href=\"#包与包之间的关系\" class=\"headerlink\" title=\"包与包之间的关系\"></a>包与包之间的关系</h1><p><a href=\"http://stepimagewm.how2j.cn/605.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://stepimagewm.how2j.cn/605.png\" alt></a> 类和类之间的关系有如下几种: 以Hero为例 自身：指的是Hero自己 同包子类：ADHero这个类是Hero的子类，并且和Hero处于同一个包下 不同包子类：Support这个类是Hero的子类，但是在另一个包下 同包类： GiantDragon 这个类和Hero是同一个包，但是彼此没有继承关系 其他类：Item这个类，在不同包，也没有继承关系的类</p>\n","text":"首先我在这里贴一下四种修饰词的作用域:  [Figure]  类和类之间的关系有如下几种: 以Hero为例 自身：指的是Hero自己 同包子类：ADHero这个类是Hero的子类，并且和Hero处于同一个包下 不同包子类：Support这个类是Hero的子类，但是在另一个包下 同","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java 单例模式","slug":"java-singleton","date":"2018-01-12T12:45:47.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-singleton.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"1-饿汉式单例模式\"><a href=\"#1-饿汉式单例模式\" class=\"headerlink\" title=\"1.饿汉式单例模式\"></a>1.<code>饿汉式</code>单例模式</h1><h4 id=\"GiantDragon-应该只有一只，通过私有化其构造方法，使得外部无法通过new-得到新的实例。\"><a href=\"#GiantDragon-应该只有一只，通过私有化其构造方法，使得外部无法通过new-得到新的实例。\" class=\"headerlink\" title=\"GiantDragon 应该只有一只，通过私有化其构造方法，使得外部无法通过new 得到新的实例。\"></a>GiantDragon 应该只有一只，通过<code>私有化其构造方法</code>，使得外部无法通过new 得到新的实例。</h4><h4 id=\"GiantDragon-提供了一个public-static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。-从而达到单例的目的。\"><a href=\"#GiantDragon-提供了一个public-static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。-从而达到单例的目的。\" class=\"headerlink\" title=\"GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 从而达到单例的目的。\"></a>GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 从而达到单例的目的。</h4><h4 id=\"这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例\"><a href=\"#这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例\" class=\"headerlink\" title=\"这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例\"></a>这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例</h4><pre><code>package charactor;\n\npublic class GiantDragon {\n\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){\n\n    }\n\n    //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个\n\n    private static GiantDragon instance = new GiantDragon();\n\n    //public static 方法，提供给调用者获取12行定义的对象\n    public static GiantDragon getInstance(){\n        return instance;\n    }\n\n}</code></pre><p>测试:</p>\n<pre><code>package charactor;\n\npublic class TestGiantDragon {\n\n    public static void main(String[] args) {\n        //通过new实例化会报错\n//      GiantDragon g = new GiantDragon();\n\n        //只能通过getInstance得到对象\n\n        GiantDragon g1 = GiantDragon.getInstance();\n        GiantDragon g2 = GiantDragon.getInstance();\n        GiantDragon g3 = GiantDragon.getInstance();\n\n        //都是同一个对象\n        System.out.println(g1==g2);\n        System.out.println(g1==g3);\n    }\n}</code></pre><h1 id=\"2-懒汉式单例模式\"><a href=\"#2-懒汉式单例模式\" class=\"headerlink\" title=\"2.懒汉式单例模式\"></a>2.<code>懒汉式</code>单例模式</h1><h4 id=\"懒汉式单例模式与饿汉式单例模式不同，只有在调用getInstance的时候，才会创建实例\"><a href=\"#懒汉式单例模式与饿汉式单例模式不同，只有在调用getInstance的时候，才会创建实例\" class=\"headerlink\" title=\"懒汉式单例模式与饿汉式单例模式不同，只有在调用getInstance的时候，才会创建实例\"></a>懒汉式单例模式与饿汉式单例模式不同，只有在调用getInstance的时候，才会创建实例</h4><pre><code>package charactor;\n\npublic class GiantDragon {\n\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){       \n    }\n\n    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null\n    private static GiantDragon instance;\n\n    //public static 方法，返回实例对象\n    public static GiantDragon getInstance(){\n        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象\n        if(null==instance){\n            instance = new GiantDragon();\n        }\n        //返回 instance指向的对象\n        return instance;\n    }\n\n}</code></pre><p>测试:</p>\n<pre><code>package charactor;\n\npublic class TestGiantDragon {\n\n    public static void main(String[] args) {\n        //通过new实例化会报错\n//      GiantDragon g = new GiantDragon();\n\n        //只能通过getInstance得到对象\n\n        GiantDragon g1 = GiantDragon.getInstance();\n        GiantDragon g2 = GiantDragon.getInstance();\n        GiantDragon g3 = GiantDragon.getInstance();\n\n        //都是同一个对象\n        System.out.println(g1==g2);\n        System.out.println(g1==g3);\n    }\n}</code></pre><h3 id=\"单例模式三要素\"><a href=\"#单例模式三要素\" class=\"headerlink\" title=\"单例模式三要素:\"></a>单例模式三要素:</h3><p>这个是面试的时候经常会考的点，面试题通常的问法是: 什么是单例模式？ 回答的时候，要答到三元素 1. 构造方法私有化 2. 静态属性指向实例 3. public static的 getInstance方法，返回第二步的静态属性</p>\n","text":"1.饿汉式单例模式GiantDragon 应该只有一只，通过私有化其构造方法，使得外部无法通过new 得到新的实例。GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java STL & JDK8 聚合","slug":"java-stl-jdk8-juhe","date":"2018-01-17T03:01:17.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-stl-jdk8-juhe.json","excerpt":"","keywords":null,"cover":null,"content":"<p>JDK8的聚合和C#的Fluent API基本一样,每次操作后返回的类型和之前的一样,股可以继续操作. 至于STL,和C++比一下就是一些单词不一样罢了. 排序时需要实现Comparable接口. 这节水过去= =. 其中泛型如果需要支持一个类的子类.需要这样写. 使用<code>? extends 类型</code>名.</p>\n<pre><code>ArrayList&lt;? extends Hero&gt; heroList = apHeroList;</code></pre><p>泛型通配符: <code>?</code></p>\n","text":"JDK8的聚合和C#的Fluent API基本一样,每次操作后返回的类型和之前的一样,股可以继续操作. 至于STL,和C++比一下就是一些单词不一样罢了. 排序时需要实现Comparable接口. 这节水过去= =. 其中泛型如果需要支持一个类的子类.需要这样写. 使用? ext","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java Throwable","slug":"java-throwable","date":"2018-01-15T02:32:48.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-throwable.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/742.png","content":"<p>Throwable是个接口.用于定义异常和error的类. 异常分为两类: error和exception. exception里又分 运行时异常,可查异常 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/742.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/742.png\" alt></a> throws 和 throw两个关键词,第一个经常出现在函数声明中. 自定义异常:</p>\n<pre><code>class 类名 extends Exception{\n\n    public 类名(){\n\n    }\n    public 类名(String msg){\n        super(msg);\n    }\n}</code></pre>","text":"Throwable是个接口.用于定义异常和error的类. 异常分为两类: error和exception. exception里又分 运行时异常,可查异常  [Figure]  throws 和 throw两个关键词,第一个经常出现在函数声明中. 自定义异常:class 类名 ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"深入分析Java Web技术内幕-第二章","slug":"javaweb-two","date":"2018-06-21T07:28:30.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/javaweb-two.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/06/1ad8ecc702cf83a89ac412c4e586aed3.png","content":"<h1 id=\"深入分析Java-I-O机制\"><a href=\"#深入分析Java-I-O机制\" class=\"headerlink\" title=\"深入分析Java I/O机制\"></a>深入分析Java I/O机制</h1><h2 id=\"Java-I-O类库的基础架构\"><a href=\"#Java-I-O类库的基础架构\" class=\"headerlink\" title=\"Java I/O类库的基础架构\"></a>Java I/O类库的基础架构</h2><p>类库大概分为四组:</p>\n<blockquote>\n<p>基于字节操作的I/O接口:InputStream 和 OutputStream 基于字符操作的I/O接口: Writer和Reader 基于磁盘操作的I/O接口: File 基于网络操作的I/O接口: Socket (这尼玛也能划到一起,不过这样好像也行)</p>\n</blockquote>\n<h2 id=\"基于字节的I-O操作接口\"><a href=\"#基于字节的I-O操作接口\" class=\"headerlink\" title=\"基于字节的I/O操作接口\"></a>基于字节的I/O操作接口</h2><blockquote>\n<p>InputStream</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/1ad8ecc702cf83a89ac412c4e586aed3.png\" alt></p>\n<blockquote>\n<p>OutputStream</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/268a47ba3edf2add83c46b8f5a2a5342.png\" alt></p>\n<blockquote>\n<blockquote>\n<p>详见JDK API.</p>\n</blockquote>\n</blockquote>\n<p>Tip: 操作数据可以组合使用-&gt;某流转某流 OutputStream out=new PipeOutputStream(new ObjectOutputStream(new FileOutputStream(“fileName”))); 还有一点是一定要制定流最终要写到哪里</p>\n<h2 id=\"基于字符的I-O操作接口\"><a href=\"#基于字符的I-O操作接口\" class=\"headerlink\" title=\"基于字符的I/O操作接口\"></a>基于字符的I/O操作接口</h2><blockquote>\n<p>I/O接口一般都是字节流,但是为了方便起见,也有字符流.</p>\n</blockquote>\n<p><strong>字符到字节必须经过编码转换,而编码很耗时</strong></p>\n<blockquote>\n<p>写字符接口以及涉及到的类</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/d1c5a427e25d73e1ea7d0e04af57c65f.png\" alt> Writer类提供了一个抽象接口:Write(char cbuf[],int off,int len)</p>\n<blockquote>\n<p>读字符</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/0b3cd200a1da4d54aaa17d095e16cf42.png\" alt> int Read(char cbuf[],int off,int len) 返回读到的n个字节数 他们只规定了读取和写入的方式,但没有规定读和写到哪里去.</p>\n<h2 id=\"字节与字符的转化接口\"><a href=\"#字节与字符的转化接口\" class=\"headerlink\" title=\"字节与字符的转化接口\"></a>字节与字符的转化接口</h2><blockquote>\n<p>数据持久化或网络传输都是以字节进行的，所以必要有对应的接口</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/8aa6ff0a0ffe1b15ad470370844d78b5.png\" alt> InputStreamReader是<strong>字节到字符</strong>的桥梁,InputStream到Reader的过程<strong>要指定编码字符集</strong>,否则将采用操作系统默认字符集,很可能会出现乱码. StreamDecoder是<strong>字节到字符</strong>解码的实现类. StreamEncoder类似 <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f38fb77be5e4351910897b9df42403e3.png\" alt></p>\n<h2 id=\"磁盘I-O工作机制\"><a href=\"#磁盘I-O工作机制\" class=\"headerlink\" title=\"磁盘I/O工作机制\"></a>磁盘I/O工作机制</h2><h3 id=\"应用程序访问文件的几种方式\"><a href=\"#应用程序访问文件的几种方式\" class=\"headerlink\" title=\"应用程序访问文件的几种方式\"></a>应用程序访问文件的几种方式</h3><p>read()和write()这两个是系统调用. 系统调用可能会存在内核空间地址和用户空间地址切换的问题,这是操作系统为了保护系统本身的运行安全而将<strong>内核程序运行使用的内存空间和用户活动使用的内核空间隔离</strong>,但是这样虽然保证了内核程序运行的安全性,但是也必然存在<strong>时间耗费的问题</strong> 磁盘I/O非常缓慢,所以操作系统使用了缓存的机制.</p>\n<h4 id=\"标准访问文件方式\"><a href=\"#标准访问文件方式\" class=\"headerlink\" title=\"标准访问文件方式\"></a>标准访问文件方式</h4><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/6de33c5d864a218b1d3a0fe38565f411.png\" alt></p>\n<h4 id=\"直接I-O方式\"><a href=\"#直接I-O方式\" class=\"headerlink\" title=\"直接I/O方式\"></a>直接I/O方式</h4><blockquote>\n<p>直接IO就是直接访问磁盘数据,来减少从内和缓冲区到用户活动区的复制.</p>\n<blockquote>\n<p>这种思想常用于 由应用实现的数据库管理系统. 提前将热点数据加入内存,可以加速数据的访问速度.</p>\n</blockquote>\n<p>但操作系统并不知道哪些是热点数据,所以直接I/O也有负面影响.而我们一般将异步IO和直接IO结合使用.</p>\n</blockquote>\n<p>直接IO方式如图(没有穿过高速页缓存): <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/74d178a897ed7f8fd8ba0439ccaceba1.png\" alt></p>\n<h4 id=\"同步访问文件方式\"><a href=\"#同步访问文件方式\" class=\"headerlink\" title=\"同步访问文件方式\"></a>同步访问文件方式</h4><blockquote>\n<p>即读取与写入都是同步操作的.</p>\n</blockquote>\n<p>但他的标志是:<strong>只有写入完成才是成功的标志</strong> 性能较差</p>\n<h4 id=\"异步访问文件方式\"><a href=\"#异步访问文件方式\" class=\"headerlink\" title=\"异步访问文件方式\"></a>异步访问文件方式</h4><blockquote>\n<p>异步访问就是,当访问数据的线程发出请求后,线程会继续去处理其它事情,而不是阻塞等待,当请求的数据返回后再继续处理接下来的操作.</p>\n</blockquote>\n<p>这种方式可以明显的提高应用程序的效率,但并不会改变访问文件的效率. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/423d961b94b4779ba7212af4db51017c.png\" alt></p>\n<h4 id=\"内存映射方式\"><a href=\"#内存映射方式\" class=\"headerlink\" title=\"内存映射方式\"></a>内存映射方式</h4><blockquote>\n<p>将操作系统某一块区域与磁盘中的文件关联起来,增加缓冲区的个数,减少缓冲区-&gt;用户活动区的复制操作</p>\n</blockquote>\n<p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/246dcd50203f24f93da00714daae2db3.png\" alt></p>\n<h3 id=\"Java访问磁盘文件\"><a href=\"#Java访问磁盘文件\" class=\"headerlink\" title=\"Java访问磁盘文件\"></a>Java访问磁盘文件</h3><p>接下来我们来讨论数据的流向</p>\n<h4 id=\"数据持久化到磁盘\"><a href=\"#数据持久化到磁盘\" class=\"headerlink\" title=\"数据持久化到磁盘\"></a>数据持久化到磁盘</h4><p>数据在磁盘中唯一<strong>最小描述</strong>就是<strong>文件</strong>. 文件也是操作系统和磁盘驱动器交互的<strong>最小单元</strong> Java中的File<strong>并不代表一个真实存在的对象</strong>.而是一个路径和虚拟对象. 因为我们更多关心的是操作,而不是整个文件. <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/76a6f5098ea16378295a325a05064602.png\" alt> 从磁盘中读取文件流程: <img src=\"http://be-sunshine.cn/wp-content/uploads/2018/06/f6b5aefd246cf978ed0563d0f999191e.png\" alt></p>\n<ul>\n<li>先创建一个FileDescriptor对象</li>\n<li>然后创建FileInputStream</li>\n<li>因为要读取的是字符格式,所以需要StreamDecoder类将byte解码为char格式…</li>\n</ul>\n","text":"深入分析Java I/O机制Java I/O类库的基础架构类库大概分为四组:基于字节操作的I/O接口:InputStream 和 OutputStream 基于字符操作的I/O接口: Writer和Reader 基于磁盘操作的I/O接口: File 基于网络操作的I/O接口: S","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"技术","slug":"Java/技术","count":1,"path":"api/categories/Java/技术.json"}],"tags":[{"name":"技术","slug":"技术","count":14,"path":"api/tags/技术.json"},{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 1st","slug":"lets-gank-java-1st","date":"2017-11-12T08:51:22.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-1st.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Graphical interfaces Output and Input.</p>\n<pre><code>import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AppGraphInOut{\n    public static void main(String args[]){\n        new AppFrame();\n    }\n}\nclass AppFrame extends JFrame\n{\n    JTextField in = new JTextField(10);\n    JButton btn = new JButton(&quot;求平方&quot;);\n    JLabel out = new JLabel(&quot;用于显示结果的标签&quot;);\n\n    public AppFrame(){\n        setLayout(new FlowLayout());\n        getContentPane().add(in);\n        getContentPane().add(btn);\n        getContentPane().add(out);\n        btn.addActionListener(new BtnActionAdapter());\n        //事件监听对象\n        setSize(400,100);\n        setDefaultCloseOperation(DISPOSE_ON_CLOSE);\n        setVisible(true);\n    }\n    class BtnActionAdapter implements ActionListener\n    {\n        public void actionPerformed(ActionEvent e){\n            String s = in.getText();\n            double d = Double.parseDouble(s);\n            double sq = d*d;\n            out.setText(d+&quot;的平方是: &quot;+sq);\n        }\n    }\n}</code></pre><p><code>implements</code> is meaning interface. Your need to implement a method - <code>actionPerformed(ActionEvent e)</code> in this interface. <code>getContentPane</code> is Window object?(Maybe…) 2st <code>Java8 : Lambda</code> You can use lambda expression to solve it.</p>\n<pre><code>import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AppGraphInOut{\n    public static void main(String args[]){\n        new AppFrame();\n    }\n}\nclass AppFrame extends JFrame\n{\n    JTextField in = new JTextField(10);\n    JButton btn = new JButton(&quot;求平方&quot;);\n    JLabel out = new JLabel(&quot;用于显示结果的标签&quot;);\n\n    public AppFrame(){\n        setLayout(new FlowLayout());\n        getContentPane().add(in);\n        getContentPane().add(btn);\n        getContentPane().add(out);\n        btn.addActionListener(e-&gt;{\n            String s = in.getText();\n            double d = Double.parseDouble(s);\n            double sq = d*d;\n            out.setText(d+&quot;的平方是: &quot;+sq);\n        });\n        setSize(400,100);\n        setDefaultCloseOperation(DISPOSE_ON_CLOSE);\n        setVisible(true);\n    }\n}</code></pre>","text":"Graphical interfaces Output and Input.import java.awt.*;import java.awt.event.*;import javax.swing.*;public class AppGraphInOut{    public s","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 2st","slug":"lets-gank-java-2st","date":"2017-11-12T09:44:14.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-2st.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Bitwise Operation.</p>\n<pre><code>public class BitwiseOperators\n{\n    public static void main(String args[]){\n        int a = 0b1100;//二进制\n        int b = 0b1010;\n        print(&quot;a  &quot;,a);\n        print(&quot;a&amp;b&quot;,a&amp;b);\n        print(&quot;a|b&quot;,a|b);\n        print(&quot;a^b&quot;,a^b);\n        print(&quot;~a&quot;,~a);\n        print(&quot;a&lt;&lt;2&quot;,a&lt;&lt;2);\n        print(&quot;a&gt;&gt;2&quot;,a&gt;&gt;2);\n        print(&quot;无符号移位运算: a&gt;&gt;&gt;2&quot;,a&gt;&gt;&gt;2);\n    }\n    static void print(String prefix,int n){\n        String s = Integer.toBinaryString(n);//转二进制\n        while(s.length()&lt;4) s=&quot;0&quot;+s;//补0\n        System.out.println(prefix+&quot; &quot;+s);\n    }\n}</code></pre><p><code>&gt;&gt;&gt;</code> means unsigned bitwise operation.</p>\n","text":"Bitwise Operation.public class BitwiseOperators{    public static void main(String args[]){        int a = 0b1100;//二进制        int b = 0b101","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 3st","slug":"lets-gank-java-3st","date":"2017-11-12T12:13:01.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-3st.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171112201102.jpg","content":"<p>Draw Circle.</p>\n<pre><code>import java.awt.*;\nimport javax.swing.*;\n\npublic class Circle99 extends JFrame{\n    public static void main(String args[]){\n        JFrame frame = new Circle99();\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(600,600);\n        frame.setVisible(true);\n    }\n    public void paint(Graphics g){\n        g.drawString(&quot;circle 99&quot;,20,20);\n        int x0=getSize().width&gt;&gt;1;\n        int y0=getSize().height&gt;&gt;1;\n\n        for(int r=0;r&lt;getSize().height/2;r+=10){\n            g.drawOval(x0,y0,r*2,r*2);//前两个参数是圆左上角的坐标\n        }\n        for(int r=0;r&lt;getSize().height/2;r+=10){\n            g.drawOval(0,0,r*2,r*2);\n        }\n    }\n}</code></pre><h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ截图20171112201102.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171112201102.jpg\" alt></a></p>\n","text":"Draw Circle.import java.awt.*;import javax.swing.*;public class Circle99 extends JFrame{    public static void main(String args[]){        J","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 4st","slug":"lets-gank-java-4","date":"2017-11-15T05:28:57.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-4.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Throw Exception.</p>\n<pre><code>public class ExceptionForNumber\n{\n    private static String output=&quot;&quot;;\n    public static void main(String[] args){\n        foo(1);//exceptionally\n        System.out.println(output);\n        output=&quot;&quot;;\n        foo(0);//normal\n        System.out.println(output);\n    }\n\n    public static void foo(int i){\n        try{\n            if(i==1){\n                throw new Exception();\n            }\n            output+=&quot;1&quot;;\n        }catch(Exception e){\n            output+=&quot;2&quot;;\n            return;\n        }finally{\n            output+=&quot;3&quot;;\n        }\n        output+=&quot;4&quot;;\n    }\n}</code></pre><p>For instance, <code>foo(0)</code> result is <code>&quot;134&quot;</code> and <code>foo(1)</code> is <code>&quot;23&quot;</code>.</p>\n","text":"Throw Exception.public class ExceptionForNumber{    private static String output=&quot;&quot;;    public static void main(String[] args){   ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 6st","slug":"lets-gank-java-6st","date":"2017-11-17T13:14:56.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-6st.json","excerpt":"","keywords":null,"cover":null,"content":"<p>We can use the typeof <em>string</em> to instance a <em>object</em>. Demo</p>\n<pre><code>import java.util.*;\npublic class GeneraicMethod {\n    public static void main(String[] args){\n        Date date=BeanUtil.getInstance(&quot;java.util.Date&quot;);\n        System.out.println(date);\n    }\n\n}\n\nclass BeanUtil{//泛型方法\n    //&lt;T&gt; T 反馈类型//参数用到的T都需要放在函数前面\n    public static &lt;T&gt; T getInstance( String clzName ){\n        try{\n            Class c = Class.forName(clzName);\n            return (T) c.newInstance();\n        }\n        catch(ClassNotFoundException ex){}\n        catch (InstantiationException ex){}\n        catch (IllegalAccessException ex){}\n        return null;\n    }\n}</code></pre><p>Demo2</p>\n<pre><code>import java.util.*;\npublic class GenericTreeClass {\n    public static void main(String[] args){\n        TNode&lt;String&gt; t = new TNode&lt;&gt;(&quot;Roo&quot;);\n        t.add(&quot;Left&quot;); t.add(&quot;Middle&quot;);\n        t.getChild(0).add(&quot;aaa&quot;);\n        t.getChild(0).add(&quot;bbb&quot;);\n        t.traverse();\n    }\n}\n\nclass TNode&lt;T&gt;{\n    private T value;\n    private ArrayList&lt;TNode&lt;T&gt;&gt; children = new ArrayList&lt;&gt;();\n\n    TNode(T v){ this.value= v; }//构造函数\n    public T getValue(){\n        return this.value;\n    }\n    public void add(T v){\n        TNode&lt;T&gt; child=new TNode&lt;&gt;(v);\n        this.children.add(child);\n    }\n    public TNode&lt;T&gt; getChild(int i){\n        if((i&lt;0) || (i&gt;this.children.size())) return null;\n        return (TNode&lt;T&gt;)this.children.get(i);\n    }\n    public void traverse() {\n        //查找所有\n        System.out.println(this.value);\n        for (TNode child : this.children)\n            child.traverse();\n    }\n}</code></pre><p>Generaic Method Limitation.</p>\n<pre><code>reverse&lt;List&lt;?&gt; list&gt;//限定为Object(无限定)\naddAll(Collection&lt;? extends E&gt; col)//extends\nfill(List&lt;? super T&gt; list,T obj)//super</code></pre>","text":"We can use the typeof string to instance a object. Demoimport java.util.*;public class GeneraicMethod {    public static void main(String[] ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 5st","slug":"lets-gank-java-5st","date":"2017-11-15T09:27:26.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-5st.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171115171542.jpg","content":"<p>1.String Methods</p>\n<pre><code>class TestStringMethod\n{\n    public static void main(String[] args) \n    {\n        String s = new String( &quot;Hello World&quot; );\n\n        System.out.println( s.length() );\n        System.out.println( s.indexOf(&apos;o&apos;) );\n        System.out.println( s.indexOf(&quot;He&quot;) );\n        System.out.println( s.startsWith(&quot;He&quot;) );\n        System.out.println( s.equals(&quot;Hello world&quot;) );\n        System.out.println( s.equalsIgnoreCase(&quot;Hello world&quot;) );\n        System.out.println( s.compareTo(&quot;Hello Java&quot;) );\n        System.out.println( s.charAt(1) );\n        System.out.println( s.substring(0,2) );\n        System.out.println( s.substring(2) );\n        System.out.println( s.concat(&quot;!!!&quot;) );\n        System.out.println( s.trim() );\n        System.out.println( s.toUpperCase() );\n        System.out.println( s.toLowerCase() );\n        System.out.println( s.replace(&apos;o&apos;, &apos;x&apos; ) );\n\n        System.out.println( s );  //注意，s本身没有改变\n    }\n}</code></pre><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ截图20171115171542.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/QQ%E6%88%AA%E5%9B%BE20171115171542.jpg\" alt></a> 比较字符串相加和直接将字符串添加至尾部的时间: 第一个是字符串相加,在Java中,每次字符串相加都会生成一个StringBuilder,再append,最后tostring(). 而第二种方法直接append(),tostring().</p>\n<pre><code>import java.util.*;\nclass StringAndStringBuffer \n{\n    public static void main(String[] args) \n    {\n        String a = &quot;a&quot;;\n        String s = &quot;&quot;;\n        StringBuffer sb = new StringBuffer();\n\n        final int N = 10000;\n\n        long t0 = System.currentTimeMillis();\n        for( int i=0; i&lt;N; i++) s+=a;//每次相加都会新生成一个StringBuffer类\n        long t1 = System.currentTimeMillis();\n        for( int i=0; i&lt;N; i++) sb.append(a);//不生成SB类\n        long t2 = System.currentTimeMillis();\n\n        System.out.println(t1-t0);\n        System.out.println(t2-t1);\n    }\n}</code></pre><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/518.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/518.jpg\" alt></a> StringTokenizer(字符串截取) <code>st.hasMoreTokens()</code>:存在下一个子串 <code>st.nextToken()</code>:下一个子串 <code>Double.parseDouble(string);</code>:将string转换为double 基本用法<code>StringTokenizer st = new StringTokenizer(string, 格式化字符(比如&quot; &quot;));</code></p>\n<pre><code>import java.util.*;\nclass TestStringTokenizer \n{\n    public static void main(String[] args) \n    {\n        StringTokenizer st = new StringTokenizer(&quot;this is a test&quot;, &quot; &quot;);\n        while (st.hasMoreTokens()) {\n            System.out.println(st.nextToken());\n        }\n        st = new StringTokenizer(&quot;253,197,546&quot;, &quot;,&quot;);\n        double sum = 0;\n        while (st.hasMoreTokens()) {\n            sum += Double.parseDouble(st.nextToken());\n        }\n        System.out.println( sum );\n    }\n}</code></pre><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/522.jpg\" alt=\"http://be-sunshine.cn/wp-content/uploads/2017/11/522.jpg\"></p>\n","text":"1.String Methodsclass TestStringMethod{    public static void main(String[] args)     {        String s = new String( &quot;Hello World&quot","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 7st","slug":"lets-gank-java-7st","date":"2017-11-17T14:09:00.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-7st.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/%E6%8D%95%E8%8E%B7-1.png","content":"<p>Action : Thread Unit. Demo:</p>\n<pre><code>import java.util.*;\nimport java.text.*;\npublic class ThreadDemo {\n    public static void main(String[] args){\n        Counter c1 = new Counter(1);\n        Thread t1=new Thread(c1);\n        Thread t2=new Thread(c1);\n        Thread t3=new Thread(c1);\n        Counter c2=new Counter(2);\n        Thread t4=new Thread(c2);\n        Thread t5=new Thread(c2);\n        Thread t6=new Thread(c2);\n        TimeDisplay timer = new TimeDisplay();\n        Thread t7 = new Thread(timer);\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        t6.start();\n        t7.start();\n    }\n}\n\nclass Counter implements Runnable{\n    int id;\n    Counter(int id){//构造函数,为count指定id\n        this.id = id;\n    }\n\n    public void run(){//重写runnable的run()\n        int i=0;\n        while(i++&lt;10){\n            System.out.println(&quot;ID: &quot;+id+&quot; No.&quot; + i);\n            try{\n                Thread.sleep(10);\n            }catch(InterruptedException e){}\n        }\n    }\n}\n\nclass TimeDisplay implements Runnable{\n    public void run(){//重写runnable的run()\n        int i=0;\n        while(i++&lt;=3){\n            System.out.println(\n                    new SimpleDateFormat().format(new Date()));\n            try{\n                Thread.sleep(40);\n            }catch(InterruptedException e){}\n        }\n    }\n}</code></pre><p>Output:</p>\n<pre><code>ID: 1 No.1\nID: 1 No.1\nID: 2 No.1\nID: 2 No.1\nID: 2 No.1\nID: 1 No.1\nID: 2 No.2\nID: 1 No.2\nID: 2 No.2\nID: 1 No.2\nID: 1 No.2\nID: 2 No.2\nID: 2 No.3\nID: 1 No.3\nID: 2 No.3\nID: 1 No.3\nID: 1 No.3\nID: 2 No.3\nID: 1 No.4\nID: 2 No.4\nID: 2 No.4\nID: 1 No.4\nID: 1 No.4\nID: 2 No.4\nID: 2 No.5\nID: 1 No.5\nID: 1 No.5\nID: 1 No.5\nID: 2 No.5\nID: 2 No.5\nID: 1 No.6\nID: 1 No.6\nID: 1 No.6\nID: 2 No.6\nID: 2 No.6\nID: 2 No.6\nID: 1 No.7\nID: 1 No.7\nID: 2 No.7\nID: 1 No.7\nID: 2 No.7\nID: 2 No.7\nID: 1 No.8\nID: 2 No.8\nID: 2 No.8\nID: 1 No.8\nID: 1 No.8\nID: 2 No.8\n17-11-18 下午1:50\nID: 1 No.9\nID: 2 No.9\nID: 1 No.9\nID: 1 No.9\nID: 2 No.9\nID: 2 No.9\nID: 2 No.10\nID: 1 No.10\nID: 2 No.10\nID: 1 No.10\nID: 1 No.10\nID: 2 No.10\n17-11-18 下午1:50\n17-11-18 下午1:50\n17-11-18 下午1:50</code></pre><p>可以看到他们并不是一个运行完才继续运行下一个的.这就是多线程. Demo 2: 多线程下载文件</p>\n<pre><code>import java.util.*;\nimport java.io.*;\nimport java.net.*;\npublic class ThreadDownload {\n    public static void main(String[] args)\n        throws IOException\n    {\n        //网址变量\n        final URL[] urls = {\n                new URL(&quot;http://www.pku.edu.cn&quot;),\n                new URL(&quot;http://www.baidu.com&quot;),\n                new URL(&quot;http://www.sina.com.cn&quot;),\n                new URL(&quot;http://www.dstang.com&quot;)\n        };\n        //下载完成后存储的文件名\n        final String[] files = {\n                &quot;pku.htm&quot;, \n                &quot;baidu.htm&quot;,\n                &quot;sina.htm&quot;, \n                &quot;study.htm&quot;,\n        };\n\n        for(int i=0;i&lt;urls.length;++i){\n            final int idx=i;\n            new Thread(()-&gt;{\n                try{\n                    System.out.println(urls[idx]);\n                    download( urls[idx], files[idx]);\n                }catch(Exception ex){\n                    ex.printStackTrace();\n                }\n            }).start();\n        }\n    }\n    static void download(URL url,String file)\n        throws IOException\n    {\n        //创建度入流和写入文件流\n        try(InputStream input=url.openStream();\n            OutputStream output = new FileOutputStream(\n            file))\n        {\n            //每次存入的byte数组\n            byte[] data = new byte[1024];\n            int length;\n            //存入，第二个参数offset表示从data的下标为几开始写入\n            while((length=input.read(data))!=-1){\n                output.write(data, 0, length);\n            }\n        }\n    }\n}</code></pre><p>Output:</p>\n<pre><code>http://www.pku.edu.cn\nhttp://www.baidu.com\nhttp://www.sina.com.cn\nhttp://www.dstang.com\n\n文件在主目录下.</code></pre><p>Demo 3: 多线程画图 结果图: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/捕获-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/%E6%8D%95%E8%8E%B7-1.png\" alt></a> Code:</p>\n<pre><code>import java.awt.*;\nimport java.applet.*;\nimport java.awt.event.*;\nimport javax.swing.*;\npublic class ThreadDrawJ extends JFrame {\n    MovingShape [] shapes;\n    public void init(){\n        setLayout(null);\n        setSize(426,266);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setVisible(true);\n\n        shapes = new MovingShape[10];\n        for(int i=0;i&lt;shapes.length;++i){\n            shapes[i] = new MovingShape(this);\n            shapes[i].start();\n        }\n    }\n    public static void main(String [] args) //加入main,使之能当Application应用\n    {\n        ThreadDrawJ f = new ThreadDrawJ();\n        f.init();\n    }\n}\n\nclass MovingShape extends Thread{\n    private int size = 100;\n    private int speed=10;\n    private Color color;\n    private int type;\n    private int x,y,w,h,dx,dy;\n    protected java.awt.Component app;\n\n    public boolean stopped;\n\n    MovingShape(JFrame app){\n        this.app=app;\n        x=(int)(Math.random()*app.getSize().width);\n        y=(int)(Math.random()*app.getSize().height);\n        w=(int)(Math.random()*size);\n        h=(int)(Math.random()*size);\n        dx = (int)(Math.random() * speed );\n        dy = (int)(Math.random() * speed );\n        color = new Color ( \n            (int)(Math.random()*128+128), \n            (int)(Math.random()*128+128),\n            (int)(Math.random()*128+128) );\n        type = (int)(Math.random() * 3 );\n    }\n\n    public void run(){\n        while(true){\n            if(stopped) break;\n\n            //draw(),多线程方法必须卸载invoke中\n            SwingUtilities.invokeLater( ()-&gt;{\n                draw(); \n            });\n\n            try{ Thread.sleep(130);}catch(InterruptedException e){}\n        }\n    }\n    void draw(){\n        x+=dx;\n        y+=dy;\n        //控制边界\n        if(x&lt;0 || x+w&gt;app.getSize().width) dx=-dx;\n        if(y&lt;0 || y+h&gt;app.getSize().height) dy=-dy;\n\n        Graphics g=app.getGraphics();\n        switch(type){\n            case 0:\n                //矩形\n                g.setColor(color);\n                g.fillRect( x,y,w,h ); \n                g.setColor( Color.black );\n                g.drawRect( x,y,w,h );\n                break;\n            case 1:\n                //椭圆\n                g.setColor(color);\n                g.fillOval( x,y,w,h ); \n                g.setColor( Color.black );\n                g.drawOval( x,y,w,h );\n                break;\n            case 2:\n                //圆角矩形\n                g.setColor(color);\n                g.fillRoundRect( x,y,w,h,w/5,h/5); \n                g.setColor( Color.black );\n                g.drawRoundRect( x,y,w,h,w/5,h/5 );\n                break;\n        }\n    }\n}</code></pre><p>针对线程全局变量不会因线程执行而改变混乱. JDK 1.5+ 提供了原子变量,以及并发的泛型类型.</p>\n","text":"Action : Thread Unit. Demo:import java.util.*;import java.text.*;public class ThreadDemo {    public static void main(String[] args){       ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Let's Gank Java - 8st","slug":"lets-gank-java-8st","date":"2017-11-20T12:56:05.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/lets-gank-java-8st.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/%E6%8D%95%E8%8E%B7-2.png","content":"<p>这次我们要用网络编程+正则+swing来实现获取百度显示关键字相关的功能. 首先,我们需要先在：<a href=\"http://hc.apache.org/downloads.cgi\" target=\"_blank\" rel=\"noopener\">http://hc.apache.org/downloads.cgi</a> 中下载 <code>4.5.3.zip</code>(根据平台选择,我这里选择的是Windows的)解压后,将lib中的所有jar包build到工程中,这样可以使用这个包内的网络操作相关方法. 然后就是另外一个问题,当我们使用String.replaceAll(regex,replacement)时,第一个参数为正则表达式,而第二个参数有三种情况: 1.替换目标正则得到的结果 2.${number} 符号表示目标正则得到的组(number为组数). 3.(暂时不知道,貌似是代表结束符) 官方文档: <strong>Note that backslashes () and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.</strong></p>\n<pre><code>import org.apache.http.*;\nimport org.apache.http.client.*;\nimport org.apache.http.client.fluent.*;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\n\nimport java.awt.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\nimport javax.swing.JFrame;\nimport javax.swing.JList;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextField;\nimport javax.swing.SwingUtilities;\n\npublic class HttpSuggestion extends JFrame {\n    JTextField txtInput = new JTextField();\n    JList&lt;String&gt; lstSuggestion = new JList&lt;&gt;();\n\n    public HttpSuggestion(){\n        super(&quot;auto suggestion&quot;);//javax.swing.JFrame.JFrame(String title)\n        getContentPane().add(BorderLayout.NORTH,txtInput);\n        getContentPane().add(BorderLayout.CENTER,new JScrollPane(lstSuggestion));\n\n        setSize(300,200);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setVisible(true);\n\n        txtInput.addKeyListener(new KeyAdapter(){\n            public void keyPressed(KeyEvent arg0){\n                /*\n                  当按键被按下时调用。 \n                 Invoked when a key has been pressed.\n                 */\n                new Thread(()-&gt;{\n                    try{\n                        String word = txtInput.getText();\n                        String[] suggestion = fetchSuggestion(word);\n                        //还记得之前说的么,在swing中多线程的函数必须调用SwingUtilities.invokeLater执行\n                        SwingUtilities.invokeLater(()-&gt;{\n                            //每次获取新信息就更新一次JList\n                            lstSuggestion.removeAll();\n                            lstSuggestion.setListData(suggestion);\n                            lstSuggestion.updateUI();\n                        });\n                    }catch(Exception ex){\n                        ex.printStackTrace();\n                    }\n                }).start();\n            }\n        });\n\n        //每当JList被选中时,更新Text内的内容\n        lstSuggestion.addListSelectionListener(e -&gt; {\n            txtInput.setText(lstSuggestion.getSelectedValue());\n        });\n    }\n\n    public static void main(String[] args)\n        throws Exception\n    {\n        //String word=&quot;人&quot;;\n        //fetchSuggestion(word);\n\n        SwingUtilities.invokeLater(()-&gt;{\n            new HttpSuggestion();\n        });\n    }\n\n    public static String[] fetchSuggestion(String word)\n            throws UnsupportedEncodingException, \n            ClientProtocolException,\n            IOException\n    {\n        //安全机制\n        if(word == null || word.length() == 0)\n            return new String[0];\n\n        String url=&quot;http://suggestion.baidu.com/su?wd=&quot;\n                + URLEncoder.encode(word,&quot;utf-8&quot;);\n        url += &quot;&amp;rnd=&quot; + Math.random();\n        //输出拼接后的url\n        System.out.println(url);\n\n        String content = Request.Get(url)\n                .addHeader(&quot;cookie&quot;,&quot;BDUSS=Aadasdfsfee&quot;).execute()\n                .returnContent().asString();\n        //输出返回的值\n        System.out.println(content);\n        //最后会返回类似\n        // window.baidu.sug({q:&quot;人&quot;,p:false,s:[&quot;人体艺术&quot;,&quot;人体艺术图片&quot;,&quot;人人网&quot;,&quot;人体艺术摄影&quot;,&quot;人民币对美元汇率&quot;,&quot;人体&quot;,&quot;人人贷&quot;,&quot;人人影视&quot;]});\n        String[] sug = content.replaceAll(&quot;.*,s:\\\\[([^]]*)\\\\].*&quot;,&quot;$1&quot;)\n                .replaceAll(&quot;\\&quot;&quot;, &quot;&quot;).split(&quot;,&quot;);\n        //输出瞅一瞅每次都转换了什么\n        for(String a : sug){\n            System.out.println(a);\n        }\n        String ss=content.replaceAll(&quot;.*,s:\\\\[([^]]*)\\\\].*&quot;,&quot;$1&quot;);\n        System.out.println(ss);\n        return sug;\n    }\n}</code></pre><p>结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/捕获-2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/%E6%8D%95%E8%8E%B7-2.png\" alt></a></p>\n","text":"这次我们要用网络编程+正则+swing来实现获取百度显示关键字相关的功能. 首先,我们需要先在：http://hc.apache.org/downloads.cgi 中下载 4.5.3.zip(根据平台选择,我这里选择的是Windows的)解压后,将lib中的所有jar包buil","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"网络编程","slug":"Java/网络编程","count":1,"path":"api/categories/Java/网络编程.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"},{"name":"网络编程","slug":"网络编程","count":4,"path":"api/tags/网络编程.json"}]},{"title":"排序可视化","slug":"sort-vis","date":"2019-01-08T08:57:47.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/sort-vis.json","excerpt":"","keywords":null,"cover":null,"content":"<p>源码: <a href=\"https://github.com/834930269/sort_visualization\" title=\"排序的可视化\" target=\"_blank\" rel=\"noopener\">排序的可视化</a></p>\n<blockquote>\n<p>暂时有： 插入排序,归并排序,快速排序,快速排序(严蔚敏版),选择排序,希尔排序</p>\n</blockquote>\n<blockquote>\n<p>运行方式,IDLE打开,然后打开某算法下的AlgoVisualizer,在main函数上run即可(有些算法设置了需要点击才会开始运行)</p>\n</blockquote>\n<p>一下目录为待补充(回头写)</p>\n<h1 id=\"可视化框架\"><a href=\"#可视化框架\" class=\"headerlink\" title=\"可视化框架\"></a>可视化框架</h1><h2 id=\"Java-swing的MVC架构\"><a href=\"#Java-swing的MVC架构\" class=\"headerlink\" title=\"Java swing的MVC架构\"></a>Java swing的MVC架构</h2><h3 id=\"M-模型\"><a href=\"#M-模型\" class=\"headerlink\" title=\"M-模型\"></a>M-模型</h3><h3 id=\"V-视图\"><a href=\"#V-视图\" class=\"headerlink\" title=\"V-视图\"></a>V-视图</h3><h3 id=\"C-控制层\"><a href=\"#C-控制层\" class=\"headerlink\" title=\"C-控制层\"></a>C-控制层</h3><h3 id=\"具体架构可扩展至其他语言\"><a href=\"#具体架构可扩展至其他语言\" class=\"headerlink\" title=\"具体架构可扩展至其他语言\"></a>具体架构可扩展至其他语言</h3><h2 id=\"基于MVC架构下的排序可视化基础框架\"><a href=\"#基于MVC架构下的排序可视化基础框架\" class=\"headerlink\" title=\"基于MVC架构下的排序可视化基础框架\"></a>基于MVC架构下的排序可视化基础框架</h2>","text":"源码: 排序的可视化暂时有： 插入排序,归并排序,快速排序,快速排序(严蔚敏版),选择排序,希尔排序运行方式,IDLE打开,然后打开某算法下的AlgoVisualizer,在main函数上run即可(有些算法设置了需要点击才会开始运行)一下目录为待补充(回头写)可视化框架Java","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Spring Validation-Spring后台验证框架","slug":"spring-validation-spring","date":"2019-02-09T15:34:46.000Z","updated":"2019-07-03T16:01:03.116Z","comments":true,"path":"api/articles/spring-validation-spring.json","excerpt":"<h1 id=\"JSR-303简介\"><a href=\"#JSR-303简介\" class=\"headerlink\" title=\"JSR-303简介\"></a>JSR-303简介</h1><p>JSR-303 是 JavaEE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator。 此实现与 Hibernate ORM 没有任何关系。JSR-303 用于对 Java Bean 中的字段的值进行验证。 Spring MVC 3.x 之中也大力支持 JSR-303，可以在控制器中使用注解的方式对表单提交的数据方便地验证。 Spring 4.0 开始支持 Bean Validation 功能。</p>","keywords":null,"cover":null,"content":null,"text":"JSR-303简介JSR-303 是 JavaEE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator。 此实现与 Hibernate ORM 没有任何关系。JSR-303 用于对 Java Bean 中的字段的值进行","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"Spring","slug":"Java/Spring","count":1,"path":"api/categories/Java/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":6,"path":"api/tags/Spring.json"},{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"Java I/O","slug":"java-i-o","date":"2018-01-16T05:43:46.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/java-i-o.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png","content":"<p>[toc]</p>\n<h1 id=\"I-O\"><a href=\"#I-O\" class=\"headerlink\" title=\"I/O\"></a>I/O</h1><h2 id=\"文件对象\"><a href=\"#文件对象\" class=\"headerlink\" title=\"文件对象\"></a>文件对象</h2><h3 id=\"创建一个文件对象\"><a href=\"#创建一个文件对象\" class=\"headerlink\" title=\"创建一个文件对象\"></a>创建一个文件对象</h3><pre><code>package file;\n\nimport java.io.File;\n\npublic class TestFile {\n    public static void main(String[] args){\n        //绝对路径\n        File f1=new File(&quot;d:/LOLFolder&quot;);\n        System.out.println(&quot;f1的绝对路径: &quot; + f1.getAbsolutePath());\n        //相对路径,相对于工作目录,如果在eclipse中,就是项目目录\n        File f2=new File(&quot;LOL.exe&quot;);\n        System.out.println(&quot;f2的绝对路径: &quot;+f2.getAbsolutePath());\n        //把f1作为父目录创建文件对象\n        File f3=new File(f1,&quot;LOL.exe&quot;);\n        System.out.println(&quot;f3的绝对路径: &quot;+f3.getAbsolutePath());\n    }\n}</code></pre><p>输出:</p>\n<pre><code>f1的绝对路径: d:\\LOLFolder\nf2的绝对路径: D:\\Java\\Learning\\LOL.exe\nf3的绝对路径: d:\\LOLFolder\\LOL.exe</code></pre><h3 id=\"文件常用方法\"><a href=\"#文件常用方法\" class=\"headerlink\" title=\"文件常用方法\"></a>文件常用方法</h3><p>exists() -是否存在 isDirectory() -是否是文件夹 isFile() -是否是文件 length() -长度 lastModified() -文件最后修改时间 setlastModified() -修改文件最后修改时间 renameTo(f2 type is File) -把名字改成f2的名字,两个文件必须存在</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.util.Date;\n\npublic class Method {\n    public static void main(String args[]){\n        File f = new File(&quot;d:/LOLFolder/LOL.exe&quot;);\n        System.out.println(&quot;当前文件是：&quot; +f);\n        //文件是否存在\n        System.out.println(&quot;判断是否存在：&quot;+f.exists());\n\n        //是否是文件夹\n        System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());\n\n        //是否是文件（非文件夹）\n        System.out.println(&quot;判断是否是文件：&quot;+f.isFile());\n\n        //文件长度\n        System.out.println(&quot;获取文件的长度：&quot;+f.length());\n\n        //文件最后修改时间\n        long time = f.lastModified();\n        Date d = new Date(time);\n        System.out.println(&quot;获取文件的最后修改时间：&quot;+d);\n        //设置文件修改时间为1970.1.1 08:00:00\n        f.setLastModified(0);\n\n        //文件重命名\n        File f2 =new File(&quot;d:/LOLFolder/DOTA.exe&quot;);\n        f.renameTo(f2);\n        System.out.println(&quot;把LOL.exe改名成了DOTA.exe&quot;);\n\n        System.out.println(&quot;注意： 需要在D:\\\\LOLFolder确实存在一个LOL.exe,\\r\\n才可以看到对应的文件长度、修改时间等信息&quot;);\n    }\n}</code></pre><p>输出:</p>\n<pre><code>当前文件是：d:\\LOLFolder\\LOL.exe\n判断是否存在：false\n判断是否是文件夹：false\n判断是否是文件：false\n获取文件的长度：0\n获取文件的最后修改时间：Thu Jan 01 08:00:00 GMT+08:00 1970\n把LOL.exe改名成了DOTA.exe\n注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\n才可以看到对应的文件长度、修改时间等信息</code></pre><h3 id=\"文件的常用方法2\"><a href=\"#文件的常用方法2\" class=\"headerlink\" title=\"文件的常用方法2\"></a>文件的常用方法2</h3><p>list() -以字符串数组的形式，返回当前文件夹下的所有文件 File[] fs=f.listFiles() -以文件数组的形式，返回当前文件夹下的所有文件 getParent() -以字符串形式返回所在文件夹 getParentFile() -以文件形式返回获取所在文件夹 mkdir() -创建文件夹,如果父目录不存在,创建失败 mkdirs() -如果父目录不存在,一样创建 createNewFile() -创建新文件,父目录不存在,抛异常 listRoots() -盘符c: d: delete() -删除 deleteOnExit() -JVM结束时删除</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class Method2 {\n    public static void main(String[] args) throws IOException {\n\n        File f = new File(&quot;d:/LOLFolder/skin/garen.ski&quot;);\n\n        // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）\n        f.list();\n\n        // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）\n        File[]fs= f.listFiles();\n\n        // 以字符串形式返回获取所在文件夹\n        f.getParent();\n\n        // 以文件形式返回获取所在文件夹\n        f.getParentFile();\n        // 创建文件夹，如果父文件夹skin不存在，创建就无效\n        f.mkdir();\n\n        // 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹\n        f.mkdirs();\n\n        // 创建一个空文件,如果父文件夹skin不存在，就会抛出异常\n        f.createNewFile();\n        // 所以创建一个空文件之前，通常都会创建父目录\n        f.getParentFile().mkdirs();\n\n        // 列出所有的盘符c: d: e: 等等\n        f.listRoots();\n\n        // 刪除文件\n        f.delete();\n\n        // JVM结束的时候，刪除文件，常用于临时文件的删除\n        f.deleteOnExit();\n\n    }\n}</code></pre><p>流<br>-</p>\n<h3 id=\"什么是流\"><a href=\"#什么是流\" class=\"headerlink\" title=\"什么是流\"></a>什么是流</h3><p><strong>流即一系列数据.</strong> 当不同的介质之间有数据交互的时候，JAVA就使用流来实现。 数据源可以是文件，还可以是数据库，网络甚至是其他的程序 比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流 输入流： InputStream 输出流：OutputStream</p>\n<h3 id=\"文件输入流\"><a href=\"#文件输入流\" class=\"headerlink\" title=\"文件输入流\"></a>文件输入流</h3><pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class Stream {\n    public static void main(String[] args) {\n        try {\n            File f = new File(&quot;d:/lol.txt&quot;);\n            // 创建基于文件的输入流\n            FileInputStream fis = new FileInputStream(f);\n            // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟中来，也就是读取到内存中\n\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3 id=\"文件读入与输出\"><a href=\"#文件读入与输出\" class=\"headerlink\" title=\"文件读入与输出\"></a>文件读入与输出</h3><pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class bytes {\n    //FileInputStream是InputStream的子类\n    public static void main(String[] args){\n        try{\n            //从文件读入\n            File f=new File(&quot;log.txt&quot;);\n            //创建基于文件的输入流\n            FileInputStream fis=new FileInputStream(f);\n            //创建字节数组,其长度就是文件的长度\n            byte[] all=new byte[(int)f.length()];\n            //以字节流的形式读取文件所有内容\n            fis.read(all);\n            for(byte b:all){\n                System.out.println(b);\n            }\n\n            //每次使用完毕关闭\n            fis.close();\n\n\n            //向文件输出\n            File f1=new File(&quot;log1.txt&quot;);\n            byte data[]={88,89};\n            FileOutputStream fos=new FileOutputStream(f1);\n            fos.write(data);\n            fos.close();\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3 id=\"关闭文件时需要注意\"><a href=\"#关闭文件时需要注意\" class=\"headerlink\" title=\"关闭文件时需要注意\"></a>关闭文件时需要注意</h3><p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端； 如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用 最标准的写法是在 finally 中关闭文件. 1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally. 2. 在finally关闭之前，要先判断该引用是否为空 3. 关闭的时候，需要再一次进行try catch处理 使用try()方式.其使用方法和C#的using(),Python的with一样.</p>\n<h3 id=\"字符流\"><a href=\"#字符流\" class=\"headerlink\" title=\"字符流\"></a>字符流</h3><p>这节之前都是字节流 Reader字符输入流 Writer字符输出流 专门用于字符的形式读取和写入数据</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class CharacterStream {\n    public static void main(String[] args){\n        File f=new File(&quot;log.txt&quot;);\n        try(FileReader fr=new FileReader(f)){\n            //以字符流读入到char数组中\n            char[] all=new char[(int)f.length()];\n            fr.read(all);\n            for(char ch : all){\n                System.out.println(ch);\n            }\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n\n        File f1=new File(&quot;log1.txt&quot;);\n        try(FileWriter fr=new FileWriter(f1)){\n            String data=&quot;abcdefghijklmn123456789&quot;;\n            //字符串转字符数组\n            char[] cs=data.toCharArray();\n            fr.write(cs);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}</code></pre><h3 id=\"中文编码问题\"><a href=\"#中文编码问题\" class=\"headerlink\" title=\"中文编码问题\"></a>中文编码问题</h3><p>1.中文编码</p>\n<pre><code>package file;\n\nimport java.io.UnsupportedEncodingException;\n//以字符 中 为例，查看其在不同编码方式下的值是多少\n\npublic class encode {\n    public static void main(String[] args){\n        String str = &quot;中&quot;;\n        showCode(str);\n    }\n\n    private static void showCode(String str){\n        String[] encodes={&quot;BIG5&quot;,&quot;GBK&quot;,&quot;GB2312&quot;,&quot;UTF-8&quot;,&quot;UTF-16&quot;,&quot;UTF32&quot;};\n        for(String encode : encodes){\n            showCode(str,encode);\n        }\n    }\n\n    private static void showCode(String str,String encode){\n        try{\n            //格式化输出用printf\n            System.out.printf(&quot;字符: \\&quot;%s\\&quot; 的在编码方式%s下的十六进制是%n&quot;,str,encode);\n            //str获取encode编码的byte数组 \n            byte[] bs=str.getBytes(encode);\n            for(byte b: bs){\n                //只显示每字节的低两位\n                int i=b&amp;0xff;\n                //toHex =&gt; 16进制\n                System.out.print(Integer.toHexString(i) + &quot;\\t&quot;);\n            }\n            System.out.println();\n            System.out.println();\n        }catch(UnsupportedEncodingException e){\n            System.out.printf(&quot;UnsupportedEncodingException: %s编码方式无法解析字符%s\\n&quot;, encode, str);\n        }\n    }\n}</code></pre><p>2.文件流读取中文</p>\n<pre><code>package file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\n\npublic class fileEncode {\n    public static void main(String[] args) throws UnsupportedEncodingException, FileNotFoundException {\n        File f = new File(&quot;test.txt&quot;);\n        System.out.println(&quot;默认编码方式:&quot;+Charset.defaultCharset());\n        //FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了\n        //而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK\n        try (FileReader fr = new FileReader(f)) {\n            char[] cs = new char[(int) f.length()];\n            fr.read(cs);\n            System.out.printf(&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;,Charset.defaultCharset());\n            System.out.println(new String(cs));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        //FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替\n        //并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式\n        try (InputStreamReader isr = new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))) {\n            char[] cs = new char[(int) f.length()];\n            isr.read(cs);\n            System.out.printf(&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;);\n            System.out.println(new String(cs));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}</code></pre><h3 id=\"缓存流\"><a href=\"#缓存流\" class=\"headerlink\" title=\"缓存流\"></a>缓存流</h3><pre><code>package file;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n//缓存流\npublic class Buffer {\n    public static void main(String[] args) {\n        //缓存流读取\n        {\n            // 准备文件lol.txt其中的内容是\n            // garen kill teemo\n            // teemo revive after 1 minutes\n            // teemo try to garen, but killed again\n            File f = new File(&quot;log.txt&quot;);\n            // 创建文件字符流\n            // 缓存流必须建立在一个存在的流的基础上\n            try (\n                    FileReader fr = new FileReader(f);\n                    //BufferedReader的带参构造函数是一个流\n                    BufferedReader br = new BufferedReader(fr);\n                )\n            {\n                while (true) {\n                    // 一次读一行\n                    String line = br.readLine();\n                    if (null == line)\n                        break;\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        //缓存流写出\n        {\n            File f=new File(&quot;log1.txt&quot;);\n            try(\n                //创建文件字符流\n                FileWriter fw=new FileWriter(f);\n                //缓存流必须建立在一个存在的流的基础上\n                PrintWriter pw=new PrintWriter(fw);\n            ){\n                //直接pw.println\n                pw.println(&quot;garen kill teemo&quot;);\n                //如果想要在不是缓存满了才写入硬盘\n                //就需要使用pw.flush()\n                //pw.flush()\n                //否则会在缓存满了或者结束才写入到硬盘中\n                pw.println(&quot;teemo revive after 1 minutes&quot;);\n                pw.println(&quot;teemo try to garen, but killed again&quot;);\n            }catch(IOException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre><h3 id=\"对象流\"><a href=\"#对象流\" class=\"headerlink\" title=\"对象流\"></a>对象流</h3><p>即常见的 Serializable 将对象流化方便传递. 必须实现Serializable接口 Hero类</p>\n<pre><code>package charactor;\n\nimport java.io.Serializable;\n\npublic class Hero implements Serializable {\n    //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号\n    private static final long serialVersionUID = 1L;\n    public String name;\n    public float hp;\n\n}</code></pre><p>应用:</p>\n<pre><code>package stream;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport charactor.Hero;\n\npublic class TestStream {\n\n    public static void main(String[] args) {\n        //创建一个Hero garen\n        //要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口\n        Hero h = new Hero();\n        h.name = &quot;garen&quot;;\n        h.hp = 616;\n\n        //准备一个文件用于保存该对象\n        File f =new File(&quot;d:/garen.lol&quot;);\n\n        try(\n            //创建对象输出流\n            FileOutputStream fos = new FileOutputStream(f);\n            ObjectOutputStream oos =new ObjectOutputStream(fos);\n            //创建对象输入流              \n            FileInputStream fis = new FileInputStream(f);\n            ObjectInputStream ois =new ObjectInputStream(fis);\n        ) {\n            oos.writeObject(h);\n            Hero h2 = (Hero) ois.readObject();\n            System.out.println(h2.name);\n            System.out.println(h2.hp);\n\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}</code></pre><h2 id=\"常用的控制台输入System-in-Scanner\"><a href=\"#常用的控制台输入System-in-Scanner\" class=\"headerlink\" title=\"常用的控制台输入System.in(Scanner)\"></a>常用的控制台输入System.in(Scanner)</h2><pre><code>package stream;\n\nimport java.util.Scanner;\n\npublic class TestStream {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int a = s.nextInt();\n        System.out.println(&quot;第一个整数：&quot;+a);\n        int b = s.nextInt();\n        System.out.println(&quot;第二个整数：&quot;+b);\n    }\n}</code></pre><h2 id=\"流关系图\"><a href=\"#流关系图\" class=\"headerlink\" title=\"流关系图\"></a>流关系图</h2><p><a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/5678.png\" alt></a></p>\n","text":"[toc]I/O文件对象创建一个文件对象package file;import java.io.File;public class TestFile {    public static void main(String[] args){        //绝对路径       ","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}]},{"title":"聊天室架构从0开始 - 1 TCP&UDP问题","slug":"type-1","date":"2019-01-01T01:00:24.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/type-1.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/12/ServerSocket%E4%B8%8ESocket.png","content":"<blockquote>\n<p>最后更新于2019/1/1</p>\n</blockquote>\n<h1 id=\"课设过程中的记录\"><a href=\"#课设过程中的记录\" class=\"headerlink\" title=\"课设过程中的记录\"></a>课设过程中的记录</h1><h2 id=\"序言-tcp与udp的族谱\"><a href=\"#序言-tcp与udp的族谱\" class=\"headerlink\" title=\"序言 - tcp与udp的族谱\"></a>序言 - tcp与udp的族谱</h2><h3 id=\"借助工具-流式读取\"><a href=\"#借助工具-流式读取\" class=\"headerlink\" title=\"借助工具 - 流式读取\"></a>借助工具 - 流式读取</h3><p><a href=\"http://be-sunshine.cn/index.php/2018/06/21/javaweb-two/\" title=\"java流式读取\" target=\"_blank\" rel=\"noopener\">戳-&gt;java流式读取</a></p>\n<h3 id=\"简单tcp问题\"><a href=\"#简单tcp问题\" class=\"headerlink\" title=\"简单tcp问题\"></a>简单tcp问题</h3><p>因为要求服务端是无限接收客户端的请求,所以服务端必须用线程来新建和处理请求.</p>\n<h4 id=\"服务端代码\"><a href=\"#服务端代码\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h4><pre><code>import javax.print.DocFlavor;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.SQLTransactionRollbackException;\n\npublic class Server {\n    public static void main(String[] args)throws IOException {\n        //如果不指定端口号和ip地址,默认是本地\n        ServerSocket server=new ServerSocket(2019);\n        System.out.println(&quot;服务器准备就绪~&quot;);\n        System.out.println(&quot;服务器信息: &quot;+server.getInetAddress()+&quot; P:&quot;+server.getLocalPort() );\n\n        //等待客户端连接\n        while(true) {\n            //得到客户端\n            Socket client = server.accept();\n            //客户端构建异步线程\n            ClientHandler clientHandler = new ClientHandler(client);\n            //启动线程\n            clientHandler.start();\n        }\n    }\n\n    //处理多个请求时要用异步\n    private static class ClientHandler extends Thread{\n        private Socket socket;\n        private boolean flag=true;\n\n        ClientHandler(Socket socket){\n            this.socket=socket;\n        }\n\n        //运行时运行run\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;新客户端连接: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n            try{\n                //得到打印流,用于数据输出：服务器回送数据使用\n                PrintStream socketOutput=new PrintStream(socket.getOutputStream());\n                //得到输入流,用于接收数据\n                BufferedReader socketInput=new BufferedReader(new InputStreamReader(\n                        socket.getInputStream()));\n\n                do{\n                    String str=socketInput.readLine();\n                    //equalsIgnoreCase忽略大小写\n                    if(&quot;bye&quot;.equalsIgnoreCase(str)){\n                        flag=false;\n                        //回送\n                        socketOutput.println(&quot;bye&quot;);\n                    }else{\n                        System.out.println(str);\n                        socketOutput.println(&quot;回送： &quot;+ str.length());\n                    }\n                }while(flag);\n\n                socketInput.close();\n                socketOutput.close();\n            }catch(Exception e){\n                System.out.println(&quot;连接异常断开&quot;);\n            }finally {\n                //连接关闭(每个线程)\n                try{\n                    socket.close();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(&quot;客户端已退出: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n        }\n    }\n}</code></pre><h4 id=\"客户端代码\"><a href=\"#客户端代码\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h4><pre><code>import java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class Client {\n    public static void main(String[] args)throws IOException {\n        Socket socket=new Socket();\n        ///超时时间\n        socket.setSoTimeout(3000);\n        //连接本地,端口2000,超时时间3000ms\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),2019),3000);\n        System.out.println(&quot;已发起服务器连接,并进入后续流程~&quot;);\n        System.out.println(&quot;客户端信息: &quot;+socket.getLocalAddress()+&quot; P:&quot;+socket.getLocalPort());\n        System.out.println(&quot;服务器信息: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort() );\n\n        try{\n            //发送接收数据\n            todo(socket);\n        }catch(Exception e){\n            System.out.println(&quot;异常关闭&quot;);\n        }\n        //释放资源\n        socket.close();\n        System.out.println(&quot;客户端已关闭&quot;);\n    }\n\n    private static void todo(Socket client) throws IOException{\n        //构建键盘输入流\n        InputStream in=System.in;\n        BufferedReader  input=new BufferedReader(new InputStreamReader(in));\n\n        //得到Socket输出流,并转换为打印流\n        OutputStream output=client.getOutputStream();\n        PrintStream socketPrintStream=new PrintStream(output);\n\n        //得到Socket输入流,并转换为BufferedReader\n        InputStream inputStream=client.getInputStream();\n        BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n        boolean flag=true;\n        do{\n            //键盘读一行\n            String str=input.readLine();\n            //发送到服务器\n            socketPrintStream.println(str);\n\n            //从服务器读取一行\n            String echo=socketBufferedReader.readLine();\n            if(&quot;bye&quot;.equalsIgnoreCase(echo)){\n                flag=false;\n            }else{\n                System.out.println(echo);\n            }\n        }while(flag);\n\n        //关闭全部流,资源释放\n        socketBufferedReader.close();\n        socketPrintStream.close();\n        input.close();\n    }\n}</code></pre><h3 id=\"常见协议端口号\"><a href=\"#常见协议端口号\" class=\"headerlink\" title=\"常见协议端口号\"></a>常见协议端口号</h3><p>协议</p>\n<p>端口</p>\n<p>TCP or UDP</p>\n<p>FTP</p>\n<p>20,21</p>\n<p>TCP</p>\n<p>SSH</p>\n<p>22</p>\n<p>TCP</p>\n<p>Telnet</p>\n<p>23</p>\n<p>TCP</p>\n<p>SMTP</p>\n<p>25</p>\n<p>TCP</p>\n<p>DNS</p>\n<p>53</p>\n<p>UDP</p>\n<p>TFTP</p>\n<p>69</p>\n<p>UDP</p>\n<p>HTTP</p>\n<p>80</p>\n<p>TCP</p>\n<p>POP3</p>\n<p>110</p>\n<p>TCP</p>\n<p>IMAP4</p>\n<p>143</p>\n<p>TCP</p>\n<p>HTTPS</p>\n<p>443</p>\n<p>TCP</p>\n<p>其中49152~65535号端口属于动态端口,没有端口可以被正式注册.</p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>UDP是不可靠连接的协议,它的结构简单,不保留数据备份,无校验,速度快,容易丢包,可广播. 自身协议占用64位. 0-15(2个字节,短整型):发送源ip 16-31：接收源ip 32-47:长度 48-64:校验字段和header 其余均为data域: 最大的数据长度为65507 Bite,超过的要自行分包.</p>\n<h4 id=\"UDP能做什么\"><a href=\"#UDP能做什么\" class=\"headerlink\" title=\"UDP能做什么?\"></a>UDP能做什么?</h4><ol>\n<li>解析ip时的DNS就是依赖于UDP,以及TFTP,SNMP</li>\n<li>视频,音频,普通数据(无关紧要的数据),但若下载时用的是tcp</li>\n</ol>\n<h4 id=\"UDP-核心API\"><a href=\"#UDP-核心API\" class=\"headerlink\" title=\"UDP 核心API\"></a>UDP 核心API</h4><ol>\n<li>UDP并未合并到Socket核心包中.</li>\n</ol>\n<p>API</p>\n<p>作用</p>\n<p>DatagramSocket()</p>\n<p>创建简单实例,不指定端口和ip</p>\n<p>DatagramSocket(int port)</p>\n<p>创建监听某端口实例</p>\n<p>DatagramSocket(int port，InetAddress localAddr)</p>\n<p>创建固定端口指定ip的实例</p>\n<p>receive(DatagramPacket d)</p>\n<p>继续DatagramPacket后-接收</p>\n<p>sent(DatagramPacket d)</p>\n<p>继续DatagramPacket后-发送</p>\n<p>setSoTimeout(int timeout)</p>\n<p>设置传输/监听时超时时间,毫秒</p>\n<p>close()</p>\n<p>关闭,释放资源</p>\n<p>DatagramPacket(byte[] buf,int offset,int length,InetAddress address,int port)</p>\n<p>用于处理报文,拆包,封包,是发送/接收实体 - byte数组，可用区间(offset,length),接收者(发送时有效)地址(address,port)</p>\n<p>DatagramPacket(byte[] buf,int length,SocketAddress address)</p>\n<p>用Socket封装</p>\n<p>setData(byte[] buf,int offset,int length)</p>\n<p>DatagramPacket.setData构造一,指定偏移</p>\n<p>setData(byte[] buf)</p>\n<p>DatagramPacket无偏移</p>\n<p>setLength(int length)</p>\n<p>DatagramPacket单独指定长度</p>\n<p>getData(),getOffset(),getLength()</p>\n<p>DatagramPacket获取信息</p>\n<p>setAddress(InetAddress address),setPort(int iport)</p>\n<p>DatagramPacket指定发送时接收端ip</p>\n<p>setSocketAddress(SocketAddress address)</p>\n<p>DatagramPacket指定封装ip端口后的SocketAddress</p>\n<p>get…()</p>\n<p>DatagramPacket获取这些信息</p>\n<h4 id=\"单播-广播和多播\"><a href=\"#单播-广播和多播\" class=\"headerlink\" title=\"单播,广播和多播\"></a>单播,广播和多播</h4><ol>\n<li>单播: 将信息传给单点，两者间</li>\n<li>多播(组播): 给一组设备发送</li>\n<li>广播: 给所有设备(同一网段)发送</li>\n</ol>\n<h4 id=\"UDP点对点\"><a href=\"#UDP点对点\" class=\"headerlink\" title=\"UDP点对点\"></a>UDP点对点</h4><h5 id=\"服务提供方代码\"><a href=\"#服务提供方代码\" class=\"headerlink\" title=\"服务提供方代码\"></a>服务提供方代码</h5><pre><code>import javax.xml.crypto.Data;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\n/*\n UDP 服务提供方\n */\npublic class UDPProvider {\n    public static void main(String[] args)throws IOException {\n        System.out.println(&quot;Provider Started.&quot;);\n\n        //作为接受者,制定一个端口用于数据接收\n        DatagramSocket ds=new DatagramSocket(20000);\n\n        //构建接收实体\n        final byte[] buf=new byte[512];\n        DatagramPacket receivePack=new DatagramPacket(buf,buf.length);\n\n        //接收\n        ds.receive(receivePack);\n\n        //打印接收到的信息与发送者的信息\n        //发送端ip地址\n        String ip=receivePack.getAddress().getHostAddress();\n        int port=receivePack.getPort();\n        int dataLen=receivePack.getLength();\n        String data=new String(receivePack.getData(),0,dataLen);\n        System.out.println(&quot;UDPProvider receive from ip:&quot;+ip+&quot;\\tport:&quot;+port+&quot;\\tdata:&quot;+data);\n\n        //构建一份回送数据\n        String responseData=&quot;Receive data with len：&quot;+dataLen;\n        byte[] responseDataBytes=responseData.getBytes();\n        //直接根据发送者构建一份回送信息\n        DatagramPacket responsePacket= new DatagramPacket(responseDataBytes,responseDataBytes.length,receivePack.getAddress(),receivePack.getPort());\n        ds.send(responsePacket);\n\n        //完成\n        System.out.println(&quot;UDPProvider Finished.&quot;);\n        ds.close();\n    }\n}</code></pre><h5 id=\"服务请求方代码\"><a href=\"#服务请求方代码\" class=\"headerlink\" title=\"服务请求方代码\"></a>服务请求方代码</h5><pre><code>import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\n/*\n    UDP搜索者,用于搜索服务支持方\n */\npublic class UDPSearcher {\n    public static void main(String[] args)throws IOException {\n        System.out.println(&quot;UDPSearcher Started.&quot;);\n\n        //作为搜索方,系统直接分配端口\n        DatagramSocket ds=new DatagramSocket();\n\n        //构建一份请求数据\n        String requestData=&quot;HelloWorld&quot;;\n        byte[] requestDataBytes=requestData.getBytes();\n        //直接根据构建一份请求信息\n        DatagramPacket requestPacket= new DatagramPacket(requestDataBytes,requestDataBytes.length);\n        requestPacket.setAddress(InetAddress.getLocalHost());\n        requestPacket.setPort(20000);\n\n        ds.send(requestPacket);\n\n        //构建接收实体\n        final byte[] buf=new byte[512];\n        DatagramPacket receivePack=new DatagramPacket(buf,buf.length);\n\n        //接收\n        ds.receive(receivePack);\n\n        //打印接收到的信息与发送者的信息\n        //发送端ip地址\n        String ip=receivePack.getAddress().getHostAddress();\n        int port=receivePack.getPort();\n        int dataLen=receivePack.getLength();\n        String data=new String(receivePack.getData(),0,dataLen);\n        System.out.println(&quot;UDPSearcher receive from ip:&quot;+ip+&quot;\\tport:&quot;+port+&quot;\\tdata:&quot;+data);\n\n\n        //完成\n        System.out.println(&quot;UDPSearcher Finished.&quot;);\n        ds.close();\n    }\n}</code></pre><h4 id=\"UDP广播\"><a href=\"#UDP广播\" class=\"headerlink\" title=\"UDP广播\"></a>UDP广播</h4><h5 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h5><ol>\n<li>线程中的CountDownLatch异步通知外部.</li>\n<li>线程关闭</li>\n<li>局域网广播地址255.255.255.255</li>\n<li>唯一标识库 UUID</li>\n<li>字符串处理API （startsWith(String),substring(length)）</li>\n<li>DatagramSocket和DatagramPacket</li>\n</ol>\n<h5 id=\"简单架构\"><a href=\"#简单架构\" class=\"headerlink\" title=\"简单架构\"></a>简单架构</h5><ol>\n<li>无论客户端还是服务端,在发送前首先要保证自己的监听时开启的,否则可能因为指令优化导致先发送而却无法接收.</li>\n<li>搜索端用内部类建立Device来保存设备数据.</li>\n<li>搜索端用CountDownLatch来通知监听器该请求已成功.</li>\n<li>搜索端和客户端共用一个MessageCreator类来解析互传的消息.</li>\n<li>DatapramSocket是监听端口,DatapramPacket是封装/拆封报文.</li>\n</ol>\n<h5 id=\"解析信息代码\"><a href=\"#解析信息代码\" class=\"headerlink\" title=\"解析信息代码\"></a>解析信息代码</h5><pre><code>import org.omg.CORBA.INTERNAL;\n\npublic class MessageCreator{\n    private static final String SN_HEADER = &quot;收到暗号,我是(SN): &quot;;\n    private static final String PORT_HEADER=&quot;这是暗号,请回电端口(Port)&quot;;\n\n    public static String buildWithPort(int port){\n        return PORT_HEADER+port;\n    }\n\n    public static int parsePort(String data){\n        if(data.startsWith(PORT_HEADER)){\n            return Integer.parseInt(data.substring(PORT_HEADER.length()));\n        }\n        return -1;\n    }\n\n    public static String buildWithSN(String SN){\n        return SN_HEADER+SN;\n    }\n\n    public static String parseSN(String data){\n        if(data.startsWith(SN_HEADER)){\n            return data.substring(PORT_HEADER.length());\n        }\n        return null;\n    }\n}</code></pre><h5 id=\"服务提供端代码\"><a href=\"#服务提供端代码\" class=\"headerlink\" title=\"服务提供端代码\"></a>服务提供端代码</h5><pre><code>import javax.xml.crypto.Data;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.util.UUID;\n\n/*\n UDP 服务提供方\n */\npublic class UDPProvider {\n    public static void main(String[] args)throws IOException {\n        //生成一份唯一标识\n        String sn= UUID.randomUUID().toString();\n        //开启监听\n        Provider provider=new Provider(sn);\n        provider.start();\n\n        //本地读取任意键盘信息后可以退出\n        System.in.read();\n        provider.exit();\n    }\n\n    private static class Provider extends Thread{\n        private final String sn;\n        private boolean done=false;\n        private DatagramSocket ds=null;\n        public Provider(String sn){\n            super();\n            this.sn=sn;\n        }\n\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;Provider Started.&quot;);\n            try {\n                //作为接受者,制定一个端口用于监听数据接收\n                ds = new DatagramSocket(20000);\n\n                while (!done) {\n                    //构建接收实体\n                    final byte[] buf = new byte[512];\n                    DatagramPacket receivePack = new DatagramPacket(buf, buf.length);\n\n                    //接收\n                    ds.receive(receivePack);\n\n                    //打印接收到的信息与发送者的信息\n                    //发送端ip地址\n                    String ip = receivePack.getAddress().getHostAddress();\n                    int port = receivePack.getPort();\n                    int dataLen = receivePack.getLength();\n                    String data = new String(receivePack.getData(), 0, dataLen);\n                    System.out.println(&quot;UDPProvider receive from ip:&quot; + ip + &quot;\\tport:&quot; + port + &quot;\\tdata:&quot; + data);\n\n                    //解析回送端口号\n                    int responsePort = MessageCreator.parsePort(data);\n                    if(responsePort !=-1) {\n                        //构建一份回送数据\n                        String responseData = MessageCreator.buildWithSN(sn);\n                        byte[] responseDataBytes = responseData.getBytes();\n                        //直接根据发送者构建一份回送信息,发送到指定Port上去,并附上口令sn\n                        DatagramPacket responsePacket =\n                                new DatagramPacket(responseDataBytes,\n                                responseDataBytes.length,\n                                receivePack.getAddress(),\n                                responsePort);\n                        ds.send(responsePacket);\n                    }\n\n                }\n            }catch (Exception ignore){\n            }finally {\n                //done退出后阻塞异常到这里再判断一次是否需要退出\n                close();\n            }\n            //完成\n            System.out.println(&quot;UDPProvider Finished.&quot;);\n        }\n\n        private void close(){\n            if(ds!=null){\n                ds.close();\n                ds=null;\n            }\n        }\n\n        ///提供随时停止的方法\n        void exit(){\n            done=true;\n            close();\n        }\n    }\n}</code></pre><h5 id=\"客户搜索端代码\"><a href=\"#客户搜索端代码\" class=\"headerlink\" title=\"客户搜索端代码\"></a>客户搜索端代码</h5><pre><code>import java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n/*\n    UDP搜索者,用于搜索服务支持方\n */\npublic class UDPSearcher {\n    //监听端口\n    private static final int LISTEN_PORT=30000;\n\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        System.out.println(&quot;UDPSearcher Started.&quot;);\n\n        Listener listener=listen();\n        sendBroadcast();\n\n        //本地读取任意键盘信息后可以退出\n        System.in.read();\n        List&lt;Device&gt; devices=listener.getDevicesAndClose();\n        for (Device device: devices) {\n            System.out.println(&quot;Device:&quot; + device.toString());\n        }\n\n        System.out.println(&quot;完成&quot;);\n    }\n\n    //用于监听请求服务端后的回发\n    private static  Listener listen() throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(1);\n        Listener listener=new Listener(LISTEN_PORT,countDownLatch);\n        listener.start();\n\n        //执行countdownlatch.countdown()后await释放\n        countDownLatch.await();\n        return listener;\n    }\n\n    //广播\n    private static void sendBroadcast() throws IOException {\n        System.out.println(&quot;UDPSearcher sendBroadcast Started.&quot;);\n\n        //作为搜索方,系统直接分配端口\n        DatagramSocket ds=new DatagramSocket();\n\n        //构建一份请求数据\n        String requestData=MessageCreator.buildWithPort(LISTEN_PORT);\n        byte[] requestDataBytes=requestData.getBytes();\n        //直接根据构建一份请求信息\n        DatagramPacket requestPacket= new DatagramPacket(requestDataBytes,\n                requestDataBytes.length);\n        requestPacket.setAddress(InetAddress.getByName(&quot;255.255.255.255&quot;));\n        requestPacket.setPort(20000);\n\n        ds.send(requestPacket);\n        ds.close();\n        System.out.println(&quot;发送已完成.&quot;);\n    }\n\n    public static class Device{\n        ///必须要\n        final int port;\n        final String ip;\n        final String sn;\n        public Device(int port, String ip, String sn) {\n            this.port = port;\n            this.ip = ip;\n            this.sn = sn;\n        }\n\n        @Override\n        public String toString() {\n            return &quot;Device{&quot; +\n                    &quot;port=&quot; + port +\n                    &quot;, ip=&apos;&quot; + ip + &apos;\\&apos;&apos; +\n                    &quot;, sn=&apos;&quot; + sn + &apos;\\&apos;&apos; +\n                    &apos;}&apos;;\n        }\n    }\n\n    private static class Listener extends Thread{\n        private final int listenPort;\n        //用CountDownLatch通知外部已启动\n        private final CountDownLatch countDownLatch;\n        private final List&lt;Device&gt; devices=new ArrayList&lt;&gt;();\n        private boolean done=false;\n        private DatagramSocket ds=null;\n\n        public Listener(int listenPort,CountDownLatch countDownLatch){\n            super();\n            this.listenPort=listenPort;\n            this.countDownLatch=countDownLatch;\n        }\n        @Override\n        public void run(){\n            super.run();\n\n            //通知已启动\n            countDownLatch.countDown();\n            try{\n                //监听端口\n                ds=new DatagramSocket(listenPort);\n                while(!done) {\n                    //构建接收实体\n                    final byte[] buf = new byte[512];\n                    DatagramPacket receivePack = new DatagramPacket(buf, buf.length);\n\n                    //接收\n                    ds.receive(receivePack);\n\n                    //打印接收到的信息与发送者的信息\n                    //发送端ip地址\n                    String ip = receivePack.getAddress().getHostAddress();\n                    int port = receivePack.getPort();\n                    int dataLen = receivePack.getLength();\n                    String data = new String(receivePack.getData(), 0, dataLen);\n                    System.out.println(&quot;UDPSearcher receive from ip:&quot; + ip + &quot;\\tport:&quot; + port + &quot;\\tdata:&quot; + data);\n\n                    String sn=MessageCreator.parseSN(data);\n                    if(sn!=null){\n                        Device device=new Device(port,ip,sn);\n                        devices.add(device);\n                    }\n                }\n            }catch(Exception ignore){\n\n            }finally {\n                close();\n            }\n            System.out.println(&quot;UDPSearcher listener finished&quot;);\n        }\n\n        private void close(){\n            if(ds!=null){\n                ds.close();\n                ds=null;\n            }\n        }\n\n        List&lt;Device&gt; getDevicesAndClose(){\n            done=true;\n            close();\n            return devices;\n        }\n    }\n\n}</code></pre><h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>tcp是传输控制协议,是一种面向连接,可靠的,基于字节流的传输曾通信协议. 区别于UDP: udp基于数字报,不可靠. 相同: 完成第四层所指定的职责.</p>\n<h4 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h4><ol>\n<li>三次握手、四次挥手</li>\n<li>具有校验机制、可靠、数据传输稳定</li>\n<li>建立连接后,传递字节流数据</li>\n</ol>\n<h4 id=\"TCP能做什么\"><a href=\"#TCP能做什么\" class=\"headerlink\" title=\"TCP能做什么?\"></a>TCP能做什么?</h4><ol>\n<li>聊天消息传输、推送</li>\n<li>单人语音、视频聊天(信息要求完全准确用tcp)</li>\n<li>几乎udp可以做的tcp都可以做,只不过需要考虑复杂性和心跟那个问题</li>\n<li>限制: 无法进行广播,多播</li>\n</ol>\n<h4 id=\"TCP核心API\"><a href=\"#TCP核心API\" class=\"headerlink\" title=\"TCP核心API\"></a>TCP核心API</h4><p>API</p>\n<p>功能</p>\n<p>socket()</p>\n<p>创建一个socket</p>\n<p>bind()</p>\n<p>绑定一个Socket到一个本地地址和端口上</p>\n<p>connect()</p>\n<p>连接到远程套接字</p>\n<p>accept()</p>\n<p>接受一个新的连接,调用该方法时,服务端会进入阻塞状态,直到有一个套接字到达</p>\n<p>write()</p>\n<p>把数据写入到Socket输出流</p>\n<p>read()</p>\n<p>从Socket输入流中读取数据</p>\n<h4 id=\"创建流程\"><a href=\"#创建流程\" class=\"headerlink\" title=\"创建流程\"></a>创建流程</h4><h5 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h5><ol>\n<li>创建 Socket</li>\n<li>bind本地套接字(占用一个端口)</li>\n<li>connect远程套接字(成功)</li>\n<li>客户端与远程套接字通信</li>\n</ol>\n<h5 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h5><ol>\n<li>创建 SeverSocket</li>\n<li>bind本地套接字(占用一个端口)</li>\n<li>connect客户端套接字(成功)</li>\n<li>客户端与远程套接字通信</li>\n</ol>\n<h4 id=\"Socket也可以创建进程与进程间通信\"><a href=\"#Socket也可以创建进程与进程间通信\" class=\"headerlink\" title=\"Socket也可以创建进程与进程间通信\"></a>Socket也可以创建进程与进程间通信</h4><h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h4><ol>\n<li>客户端发起的(SYN 连接请求)</li>\n<li>服务端回送ACK</li>\n<li>匹配成功,客户端在发送给服务端一个ACK</li>\n</ol>\n<h4 id=\"四次挥手-断开\"><a href=\"#四次挥手-断开\" class=\"headerlink\" title=\"四次挥手(断开)\"></a>四次挥手(断开)</h4><p>FIN是申请结束字段. 1. 客户端发送: FIN=1,seq=u 2. 服务端发送: ACK=1,seq=v,ack=u+1 这之后因为可能会有一些信息还未发送完毕,所以需要发送完再进行断开确认.</p>\n<ol start=\"3\">\n<li>服务端发送: FIN=1,ACK=1,seq=w,ack=u+1</li>\n<li>客户端发送: ACK=1,seq=u+1,ack=w+1</li>\n</ol>\n<h4 id=\"前置知识-1\"><a href=\"#前置知识-1\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h4><h5 id=\"客户端-1\"><a href=\"#客户端-1\" class=\"headerlink\" title=\"客户端\"></a>客户端</h5><h6 id=\"Nagle算法\"><a href=\"#Nagle算法\" class=\"headerlink\" title=\"Nagle算法\"></a>Nagle算法</h6><p>当我们在发送报文时,如果报文是成块的发送,那么对报文的利用率将会很高,但如果是一小段一小段的发送的话,对于当前tcp的链接将会是很低效的,因为每次都需要额外处理的开销. 而Nagle算法就是为了解决小包的问题.</p>\n<blockquote>\n<p>其核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送</p>\n</blockquote>\n<h6 id=\"心跳包\"><a href=\"#心跳包\" class=\"headerlink\" title=\"心跳包\"></a>心跳包</h6><blockquote>\n<p>人活着的证明之一是心跳依然在跳动,心跳包就是用于判断在长时间无活动的前提下连接是否已断开.</p>\n<blockquote>\n<p>socket.setKeepAlive(true)</p>\n</blockquote>\n</blockquote>\n<h6 id=\"连接关闭缓冲\"><a href=\"#连接关闭缓冲\" class=\"headerlink\" title=\"连接关闭缓冲\"></a>连接关闭缓冲</h6><blockquote>\n<p>在两端连接执行关闭操作前必须要保证两端数据已经传输完成. 如果没有传输完成就关闭大概率会导致数据异常,而socket库对于关闭有三种方式.（内置于socket.setSoLinger()函数中）</p>\n<blockquote>\n<ol>\n<li>socket.setSoLinger(false,0) 关闭时立即返回,底层系统接管出输出流,将缓冲区内数据发送完全.</li>\n<li>true,0:关闭时立即返回,抛弃缓冲区数据,直接发送RST结束命令到对方</li>\n<li>true,200: 关闭后等待200ms,然后按第二种方式处理.</li>\n</ol>\n</blockquote>\n</blockquote>\n<h6 id=\"紧急数据内敛\"><a href=\"#紧急数据内敛\" class=\"headerlink\" title=\"紧急数据内敛\"></a>紧急数据内敛</h6><blockquote>\n<p>将某一块数据的优先级提至最高,一般不需要</p>\n<blockquote>\n<p>socket.setOOBInline(true) (默认false)</p>\n</blockquote>\n</blockquote>\n<h6 id=\"设置缓冲区大小\"><a href=\"#设置缓冲区大小\" class=\"headerlink\" title=\"设置缓冲区大小\"></a>设置缓冲区大小</h6><blockquote>\n<p>1024是1kb,1024*1024是1mb</p>\n<blockquote>\n<p>加快速度可以用 data &lt;&lt; 10 代表1kb</p>\n<blockquote>\n<p>socket.setReceiveBufferSize(64 * 1024 * 1024); 接受缓冲区 socket.setSendBufferSize(64 * 1024 * 1024); 发送缓冲区</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h6 id=\"设置性能参数\"><a href=\"#设置性能参数\" class=\"headerlink\" title=\"设置性能参数\"></a>设置性能参数</h6><blockquote>\n<p>短链接，延迟，带宽的相对重要性</p>\n<blockquote>\n<p>socket.setPerformancePreferences(1, 1, 0); 其中这三个参数代表的是权重占比,无实际意义.</p>\n</blockquote>\n</blockquote>\n<h6 id=\"几种不同的套接字参数\"><a href=\"#几种不同的套接字参数\" class=\"headerlink\" title=\"几种不同的套接字参数\"></a>几种不同的套接字参数</h6><pre><code>// 无代理模式，等效于空构造函数\nSocket socket = new Socket(Proxy.NO_PROXY);\n\n// 新建一份具有HTTP代理的套接字，传输数据将通过www.baidu.com:8080端口转发\nProxy proxy = new Proxy(Proxy.Type.HTTP,\n        new InetSocketAddress(Inet4Address.getByName(&quot;www.baidu.com&quot;), 8800));\nsocket = new Socket(proxy);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上\nsocket = new Socket(&quot;localhost&quot;, PORT);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上\nsocket = new Socket(Inet4Address.getLocalHost(), PORT);\n\n// 新建一个套接字，并且直接链接到本地20000的服务器上，并且绑定到本地20001端口上\nsocket = new Socket(&quot;localhost&quot;, PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\nsocket = new Socket(Inet4Address.getLocalHost(), PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n\nSocket socket = new Socket();\n// 绑定到本地20001端口\nsocket.bind(new InetSocketAddress(Inet4Address.getLocalHost(), LOCAL_PORT));</code></pre><h6 id=\"连接数据的流式操作\"><a href=\"#连接数据的流式操作\" class=\"headerlink\" title=\"连接数据的流式操作\"></a>连接数据的流式操作</h6><blockquote>\n<p>我仅用一串代码表示,但经过事实证明,各类型数据在ByteBuffer这个NIO库下只能传输一个数据,多了的话就会出现数据紊乱.除非用字符串传送.</p>\n</blockquote>\n<pre><code>//得到Socket输出流,并转换为打印流\n   OutputStream outputStream=client.getOutputStream();\n\n   //得到Socket输入流,并用ByteBuffer包裹起来\n   InputStream inputStream=client.getInputStream();\n   byte[] buffer=new byte[256];\n   ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n   // byte\n   byteBuffer.put((byte) 126);\n\n   // char\n   char c = &apos;a&apos;;\n   byteBuffer.putChar(c);\n\n   // int\n   int i = 2323123;\n   byteBuffer.putInt(i);\n\n   // bool\n   boolean b = true;\n   byteBuffer.put(b ? (byte) 1 : (byte) 0);\n\n   // Long\n   long l = 298789739;\n   byteBuffer.putLong(l);\n\n\n   // float\n   float f = 12.345f;\n   byteBuffer.putFloat(f);\n\n\n   // double\n   double d = 13.31241248782973;\n   byteBuffer.putDouble(d);\n\n   // String\n   String str = &quot;Hello你好！&quot;;\n   byteBuffer.put(str.getBytes());\n\n   //发送到服务器\n   outputStream.write(buffer,0,byteBuffer.position()+1);\n\n   //接受服务器返回\n   int read=inputStream.read(buffer);\n   System.out.println(&quot;收到数量: &quot;+read);\n\n   //资源释放\n   outputStream.close();\n   inputStream.close();</code></pre><h5 id=\"服务端-1\"><a href=\"#服务端-1\" class=\"headerlink\" title=\"服务端\"></a>服务端</h5><h6 id=\"ServerSocket\"><a href=\"#ServerSocket\" class=\"headerlink\" title=\"ServerSocket\"></a>ServerSocket</h6><blockquote>\n<p>对于服务端的Socket,为何要用ServerSocket?因为不一定只有一个客户端啊,课本部分会有一大堆Socket传过来啊,所以ServerSocket其实是用来处理多个Socket用的，最后仍然要回归到处理Socket</p>\n</blockquote>\n<h6 id=\"ServerSocket-与-Socket的关系\"><a href=\"#ServerSocket-与-Socket的关系\" class=\"headerlink\" title=\"ServerSocket 与 Socket的关系\"></a>ServerSocket 与 Socket的关系</h6><p><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/12/ServerSocket%E4%B8%8ESocket.png\" alt></p>\n<h6 id=\"ServerSocket配置\"><a href=\"#ServerSocket配置\" class=\"headerlink\" title=\"ServerSocket配置\"></a>ServerSocket配置</h6><pre><code>ServerSocket serverSocket=new ServerSocket();\n// 绑定到本地端口20000上，并且设置当前可允许等待链接的队列为50个\n//serverSocket = new ServerSocket(PORT);\n\n// 等效于上面的方案，队列设置为50个\n//serverSocket = new ServerSocket(PORT, 50);\n\n// 与上面等同\n// serverSocket = new ServerSocket(PORT, 50, Inet4Address.getLocalHost());\n// 是否复用未完全关闭的地址端口\nserverSocket.setReuseAddress(true);\n\n// 等效Socket#setReceiveBufferSize\nserverSocket.setReceiveBufferSize(64 * 1024 * 1024);\n\n// 设置serverSocket#accept超时时间\n// serverSocket.setSoTimeout(2000);\n\n// 设置性能参数：短链接，延迟，带宽的相对重要性\nserverSocket.setPerformancePreferences(1, 1, 1);</code></pre><h4 id=\"服务端代码-1\"><a href=\"#服务端代码-1\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h4><pre><code>import org.omg.CORBA.PRIVATE_MEMBER;\n\nimport javax.print.DocFlavor;\nimport java.io.*;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.sql.SQLTransactionRollbackException;\n\npublic class Server {\n    private static final int PORT=20000;\n    public static void main(String[] args)throws IOException {\n        //如果不指定端口号和ip地址,默认是本地\n        ServerSocket server=createServerSocket();\n\n        initServerSocket(server);\n\n        server.bind(new InetSocketAddress(Inet4Address.getLocalHost(),PORT),50);\n\n        System.out.println(&quot;服务器准备就绪~&quot;);\n        System.out.println(&quot;服务器信息: &quot;+server.getInetAddress()+&quot; P:&quot;+server.getLocalPort() );\n\n        //等待客户端连接\n        while(true) {\n            //得到客户端\n            Socket client = server.accept();\n            //客户端构建异步线程\n            ClientHandler clientHandler = new ClientHandler(client);\n            //启动线程\n            clientHandler.start();\n        }\n    }\n\n    private static ServerSocket createServerSocket() throws IOException {\n        ServerSocket serverSocket=new ServerSocket();\n        // 绑定到本地端口20000上，并且设置当前可允许等待链接的队列为50个\n        //serverSocket = new ServerSocket(PORT);\n\n        // 等效于上面的方案，队列设置为50个\n        //serverSocket = new ServerSocket(PORT, 50);\n\n        // 与上面等同\n        // serverSocket = new ServerSocket(PORT, 50, Inet4Address.getLocalHost());\n        return serverSocket;\n    }\n\n    private static void initServerSocket(ServerSocket serverSocket)throws IOException{\n        //是否复用未完全关闭的地址端\n        serverSocket.setReuseAddress(true);\n\n        // 等效Socket#setReceiveBufferSize\n        serverSocket.setReceiveBufferSize(64 * 1024 * 1024);\n\n        // 设置serverSocket#accept超时时间\n        // serverSocket.setSoTimeout(2000);\n\n        // 设置性能参数：短链接，延迟，带宽的相对重要性\n        serverSocket.setPerformancePreferences(1, 1, 1);\n    }\n\n    //处理多个请求时要用异步\n    private static class ClientHandler extends Thread{\n        private Socket socket;\n        private boolean flag=true;\n\n        ClientHandler(Socket socket){\n            this.socket=socket;\n        }\n\n        //运行时运行run\n        @Override\n        public void run(){\n            super.run();\n            System.out.println(&quot;新客户端连接: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n            try{\n                //得到套接字流\n                OutputStream outputStream=socket.getOutputStream();\n                InputStream inputStream=socket.getInputStream();\n                byte[] buffer=new byte[256];\n                int readCount=inputStream.read(buffer);\n                ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n                // byte\n                byte be = byteBuffer.get();\n\n                // char\n                char c = byteBuffer.getChar();\n\n                // int\n                int i = byteBuffer.getInt();\n\n                // bool\n                boolean b = byteBuffer.get() == 1;\n\n                // Long\n                long l = byteBuffer.getLong();\n\n                // float\n                float f = byteBuffer.getFloat();\n\n                // double\n                double d = byteBuffer.getDouble();\n\n                // String\n                int pos = byteBuffer.position();\n\n                String str = new String(buffer, pos, readCount - pos - 1);\n\n                System.out.println(&quot;收到数量：&quot; + readCount + &quot; 数据：&quot;\n                        + be + &quot;\\n&quot;\n                        + c + &quot;\\n&quot;\n                        + i + &quot;\\n&quot;\n                        + b + &quot;\\n&quot;\n                        + l + &quot;\\n&quot;\n                        + f + &quot;\\n&quot;\n                        + d + &quot;\\n&quot;\n                        + str + &quot;\\n&quot;);\n                System.out.println(buffer.toString());\n\n                outputStream.write(buffer, 0, readCount);\n                outputStream.close();\n                inputStream.close();\n            }catch(Exception e){\n                System.out.println(&quot;连接异常断开&quot;);\n            }finally {\n                //连接关闭(每个线程)\n                try{\n                    socket.close();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(&quot;客户端已退出: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort());\n        }\n    }\n}</code></pre><h4 id=\"客户端代码-1\"><a href=\"#客户端代码-1\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h4><pre><code>import java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\n\npublic class Client {\n\n    private static final int PORT=20000;\n    private static final int LOCAL_PORT=20001;\n\n    public static void main(String[] args)throws IOException {\n        Socket socket=createSocket();\n\n        initSocket(socket);\n\n        //连接本地,端口20000,超时时间3000ms\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),PORT),3000);\n        System.out.println(&quot;已发起服务器连接,并进入后续流程~&quot;);\n        System.out.println(&quot;客户端信息: &quot;+socket.getLocalAddress()+&quot; P:&quot;+socket.getLocalPort());\n        System.out.println(&quot;服务器信息: &quot;+socket.getInetAddress()+&quot; P:&quot;+socket.getPort() );\n\n        try{\n            //发送接收数据\n            todo(socket);\n        }catch(Exception e){\n            System.out.println(&quot;异常关闭&quot;);\n        }\n        //释放资源\n        socket.close();\n        System.out.println(&quot;客户端已关闭&quot;);\n    }\n\n    private static Socket createSocket() throws IOException{\n        /*\n        // 无代理模式，等效于空构造函数\n        Socket socket = new Socket(Proxy.NO_PROXY);\n\n        // 新建一份具有HTTP代理的套接字，传输数据将通过www.baidu.com:8080端口转发\n        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n                new InetSocketAddress(Inet4Address.getByName(&quot;www.baidu.com&quot;), 8800));\n        socket = new Socket(proxy);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上\n        socket = new Socket(&quot;localhost&quot;, PORT);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上\n        socket = new Socket(Inet4Address.getLocalHost(), PORT);\n\n        // 新建一个套接字，并且直接链接到本地20000的服务器上，并且绑定到本地20001端口上\n        socket = new Socket(&quot;localhost&quot;, PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n        socket = new Socket(Inet4Address.getLocalHost(), PORT, Inet4Address.getLocalHost(), LOCAL_PORT);\n        */\n        Socket socket=new Socket();\n        //绑定到本地20001端口\n        socket.bind(new InetSocketAddress(Inet4Address.getLocalHost(),LOCAL_PORT));\n        return socket;\n    }\n\n    private static void initSocket(Socket socket)  throws SocketException{\n        //设置读取超时时间为2秒\n        socket.setSoTimeout(2000);\n        //是否复用未完全关闭的Socket地址,对于指定build操作后的套接字有效\n        socket.setReuseAddress(true);\n        //是否需要开启Nagle算法\n        socket.setKeepAlive(true);\n        //是否需要在长时间无数据时确认是否依然连接(类似于心跳包),时间大约为2h\n        socket.setKeepAlive(true);\n\n        // 对于close关闭操作行为进行怎样的处理；默认为false，0\n        // false、0：默认情况，关闭时立即返回，底层系统接管输出流，将缓冲区内的数据发送完成\n        // true、0：关闭时立即返回，缓冲区数据抛弃，直接发送RST结束命令到对方，并无需经过2MSL等待\n        // true、200：关闭时最长阻塞200毫秒，随后按第二情况处理\n        socket.setSoLinger(true,20);\n        // 是否让紧急数据内敛，默认false；紧急数据通过 socket.sendUrgentData(1);发送\n        socket.setOOBInline(true);\n\n        // 设置接收发送缓冲器大小\n        socket.setReceiveBufferSize(64 * 1024 * 1024);\n        socket.setSendBufferSize(64 * 1024 * 1024);\n\n        // 设置性能参数：短链接，延迟，带宽的相对重要性\n        socket.setPerformancePreferences(1, 1, 0);\n\n    }\n\n    private static void todo(Socket client) throws IOException{\n        //得到Socket输出流,并转换为打印流\n        OutputStream outputStream=client.getOutputStream();\n\n        //得到Socket输入流,并用ByteBuffer包裹起来\n        InputStream inputStream=client.getInputStream();\n        byte[] buffer=new byte[256];\n        ByteBuffer byteBuffer=ByteBuffer.wrap(buffer);\n\n        // byte\n        byteBuffer.put((byte) 126);\n\n        // char\n        char c = &apos;a&apos;;\n        byteBuffer.putChar(c);\n\n        // int\n        int J = 12138;\n        byteBuffer.putInt(J);\n\n        // bool\n        boolean b = true;\n        byteBuffer.put(b ? (byte) 1 : (byte) 0);\n\n        // Long\n        long l = 298789739;\n        byteBuffer.putLong(l);\n\n\n        // float\n        float f = 12.345f;\n        byteBuffer.putFloat(f);\n\n\n        // double\n        double d = 13.31241248782973;\n        byteBuffer.putDouble(d);\n\n        // String\n        String str = &quot;Hello你好！&quot;;\n        byteBuffer.put(str.getBytes());\n\n        //发送到服务器\n        outputStream.write(buffer,0,byteBuffer.position()+1);\n\n        //接受服务器返回\n        int read=inputStream.read(buffer);\n        System.out.println(&quot;收到数量: &quot;+read);\n\n        //资源释放\n        outputStream.close();\n        inputStream.close();\n    }\n}</code></pre><h1 id=\"聊天室架构从0开始-–-2-TCP-UDP-实现搜索IP与端口\"><a href=\"#聊天室架构从0开始-–-2-TCP-UDP-实现搜索IP与端口\" class=\"headerlink\" title=\"聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口\"></a>聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口</h1><p><a href=\"be-sunshine.cn/index.php/2019/01/14/ty2/\" title=\"聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口\">聊天室架构从0开始 – 2 TCP+UDP 实现搜索IP与端口</a></p>\n","text":"最后更新于2019/1/1课设过程中的记录序言 - tcp与udp的族谱借助工具 - 流式读取戳-&gt;java流式读取简单tcp问题因为要求服务端是无限接收客户端的请求,所以服务端必须用线程来新建和处理请求.服务端代码import javax.print.DocFlavor;","link":"","raw":null,"photos":[],"categories":[{"name":"Java","slug":"Java","count":21,"path":"api/categories/Java.json"},{"name":"tcp","slug":"Java/tcp","count":1,"path":"api/categories/Java/tcp.json"},{"name":"网络编程","slug":"Java/tcp/网络编程","count":1,"path":"api/categories/Java/tcp/网络编程.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"},{"name":"网络编程","slug":"网络编程","count":4,"path":"api/tags/网络编程.json"},{"name":"tcp","slug":"tcp","count":3,"path":"api/tags/tcp.json"}]}]}