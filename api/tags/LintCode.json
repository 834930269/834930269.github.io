{"name":"LintCode","slug":"LintCode","count":2,"postlist":[{"title":"LintCode(12-22)","slug":"lintcode12-22","date":"2019-02-10T06:42:21.000Z","updated":"2019-07-03T13:51:36.864Z","comments":true,"path":"api/articles/lintcode12-22.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"12-Min-Stack\"><a href=\"#12-Min-Stack\" class=\"headerlink\" title=\"(12) - Min Stack\"></a>(12) - Min Stack</h1><blockquote>\n<p>一个栈维护最小值,另一个栈存数据</p>\n<blockquote>\n<p>为什么最小值同步插入可行,因为栈的pop只能从栈顶开始，所以:</p>\n<blockquote>\n<p>1.栈顶元素最小,minValue栈顶也是该元素 2.栈顶元素不是最小,minValue中没有该元素</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<pre><code>public class MinStack {\n\n    private Stack&lt;Integer&gt; data;\n    private Stack&lt;Integer&gt; minValue;\n\n    public MinStack() {\n        // do intialization if necessary\n        data=new Stack&lt;&gt;();\n        minValue=new Stack&lt;&gt;();\n        minValue.push(0x3f3f3f3f);\n    }\n\n    /*\n     * @param number: An integer\n     * @return: nothing\n     */\n    public void push(int number) {\n        // write your code here\n        data.push(number);\n        if(number&lt;=minValue.peek()) minValue.push(number);\n    }\n\n    /*\n     * @return: An integer\n     */\n    public int pop() {\n        // write your code here\n        if(data.peek().equals(minValue.peek())) minValue.pop();\n        return data.pop();\n    }\n\n    /*\n     * @return: An integer\n     */\n    public int min() {\n        // write your code here\n        return minValue.peek();\n    }\n}</code></pre><h1 id=\"13-Implement-strStr\"><a href=\"#13-Implement-strStr\" class=\"headerlink\" title=\"(13) - Implement strStr()\"></a>(13) - Implement strStr()</h1><blockquote>\n<p>KMP模板,但是实际面试的时候不需要使用KMP,暴力O(N^2)即可</p>\n</blockquote>\n<pre><code>public class Solution {\n\n    private final int maxn=10000+7;\n    private int Next[];\n\n    private void getNext(String S,String T){\n        int k=-1,len=T.length();\n        int j=0;\n        Next[0]=-1;\n        while(j&lt;len){\n            if(k==-1 || T.charAt(j)==T.charAt(k)) Next[++j]=++k;\n            else k=Next[k];\n        }\n    }\n\n    private int KMP_index(String S,String T){\n        int i=0,j=0,slen=S.length(),tlen=T.length();\n        getNext(S,T);\n        while(i&lt;slen &amp;&amp; j&lt;tlen){\n            if(j==-1 || S.charAt(i)==T.charAt(j)){\n                i++;\n                j++;\n            }else j=Next[j];\n        }\n        if(j==tlen) return i-tlen;\n        else return -1;\n    }\n\n    /**\n     * @param source: \n     * @param target: \n     * @return: return the index\n     */\n    public int strStr(String source, String target) {\n        // Write your code here\n        Next=new int[maxn];\n        return KMP_index(source,target);\n\n    }\n}</code></pre><h1 id=\"14-First-Position-of-Target\"><a href=\"#14-First-Position-of-Target\" class=\"headerlink\" title=\"(14) - First Position of Target\"></a>(14) - First Position of Target</h1><h2 id=\"C-偷懒用二分\"><a href=\"#C-偷懒用二分\" class=\"headerlink\" title=\"C++偷懒用二分\"></a>C++偷懒用二分</h2><pre><code>class Solution {\npublic:\n    /**\n     * @param nums: The integer array.\n     * @param target: Target to find.\n     * @return: The first position of target. Position starts from 0.\n     */\n    int binarySearch(vector&lt;int&gt; &amp;nums, int target) {\n        // write your code here\n        int index=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\n        if(nums[index]!=target)\n            return -1;\n        return index;\n    }\n};</code></pre><h2 id=\"Java-实现二分\"><a href=\"#Java-实现二分\" class=\"headerlink\" title=\"Java 实现二分\"></a>Java 实现二分</h2><pre><code>public class Solution {\n    /**\n     * @param nums: The integer array.\n     * @param target: Target to find.\n     * @return: The first position of target. Position starts from 0.\n     */\n    public int binarySearch(int[] nums, int target) {\n        // write your code here\n\n        int mid=0,l=0,r=nums.length;\n        while(l&lt;=r){\n            mid=((l+r)&gt;&gt;1);\n            if(nums[mid]&lt;target)\n                l=mid+1;\n            else r=mid-1;\n        }\n        if(nums[l]==target) return l;\n        else return -1;\n    }\n}</code></pre><h1 id=\"15-Permutations\"><a href=\"#15-Permutations\" class=\"headerlink\" title=\"(15) - Permutations\"></a>(15) - Permutations</h1><blockquote>\n<p>dfs即可</p>\n</blockquote>\n<pre><code>public class Solution {\n\n    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();\n        boolean[] used = new boolean[nums.length];\n        helper(nums, used, new LinkedList&lt;&gt;(), res);\n        return res;\n    }\n  private void helper(int[] nums, boolean[] used, List&lt;Integer&gt; tmp, List&lt;List&lt;Integer&gt;&gt; res) {\n    if (tmp.size() == nums.length) {\n      res.add(new LinkedList&lt;&gt;(tmp));\n      return;\n    }\n    for (int i = 0; i &lt; nums.length; i++) {\n      if (used[i]) {\n        continue;\n      }\n      used[i] = true;\n      tmp.add(nums[i]);\n      helper(nums, used, tmp, res);\n      used[i] = false;\n      tmp.remove(tmp.size()-1);\n    }\n    return;\n  }\n}</code></pre><h1 id=\"16-Permutations-II\"><a href=\"#16-Permutations-II\" class=\"headerlink\" title=\"(16) - Permutations II\"></a>(16) - Permutations II</h1><blockquote>\n<p>用set集直接映射即可</p>\n</blockquote>\n<pre><code>public class Solution {\n\n    private Set&lt;String&gt; reg;\n\n    private void helper(int[] nums, boolean[] used, List&lt;Integer&gt; tmp, List&lt;List&lt;Integer&gt;&gt; res,StringBuilder str){\n        if (tmp.size() == nums.length) {\n            String ts=str.toString();\n            if(reg.contains(ts)){\n                return;\n            }\n            reg.add(ts);\n            res.add(new LinkedList&lt;&gt;(tmp));\n            return;\n        }\n        for (int i = 0; i &lt; nums.length; i++) {\n            if (used[i]) {\n                continue;\n            }\n            used[i] = true;\n            tmp.add(nums[i]);\n            String nw=String.valueOf(nums[i]);\n            str.append(nw);\n            helper(nums, used, tmp, res,str);\n            used[i] = false;\n            tmp.remove(tmp.size()-1);\n            str.delete(str.length()-nw.length(),str.length());\n        }\n        return;\n    }\n    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();\n        boolean[] used = new boolean[nums.length];\n        reg=new HashSet&lt;String&gt;();\n        helper(nums, used, new LinkedList&lt;&gt;(), res,new StringBuilder());\n        return res;\n    }\n};</code></pre><h1 id=\"17-Subsets\"><a href=\"#17-Subsets\" class=\"headerlink\" title=\"(17) - Subsets\"></a>(17) - Subsets</h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>[[]]] [[1]] [[2],[1,2]] [[3],[1,3],[2,3],[1,2,3]] 合起来就好了</p>\n</blockquote>\n<p>一个小语法</p>\n<blockquote>\n<p>java中的List是引用传递,List套List给出来的是引用对象,所以必须new一个新的ArrayList才行.</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param nums: A set of numbers\n     * @return: A list of lists\n     */\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {\n        // write your code here\n        int len=nums.length;\n        Arrays.sort(nums);\n        List&lt;Integer&gt; init=new ArrayList();\n        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();\n        ans.add(init);\n        for(int i=0;i&lt;len;++i){\n            int size=ans.size();\n            for(int j=0;j&lt;size;++j){\n                List&lt;Integer&gt; reg=new ArrayList&lt;Integer&gt;(ans.get(j));\n                reg.add(nums[i]);\n                ans.add(reg);\n            }\n        }\n        return ans;\n    }\n}</code></pre><h1 id=\"18-Subsets-II\"><a href=\"#18-Subsets-II\" class=\"headerlink\" title=\"(18) - Subsets II\"></a>(18) - Subsets II</h1><blockquote>\n<p>还是用set映射</p>\n</blockquote>\n<pre><code>import java.util.*;\n\npublic class Topic_18 {\n    private static Set&lt;String&gt; dict;\n\n    /**\n     * @param nums: A set of numbers.\n     * @return: A list of lists. All valid subsets.\n     */\n    public static List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {\n        // write your code here\n        dict=new HashSet&lt;String&gt;();\n        int len=nums.length;\n        Arrays.sort(nums);\n        List&lt;Integer&gt; init=new ArrayList();\n        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();\n        ans.add(init);\n        for(int i=0;i&lt;len;++i){\n            int size=ans.size();\n            for(int j=0;j&lt;size;++j){\n                StringBuilder str=new StringBuilder();\n                List&lt;Integer&gt; reg=new ArrayList&lt;Integer&gt;(ans.get(j));\n                reg.add(nums[i]);\n                for(int k=0;k&lt;reg.size();++k){\n                    str.append(String.valueOf(reg.get(k)));\n                }\n                String n=str.toString();\n                if(!dict.contains(n)){\n                    ans.add(reg);\n                    dict.add(n);\n                }\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args){\n        int[] nums={1,2};\n        List&lt;List&lt;Integer&gt;&gt; ans=subsetsWithDup(nums);\n        System.out.println(ans.size());\n    }\n\n}</code></pre>","text":"(12) - Min Stack一个栈维护最小值,另一个栈存数据为什么最小值同步插入可行,因为栈的pop只能从栈顶开始，所以:1.栈顶元素最小,minValue栈顶也是该元素 2.栈顶元素不是最小,minValue中没有该元素public class MinStack {    ","link":"","raw":null,"photos":[],"categories":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/categories/LintCode.json"}],"tags":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/tags/LintCode.json"}]},{"title":"LintCode(1-11+114)","slug":"pl2-lintcode","date":"2018-06-17T09:46:21.000Z","updated":"2019-07-03T13:51:36.863Z","comments":true,"path":"api/articles/pl2-lintcode.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"（2）-尾部的零-Easy\"><a href=\"#（2）-尾部的零-Easy\" class=\"headerlink\" title=\"（2） 尾部的零(Easy)\"></a>（2） 尾部的零(Easy)</h1><blockquote>\n<p>因为2的数量远大于5,统计5的数量即可</p>\n</blockquote>\n<pre><code>public class Solution {\n    /*\n     * @param n: An integer\n     * @return: An integer, denote the number of trailing zeros in n!\n     */\n\n    public long trailingZeros(long n) {\n        // write your code here, try to do it without arithmetic operators.\n        long cnt=0,k=n;\n\n        while(k&gt;0){\n            cnt+=k/5;\n            k/=5;\n        }\n        return cnt;\n    }\n}</code></pre><h1 id=\"（3）-统计数字-中等\"><a href=\"#（3）-统计数字-中等\" class=\"headerlink\" title=\"（3） 统计数字(中等)\"></a>（3） 统计数字(中等)</h1><blockquote>\n<p>伪数位DP</p>\n</blockquote>\n<pre><code>public class Solution {\n    /*\n     * @param : An integer\n     * @param : An integer\n     * @return: An integer denote the count of digit k in 1..n\n     */\n\n    public int digitCounts(int k, int n) {\n        // write your code here\n        int cnt=0,mt=1,tmp=0;\n        int a=n;\n        if(k==0)tmp=1;\n        while(a&gt;0){\n            int digit=a%10;\n            a/=10;\n            if(digit&gt;k)cnt+=(a+1-tmp)*mt;\n            else if(digit==k) cnt+=(a-tmp)*mt+n%mt+1;\n            else cnt+=a*mt;\n            mt*=10;\n        }\n        cnt+=tmp;\n        return cnt;\n    }\n};</code></pre><h1 id=\"（4）-丑数二-中等\"><a href=\"#（4）-丑数二-中等\" class=\"headerlink\" title=\"（4） 丑数二(中等)\"></a>（4） 丑数二(中等)</h1><h2 id=\"筛法只能过94\"><a href=\"#筛法只能过94\" class=\"headerlink\" title=\"筛法只能过94%\"></a>筛法只能过94%</h2><blockquote>\n<p>因为他后面的数据超过10亿!….</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n        int[] ans=new int[767];\n        boolean[] is=new boolean[10000000];  \n        int tot=0;\n\n        void init(int n){\n            for(int i=0;i&lt;10000000;++i) is[i]=false;\n            is[1]=true;\n            ans[tot++]=1;\n            for(int i=1;i&lt;10000000;++i){\n                if(is[i]){\n                    for(int j=i*2;j&lt;10000000;j*=2){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                    for(int j=i*3;j&lt;10000000;j*=3){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                    for(int j=i*5;j&lt;10000000;j*=5){\n                        if(!is[j]){\n                            is[j]=true;\n                            ans[tot++]=j;\n                        }\n                    }\n                }\n            }\n        }\n\n    public int nthUglyNumber(int n) {\n        // write your code here\n            init(n);\n            //ans=IntStream.of(ans).boxed().sorted().mapToInt(Integer::intValue).toArray();\n            Arrays.sort(ans);\n            return ans[n-1];\n    }\n}</code></pre><h2 id=\"用HashSet-Dfs-AC\"><a href=\"#用HashSet-Dfs-AC\" class=\"headerlink\" title=\"用HashSet+Dfs AC\"></a>用HashSet+Dfs AC</h2><blockquote>\n<p>因为他给数据了,所以在已知数据是INT_MAX的前提下就好做多了</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n    HashSet&lt;Integer&gt; tSet=new HashSet&lt;&gt;();\n    int[] ans=new int[1665];\n    int tot=0;\n    void dfs(long num){\n        if(num&gt;(long)1898437500)return;\n        if(tSet.size()&gt;=1665) return;\n        if(tSet.contains((int)num)) return;\n        else{\n            tSet.add((int)num);\n            if(tot==1665)return;\n            ans[tot++]=(int)num;\n            dfs(num*2);\n            dfs(num*3);\n            dfs(num*5);\n        }\n    }\n\n    public int nthUglyNumber(int n) {\n        // write your code here\n        dfs(1);\n        Arrays.sort(ans);\n        return ans[n-1];\n    }\n}</code></pre><h2 id=\"找规律的解法\"><a href=\"#找规律的解法\" class=\"headerlink\" title=\"找规律的解法\"></a>找规律的解法</h2><blockquote>\n<p>可以发现只需要三个指针指向P1P2P3,同步前移,第n个就是这三个中最小的一个</p>\n</blockquote>\n<pre><code>class Solution {\npublic:\n    /**\n     * @param n: An integer\n     * @return: the nth prime number as description.\n     */\n    #define min(a,b) ((a)&lt;(b)?(a):(b))\n    #define min3(a,b,c) (min(min(a,b),min(a,c)))\n    int nthUglyNumber(int n) {\n        int i = 1;\n        int p2 = 0;\n        int p3 = 0;\n        int p5 = 0;\n        int uglyNum[6048] = {0};\n        uglyNum[0] = 1;\n        while ( i &lt; n ) {\n            uglyNum[i] = min3(uglyNum[p2] * 2, uglyNum[p3] * 3, uglyNum[p5] * 5);\n            if (uglyNum[i] == uglyNum[p2] * 2) {\n                p2++;\n            }\n            if (uglyNum[i] == uglyNum[p3] * 3) {\n                p3++;\n            }\n            if (uglyNum[i] == uglyNum[p5] * 5) {\n                p5++;\n            }\n            i++;\n        }\n        return uglyNum[n-1];\n    }\n};</code></pre><h1 id=\"（5）-第K大-中等\"><a href=\"#（5）-第K大-中等\" class=\"headerlink\" title=\"（5） - 第K大(中等)\"></a>（5） - 第K大(中等)</h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>利用快速排序的分块算法(Partition)+二分查找的思想解决即可.</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Topic_5 {\n    public static void main(String[] args){\n        int[] nums=new int[]{9,3,2,4,8};\n        System.out.println(kthLargestElement(3,nums));\n    }\n\n    //用首元素做pivot\n    private static int partition(int l,int r,int[] nums){\n        int pivot=nums[l];\n        int temp=nums[l],low=l,high=r;\n        while(low&lt;high){\n            while(low&lt;high &amp;&amp; nums[high]&lt;=temp){\n                high--;\n            }\n            nums[low]=nums[high];\n            while(low&lt;high &amp;&amp; nums[low]&gt;=temp){\n                low++;\n            }\n            nums[high]=nums[low];\n        }\n        nums[low]=temp;\n        return low;\n    }\n\n    public static int kthLargestElement(int n, int[] nums) {\n        // write your code here\n        int l=0,r=nums.length - 1;\n        while(l&lt;r){\n            int k=partition(l,r,nums);\n            if(k==n-1) break;\n            if(k&lt;n-1) l=k+1;\n            else if(k&gt;n-1) r=k-1;\n        }\n        return nums[n-1];\n    }\n}</code></pre><h1 id=\"（6）-合并有序数组-简单\"><a href=\"#（6）-合并有序数组-简单\" class=\"headerlink\" title=\"（6） - 合并有序数组(简单)\"></a>（6） - 合并有序数组(简单)</h1><blockquote>\n<p>方法:</p>\n<blockquote>\n<p>常规合并</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param A: sorted integer array A\n     * @param B: sorted integer array B\n     * @return: A new sorted integer array\n     */\n\n    private int[] solve(int A[],int B[]){\n        int[] res=new int[A.length+B.length];\n        int tagA=0,tagB=0,tot=0;\n        while(tagA&lt;A.length &amp;&amp; tagB&lt;B.length){\n            if(A[tagA]&lt;B[tagB])res[tot++]=A[tagA++];\n            else res[tot++]=B[tagB++];\n        }\n        while(tagA&lt;A.length){\n            res[tot++]=A[tagA++];\n        }\n        while(tagB&lt;B.length){\n            res[tot++]=B[tagB++];\n        }\n        return res;\n    }\n\n    public int[] mergeSortedArray(int[] A, int[] B) {\n        // write your code here\n        return solve(A,B);\n    }\n}</code></pre><h1 id=\"（7）-序列化二叉树与反序列化\"><a href=\"#（7）-序列化二叉树与反序列化\" class=\"headerlink\" title=\"（7） - 序列化二叉树与反序列化\"></a>（7） - 序列化二叉树与反序列化</h1><blockquote>\n<p>注意bfs序列化后最简单的反序列化是for循环. dfs序列化后最简单的反序列是递归. 当然也可以用两序遍历</p>\n</blockquote>\n<pre><code>import sun.reflect.generics.tree.Tree;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class TOPIC_6 {\n    public static class TreeNode {\n        public int val;\n        public TreeNode left, right;\n        public TreeNode(int val) {\n            this.val = val;\n            this.left = this.right = null;\n        }\n    }\n\n    public static void main(String[] args){\n        TreeNode nt=Solution.deserialize(&quot;1,2,3,#,#,#,#,&quot;);\n        System.out.println(Solution.serialize(nt));\n    }\n\n    public static class Solution {\n        /**\n         * This method will be invoked first, you should design your own algorithm\n         * to serialize a binary tree which denote by a root node to a string which\n         * can be easily deserialized by your own &quot;deserialize&quot; method later.\n         */\n\n        public static void dfs(TreeNode root,StringBuilder data){\n            if(root==null){\n                data.append(&quot;#,&quot;);\n            }else{\n                data.append(String.valueOf(root.val)+&quot;,&quot;);\n                dfs(root.left,data);\n                dfs(root.right,data);\n            }\n        }\n\n        public static String serialize(TreeNode root) {\n            // write your code here\n            StringBuilder data=new StringBuilder();\n            dfs(root,data);\n            return data.toString();\n        }\n\n        // Decodes your encoded data to tree.\n        public static TreeNode deserialize(String data) {\n            LinkedList&lt;String&gt; que = new LinkedList&lt;String&gt;();\n            que.addAll(Arrays.asList(data.split(&quot;,&quot;)));\n            return deserial(que);\n        }\n\n        private static TreeNode deserial(LinkedList&lt;String&gt; que){\n            String str = que.pollFirst();\n            if(str.equals(&quot;#&quot;)){\n                return null;\n            }\n            TreeNode root = new TreeNode(Integer.valueOf(str));\n            if(que.size()!=0) {\n                root.left = deserial(que);\n                root.right = deserial(que);\n            }\n            return root;\n        }\n    }\n}</code></pre><h1 id=\"（8）-旋转字符串\"><a href=\"#（8）-旋转字符串\" class=\"headerlink\" title=\"（8） 旋转字符串\"></a>（8） 旋转字符串</h1><blockquote>\n<p>剑指Offer上的一道题</p>\n<blockquote>\n<p>先整体旋转,然后把offset前后各旋转一次即可</p>\n</blockquote>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param str: An array of char\n     * @param offset: An integer\n     * @return: nothing\n     */\n\n    void Reverse(char[] str,int start,int end){\n        while(start&lt;end){\n            if(end-1&lt;=start)break;\n            str[start]^=str[end-1];\n            str[end-1]^=str[start];\n            str[start]^=str[end-1];\n            start++;end--;\n        }\n    } \n\n    public void rotateString(char[] str, int offset) {\n        // write your code here\n        int len=str.length;\n        if(len&lt;=0)return;\n        int fnos=offset%len;\n        Reverse(str,0,len);\n        Reverse(str,0,fnos);\n        Reverse(str,fnos,len);\n    }\n}</code></pre><h1 id=\"（9）-嘶嘶\"><a href=\"#（9）-嘶嘶\" class=\"headerlink\" title=\"（9） - 嘶嘶\"></a>（9） - 嘶嘶</h1><pre><code>public class Solution {\n    /**\n     * @param n: An integer\n     * @return: A list of strings.\n     */\n    public List&lt;String&gt; fizzBuzz(int n) {\n        // write your code here\n        List&lt;String&gt; ans=new LinkedList&lt;String&gt;();\n        for(int i=1;i&lt;=n;++i){\n            if(i%3==0 &amp;&amp; i%5==0) ans.add(&quot;fizz buzz&quot;);\n            else if(i%3==0) ans.add(&quot;fizz&quot;);\n            else if(i%5==0) ans.add(&quot;buzz&quot;);\n            else ans.add(String.valueOf(i));\n        }\n        return ans;\n    }\n}</code></pre><h1 id=\"（11）-Search-Range-in-Binary-Search-Tree\"><a href=\"#（11）-Search-Range-in-Binary-Search-Tree\" class=\"headerlink\" title=\"（11） - Search Range in Binary Search Tree\"></a>（11） - Search Range in Binary Search Tree</h1><blockquote>\n<p>常规dfs,可以剪枝</p>\n</blockquote>\n<pre><code>/**\n * Definition of TreeNode:\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left, right;\n *     public TreeNode(int val) {\n *         this.val = val;\n *         this.left = this.right = null;\n *     }\n * }\n */\n\npublic class Solution {\n\n    private int l;\n    private int r;\n\n    public void dfs(List&lt;Integer&gt; data,TreeNode root){\n        int value=root.val;\n        if(value&gt;=l &amp;&amp; value&lt;= r){\n            data.add(value);\n            if(root.left!=null)\n                dfs(data,root.left);\n            if(root.right!=null)\n                dfs(data,root.right);\n        }else{\n            if(value &gt;= r &amp;&amp; root.left!=null){\n                dfs(data,root.left);\n            }\n            if(value &lt;= l &amp;&amp; root.right!=null){\n                dfs(data,root.right);\n            }\n        }\n    }\n\n\n\n    /**\n     * @param root: param root: The root of the binary search tree\n     * @param k1: An integer\n     * @param k2: An integer\n     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order\n     */\n    public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) {\n        List&lt;Integer&gt; data=new LinkedList&lt;&gt;();\n        if(root==null)return data;\n        this.l=k1;\n        this.r=k2;\n        dfs(data,root);\n        return data;\n    }\n}</code></pre><h1 id=\"（114）-不同的路径-中等\"><a href=\"#（114）-不同的路径-中等\" class=\"headerlink\" title=\"（114） 不同的路径(中等)\"></a>（114） 不同的路径(中等)</h1><blockquote>\n<p>很明显是杨辉三角,求C(n,m) 当然,也可以用动态规划,dp[i][j]=dp[i-1][j]+dp[i][j-1]</p>\n</blockquote>\n<pre><code>public class Solution {\n    /**\n     * @param m: positive integer (1 &lt;= m &lt;= 100)\n     * @param n: positive integer (1 &lt;= n &lt;= 100)\n     * @return: An integer\n     */\n    public int[][] res=new int[204][204];\n    public void init(){\n        res[0][0]=1;\n        for(int i=1;i&lt;=200;++i){\n            res[i][0]=1;\n            for(int j=1;j&lt;=i;++j){\n                res[i][j]=res[i-1][j-1]+res[i-1][j];\n            }\n        }\n    }\n\n    public int uniquePaths(int m, int n) {\n        // write your code here\n        init();\n        return res[m+n-2][m-1];\n    }\n}</code></pre>","text":"（2） 尾部的零(Easy)因为2的数量远大于5,统计5的数量即可public class Solution {    /*     * @param n: An integer     * @return: An integer, denote the number of tr","link":"","raw":null,"photos":[],"categories":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/categories/LintCode.json"}],"tags":[{"name":"LintCode","slug":"LintCode","count":2,"path":"api/tags/LintCode.json"}]}]}