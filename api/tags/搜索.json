{"name":"搜索","slug":"搜索","count":2,"postlist":[{"title":"POJ 1321 && 2251","slug":"poj-1321-2251","date":"2017-01-21T13:39:02.000Z","updated":"2019-07-03T13:51:36.845Z","comments":true,"path":"api/articles/poj-1321-2251.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 dfs,bfs,搜索基础 【来源】 <a href=\"https://vjudge.net/contest/148331#overview\" target=\"_blank\" rel=\"noopener\">[kuangbin带你飞]专题一 简单搜索 [Cloned]</a> 【Tip】 摘自网上一个blog,一般求最大或者总的xx(方案,步数…)的时候,一般用bfs,如果用dfs的话,你要写很多if来判断. 【Code】 1321</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<cstdio></cstdio></em> <em>#include<cstring></cstring></em> <em>using namespace std;</em> <em>int chess[15][15];</em> <em>int vichess[15]={0};</em> <em>int n,k,cnt,num=0;</em> <em>char elem;</em> <em>void dfs(int i){</em> _    if(num==k){_ _        cnt++;_ _        return;_ _    }_ _    for(int t=i;t&lt;=n;++t)_ _        for(int j=1;j&lt;=n;++j)_ _            if(chess[t][j] &amp;&amp; !vichess[j]){_ _                vichess[j]=1;_ _                num++;_ _                dfs(t+1);_ _                vichess[j]=0;_ _                num–;_ _            }_ <em>}</em> <em>int main(){</em> _    while(~scanf(“%d %d”,&amp;n,&amp;k) &amp;&amp; n!=-1 &amp;&amp; k!=-1){_ _         memset(chess,0,sizeof(chess));_ _         cnt=0;_ _         for(int i=1;i&lt;=n;++i){_ _            for(int j=1;j&lt;=n;++j){_ _                cin&gt;&gt;elem;_ _                if(elem==’#’)_ _                    chess[i][j]=1;_ _            }_ _         }_ _        dfs(1);_ _        printf(“%d\\n”,cnt);_ _    }_ _    return 0;_ <em>}</em></p>\n</blockquote>\n<p>2251</p>\n<blockquote>\n<p><em>#include<iostream></iostream></em> <em>#include<algorithm></algorithm></em> <em>#include<queue></queue></em> <em>#include<cstdio></cstdio></em> <em>#include<cstring></cstring></em> <em>#define maxn 40</em> <em>using namespace std;</em> <em>struct Node{</em> _    int x,y,z,t;_ _    Node(int i,int j,int m,int n):x(i),y(j),z(m),t(n){}//构造_ _    Node(){}_ <em>}pre;</em> <em>char ma[maxn][maxn][maxn];</em> <em>int vi[maxn][maxn][maxn];</em> <em>int L,R,C,sx,sy,sz,ex,ey,ez;</em> <em>int toward[6][3]={1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1};//六种走向</em> <em>bool judge(int xx,int yy,int zz){</em> _    if(xx&lt;=0 || xx&gt;L || yy&lt;=0 || yy&gt;R || zz&lt;=0 || zz&gt;C)_ _        return false;_ _    return true;_ <em>}</em> <em>void bfs(){</em> _    memset(vi,0,sizeof(vi));_ _    queue<node> que;_ _    que.push(Node(sx,sy,sz,0));_ _    vi[sx][sy][sz]=1;_ _    while(!que.empty()){_ _        pre=que.front(); que.pop();_ _        if(pre.x==ex &amp;&amp; pre.y==ey &amp;&amp; pre.z==ez){_ _            printf(“Escaped in %d minute(s).\\n”,pre.t);_ _            return;_ _        }_ _        for(int i=0;i&lt;6;++i){_ _            int xx=pre.x+toward[i][0];_ _            int yy=pre.y+toward[i][1];_ _            int zz=pre.z+toward[i][2];_ _            if(judge(xx,yy,zz) &amp;&amp; !vi[xx][yy][zz] &amp;&amp; ma[xx][yy][zz]!=’#’){_ _                vi[xx][yy][zz]=1;_ _                que.push(Node(xx,yy,zz,pre.t+1));_ _            }_ _        }_ _    }_ _    printf(“Trapped!\\n”);_ <em>}</em> <em>int main(){</em> _    while(~scanf(“%d%d%d”,&amp;L,&amp;R,&amp;C),L+R+C){_ _        for(int i=1;i&lt;=L;++i)_ _            for(int j=1;j&lt;=R;++j)_ _                scanf(“%s”,ma[i][j]+1);_ _        for(int i=1;i&lt;=L;++i)_ _            for(int j=1;j&lt;=R;++j)_ _                for(int z=1;z&lt;=C;++z)_ _                    if(ma[i][j][z]==’S’)_ _                        sx=i,sy=j,sz=z;_ _                    else if(ma[i][j][z]==’E’)_ _                        ex=i,ey=j,ez=z;_ _         bfs();_ _    }_ _    return 0;_ <em>}</em></node></p>\n</blockquote>\n","text":"【类型】 dfs,bfs,搜索基础 【来源】 [kuangbin带你飞]专题一 简单搜索 [Cloned] 【Tip】 摘自网上一个blog,一般求最大或者总的xx(方案,步数…)的时候,一般用bfs,如果用dfs的话,你要写很多if来判断. 【Code】 1321#includ","link":"","raw":null,"photos":[],"categories":[{"name":"搜索","slug":"搜索","count":2,"path":"api/categories/搜索.json"}],"tags":[{"name":"搜索","slug":"搜索","count":2,"path":"api/tags/搜索.json"}]},{"title":"POJ 3984","slug":"poj-3984","date":"2017-03-24T12:40:32.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/poj-3984.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【类型】 bfs 【Tip】 当结构体内部有构造函数时,不能定义二维结构体. 【Code】</p>\n<p>#include<iostream></iostream></p>\n<p>#include<algorithm></algorithm></p>\n<p>#include<cstdio></cstdio></p>\n<p>#include<cstring></cstring></p>\n<p>#include<cstdlib></cstdlib></p>\n<p>#include<queue></queue></p>\n<p>#include<stack><br>using namespace std;<br>struct node{<br>    int x,y,sx,sy;<br>    //node(int xx,int yy,int ssx,int ssy):x(xx),y(yy),sx(ssx),sy(ssy) {}<br>};<br>node position[10][10];<br>queue q;<br>int vi[6][6]={0};<br>int maze[5][5]={<br>    0, 1, 0, 0, 0,<br>    0, 1, 0, 1, 0,<br>    0, 0, 0, 0, 0,<br>    0, 1, 1, 1, 0,<br>    0, 0, 0, 1, 0,<br>};</stack></p>\n<p>void Bac(int x,int y){<br>    if(x==-1,y==-1){<br>        return;<br>    }<br>    Bac(position[x][y].x,position[x][y].y);<br>    printf(“(%d, %d)\\n”,x,y);<br>}</p>\n<p>node Anode(int x,int y,int sx,int sy){<br>    node A;<br>    A.x=x;<br>    A.y=y;<br>    A.sx=sx;<br>    A.sy=sy;<br>    return A;<br>}</p>\n<p>void bfs(){<br>    position[0][0].x=-1;<br>    position[0][0].y=-1;<br>    position[0][0].sx=0;<br>    position[0][0].sy=0;<br>    q.push(Anode(-1,-1,0,0));<br>    vi[0][0]=1;<br>    while(!q.empty()){<br>        node a=q.front();<br>        if(a.sx==4 &amp;&amp; a.sy==4){<br>            Bac(a.sx,a.sy);<br>            return;<br>        }<br>        q.pop();<br>        if(a.sx+1=0 &amp;&amp; !vi[a.sx][a.sy-1]&amp;&amp; !maze[a.sx][a.sy-1]){<br>            position[a.sx][a.sy-1].sx=a.sx;<br>            position[a.sx][a.sy-1].sy=a.sy-1;<br>            position[a.sx][a.sy-1].x=a.sx;<br>            position[a.sx][a.sy-1].y=a.sy;<br>            q.push(Anode(a.sx,a.sy,a.sx,a.sy-1));<br>            vi[a.sx][a.sy-1]=1;<br>        }<br>        if(a.sx-1&gt;=0 &amp;&amp; !vi[a.sx-1][a.sy]&amp;&amp; !maze[a.sx-1][a.sy]){<br>            position[a.sx-1][a.sy].sx=a.sx-1;<br>            position[a.sx-1][a.sy].sy=a.sy;<br>            position[a.sx-1][a.sy].x=a.sx;<br>            position[a.sx-1][a.sy].y=a.sy;<br>            q.push(Anode(a.sx,a.sy,a.sx-1,a.sy));<br>            vi[a.sx-1][a.sy]=1;<br>        }<br>    }<br>}<br>int main(){<br>    bfs();<br>    return 0;<br>}</p>\n","text":"【类型】 bfs 【Tip】 当结构体内部有构造函数时,不能定义二维结构体. 【Code】#include#include#include#include#include#include#include<br>using namespace std;<br>struct node","link":"","raw":null,"photos":[],"categories":[{"name":"搜索","slug":"搜索","count":2,"path":"api/categories/搜索.json"}],"tags":[{"name":"搜索","slug":"搜索","count":2,"path":"api/tags/搜索.json"}]}]}