{"name":"容斥原理","slug":"容斥原理","count":3,"postlist":[{"title":"2018全国多校算法寒假练习赛(三) G","slug":"2018qs-g","date":"2018-02-08T08:58:44.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/2018qs-g.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://www.nowcoder.net/acm/contest/75/G\" title=\"https://www.nowcoder.net/acm/contest/75/G\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.net/acm/contest/75/G</a></p>\n<h1 id=\"type-容斥定理-1-n整数倍定理\"><a href=\"#type-容斥定理-1-n整数倍定理\" class=\"headerlink\" title=\"type: 容斥定理,1~n整数倍定理\"></a>type: 容斥定理,1~n整数倍定理</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个n(1<del>1e18 long long 范围内),问你1</del>n中不为2,5,1,,13倍数的数有多少个.</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>1.我忘了一个定理:</p>\n<blockquote>\n<p>设求: 1~n之间有多少个数是给定的x的倍数?</p>\n<blockquote>\n<p>答案为 n/x</p>\n</blockquote>\n</blockquote>\n<p>有了以上那个定理就好求了,设条件 A 为1<del>n中2的倍数,B 为1</del>n中5的倍数,C,D. 则答案就是:</p>\n<blockquote>\n<p>|(<del>A)∩(</del>B)∩(<del>C)∩(</del>D)|</p>\n</blockquote>\n<p>标准容斥,情况只有2^4-1=15种,写代码吧</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\n\nvoid solve(LL N){\n    LL ans=N;\n    LL k[4]={2,5,11,13};\n    for(int seq=1;seq&lt;16;++seq){\n        LL reg=1;\n        int d=0;\n        if(seq&amp;1) reg*=k[0],d++;\n        if(seq&amp;2) reg*=k[1],d++;\n        if(seq&amp;4) reg*=k[2],d++;\n        if(seq&amp;8) reg*=k[3],d++;\n        if(d&amp;1) ans-=(N/reg);\n        else ans+=(N/reg);\n    }\n    printf(&quot;%lld\\n&quot;,ans);\n}\n\nint main(){\n    LL n;\n    while(cin&gt;&gt;n){\n        solve(n);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://www.nowcoder.net/acm/contest/75/Gtype: 容斥定理,1~n整数倍定理题意给你一个n(11e18 long long 范围内),问你1n中不为2,5,1,,13倍数的数有多少个.题解1.我忘了一个定理:设求: 1~n之间有","link":"","raw":null,"photos":[],"categories":[{"name":"容斥原理","slug":"容斥原理","count":1,"path":"api/categories/容斥原理.json"},{"name":"数论","slug":"容斥原理/数论","count":1,"path":"api/categories/容斥原理/数论.json"},{"name":"牛客练习赛","slug":"容斥原理/数论/牛客练习赛","count":1,"path":"api/categories/容斥原理/数论/牛客练习赛.json"}],"tags":[{"name":"牛客练习赛","slug":"牛客练习赛","count":10,"path":"api/tags/牛客练习赛.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"}]},{"title":"CSU 1803","slug":"csu-1803","date":"2017-08-20T07:41:04.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/csu-1803.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 容斥,唯一分解定理 题目连接: :earth_americas:<a href=\"https://vjudge.net/problem/CSU-1803\" title=\"CSU-1803\" target=\"_blank\" rel=\"noopener\">CSU-1803</a> 题解: 由素分可以得到</p>\n<pre><code>2016=2*2*2*2*2*3*3*7 所以我们可以判断出 a 中有多少2016的因子,然后算出b中与a至少互补的因子个数,利用容斥原理计算出最后的结果.</code></pre><p>github: :moon:<a href=\"https://github.com/834930269/Other_OJ/blob/master/CSU/%E5%AE%B9%E6%96%A5/1803.cpp\" title=\"1803.cpp\" target=\"_blank\" rel=\"noopener\">1803.cpp</a> Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long LL;\nLL arr[10][10][10];\nLL a,b;\nint main(){\n    ///2016=2*2*2*2*2*3*3*7\n\n    while(~scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b)){\n        memset(arr,0,sizeof(arr));\n        for(int i=0;i&lt;6;++i)\n            for(int j=0;j&lt;3;++j)\n                for(int t=0;t&lt;2;++t)\n                    arr[i][j][t]=a/(int)(pow(2,i)*pow(3,j)*pow(7,t));\n        LL ans=0;\n        for(int i=0;i&lt;6;++i)\n            for(int j=0;j&lt;3;++j)\n                for(int t=0;t&lt;2;++t)\n                    ans+=(arr[i][j][t]-arr[i+1][j][t]-arr[i][j+1][t]-arr[i][j][t+1]+arr[i+1][j+1][t]+arr[i+1][j][t+1]+arr[i][j+1][t+1]-arr[i+1][j+1][t+1])*(b/(int)(pow(2,5-i)*pow(3,2-j)*pow(7,1-t)));\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"类型: 容斥,唯一分解定理 题目连接: :earth_americas:CSU-1803 题解: 由素分可以得到2016=2*2*2*2*2*3*3*7 所以我们可以判断出 a 中有多少2016的因子,然后算出b中与a至少互补的因子个数,利用容斥原理计算出最后的结果.github","link":"","raw":null,"photos":[],"categories":[{"name":"CSU","slug":"CSU","count":1,"path":"api/categories/CSU.json"},{"name":"唯一分解定理","slug":"CSU/唯一分解定理","count":1,"path":"api/categories/CSU/唯一分解定理.json"},{"name":"容斥原理","slug":"CSU/唯一分解定理/容斥原理","count":1,"path":"api/categories/CSU/唯一分解定理/容斥原理.json"}],"tags":[{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"},{"name":"CSU","slug":"CSU","count":1,"path":"api/tags/CSU.json"},{"name":"唯一分解定理","slug":"唯一分解定理","count":1,"path":"api/tags/唯一分解定理.json"}]},{"title":"UVa 11806","slug":"uva-11806","date":"2018-02-05T09:48:17.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11806.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11806\" title=\"https://vjudge.net/problem/UVA-11806\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11806</a></p>\n<h1 id=\"Type\"><a href=\"#Type\" class=\"headerlink\" title=\"Type:\"></a>Type:</h1><blockquote>\n<p>组合数学,排列预处理,容斥原理,减法取模公式</p>\n</blockquote>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,</p>\n<blockquote>\n<p>问最上边,最左边,最下边,最右边都有石子的种数为多少?</p>\n</blockquote>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>我们可以将问题转化为:</p>\n<blockquote>\n<p>全集|S|-至少有一条边上没有棋子的种类个数. 并且我们可以发现,当四条边上都没有棋子时的种类个数为</p>\n<blockquote>\n<p>C((m-2)*(n-2),k).</p>\n</blockquote>\n<p>我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,D为下边没有石子. 则(我们设~A为非A集合):</p>\n<blockquote>\n<p>ans=|(<del>A)∩(</del>B)∩(<del>C)∩(</del>D)|</p>\n</blockquote>\n<p>可以发现就是容斥原理 至于每个集合的计算,在图中就相当于少了一行或一列, 即:</p>\n<blockquote>\n<p>C(row*column,k)</p>\n</blockquote>\n<p>因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能 即 可以用四位2进制表示</p>\n<blockquote>\n<p>0000 0001 0010</p>\n</blockquote>\n<p>我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行)) 等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0</p>\n</blockquote>\n<p>答案为全部的和.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\nLink: https://vjudge.net/problem/UVA-11806\nType: 组合数学,排列预处理,容斥原理,减法取模公式\n题意: 给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,\n问最上边,最左边,最下边,最右边都有石子的种数为多少?\n\n题解:\n我们可以将问题转化为:\n全集|S|-至少有一条边上没有棋子的种类个数.\n并且我们可以发现,当四条边上都没有棋子时的种类个数为\nC((m-2)*(n-2),k).\n我们设A最左边没有石子,B为上边没有石子,C为右边没有石子,\nD为下边没有石子.\n则(我们设~A为非A集合):\nans=|(~A)∩(~B)∩(~C)∩(~D)|\n可以发现就是容斥原理\n至于每个几何的计算,在图中就相当于少了一行或一列,\n即:\nC(row*column,k)\n因为有: Sigma(i=1~4) C(4,i) = 2^4 = 16 种可能\n即 可以用四位2进制表示\n0000\n0001\n0010\n我们设四位如下排列: (最左(减列),最上(减行),最右(减列),最下(减行))\n等全部情况,在容斥中,其中1为奇数个时符号位是-,偶数是0\n答案为全部的和.\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1e6+7;\nint T;\n\nconst int MAXK=500;\nint C[MAXK+10][MAXK+10];\nvoid init(){\n    memset(C,0,sizeof(C));\n    C[0][0]=1;\n    for(int i=0;i&lt;=MAXK;++i){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j&lt;i;++j){\n            //组合的一个递推公式\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n    }\n}\n\nint main(){\n    init();\n    cin&gt;&gt;T;\n    for(int kase=1;kase&lt;=T;++kase){\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        int sum=0;\n        for(int i=0;i&lt;16;++i){\n            int nn=n,mm=m;\n            int b=0;\n            if(i&amp;1){mm--;b++;}\n            if(i&amp;2){nn--;b++;}\n            if(i&amp;4){mm--;b++;}\n            if(i&amp;8){nn--;b++;}\n            //奇数-偶数+\n            if(b&amp;1) sum=(sum+mod-C[nn*mm][k])%mod;\n            else sum=(sum+C[nn*mm][k])%mod;\n        }\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11806Type:组合数学,排列预处理,容斥原理,减法取模公式题意给你一个M*N(M行N列)的棋盘和k个相同的石子,每个格子最多放一个石子,问最上边,最左边,最下边,最右边都有石子的种数为多少?题解我们可以将","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"容斥原理","slug":"UVa/容斥原理","count":1,"path":"api/categories/UVa/容斥原理.json"},{"name":"数论","slug":"UVa/容斥原理/数论","count":1,"path":"api/categories/UVa/容斥原理/数论.json"},{"name":"组合数学","slug":"UVa/容斥原理/数论/组合数学","count":1,"path":"api/categories/UVa/容斥原理/数论/组合数学.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"容斥原理","slug":"容斥原理","count":3,"path":"api/tags/容斥原理.json"},{"name":"组合数学","slug":"组合数学","count":12,"path":"api/tags/组合数学.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}