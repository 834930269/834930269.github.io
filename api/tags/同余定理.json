{"name":"同余定理","slug":"同余定理","count":3,"postlist":[{"title":"51nod 1225 余数之和","slug":"51nod-1225-yszh","date":"2018-03-12T10:04:08.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1225-yszh.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type逆元数论思维同余定理\">Type:逆元,数论,思维,同余定理</span></h1><h1><span id=\"直接上代码题解在代码中这道题有点耗时间但挺有趣的\">直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nLL N;\n/*打表\nvoid Table(int NN){\n    for(int i=1;i&lt;=NN;++i){\n        printf(&quot;%04d-%04d &quot;,i,NN%i);\n    }\n}\n*/\nLL fast_mod(LL a,LL n,LL Mod){\n    LL ans=1;\n    while(n){\n        if(n&amp;1){\n            ans=(ans*a)%Mod;\n        }\n        a=(a*a)%Mod;\n        n&gt;&gt;=1;\n    }\n    return ans;\n}\n\nLL inv2=fast_mod(2,mod-2,mod);\n///对照算法\nLL hh(){\n    LL n=N;\n    LL ans;\n    ans=n%mod*(n%mod)%mod;\n    for(LL t,r,i=1;i&lt;=n;++i) {\n        t=n/i;\n        r=n/t;\n        ans=ans-((r-i+1)%mod*((r+i)%mod))%mod*inv2%mod*t%mod;\n        while(ans&lt;0) ans+=mod;\n        i=r;\n    }\n    return ans;\n}\n\n///本来想的是计算当前N/i相同的数量--结果为:\n///(N-tmp*i)/i 即计算在 N-当前数字*(N/i)后还有多少个数字可以\n///整分给(N/i),由于这个方法利用了除法,所以处理除法溢出有点麻烦\n///1e9左右就炸掉了\n///乘法溢出也很麻烦\n\n///最好的方法就是 N/tmp 理解为最后一个除以 N 等于 tmp 的数字是几\n\n///式子: F[N]=N*N-Sigma(N/i*i | i∈[1,N])\n///其中 括号内的式子的 N/i 有sqrt(n)个不同的值\n///证: 设 tmp=100/i 则 tmp*i=100 故 Count(tmp)&lt;=sqrt(100)\n///并且可以看出 相同的 N/i 对应的 i 是连续的.\n///即我们可以用等差数列求和公式来求 当 tmp=N/i 时 i 的和\n///用等差数列求和时/2用 2的逆元来做\\\n\n///自己坐着坐着就莫名其妙和他一样了= =\nLL solve(){\n    LL ans=N%mod*(N%mod)%mod;\n    for(LL i=1;i&lt;=N;){\n        LL tmp=N/i;\n        LL t=N/tmp;\n        tmp=((i+t)%mod*((t-i+1)%mod))%mod*inv2%mod*tmp%mod;\n        ans=(ans%mod-tmp%mod+mod)%mod;\n        i=t+1;\n    }\n    return ans;\n}\n\nvoid dui_pai(){\n    for(LL i=1;i&lt;=1000000;++i){\n        N=i;\n        if(hh()!=solve()) printf(&quot;%lld Faild\\n&quot;,N);\n    }\n    puts(&quot;Done&quot;);\n}\n\nint main(){\n    //dui_pai();\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        printf(&quot;%lld\\n&quot;,solve());\n    }\n    return 0;\n}</code></pre>","text":"Type:逆元,数论,思维,同余定理直接上代码,题解在代码中,这道题有点耗时间,但挺有趣的#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL mod=1e9+7;LL N;/","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"同余定理","slug":"51nod/同余定理","count":1,"path":"api/categories/51nod/同余定理.json"},{"name":"数论","slug":"51nod/同余定理/数论","count":1,"path":"api/categories/51nod/同余定理/数论.json"},{"name":"逆元","slug":"51nod/同余定理/数论/逆元","count":1,"path":"api/categories/51nod/同余定理/数论/逆元.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"逆元","slug":"逆元","count":4,"path":"api/tags/逆元.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"}]},{"title":"HDU 1021","slug":"hdu-1021","date":"2018-02-09T12:25:13.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-1021.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/HDU-1021\" title=\"https://vjudge.net/problem/HDU-1021\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-1021</a></p>\n<h1><span id=\"type-数论同余定理和余数性质找规律也可以\">Type: 数论,同余定理和余数性质,找规律也可以</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11</p>\n<blockquote>\n<p>问:</p>\n<blockquote>\n<p>给你一个数n,如果f(n)整除3,则输出yes,否则no.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>(1) 暴力输出一波会发现如果 n%4==2,则输出yes (2) 正解:</p>\n<blockquote>\n<p>问题可以转换成 f(n)%3 是否等于0 那么我们只需要记录下每个 f(n)%3 的值即可 f(n)≡(f(n-1)+f(n-2))(mod 3) n&gt;=2 f(n)=((f(n-1)%3)+(f(n-2)%3))%3</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><h2><span id=\"1-找规律\">1-找规律</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main(){\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(n%4==2){\n            printf(&quot;yes\\n&quot;);\n        }else{\n            printf(&quot;no\\n&quot;);\n        }\n    }\n    return 0;\n}</code></pre><h2><span id=\"2-正解\">2-正解</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nint m[maxn];\n\nvoid init(){\n    m[0]=7,m[1]=11;\n    for(int i=2;i&lt;=1000000;++i){\n        m[i]=((m[i-1]%3)+(m[i-2]%3))%3;\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        printf(&quot;%s\\n&quot;,(!m[n])?&quot;yes&quot;:&quot;no&quot;);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-1021Type: 数论,同余定理和余数性质,找规律也可以题意f(n)=f(n-1)+f(n-2) f(0)=7，f(1)=11问:给你一个数n,如果f(n)整除3,则输出yes,否则no.题解(1) 暴力输出","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"HDU 2035","slug":"hdu-2035","date":"2018-02-11T08:47:36.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/hdu-2035.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/HDU-2035\" title=\"https://vjudge.net/problem/HDU-2035\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2035</a></p>\n<h1><span id=\"type-同余定理\">Type: 同余定理</span></h1><h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>可以将提议理解为 ans%1000</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod=1000;\nint main(){\n    int A,B;\n    while(cin&gt;&gt;A&gt;&gt;B&amp;&amp;A+B){\n        int ans=1;\n        for(int i=1;i&lt;=B;++i){\n            ans=((ans%mod)*(A%mod))%mod;\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/HDU-2035Type: 同余定理题解可以将提议理解为 ans%1000Code#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=1000;","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"同余定理","slug":"HDU/同余定理","count":2,"path":"api/categories/HDU/同余定理.json"},{"name":"数论","slug":"HDU/同余定理/数论","count":2,"path":"api/categories/HDU/同余定理/数论.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"同余定理","slug":"同余定理","count":3,"path":"api/tags/同余定理.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]}]}