{"name":"STL","slug":"STL","count":2,"postlist":[{"title":"第六届山东省ACM/ICPC B Lowest Unique Price","slug":"dljaisdsacmicpc-b-lowest-unique-price","date":"2017-04-18T15:31:58.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/dljaisdsacmicpc-b-lowest-unique-price.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>set,映射</strong> <strong>【Tip】</strong> <strong>题目上给的数据范围是 x∈[1,106]</strong> <strong>但是我写代码时把映射空间开到100000才A了过去.?????? WTF??</strong> <strong>另外,一开始我用map动态搜索,输出时遍历查找最少价值为一次的结果,果不其然,TLE.</strong> <strong>所以改成了set动态更新第一个节点.即最小点.实现不需要遍历直接插入瞎搞的算法.</strong> <strong>PS:真心搞不懂为啥映射数组要开10W啊？？？？？？？</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define cle(a,val) memset(a,(val),sizeof(a)) #define SI(N) scanf(“%d”,&amp;(N)) #define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M)) #define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K)) #define rep(i,b) for(int i=0;i&lt;(b);i++) #define rez(i,a,b) for(int i=(a);i&lt;=(b);i++) #define red(i,a,b) for(int i=(a);i&gt;=(b);i–) const ll LINF = 0x3f3f3f3f3f3f3f3f; #define PU(x) puts(#x); #define PI(A) cout&lt;&lt;(A)&lt;&lt;endl; #define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl; #define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl; #define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl; #define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl; #define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;} const double EPS = 1e-9 ; int reg[100000]; char readchar(){ char c=getchar(); while(c!=’b’ &amp;&amp; c!=’q’ &amp;&amp; c!=’c’) c=getchar(); return c; } int main(){ int T; scanf(“%d”,&amp;T); while(T–){ set<int> se; cle(reg,0); int N; SI(N); rep(i,N){ char a; int b; a=readchar(); if(a==’b’){ SI(b); reg[b]++; if(reg[b]==1) se.insert(b); else se.erase(b); } if(a==’c’){ SI(b); if(reg[b]&gt;0){ reg[b]–; if(reg[b]==1) se.insert(b); else se.erase(b); } } if(a==’q’){ if(se.empty()) puts(“none”); else printf(“%d\\n”,*(se.begin())); } } } return 0; }</int></strong></p>\n</blockquote>\n","text":"【类型】 set,映射 【Tip】 题目上给的数据范围是 x∈[1,106] 但是我写代码时把映射空间开到100000才A了过去.?????? WTF?? 另外,一开始我用map动态搜索,输出时遍历查找最少价值为一次的结果,果不其然,TLE. 所以改成了set动态更新第一个节点.","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"STL","slug":"Sdut/STL","count":2,"path":"api/categories/Sdut/STL.json"},{"name":"第六届ACM山东省赛","slug":"Sdut/STL/第六届ACM山东省赛","count":1,"path":"api/categories/Sdut/STL/第六届ACM山东省赛.json"}],"tags":[{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第六届ACM山东省赛","slug":"第六届ACM山东省赛","count":3,"path":"api/tags/第六届ACM山东省赛.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"}]},{"title":"LibreOJ  516","slug":"libreoj-516","date":"2017-07-12T10:51:48.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/libreoj-516.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Problem Link】</strong> <strong><a href=\"https://loj.ac/problem/516\" target=\"_blank\" rel=\"noopener\">#516. 「LibreOJ β Round #2」DP 一般看规律</a></strong> <strong>【题意】</strong> <strong>输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT.</strong> <strong>【题解】</strong> <strong>每个数字只与他的前驱和后继产生贡献。构建n个set，每次将较小的暴力合并到大的上面，通过lower_bound来找到他的前驱和后继。懒得离散化可以用map来存set。</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LibreOJ/%23516%20DP%E4%B8%80%E8%88%AC%E7%9C%8B%E8%A7%84%E5%BE%8B.cpp\" target=\"_blank\" rel=\"noopener\">#516 DP一般看规律.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int ans,n,m,num,x,y;<br>map&lt;int,set<int> &gt; mp;///数字-&gt;数字下标集映射</int></p>\n<p>void insert_update(int q,int index){<br>    set<int> &amp;r=mp[q];<br>    set<int>::iterator it=r.lower_bound(index);<br>    if(it!=r.end()) ans=min(ans,<em>it-index);///右边相邻第一个<br>    if(it!=r.begin()) it–,ans=min(ans,index-</em>it);///左边相邻第一个<br>    r.insert(index);<br>}</int></int></p>\n<p>int main(){<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)){<br>        ans=2147483647;mp.clear();<br>        for(int i=0;i&lt;n;++i){<br>            scanf(“%d”,&amp;num);<br>            insert_update(num,i);<br>        }<br>        for(int i=0;i&lt;m;++i){<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            if(x==y){printf(“%d\\n”,ans);continue;}<br>            set &amp;r=mp[x],&amp;t=mp[y];<br>            if(r.size()&gt;t.size())swap(r,t);<br>            for(set<int>::iterator si=r.begin();si!=r.end();si++)<br>                insert_update(y,<em>si);<br>            r.clear();<br>            printf(“%d\\n”,ans);<br>        }<br>    }<br>    return 0;<br>}*</em></int></p>\n","text":"【Problem Link】 #516. 「LibreOJ β Round #2」DP 一般看规律 【题意】 输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT. 【题解】 每个数字只与他的前驱和后继产生贡献。构建n个","link":"","raw":null,"photos":[],"categories":[{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/categories/LibreOJ.json"},{"name":"STL","slug":"LibreOJ/STL","count":1,"path":"api/categories/LibreOJ/STL.json"},{"name":"思维","slug":"LibreOJ/STL/思维","count":1,"path":"api/categories/LibreOJ/STL/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"},{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/tags/LibreOJ.json"}]}]}