{"name":"思维","slug":"思维","count":17,"postlist":[{"title":"2017多校训练2 HDU 6047 Maximum Sequence","slug":"2017-hdu-6047-maximum-sequence","date":"2017-07-29T04:51:07.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6047-maximum-sequence.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6047\" title=\"Maximum Sequence\" target=\"_blank\" rel=\"noopener\">Maximum Sequence</a> 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,记录每个i到maxindex(A)的最大值,然后动态更新. github: 1.线段树法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003_Range_Tree.cpp\" title=\"1003_Range_Tree.cpp\" target=\"_blank\" rel=\"noopener\">1003_Range_Tree.cpp</a> 2.暴力动态更新法: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/2/1003.cpp\" title=\"1003.cpp\" target=\"_blank\" rel=\"noopener\">1003.cpp</a></p>\n<pre><code>///线段树法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst int maxnode=2000050;\n\nint b[maxnode],N;\nint maxv[maxnode];\n\nvoid build(int o,int l,int r){\n    if(l==r){\n        if(l&gt;N) return;///预先分配2*N个结点\n        scanf(&quot;%d&quot;,&amp;maxv[o]);maxv[o]-=l;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(o&lt;&lt;1,l,mid);\n    build(o&lt;&lt;1|1,mid+1,r);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint query(int o,int l,int r,int ll,int rr){\n    if(l&gt;=ll&amp;&amp;r&lt;=rr) return maxv[o];\n    int ma=-1,mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=ll) ma=max(ma,query(o&lt;&lt;1,l,mid,ll,rr));\n    if(rr&gt;mid) ma=max(ma,query(o&lt;&lt;1|1,mid+1,r,ll,rr));\n    return ma;\n}\n\nvoid update(int o,int l,int r,int p,int val){\n    if(l==r){\n        maxv[o]=val;\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    if(p&lt;=mid)update(o&lt;&lt;1,l,mid,p,val);\n    else update(o&lt;&lt;1|1,mid+1,r,p,val);\n    maxv[o]=max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        build(1,1,2*N);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        LL ans=0;\n        for(int i=N+1;i&lt;=2*N;++i){\n            int k=query(1,1,2*N,b[i-N],i-1);\n            update(1,1,2*N,i,k-i);\n            ans=(ans+k)%mod;\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}\n\n\n\n///HDU 6047 暴力动态更新法\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=500000+50;\nconst int mod=1e9+7;\nint N;\nint a[maxn],b[maxn],maxa[maxn];\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)&amp;&amp;N){\n        for(int i=1;i&lt;=N;++i){\n            int aa;\n            scanf(&quot;%d&quot;,&amp;aa);\n            a[i]=aa-i;\n        }\n        maxa[N]=a[N];\n        for(int i=N-1;i&gt;=1;--i) maxa[i]=max(maxa[i+1],a[i]);\n        for(int i=1;i&lt;=N;++i) scanf(&quot;%d&quot;,&amp;b[i]);\n        sort(b+1,b+1+N);\n        long long ans=0;\n        ans=(ans+maxa[b[1]])%mod;\n        int t=maxa[b[1]]-N-1;\n        for(int i=2;i&lt;=N;++i){\n            maxa[b[i]]=max(maxa[b[i]],t);\n            ans=(ans+maxa[b[i]])%mod;\n            t=max(t,maxa[b[i]]-N-1);\n        }\n        printf(&quot;%lld\\n&quot;,ans%mod);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: :point_right:Maximum Sequence 题意: 给定一个长度为n的a数组和b数组，要求a[n+1]…a[2*n]的最大总和。 限制条件为ai≤max{aj-j│bk≤j&lt;i}。 题解: 两种方法,一种是线段树,另一种是第一次记录maxv数组,","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"segmentTree","slug":"2017多校/segmentTree","count":1,"path":"api/categories/2017多校/segmentTree.json"},{"name":"思维","slug":"2017多校/segmentTree/思维","count":1,"path":"api/categories/2017多校/segmentTree/思维.json"},{"name":"线段树","slug":"2017多校/segmentTree/思维/线段树","count":1,"path":"api/categories/2017多校/segmentTree/思维/线段树.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"segmentTree","slug":"segmentTree","count":2,"path":"api/tags/segmentTree.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}]},{"title":"51nod 1040 最大公约数之和","slug":"51nod-1040-max-gcd-sum","date":"2018-03-04T14:51:10.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1040-max-gcd-sum.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-欧拉函数-gcd性质-思维\"><a href=\"#Type-欧拉函数-gcd性质-思维\" class=\"headerlink\" title=\"Type:欧拉函数,gcd性质,思维\"></a>Type:欧拉函数,gcd性质,思维</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15</p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>1个数N(N &lt;= 10^9)</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>公约数之和</p>\n<h2 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h2><p>6</p>\n<h2 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h2><p>15</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><blockquote>\n<p>N&lt;=10^9,所以肯定无法暴力枚举 考虑我们要求 lambda(gcd(i,N) | i∈[1,N])</p>\n<blockquote>\n<p>我们可以知道: 对于每个数N,他的约数范围在[1<del>N]之间,即我们可以将问题转化为(设约数为Ni,1</del>N中约数为Ni个数为Mi):</p>\n<blockquote>\n<p>lambda(Ni*Mi)</p>\n</blockquote>\n<p>假设我们已经得到了Ni,问题就在于我们如何求出Mi 设i为1~N中任意数:</p>\n<blockquote>\n<p>(1) Mi=count(gcd(i,N)=Ni | i∈[1<del>N]) =count(gcd(i/Ni,N/Ni)=1 | i∈[1</del>N])</p>\n<blockquote>\n<p>即我们只需要求出1~N中与N/Ni互素的数的个数即可</p>\n<blockquote>\n<p>即 euler(N/Ni)</p>\n</blockquote>\n</blockquote>\n<p>(2) Mi=euler(N/Ni)</p>\n</blockquote>\n<p>ans=lambda(Ni*euler(N/Ni))</p>\n</blockquote>\n<p>然后有一个小性质,即 i*i&lt;=N时,我们枚举到sqrt(i)同时求出 N/i ,枚举完所有的 i 即枚举完所有 1~N 内 N 的约数.</p>\n</blockquote>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nLL N;\n\nLL euler(LL n){\n    LL res=n,a=n;\n    for(LL i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            res=res/i*(i-1);\n            while(a%i==0)a/=i;\n        }\n    }\n    if(a&gt;1)res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        LL ans=0;\n        for(LL i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                ans+=(i*euler(N/i));\n                if(i*i!=N){\n                    ans+=((N/i)*euler(i));\n                }\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type:欧拉函数,gcd性质,思维题目给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15Input1个数N(N &lt;= 10^9)Output公约数之和Input示例","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"思维","slug":"51nod/思维","count":1,"path":"api/categories/51nod/思维.json"},{"name":"数论","slug":"51nod/思维/数论","count":1,"path":"api/categories/51nod/思维/数论.json"},{"name":"欧拉函数","slug":"51nod/思维/数论/欧拉函数","count":1,"path":"api/categories/51nod/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"51nod 1055 最长等差数列","slug":"51nod-1055-llap","date":"2018-03-08T11:18:14.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1055-llap.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-动态规划-双向DP-思维-技巧\"><a href=\"#Type-动态规划-双向DP-思维-技巧\" class=\"headerlink\" title=\"Type: 动态规划,双向DP,思维,技巧\"></a>Type: 动态规划,双向DP,思维,技巧</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10 12 14 其中6 8 10 12 14最长，长度为5。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：N，N为正整数的数量(3 &lt;= N &lt;= 10000)。 第2 - N+1行：N个正整数。(2&lt;= A[i] &lt;= 10^9)</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>最长等差数列的长度。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>10 1 3 5 6 8 9 10 12 13 14</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>5</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>数据范围可判是O(N^2) 一开始我一直在想如何把数字,即两个数之间的差用哈希存起来,来方便dp. 然后搜了题解发现是论文题. 被叫做LLAP问题 Length of the Longest Arithmetic Progressio</p>\n</blockquote>\n<h2 id=\"论文Link\"><a href=\"#论文Link\" class=\"headerlink\" title=\"论文Link:\"></a>论文Link:</h2><p><a href=\"https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/\" target=\"_blank\" rel=\"noopener\">https://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/</a></p>\n<h2 id=\"论文解释\"><a href=\"#论文解释\" class=\"headerlink\" title=\"论文解释\"></a>论文解释</h2><blockquote>\n<p>这道题可以转化为:</p>\n<blockquote>\n<p>给与一个 排过序 的集合set,我们要求这个集合中的最长等差数列的长度.</p>\n</blockquote>\n<p>标重点: 序列是已排好序的 我们设 dp[i][j] 为以下标 i 和 j 两个元素开头的等差序列最长长度. 我们可以创建一个浮标 j 作为等差数列的中间值</p>\n<blockquote>\n<p>初始化一个 i=j-1,k=j+1.</p>\n<blockquote>\n<p>1.如果 set[i]+set[k] &lt; set[j]*2</p>\n<blockquote>\n<p>k++</p>\n</blockquote>\n<p>2.如果 set[i]+set[k] &gt; set[j]*2</p>\n<blockquote>\n<p>i–</p>\n</blockquote>\n<p>如果 set[i]+set[k]=set[j]*2</p>\n<blockquote>\n<p>则构成等差数列,我们只需要让</p>\n<blockquote>\n<p>dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1</p>\n</blockquote>\n<p>如果dp[j][k]=0的话,dp[i][j]直接=3就可以了,因为 i,j,k 三个刚好构成等差数列.否则等于 dp[j][k]+1</p>\n</blockquote>\n<p>计算完以后 i–,k++ 继续计算其他以 j 为第二个点的等差数列</p>\n</blockquote>\n<p>倒序计算,正序反过来即可</p>\n</blockquote>\n<p>另外: 还可以 直接将 dp 数组初始化为 2(因为每个数的等差数列至少为2). dp[i][j]=dp[j][k]+1 另外有一个小技巧: 如果int的取值范围不大,但是数组要开很大的时候,可以用 short int,比如这道题.</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxn=10000;\n\nshort int dp[maxn][maxn];\nint Num[maxn],ans,N;\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N)){\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;Num[i]);\n        }\n        sort(Num,Num+N);\n        ans=0;\n        for(int j=N-2;j&gt;=1;--j){\n            int i=j-1,k=j+1;\n            while(k&lt;N&amp;&amp;i&gt;=0){\n                if(Num[i]+Num[k]&gt;2*Num[j]){\n                    --i;\n                }else if(Num[i]+Num[k]&lt;2*Num[j]){\n                    ++k;\n                }else{\n                    dp[i][j]=(dp[j][k]==0)?3:dp[j][k]+1;\n                    ans=max(ans,(int)dp[i][j]);\n                    --i;++k;\n                }\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type: 动态规划,双向DP,思维,技巧题目N个不同的正整数，找出由这些数组成的最长的等差数列。 例如：1 3 5 6 8 9 10 12 13 14 等差子数列包括(仅包括两项的不列举） 1 3 5 1 5 9 13 3 6 9 12 3 8 13 5 9 13 6 8 10","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"LLAP","slug":"51nod/LLAP","count":1,"path":"api/categories/51nod/LLAP.json"},{"name":"动态规划","slug":"51nod/LLAP/动态规划","count":1,"path":"api/categories/51nod/LLAP/动态规划.json"},{"name":"双向dp","slug":"51nod/LLAP/动态规划/双向dp","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp.json"},{"name":"思维","slug":"51nod/LLAP/动态规划/双向dp/思维","count":1,"path":"api/categories/51nod/LLAP/动态规划/双向dp/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LLAP","slug":"LLAP","count":1,"path":"api/tags/LLAP.json"},{"name":"双向dp","slug":"双向dp","count":1,"path":"api/tags/双向dp.json"}]},{"title":"51NOD 1241 特殊的排序","slug":"51nod-1241-tsds","date":"2018-03-08T10:57:18.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1241-tsds.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-动态规划-思维-最长等差数列-简化\"><a href=\"#Type-动态规划-思维-最长等差数列-简化\" class=\"headerlink\" title=\"Type:动态规划,思维,最长等差数列(简化)\"></a>Type:动态规划,思维,最长等差数列(简化)</h1><h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾部 =&gt; 1 2 3 4 5 这样就排好了，移动了2个元素。 给出一个1-N的排列，输出完成排序所需的最少移动次数。</p>\n<h1 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h1><p>第1行：1个数N(2 &lt;= N &lt;= 50000)。 第2 - N + 1行：每行1个数，对应排列中的元素。</p>\n<h1 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h1><p>输出1个数，对应所需的最少移动次数。</p>\n<h1 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h1><p>5 2 5 3 4 1</p>\n<h1 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h1><p>2</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>一开始会想到和逆序数有关,排序就是减少逆序数,所以会想到其中非逆序序列中最长的那个不用变化. 然后可以容易地证明剩余的数只需要移动一次即可到达正确的位置上</p>\n<blockquote>\n<p>比如 12346587 可以发现最长等差整数序列是 12345 而我们需要 12345678 第一次: 1234587 6 第二次: 1234586 7 第三次: 1234567 8 OK,往数列前面放的也一样</p>\n</blockquote>\n<p>那么我们的问题就是如何求最长等差数列(等差为1)了,</p>\n<blockquote>\n<p>因为等差为1,所以我们不难想到: dp[i] 为数字 i 的最长等差数列. 遍历Num[]数组的时候计算 dp 即可 dp[i]=dp[i-1]+1</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=50000+10;\n\nint dp[maxn],N,Num[maxn],max_;\n\nint main(){\n    while(cin&gt;&gt;N){\n        memset(dp,0,sizeof(dp));\n        dp[0]=0;\n        max_=1;\n        for(int i=1;i&lt;=N;++i){\n            cin&gt;&gt;Num[i];\n        }\n        for(int i=1;i&lt;=N;++i){\n            dp[Num[i]]=dp[Num[i]-1]+1;\n            max_=max(dp[Num[i]],max_);\n            //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;dp[Num[i]]&lt;&lt;endl;\n        }\n        cout&lt;&lt;N-max_&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Type:动态规划,思维,最长等差数列(简化)题目一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？ 例如： 2 5 3 4 1 将1移到头部 =&gt; 1 2 5 3 4 将5移到尾","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"动态规划","slug":"51nod/动态规划","count":3,"path":"api/categories/51nod/动态规划.json"},{"name":"思维","slug":"51nod/动态规划/思维","count":1,"path":"api/categories/51nod/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"}]},{"title":"第八届ACM省赛 Quadrat 找规律","slug":"acm-quadrat","date":"2017-11-27T23:42:08.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/acm-quadrat.json","excerpt":"","keywords":null,"cover":null,"content":"<p>原题连接: <a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164\" target=\"_blank\" rel=\"noopener\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164</a> B题 题意: 求数位为n位的所有数字(0~9..9(n个9))中,各个数位与其平方%10^n所得数的各个数位之差不超过d的数的个数. 注: 所有的数位之差是循环的,比如9和1差2. 首先打表(不过我认为这道题是数位dp,但我不会):</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\n\nconst int num[5]={1,10,100,1000,10000};\nint a[15][15];\nvoid init(){\n    memset(a, 0, sizeof(a));\n    for(int i = 0; i &lt;= 9; ++i){\n        for(int j = 0; j &lt;= 9; ++j){\n            a[i][j] = abs(i-j);\n            if(a[i][j] &gt; 5) a[i][j] = 10 - a[i][j];\n        }\n    }\n}\n\nbool judge(int i,int digit,int d){\n    int res=i*i;\n    for(int j=1;j&lt;=digit;++j){\n        int b=i%10;\n        int c=res%10;\n        i/=10;res/=10;\n        if(a[b][c]&gt;d) return false;\n    }\n    return true;\n}\n\nint check(int nb,int d){\n    int cnt=0;\n    for(int i=0;i&lt;num[nb];++i){\n        if(judge(i,nb,d))\n            cnt++;\n    }\n    return cnt;\n}\n\nint main(){\n    init();\n    for(int i=1;i&lt;=4;++i){\n        printf(&quot;%d:&quot;,i);\n        for(int j=0;j&lt;4;++j){\n            printf(&quot; %d&quot;,check(i,j));\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>发现dp[i][j]=dp[i-1][j]<em>(2</em>j+1) Code:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nlong long dp[19][4];\n\nvoid init(){\n    dp[1][0]=4;dp[1][1]=4;\n    dp[1][2]=8;dp[1][3]=8;\n    for(int i=2;i&lt;=18;++i){\n        for(int j=0;j&lt;4;++j){\n            dp[i][j]=dp[i-1][j]*(2*j+1);\n        }\n    }\n}\n\nint main(){\n    init();\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--){\n        int n,d;\n        scanf(&quot;%d %d&quot;,&amp;n,&amp;d);\n        printf(&quot;%lld\\n&quot;,dp[n][d]);\n    }\n    return 0;\n}</code></pre>","text":"原题连接: http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/problemlist/cid/2164 B题 题意: 求数位为n位的所有数字(0~9..9(n个9))中,各个数位与其平方%10^n所得数的各个数位","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"思维","slug":"Sdut/思维","count":1,"path":"api/categories/Sdut/思维.json"},{"name":"第八届ACM山东省赛","slug":"Sdut/思维/第八届ACM山东省赛","count":1,"path":"api/categories/Sdut/思维/第八届ACM山东省赛.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第八届ACM山东省赛","slug":"第八届ACM山东省赛","count":3,"path":"api/tags/第八届ACM山东省赛.json"}]},{"title":"「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A","slug":"ecnucodera","date":"2017-05-21T09:49:16.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/ecnucodera.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题目来源】</strong> <strong><a href=\"http://acm.ecnu.edu.cn/contest/16/problem/A/\" target=\"_blank\" rel=\"noopener\">「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A</a></strong> <strong>【Tip】</strong> <strong>找进位规律找的自己恶心吐了,最后跪在了百位进位时忘了加最后的那几次十进位…(最后也是对拍了一个ACcode才找到了错误的地方</strong> <strong>思维漏洞还是太大了,或者说这种思维方式不太好.</strong> <strong>不过也算是又学会了一点东西.</strong> <strong>【My Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int main(){</strong> **    freopen(“in_2.txt”, “r”, stdin);** **    freopen(“out_2.txt”, “w”, stdout);** **    int T,N,M,B,C,EndN,EndM;** **    while(~scanf(“%d”,&amp;T)){** **        int ca=1;** **        while(T–){** **            int REG1,REG2,D1,D2,ans=-INF,r1[3],r2[3],r11[3],r22[3];** **            D1=D2=0;** **            scanf(“%d%d”,&amp;B,&amp;C);** **            REG1=B;** **            REG2=C;** **            red(i,2,0){** **                r1[i]=REG1%10;REG1/=10;** **                r2[i]=REG2%10;REG2/=10;** **            }** **            scanf(“%d”,&amp;N);** **            rep(i,N+1){//甲得i分,乙得M分** **                int D11,D22,all;** **                D11=D22=0;all=0;** **                M=N-i;** **                EndN=B+i;** **                EndM=C+M;** **                red(i,2,0){** **                    r11[i]=EndN%10;EndN/=10;** **                    r22[i]=EndM%10;EndM/=10;** **                }//百位进位19 十位进位9** **                r11[0]=r11[0]-r1[0];** **                if(r11[0]) {** **                    r11[1]=(r11[0]-1)<em>9+(9-r1[1])+r11[1];*</em> **                    all+=(r11[0]*18+r11[1]*9);** **                }else{** **                    r11[1]=r11[1]-r1[1];** **                    all+=(r11[1]<em>9);*</em> **                }** **                r22[0]=r22[0]-r2[0];** **                if(r22[0]) {** **                    r22[1]=(r22[0]-1)<em>9+(9-r2[1])+r22[1];*</em> **                    all+=(r22[0]*18+r22[1]*9);** **                }else{** **                    r22[1]=r22[1]-r2[1];** **                    all+=(r22[1]<em>9);*</em> **                }** **               // printf(“%d\\n”,all+N);** **                ans=max(ans,all+N);** **            }** **            printf(“Case %d: %d\\n”,ca++,ans);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【效率&amp;直观 code】</strong> <strong>感觉处理方法类似于数位dp</strong></p>\n<blockquote>\n<p>**    #include&lt;bits/stdc++.h&gt;** **    using namespace std;** **    #define maxn 1005** **    int dp[maxn];** **    void init(){** **        for(int i=1;i&lt;=999;i++){** **            if(i%100==0){** **                dp[i]=dp[i-1]+19;** **            }else if(i%10==0)** **                dp[i]=dp[i-1]+10;** **            else** **                dp[i]=dp[i-1]+1;** **        }** **        return;** **    }** **    int main(){** **        freopen(“in_2.txt”, “r”, stdin);** **        freopen(“out_3.txt”, “w”, stdout);** **        int T;** **        cin&gt;&gt;T;** **        init();** **        for(int cas=1;cas&lt;=T;cas++){** **            int a,b,k;** **            cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;** **            int ans=0;** **            int tans=0;** **            for(int i=0;i&lt;=k;i++){** **                tans=dp[a+i]-dp[a]+dp[b+k-i]-dp[b];** **               // printf(“%d\\n”,tans);** **                ans=max(ans,tans);** **            }** **            cout&lt;&lt;”Case “&lt;&lt;cas&lt;&lt;”: “;** **            cout&lt;&lt;ans&lt;&lt;”\\n”;** **        }** **        return 0;** **    }**</p>\n</blockquote>\n<p>【数据 in_2.txt】 13 000 000 1 000 000 10 000 000 100 001 000 109 001 001 109 123 123 89 458 253 500 327 652 200 320 602 58 227 725 63 102 103 37 023 001 900 21 23 5 【输出】 Case 1: 1 Case 2: 19 Case 3: 199 Case 4: 217 Case 5: 217 Case 6: 179 Case 7: 1013 Case 8: 398 Case 9: 112 Case 10: 126 Case 11: 73 Case 12: 1791 Case 13: 5</p>\n","text":"【题目来源】 「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) A 【Tip】 找进位规律找的自己恶心吐了,最后跪在了百位进位时忘了加最后的那几次十进位…(最后也是对拍了一个ACcode才找到了错误的地方 思维漏洞还是太大了,或","link":"","raw":null,"photos":[],"categories":[{"name":"ECNU","slug":"ECNU","count":2,"path":"api/categories/ECNU.json"},{"name":"思维","slug":"ECNU/思维","count":2,"path":"api/categories/ECNU/思维.json"},{"name":"数位DP","slug":"ECNU/思维/数位DP","count":1,"path":"api/categories/ECNU/思维/数位DP.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数位DP","slug":"数位DP","count":3,"path":"api/tags/数位DP.json"},{"name":"ECNU","slug":"ECNU","count":2,"path":"api/tags/ECNU.json"}]},{"title":"LA 3882","slug":"la-3882","date":"2017-07-11T07:02:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3882.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3882\" target=\"_blank\" rel=\"noopener\">And Then There Was One</a></strong> <strong>【题解】</strong> <strong>假设问题是从n个人编号分别为0…n-1，取第k个，</strong> <strong>则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2…</strong> <strong>此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号</strong> <strong>把k号设置为0,则</strong> <strong>k 0</strong> <strong>k+1 1</strong> <strong>…</strong> <strong>0 n-k</strong> <strong>1 n-k+1</strong> <strong>假设已经求得了n-1个人情况下的最终胜利者保存在f[n-1]中，则毫无疑问，该胜利者还原到原来的真正编号即为 (f[n-1]+k)%n （因为第二轮重新编号的时候，相当于把每个人的编号都减了k，因此重新+k即可恢复到原来编号）。由此，我们可以想象，当最终只剩下一个人的时候，该人即为胜利者，此时重新编号，因为只有一个人，所以此时f[1]=0</strong> <strong>这样f[2]=(f[1]+k)%2,这样就可以求出最终胜利者在2个人的时候的情况下的编号，由递推公式f[n]=(f[n-1]+k)%n,可递推到最初编号序列中该胜利者的编号。</strong> <strong>因此用这个方法，只需一遍On的扫描，即可求出最终答案</strong> <strong>不过该题要求编号从1开始，只要把f[n]+1即可，同时，该题指定了第一个要删除的人必须为编号为m的人，其实也不难，求出f[n]之后，把原本编号为0的位置移到跟m只相距k的位置即可实现第一次删除的编号为m。所以最终 ans=(f[n]+1+m-k);</strong> <strong>当然因为m-k可能为负数，导致整个ans为负，这样其实最后+n即可解决。</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203882.cpp\" target=\"_blank\" rel=\"noopener\">LA 3882.cpp</a></strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=10000+10;<br>int f[maxn];<br>int main(){<br>    int n,k,m;<br>    while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n){<br>        ///最后一次变换只有一个点,所以最终点设为0<br>        ///每次去掉一个点以后重新编号,所以%i<br>        ///从底向上的方法<br>        f[1]=0;<br>        for(int i=2;i&lt;=n;++i)f[i]=(f[i-1]+k)%i;<br>        ///因为是从0编号,而题目要求从1编号,所以+1<br>        ///因为从0开始,而题目要求从m开始删除第k个<br>        ///所以第一次删除的下标应该是f[n]-k=第一次的起始下标<br>        ///0-k+m+1=真正的起始坐标,因为第一次需要将m设为0,从m开始重新编号<br>        int ans=(m-k+1+f[n])%n;<br>        ///因为m-k+1可能小于0,所以m-k+1+f[n]也可能小于0<br>        if(ans&lt;=0) ans+=n;<br>        printf(“%d\\n”,ans);<br>    }<br>    return 0;<br>}</strong></p>\n</blockquote>\n","text":"【Link】 And Then There Was One 【题解】 假设问题是从n个人编号分别为0…n-1，取第k个， 则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2… 此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号 把k号设置为","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"动态规划","slug":"LA/动态规划","count":1,"path":"api/categories/LA/动态规划.json"},{"name":"思维","slug":"LA/动态规划/思维","count":1,"path":"api/categories/LA/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3902","slug":"la-3902","date":"2017-07-10T13:21:12.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3902.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3902\" target=\"_blank\" rel=\"noopener\">Network</a></strong> <strong>【题解】</strong> <strong>可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表.</strong> <strong>最优选择放置服务器的方法是选择距离主机最远(k)的那个服务器上安装VOD即可.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203902.cpp\" target=\"_blank\" rel=\"noopener\">LA 3902.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;</p>\n<p>const int maxn=1000+10;<br>vector<int> gr[maxn],nodes[maxn];<br>int n,s,k,fa[maxn];<br>bool covered[maxn];</int></p>\n<p>///无根树转有根树,计算fa数组,根据深度把–叶子节点–插入nodes表中<br>///u当前节点下标,f,当前节点父节点下标,d深度.<br>void dfs(int u,int f,int d){<br>    fa[u]=f;<br>    int nc=gr[u].size();<br>    ///距离根节点k距离以内的叶子结点不用记录<br>    if(nc==1 &amp;&amp; d&gt;k) nodes[d].push_back(u);<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f)dfs(v,u,d+1);<br>    }<br>}</p>\n<p>void dfs2(int u,int f,int d){<br>    covered[u]=true;<br>    int nc=gr[u].size();<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f&amp;&amp;d&lt;k)dfs2(v,u,d+1);///只覆盖到新服务器不超过k的结点 ///v!=f =&gt; 如果从f访问到u,那么就不能再从u回访f.深搜嘛.一路莽到底.<br>    }<br>}</p>\n<p>int solve(){<br>    int ans=0;<br>    memset(covered,0,sizeof(covered));<br>    for(int d=n-1;d&gt;k;–d){<br>        for(int i=0;i&lt;nodes[d].size();++i){<br>            int u=nodes[d][i];<br>            if(covered[u])continue;///不考虑已经覆盖的点</p>\n<pre><code>        int v=u;\n        for(int j=0;j&lt;k;++j)v=fa\\[v\\];///找到相邻k级祖先,不可能有-1，因为之前已经把离根k的节点忽略了\n        dfs2(v,-1,0);///在结点v设置服务器,然后通过对该服务器深搜\n                     ///找到所有的叶子结点\n        ans++;\n    }\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d%d”,&amp;n,&amp;s,&amp;k);///节点数,初始VOD服务器的编号和k<br>        for(int i=1;i&lt;=n;++i){gr[i].clear();nodes[i].clear();}<br>        for(int i=0;i&lt;n-1;++i){<br>            int a,b;<br>            scanf(“%d%d”,&amp;a,&amp;b);<br>            gr[a].push_back(b);<br>            gr[b].push_back(a);<br>        }<br>        dfs(s,-1,0);<br>        printf(“%d\\n”,solve());<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【Link】 Network 【题解】 可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"数据结构","slug":"LA/思维/数据结构","count":1,"path":"api/categories/LA/思维/数据结构.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]},{"title":"LibreOJ  516","slug":"libreoj-516","date":"2017-07-12T10:51:48.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/libreoj-516.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Problem Link】</strong> <strong><a href=\"https://loj.ac/problem/516\" target=\"_blank\" rel=\"noopener\">#516. 「LibreOJ β Round #2」DP 一般看规律</a></strong> <strong>【题意】</strong> <strong>输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT.</strong> <strong>【题解】</strong> <strong>每个数字只与他的前驱和后继产生贡献。构建n个set，每次将较小的暴力合并到大的上面，通过lower_bound来找到他的前驱和后继。懒得离散化可以用map来存set。</strong> <strong>【Source Code】</strong> <strong>github: <a href=\"https://github.com/834930269/Other_OJ/blob/master/LibreOJ/%23516%20DP%E4%B8%80%E8%88%AC%E7%9C%8B%E8%A7%84%E5%BE%8B.cpp\" target=\"_blank\" rel=\"noopener\">#516 DP一般看规律.cpp</a></strong></p>\n<hr>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int ans,n,m,num,x,y;<br>map&lt;int,set<int> &gt; mp;///数字-&gt;数字下标集映射</int></p>\n<p>void insert_update(int q,int index){<br>    set<int> &amp;r=mp[q];<br>    set<int>::iterator it=r.lower_bound(index);<br>    if(it!=r.end()) ans=min(ans,<em>it-index);///右边相邻第一个<br>    if(it!=r.begin()) it–,ans=min(ans,index-</em>it);///左边相邻第一个<br>    r.insert(index);<br>}</int></int></p>\n<p>int main(){<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)){<br>        ans=2147483647;mp.clear();<br>        for(int i=0;i&lt;n;++i){<br>            scanf(“%d”,&amp;num);<br>            insert_update(num,i);<br>        }<br>        for(int i=0;i&lt;m;++i){<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>            if(x==y){printf(“%d\\n”,ans);continue;}<br>            set &amp;r=mp[x],&amp;t=mp[y];<br>            if(r.size()&gt;t.size())swap(r,t);<br>            for(set<int>::iterator si=r.begin();si!=r.end();si++)<br>                insert_update(y,<em>si);<br>            r.clear();<br>            printf(“%d\\n”,ans);<br>        }<br>    }<br>    return 0;<br>}*</em></int></p>\n","text":"【Problem Link】 #516. 「LibreOJ β Round #2」DP 一般看规律 【题意】 输入n个数,m个替换规则,x换成y.输出每次替换后最近的两个相同的数相距多少.如果没有相同的,输出MAX_INT. 【题解】 每个数字只与他的前驱和后继产生贡献。构建n个","link":"","raw":null,"photos":[],"categories":[{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/categories/LibreOJ.json"},{"name":"STL","slug":"LibreOJ/STL","count":1,"path":"api/categories/LibreOJ/STL.json"},{"name":"思维","slug":"LibreOJ/STL/思维","count":1,"path":"api/categories/LibreOJ/STL/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"},{"name":"LibreOJ","slug":"LibreOJ","count":1,"path":"api/tags/LibreOJ.json"}]},{"title":"UVa 10795","slug":"uva-10795","date":"2017-07-09T13:06:29.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10795.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10795\" target=\"_blank\" rel=\"noopener\">A Different Task</a></strong> <strong>汉诺塔问题总结:</strong> <a href=\"http://blog.csdn.net/xueerfei008/article/details/9904681\" target=\"_blank\" rel=\"noopener\"><strong>杭电 汉诺塔问题总结</strong></a> <strong>【题解】</strong> <strong>大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标.</strong> <strong>f(P,i,final):已知各盘子的初始柱子编号数组为P,把盘子1,2,3,4…i全部移到柱子final所需的步数.</strong> <strong>参考局面等于中转态.即中转柱子下标为6-P[i]-finish[i].将前i-1个盘子移动到中转柱上.然后把盘子i移动到final柱子上,最后将i-1个盘子从中转态移动到final.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2010795.cpp\" target=\"_blank\" rel=\"noopener\">UVA 10795.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long LL;</p>\n<p>LL f(int* P,int i,int finaln){<br>    if(i==0) return 0;<br>    ///如果当前最大的这个号的起始盘子等于最终落脚盘子<br>    ///不用移动.所以f(P,i,final)=f(P,i-1,final)<br>    if(P[i]==finaln) return f(P,i-1,finaln);<br>    ///经典汉诺塔的结论,将前i-1个盘子从一个柱子移动到另一个柱子<br>    ///这个步骤需要2^(i-1)-1步.加上移动盘子i到最终盘子<br>    ///的那一步,一共需要2^(i-1)步.<br>    return f(P,i-1,1+2+3-P[i]-finaln)+(1LL&lt;&lt;(i-1));<br>}</p>\n<p>const int maxn=60+10;<br>int n,start[maxn],finish[maxn];</p>\n<p>int main(){<br>    int kase=0;<br>    while(scanf(“%d”,&amp;n)==1&amp;&amp;n){<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;start[i]);<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;finish[i]); ///结论:如果最大的盘子一开始就在最终的柱子上 ///则不用移动. ///找到号码最大的那几个不需要移动的盘子. int k=n; while(k&gt;=1&amp;&amp;start[k]==finish[k])k–;</p>\n<pre><code>    ///结论:由于移动的步数是对称的,即往回移动的步伐\n    ///和步数等于往前移动.\n    LL ans=0;\n    if(k&gt;=1){\n        int other=6-start\\[k\\]-finish\\[k\\];\n        ans=f(start,k-1,other)+f(finish,k-1,other)+1;\n    }\n    printf(&quot;Case %d: %lld\\\\n&quot;,++kase,ans);\n}\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n","text":"【Link】 A Different Task 汉诺塔问题总结: 杭电 汉诺塔问题总结 【题解】 大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标. ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"模拟","slug":"UVa/思维/模拟","count":1,"path":"api/categories/UVa/思维/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 10881","slug":"uva-10881","date":"2017-04-03T09:17:46.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-10881.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【名言警句】</strong></p>\n<p><strong>“One thing is for certain: there is no stopping them;</strong></p>\n<p><strong>the ants will soon be here. And I, for one, welcome our</strong></p>\n<p><strong>new insect overlords.”</strong></p>\n<p>**                                                                                          —-H.G**</p>\n<p><strong>“有一件事是肯定的:没有什么能阻止他们,那些蚂蚁一定会到这里.而我,作为其中的一个,欢迎并迎接我们新的昆虫政权.”</strong></p>\n<p>**                                                                                          —-H.G**</p>\n<p><strong>【生词】</strong> <strong>overlords 证券</strong> <strong>insect 昆虫</strong> <strong>certain 肯定,确信无疑的</strong> <strong>pole 杆子,极点,电极</strong> <strong>facting 饰面,衣服的贴边</strong> <strong>walks at 走在</strong> <strong>constant 不变的,常量,恒定的.</strong> <strong>bump into 无意中遇到,碰到</strong> <strong>instantaneously 即时,不浪费时间</strong> <strong>opposite 对立面</strong> <strong>【题解】</strong> <strong>思维,蓝书P10</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>const int maxn=10000+10;</strong> <strong>struct Node{</strong> <strong>int id;//输入顺序</strong> <strong>int d;//位置</strong> <strong>int state;//朝向,-1,左,0,Turing,1,右</strong> **    bool operator&lt;(const Node &amp;q)const{** <strong>return d&lt;q.d;</strong> <strong>}</strong> <strong>};</strong> <strong>int Te,L,T,n,order[maxn];</strong> <strong>char turing,sta[][10]={“L”,”Turning”,”R”};</strong> <strong>Node after[maxn],before[maxn];</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;Te);** <strong>for(int i=1;i&lt;=Te;++i){</strong> **        printf(“Case #%d:\\n”,i);** **        scanf(“%d%d%d”,&amp;L,&amp;T,&amp;n);** **        for(int i=1;i&lt;=n;++i){** **            int place,dig;** <strong>char s;</strong> **            scanf(“%d %c”,&amp;place,&amp;s);** <strong>dig=(s==’L’?-1:1);</strong> **            before[i]=(Node){i,place,dig};** **            after[i]=(Node){0,place+T<em>dig,dig};*</em> **        }** <strong>//计算输入顺序排序后的数组,因为输出需要按照输入顺序输出</strong> <strong>sort(before+1,before+n+1);</strong> **        for(int i=1;i&lt;=n;++i)** <strong>order[before[i].id]=i;</strong>  <strong>//修改碰撞中的方向</strong> **        sort(after+1,after+n+1);** **        for(int i=1;i&lt;n;++i)** **            if(after[i].d==after[i+1].d)** <strong>after[i].state=after[i+1].state=0;</strong>  **        for(int i=1;i&lt;=n;++i){** **            if(after[order[i]].d&gt;L || after[order[i]].d&lt;0){** **                printf(“Fell off\\n”);** <strong>continue;</strong> **            }** **            printf(“%d %s\\n”,after[order[i]].d,sta[after[order[i]].state+1]);    ** <strong>}</strong> <strong>printf(“\\n”);</strong> <strong>}</strong> <strong>return 0;</strong> <strong>}</strong></p>\n</blockquote>\n","text":"【名言警句】“One thing is for certain: there is no stopping them;the ants will soon be here. And I, for one, welcome ournew insect overlords.”**  ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"思维","slug":"POJ/思维","count":1,"path":"api/categories/POJ/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"UVa 11078","slug":"uva-11078","date":"2017-04-04T11:57:26.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11078.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>Credit 信誉,信用,相信,信任</strong> <strong>senior 上司,高级的</strong> <strong>as if 犹如,好似</strong> <strong>attend 出席,致力于,照料</strong> <strong>requisite 必需品,必需的</strong> <strong>advance 发展,前行,增长</strong> <strong>assess 评定,估价</strong> <strong>amount 数量,总数,总计</strong> <strong>figure out 计算出,估计</strong> <strong>【题解】</strong> <strong>记录输入时队列前面的最大值,然后用最大值依次减去后面比他小的数,维护ans.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int ans,T,N,Max,c;</strong> <strong>int main(){</strong> **    scanf(“%d”,&amp;T);** **    while(T–){** **        scanf(“%d”,&amp;N);** **        ans=-INF;Max=-INF;** **        for(int i=0;i&lt;N;++i){** **                scanf(“%d”,&amp;c);** **                ans=max(ans,Max-c);** **                Max=max(Max,c);** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 Credit 信誉,信用,相信,信任 senior 上司,高级的 as if 犹如,好似 attend 出席,致力于,照料 requisite 必需品,必需的 advance 发展,前行,增长 assess 评定,估价 amount 数量,总数,总计 figure ou","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11384","slug":"uva-11384","date":"2017-04-04T09:45:31.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11384.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>screen 屏幕</strong> <strong>subtract 减去,扣掉</strong> <strong>objective 目标,目的</strong> <strong>Her objective will be to make all the numbers 0.  他的目标是将所有的数字变成0.</strong> <strong>as 作为</strong> <strong>twist 扭曲,拧,拧伤,使苦恼</strong> <strong>for each 为每一个</strong> <strong>determine 下决心,决定,确定</strong> <strong>terminated 终止于</strong> <strong>separate 单独的</strong> <strong>【题解】</strong> <strong>蓝书P26</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>int N,cnt;</strong> <strong>//可以发现..其实右边界并没有用到= =Orz</strong> <strong>int solve(int l,int r,int num){</strong> **    if(l==1 &amp;&amp; r==1){** **        printf(“%d\\n”,num);** **        return num;** **    }** **    solve((l-1)/2+1,l-1,num+1);** <strong>}</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;N)){** **        cnt=0;** **        cnt=solve(N/2+1,N,1);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 screen 屏幕 subtract 减去,扣掉 objective 目标,目的 Her objective will be to make all the numbers 0.  他的目标是将所有的数字变成0. as 作为 twist 扭曲,拧,拧伤,使苦恼 for ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11426","slug":"uva-11426","date":"2018-02-12T08:37:59.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11426.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVA-11426\" title=\"https://vjudge.net/problem/UVA-11426\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11426</a></p>\n<h1 id=\"Type-数论-欧拉函数-递推-思维\"><a href=\"#Type-数论-欧拉函数-递推-思维\" class=\"headerlink\" title=\"Type: 数论,欧拉函数,递推,思维\"></a>Type: 数论,欧拉函数,递推,思维</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n∈[1,4000000]</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><blockquote>\n<p>首先我们应该清楚</p>\n<blockquote>\n<p>4000000的数据,用暴力 - 对每个gcd求值相加复杂度是i*j*O(gcd) 你懂就行,这么大的复杂度肯定爆炸.</p>\n</blockquote>\n<p>所以我们第一想法肯定是预处理.</p>\n<blockquote>\n<p>我们设 f(n) 为 (1,n)+(2,n)+(3,n)+…+(n-1,n) 则 S(n)=f(1)+f(2)+…+f(n)</p>\n<blockquote>\n<p>通过这个公式我们就可以递推出所有的 S(n)</p>\n<blockquote>\n<p>S(n)=S(n-1)+f(n)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>然后我们的问题就转化成了求f(n)</p>\n<blockquote>\n<p>首先我们会自然地想到,与n互素的答案是1.即(k,n)的结果都是n的约数</p>\n<blockquote>\n<p>我们可以按照这个约数来进行分类, 用 g(n,i)表示满足gcd(x,n)=i 且 x\\&lt;n 的正整数x的个数 则: f(n)=Sum(i*g(n,i) | i是n的约数,g(n,i)是1~n中gcd(k,n)=i的k的个数)</p>\n<blockquote>\n<p>然后我们注意到: -gcd(x,n)=i -则gcd(x/i,n/i)=1 -即x/i与n/i互质</p>\n</blockquote>\n<p>然后我们就可以将 g(n,i) 看做1~n中与 n/i 互质的数的个数,即</p>\n</blockquote>\n<p>g(n,i) = phi(n/i) 然后我们预处理phi[maxn],预处理完以后处理f(n),这里如果用二重循环依然是接受不了的 所以我们沿用筛法的思想对f[maxn]数组进行预处理,遇到i 是 k 的约数时,直接f[k]+=(i*phi[n/i])</p>\n</blockquote>\n<p>最后预处理S[maxn]即可</p>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>/*\n我们要求:\nG=Sigma(i=1~N) Sigma(j=i+1~N) GCD(i,j)\nN&lt;=4000000，这样的范围二次循环+GCD肯定是不行的\n所以我们考虑\nf(n)=Sigma(i=1~n-1) gcd(i,n)\n则\nG(n)=Sigma(i=1~n) f(i)\n=G(n-1)+f(n)\n所以我们的问题转换为如何求f(n)\n\n即k都是n的约数\n可以按照约数进行分类,用g(n,i)表示满足 (x,n)=i且x&lt;n的正整数x的个数\n则 f(n)=sum(i\\*g(n,i)|i是n的约数)\n\n再重提: g(n,i)代表满足(x,n)=i,且x&lt;n的正整数x的个数\n\n我们知道,如果 (a,n)=k\n则 (a/k,n/k)=1\n\n所以我们可以理解为g(n,i)代表的是x/i与n/i互质的数的个数\n即满足条件的x/i 有 phi(n/i)个\ng(n,i)=phi(n/i)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=4000000+10;\nLL phi[maxn];\n\nLL f[maxn];\n\nLL g[maxn];\nvoid phi_table(){\n    for(int i=2;i&lt;maxn;++i) phi[i]=0;\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nvoid init(){\n    phi_table();\n    memset(f,0,sizeof(f));\n    for(int i=1;i&lt;maxn;++i){\n        for(int j=i*2;j&lt;maxn;j+=i){\n            f[j]+=(i*phi[j/i]);\n        }\n    }\n    memset(g,0,sizeof(g));\n    for(int i=1;i&lt;maxn;++i) g[i]=g[i-1]+f[i];\n}\n\nint main(){\n    init();\n    int k;\n    while(~scanf(&quot;%d&quot;,&amp;k) &amp;&amp; k){\n        printf(&quot;%lld\\n&quot;,g[k]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11426Type: 数论,欧拉函数,递推,思维题意输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"数论","slug":"UVa/思维/数论","count":1,"path":"api/categories/UVa/思维/数论.json"},{"name":"欧拉函数","slug":"UVa/思维/数论/欧拉函数","count":1,"path":"api/categories/UVa/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"UVa 11549","slug":"uva-11549","date":"2017-04-05T05:00:42.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/uva-11549.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题解】</strong> <strong>Floyd判圈法</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>int buf[200];</strong> <strong>int next(int n,int k){</strong> **    if(!k) return 0;** **    int p=0,i=0;** **    long long RES=(long long)k<em>k;*</em> **    while(RES&gt;0){buf[i++]=RES%10;RES/=10;}** **    if(n&gt;i)n=i;** **    for(int t=0;t&lt;n;++t)p=p<em>10+buf[–i];*</em> **    return p;** <strong>}</strong> <strong>void floyd_check(int n,int k){</strong> **        int k1=k,k2=k,ans=k;//ans=k** **        do{** **            k1=next(n,k1);** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **            k2=next(n,k2);if(k2&gt;ans)ans=k2;** **        }while(k1!=k2);** **        printf(“%d\\n”,ans);** <strong>}</strong> <strong>int main(){</strong> **    int T,n,go;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        scanf(“%d%d”,&amp;n,&amp;go);** **        floyd_check(n,go);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【题解】 Floyd判圈法 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; int buf[200]; int next(int n,int k){ **    if(!k) return 0;** **    i","link":"","raw":null,"photos":[],"categories":[{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/categories/Floyd判圈法.json"},{"name":"UVa","slug":"Floyd判圈法/UVa","count":1,"path":"api/categories/Floyd判圈法/UVa.json"},{"name":"思维","slug":"Floyd判圈法/UVa/思维","count":1,"path":"api/categories/Floyd判圈法/UVa/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"},{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/tags/Floyd判圈法.json"}]},{"title":"「游族杯」上海市高校程序设计邀请赛暨华东师范大学第九届 ECNU Coder 程序设计竞赛 (重现) F","slug":"youxiabeitwo","date":"2017-05-21T10:01:25.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/youxiabeitwo.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【思路】</strong> <strong>因为时间是个天然的序,所以我们只需要去考虑蚂蚁的朝向和位置即可.而蚂蚁是否被吃也可以通过是否有和他相向而行的蚂蚁来判断.</strong> <strong>用栈来边输入(输入是向右进行的,所以我们就让右行的蚂蚁固定,用左行的蚂蚁来吃与被吃..好残忍= =)边模拟这一过程.(其实只要是链表形式的都可以用来模拟,因为这样会节省时间</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct Star{</strong> **    int A,B;** <strong>};</strong> <strong>stack<star> Inti;</star></strong> <strong>int N,A,B;</strong> <strong>int main(){</strong> **    freopen(“in.txt”, “r”, stdin);** **    freopen(“out.txt”, “w”, stdout);** **    while(~scanf(“%d”,&amp;N)){** **        while(!Inti.empty()){** **            Inti.pop();** **        }** **        rep(i,N){** **            scanf(“%d%d”,&amp;A,&amp;B);** **            //Inti.push_back((Star){A,B,true});** **            if(B==1 || (!Inti.empty() &amp;&amp; Inti.top().B==0)){** **                Inti.push((Star){A,B});** **            }else{** **                int flag=0;** **                while(!Inti.empty()){** **                    if(Inti.top().B==1){** **                        if(Inti.top().A&lt;A){** **                            Inti.pop();** **                        }else{** **                            flag=1;** **                        }** **                        if(flag) break;** **                    }else break;** **                }** **                if(!flag){** **                    Inti.push((Star){A,B});** **                }** **            }** **        }** **        printf(“%d\\n”,Inti.size());** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【输入数据 in.txt】</strong> <strong>12</strong> <strong>8 1</strong> <strong>5 0</strong> <strong>3 1</strong> <strong>6 0</strong> <strong>7 1</strong> <strong>4 0</strong> <strong>1 1</strong> <strong>9 0</strong> <strong>2 1</strong> <strong>13 0</strong> <strong>15 1</strong> <strong>32 0</strong> <strong>5</strong> <strong>4 0</strong> <strong>3 1</strong> <strong>2 0</strong> <strong>1 0</strong> <strong>5 0</strong> <strong>12</strong> <strong>8 0</strong> <strong>5 1</strong> <strong>3 0</strong> <strong>6 1</strong> <strong>7 0</strong> <strong>4 1</strong> <strong>1 0</strong> <strong>9 1</strong> <strong>2 0</strong> <strong>13 1</strong> <strong>15 0</strong> <strong>32 1</strong> <strong>【输出数据】</strong> <strong>3</strong> <strong>2</strong> <strong>4</strong></p>\n","text":"【思路】 因为时间是个天然的序,所以我们只需要去考虑蚂蚁的朝向和位置即可.而蚂蚁是否被吃也可以通过是否有和他相向而行的蚂蚁来判断. 用栈来边输入(输入是向右进行的,所以我们就让右行的蚂蚁固定,用左行的蚂蚁来吃与被吃..好残忍= =)边模拟这一过程.(其实只要是链表形式的都可以用来","link":"","raw":null,"photos":[],"categories":[{"name":"ECNU","slug":"ECNU","count":2,"path":"api/categories/ECNU.json"},{"name":"思维","slug":"ECNU/思维","count":2,"path":"api/categories/ECNU/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"ECNU","slug":"ECNU","count":2,"path":"api/tags/ECNU.json"}]},{"title":"2017 杭电多校训练赛 补题","slug":"2017-hdu-up","date":"2018-01-14T04:25:53.000Z","updated":"2019-07-03T13:51:36.860Z","comments":true,"path":"api/articles/2017-hdu-up.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif","content":"<p>[toc]</p>\n<h1 id=\"第一场\"><a href=\"#第一场\" class=\"headerlink\" title=\"第一场\"></a><strong>第一场</strong></h1><h2 id=\"1003-Colorful-Tree-hdoj6035\"><a href=\"#1003-Colorful-Tree-hdoj6035\" class=\"headerlink\" title=\"1003 Colorful Tree hdoj6035\"></a><strong>1003 Colorful Tree hdoj6035</strong></h2><p>题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n<em>(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) *</em> //思路<strong>：Answer = 所有颜色种类 * 所有路径数量 - 每一种颜色有多少路径没有经过 . 一开始假设每条路径都经过了所有颜色，再把每种颜色没经过的路径数减去就行，这个应该很好理解。问题是怎么算没经过的路径数？操作是这样的，如果算颜色1没经过的路径数，我们先把图里所有颜色是1的节点遮起来（假设这个点不存在，图在这个点是断路），图就被分成了很多块，</strong>每块的值= 那一块里的顶点数<em>（那一块里的顶点数-1）/2*</em>。 所有块的值加起来就是不经过颜色1的所有路径数。 到这里是不是还是很好理解，那么问题来了，怎么实现？…题解里说用虚树什么的… 用一个DFS即可，复杂度O（n） 用Size数组储存以每个节点为根节点的子树大小（即子树里节点的个数），Sum数组…很难解释，大概是表示以每种颜色为根节点的子树的大小和，但不是非常准确，如果以颜色2为根节点的子树里还含有颜色为2的节点，那只要算根节点这个颜色为2的子树大小即可，若在以这个颜色为2的点为根节点的子树之外还有颜色为2的点，那还要加上这个点的值…不知道能不能理解…解释不清楚，大概就这个意思… 以下图颜色2为例，代码里最后的for里(即以根<strong>第一个节点</strong>计算中)减去的（n-sum[2]）*（n-sum[2]-1）/2的那部分减去的是下图橙色圈里的那块，dfs里<code>减去pp那部分</code>是下图里蓝色圈的那块。其他具体的按照自己的理解再思考思考。 <a href=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2018/01/20170729142506432.gif\" alt></a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 200005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\n//c[]数组是每个节点的颜色\nint c[maxn],head[maxn],len,sum[maxn],size[maxn],vis[maxn];\nLL d;\n//边表\n//邻接表\nstruct node{\n    int v,next;\n}p[maxn&lt;&lt;1];\n\nvoid addedge(int u,int v){\n    //有向边指向点的编号\n    p[len].v=v;\n    //每条边的下一条边是上一次纪录的边的号码\n    p[len].next=head[u];\n    //邻接表的方法\n    //len为当前边的编号\n\n    //只记录当前节点的最后一个边的位置\n    head[u]=len++;\n}\n//对树进行dfs\nvoid dfs(int x,int fa){\n    //非这个点为根的所有该颜色的点\n    LL pre=sum[c[x]];\n    //size数组是当前节点的子节点总数目\n    size[x]=1;\n    int add=0;\n    //通过邻接表对当前节点x进行dfs\n    //等于0则退出\n    for(int i=head[x];~i;i=p[i].next){\n        //如果遇到反向边了,跳过,继续往其他边走\n        if(p[i].v==fa)\n            continue;\n        dfs(p[i].v,x);\n        size[x] += size[p[i].v];\n        //计算当前节点子树所有和当前节点颜色不同的点的个数\n        LL count = size[p[i].v] - sum[c[x]] + pre;\n        pre = sum[c[x]];\n        //当前子树的不同颜色点的个数\n        add += count;\n        //假设其他颜色都是白色,d即等于不同颜色所组成的边的总个数\n        d += count*(count-1)&gt;&gt;1;\n    }\n    //计算以x为根节点子树的所有与x不同颜色的点的个数\n    sum[c[x]] += add + 1;\n}\n\nint main(){\n    int n,tcase=1;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        memset(head,-1,sizeof(head));\n        memset(sum,0,sizeof(sum));\n        memset(vis,0,sizeof(vis));\n        d=len=0;\n        LL number = 0;\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            //记录颜色,颜色范围是[1,n]\n            if(!vis[c[i]]){\n                vis[c[i]]=1;\n                number++;\n            }\n        }\n        for(int i=1;i&lt;n;++i){\n            int u,v;\n            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);\n            addedge(u,v);\n            addedge(v,u);\n        }\n        dfs(1,0);\n        //ans初始等于(颜色个数)*(所有边的个数)-d(d为每个颜色在每个子树上被减去的不会经过那个颜色的路径的个数)\n        LL ans=(number*(n-1)*n&gt;&gt;1)-d;\n        for(int i=1;i&lt;=n;++i){\n            //不存在的颜色不需要计算,把已存在的颜色计算一下\n            if(vis[i]&amp;&amp;i!=c[1]){\n                //在根节点中与颜色i不同的颜色的个数\n                LL count=n-sum[i];\n                //每个颜色的路径数=(n*(n-1)&gt;&gt;1)-(count*(count-1)&gt;&gt;1)\n                //以根节点为中心减去不同于当前颜色的路径的个数\n                //最终得到的ans即为 每个颜色路径个数 的和\n                ans-=count*(count-1)&gt;&gt;1;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,tcase++,ans);\n    }\n    return 0;\n}</code></pre><h2 id=\"1006-Function-hdoj6038\"><a href=\"#1006-Function-hdoj6038\" class=\"headerlink\" title=\"1006 Function hdoj6038\"></a><strong>1006 Function hdoj6038</strong></h2><p>这道题似懂非懂的写了出来… 大体是寻找循环节. 我写的代码有点乱… 原式为: f[i]=b[f[a[i]]] A:{1,0,2} B{0,1} 可组成f: 000 111 110 001 A:{2,0,1} b{0,2,3,1} 可组成f: 000 231 312 123 以i -&gt; a[i] i -&gt; b[i] 为图的边进行Tarjan. 用Tarjan判断a和b各自有几个环(强连通分量),并且记录下每个环的大小. 然后AC代码如下(以后思路清楚了再重新看看…):</p>\n<pre><code>//HDU 6038\n#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\nconst int maxn=100000+100;\nconst int mod=1e9+7;\ntypedef long long int lli;\nvector&lt;int&gt; G[maxn];\n//lowlink[u] == 为u及其后代能追溯到的最早(最先被发现)的祖先节点v的pre[v]的值.\nint pre[maxn],lowlink[maxn],sccno[maxn],dfs_clock,scc_cnt;\n\nint a[maxn],b[maxn];\n\nstack&lt;int&gt; S;\nmap&lt;int,int&gt; A,B;\n\n//邻接表存储图\nvoid addAdge(int u,int v){\n    G[u].push_back(v);\n}\n\ninline lli qp(lli aa,lli x){\n    if(aa == 0) return 0;\n    lli ans = 1;\n    for(;x;x&gt;&gt;=1){\n        if(x&amp;1) ans = ans*aa % mod;\n        aa = aa*aa % mod;\n    }\n    return ans % mod;\n}\n\nvoid dfs(int u,map&lt;int,int&gt;&amp; T){\n    pre[u]=lowlink[u]= ++dfs_clock;\n    //边dfs将点入栈边Tarjan\n    S.push(u);\n    for(int i=0;i&lt;G[u].size();++i){\n        int v=G[u][i];\n        if(!pre[v]){\n            dfs(v,T);\n            //回溯时计算lowlink数组\n            lowlink[u]=min(lowlink[u],lowlink[v]);\n        }else if(!sccno[v]){\n            //未回溯时计算low数组需要通过pre数组\n            lowlink[u]=min(lowlink[u],pre[v]);\n        }\n    }\n    if(lowlink[u]==pre[u]){\n        scc_cnt++;\n        int cnt=0;\n        for(;;){\n            int x=S.top();S.pop();\n            sccno[x]=scc_cnt;\n            cnt++;\n            if(x==u)break;\n        }\n        T[cnt]++;\n    }\n}\n\nvoid Tarjan(int n,map&lt;int,int&gt;&amp; T){\n    while(!S.empty()){\n        S.pop();\n    }\n    dfs_clock=scc_cnt=0;\n    memset(sccno,0,sizeof(sccno));\n    memset(pre,0,sizeof(pre));\n    for(int i=0;i&lt;n;++i){\n        if(!pre[i]) dfs(i,T);\n    }\n}\n\nint main(){\n    int n,m,kase=0;\n    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%d&quot;,&amp;a[i]);\n        }\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;b[i]);\n        }\n        //对aTarjan\n        for(int i=0;i&lt;n;++i){\n            addAdge(i,a[i]);\n        }\n        Tarjan(n,A);\n        for(int i=0;i&lt;n;++i){\n            G[i].clear();\n        }\n        //对bTarjan\n        for(int i=0;i&lt;m;++i){\n            addAdge(i,b[i]);\n        }\n        Tarjan(m,B);\n        for(int i=0;i&lt;m;++i){\n            G[i].clear();\n        }\n\n        long long ans=1;\n        map&lt;int,int&gt;::iterator it1;\n        map&lt;int,int&gt;::iterator it2;\n        for(it1=A.begin();it1!=A.end();it1++){\n            long long tmp=0;\n            for(it2=B.begin();it2!=B.end();it2++){\n                if(it1-&gt;first%it2-&gt;first==0){\n                    tmp=tmp+it2-&gt;second*it2-&gt;first;\n                }\n                //printf(&quot;%d %d : %d %d\\n&quot;,it1-&gt;first,it2-&gt;first,it1-&gt;second,it2-&gt;second);\n            }\n            ans=ans*qp(tmp,it1-&gt;second)%mod;\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n        A.clear();\n        B.clear();\n    }\n    return 0;\n}</code></pre><h2 id=\"1008-Hints-of-sd0061-hdoj6040\"><a href=\"#1008-Hints-of-sd0061-hdoj6040\" class=\"headerlink\" title=\"1008 Hints of sd0061 hdoj6040\"></a><strong>1008 Hints of sd0061 hdoj6040</strong></h2><h1 id=\"第二场\"><a href=\"#第二场\" class=\"headerlink\" title=\"第二场\"></a><strong>第二场</strong></h1><h1 id=\"第三场\"><a href=\"#第三场\" class=\"headerlink\" title=\"第三场\"></a><strong>第三场</strong></h1>","text":"[toc]第一场1003 Colorful Tree hdoj6035题意: 给定一棵树，树上各点之间的距离定义为 两点路线上不同颜色的个数。求这课数上n(n-1)/2(即所有)的路径长度之和。 题解: (来自网络) * //思路：Answer = 所有颜色种类 * 所有路径数量","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"dfs","slug":"2017多校/dfs","count":1,"path":"api/categories/2017多校/dfs.json"},{"name":"图论","slug":"2017多校/dfs/图论","count":1,"path":"api/categories/2017多校/dfs/图论.json"},{"name":"思维","slug":"2017多校/dfs/图论/思维","count":1,"path":"api/categories/2017多校/dfs/图论/思维.json"}],"tags":[{"name":"图论","slug":"图论","count":6,"path":"api/tags/图论.json"},{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"dfs","slug":"dfs","count":2,"path":"api/tags/dfs.json"}]}]}