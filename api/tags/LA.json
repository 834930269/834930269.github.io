{"name":"LA","slug":"LA","count":8,"postlist":[{"title":"LA 3401","slug":"la-3401","date":"2017-04-04T08:44:39.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3401.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【生词】 identical 完全相同的事物,同一的,完全的 suitable 适当的,相配的 rotations 旋转 mirror 镜子,反射 Figure 3 图3 repainting 重新检测,重涂,重画 fewer 较少的,较少数 separate 分开,单独的</p>\n","text":"【生词】 identical 完全相同的事物,同一的,完全的 suitable 适当的,相配的 rotations 旋转 mirror 镜子,反射 Figure 3 图3 repainting 重新检测,重涂,重画 fewer 较少的,较少数 separate 分开,单独的","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"模拟","slug":"LA/模拟","count":1,"path":"api/categories/LA/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3708","slug":"la-3708","date":"2017-03-31T15:25:38.000Z","updated":"2019-07-03T13:51:36.846Z","comments":true,"path":"api/articles/la-3708.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【题解】</strong> <strong>蓝书P8</strong> <strong>题意是原本n个墓碑均匀分布在一个周长为10000的圆周上，现在加入m个，如果要使得n+m个墓碑都均匀分布的话，那么原来的墓碑最少的移动总距离是多少。</strong> <strong>因为加入m个之后m+n个墓碑的位置是固定的，要是移动距离最少必定会有一个墓碑不动，将圆周分成m+n段，分别标上0,1,2,3,4。。然后需要移动的墓碑坐标就是数轴上面的非整数点，两边的值靠近哪个就选哪个，之后再等比例扩大即可。</strong> <strong>放大倍数:10000/(M+N)</strong> <strong>原先N的坐标在放入M后的位置:</strong> <strong>//设距离L</strong> <strong>//i_(10000/N)=L_</strong> <em><strong>//L/(10000/(M+N))=pos</strong> <strong>//pos=i</strong></em><strong>(10000/N)/(10000/(M+N))</strong> <strong>//pos=i*(M+N)/N</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include<iostream></iostream></strong> <strong>#include<algorithm></algorithm></strong> <strong>#include<cstdio></cstdio></strong> <strong>#include<cstdlib></cstdlib></strong> <strong>#include<cstring></cstring></strong> <strong>#include<cmath></cmath></strong> <strong>using namespace std;</strong> <strong>int N,M;</strong> <strong>int main(){</strong> <em>*    while(scanf(“%d%d”,&amp;N,&amp;M)!=EOF) {** **        double ans=0.0;** **        for(int i=1;i&lt;N;++i){** **            double pos=(double)i/N</em>(N+M);<em>* **            //原先N的坐标在原来的位置是哪里** <strong>//设距离L</strong> **            //i</em>(10000/N)=L<em>* **            //L/(10000/(M+N))=pos** **//pos=i</em>(10000/N)/(10000/(M+N))<em>* **//pos=i</em>(M+N)/N** **            ans+=fabs(pos-floor(pos+0.5))/(N+M);** **            //floor()向下取整,这里等价于找两边距离最近** <strong>//的那个点.</strong> <strong>}</strong> **        printf(“%.4lf\\n”,ans<em>10000);  *</em> **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>与上面题解同理(没那么奇葩的写法的Code)</strong></p>\n<blockquote>\n<p>**#include <cstdio></cstdio></p>\n<p>#include <cstring></cstring></p>\n<p>#include <algorithm></algorithm></p>\n<p>using namespace std;</p>\n<p>int main() {<br>    int n,m;<br>    while(~scanf(“%d%d”,&amp;n,&amp;m)) {<br>        double ans = 0;<br>        for(int i = 1;i &lt; n;i++) {<br>            double pos = (double)i * (m + n) / n;<br>            ans += min(pos - (int)pos,(int)(pos + 1) - pos);<br>                        //取离两边距离最近的那个点<br>        }<br>        printf(“%.4lf\\n”,ans * 10000 / (m + n));<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【题解】 蓝书P8 题意是原本n个墓碑均匀分布在一个周长为10000的圆周上，现在加入m个，如果要使得n+m个墓碑都均匀分布的话，那么原来的墓碑最少的移动总距离是多少。 因为加入m个之后m+n个墓碑的位置是固定的，要是移动距离最少必定会有一个墓碑不动，将圆周分成m+n段，分别标上","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"}],"tags":[{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3882","slug":"la-3882","date":"2017-07-11T07:02:15.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3882.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3882\" target=\"_blank\" rel=\"noopener\">And Then There Was One</a></strong> <strong>【题解】</strong> <strong>假设问题是从n个人编号分别为0…n-1，取第k个，</strong> <strong>则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2…</strong> <strong>此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号</strong> <strong>把k号设置为0,则</strong> <strong>k 0</strong> <strong>k+1 1</strong> <strong>…</strong> <strong>0 n-k</strong> <strong>1 n-k+1</strong> <strong>假设已经求得了n-1个人情况下的最终胜利者保存在f[n-1]中，则毫无疑问，该胜利者还原到原来的真正编号即为 (f[n-1]+k)%n （因为第二轮重新编号的时候，相当于把每个人的编号都减了k，因此重新+k即可恢复到原来编号）。由此，我们可以想象，当最终只剩下一个人的时候，该人即为胜利者，此时重新编号，因为只有一个人，所以此时f[1]=0</strong> <strong>这样f[2]=(f[1]+k)%2,这样就可以求出最终胜利者在2个人的时候的情况下的编号，由递推公式f[n]=(f[n-1]+k)%n,可递推到最初编号序列中该胜利者的编号。</strong> <strong>因此用这个方法，只需一遍On的扫描，即可求出最终答案</strong> <strong>不过该题要求编号从1开始，只要把f[n]+1即可，同时，该题指定了第一个要删除的人必须为编号为m的人，其实也不难，求出f[n]之后，把原本编号为0的位置移到跟m只相距k的位置即可实现第一次删除的编号为m。所以最终 ans=(f[n]+1+m-k);</strong> <strong>当然因为m-k可能为负数，导致整个ans为负，这样其实最后+n即可解决。</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203882.cpp\" target=\"_blank\" rel=\"noopener\">LA 3882.cpp</a></strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=10000+10;<br>int f[maxn];<br>int main(){<br>    int n,k,m;<br>    while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n){<br>        ///最后一次变换只有一个点,所以最终点设为0<br>        ///每次去掉一个点以后重新编号,所以%i<br>        ///从底向上的方法<br>        f[1]=0;<br>        for(int i=2;i&lt;=n;++i)f[i]=(f[i-1]+k)%i;<br>        ///因为是从0编号,而题目要求从1编号,所以+1<br>        ///因为从0开始,而题目要求从m开始删除第k个<br>        ///所以第一次删除的下标应该是f[n]-k=第一次的起始下标<br>        ///0-k+m+1=真正的起始坐标,因为第一次需要将m设为0,从m开始重新编号<br>        int ans=(m-k+1+f[n])%n;<br>        ///因为m-k+1可能小于0,所以m-k+1+f[n]也可能小于0<br>        if(ans&lt;=0) ans+=n;<br>        printf(“%d\\n”,ans);<br>    }<br>    return 0;<br>}</strong></p>\n</blockquote>\n","text":"【Link】 And Then There Was One 【题解】 假设问题是从n个人编号分别为0…n-1，取第k个， 则第k个人编号为k-1的淘汰，剩下的编号为 0,1,2,3…k-2,k,k+1,k+2… 此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号 把k号设置为","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"动态规划","slug":"LA/动态规划","count":1,"path":"api/categories/LA/动态规划.json"},{"name":"思维","slug":"LA/动态规划/思维","count":1,"path":"api/categories/LA/动态规划/思维.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"动态规划","slug":"动态规划","count":24,"path":"api/tags/动态规划.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 3902","slug":"la-3902","date":"2017-07-10T13:21:12.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-3902.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-3902\" target=\"_blank\" rel=\"noopener\">Network</a></strong> <strong>【题解】</strong> <strong>可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表.</strong> <strong>最优选择放置服务器的方法是选择距离主机最远(k)的那个服务器上安装VOD即可.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/LA%203902.cpp\" target=\"_blank\" rel=\"noopener\">LA 3902.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;</p>\n<p>const int maxn=1000+10;<br>vector<int> gr[maxn],nodes[maxn];<br>int n,s,k,fa[maxn];<br>bool covered[maxn];</int></p>\n<p>///无根树转有根树,计算fa数组,根据深度把–叶子节点–插入nodes表中<br>///u当前节点下标,f,当前节点父节点下标,d深度.<br>void dfs(int u,int f,int d){<br>    fa[u]=f;<br>    int nc=gr[u].size();<br>    ///距离根节点k距离以内的叶子结点不用记录<br>    if(nc==1 &amp;&amp; d&gt;k) nodes[d].push_back(u);<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f)dfs(v,u,d+1);<br>    }<br>}</p>\n<p>void dfs2(int u,int f,int d){<br>    covered[u]=true;<br>    int nc=gr[u].size();<br>    for(int i=0;i&lt;nc;++i){<br>        int v=gr[u][i];<br>        if(v!=f&amp;&amp;d&lt;k)dfs2(v,u,d+1);///只覆盖到新服务器不超过k的结点 ///v!=f =&gt; 如果从f访问到u,那么就不能再从u回访f.深搜嘛.一路莽到底.<br>    }<br>}</p>\n<p>int solve(){<br>    int ans=0;<br>    memset(covered,0,sizeof(covered));<br>    for(int d=n-1;d&gt;k;–d){<br>        for(int i=0;i&lt;nodes[d].size();++i){<br>            int u=nodes[d][i];<br>            if(covered[u])continue;///不考虑已经覆盖的点</p>\n<pre><code>        int v=u;\n        for(int j=0;j&lt;k;++j)v=fa\\[v\\];///找到相邻k级祖先,不可能有-1，因为之前已经把离根k的节点忽略了\n        dfs2(v,-1,0);///在结点v设置服务器,然后通过对该服务器深搜\n                     ///找到所有的叶子结点\n        ans++;\n    }\n}\nreturn ans;</code></pre><p>}</p>\n<p>int main(){<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d%d”,&amp;n,&amp;s,&amp;k);///节点数,初始VOD服务器的编号和k<br>        for(int i=1;i&lt;=n;++i){gr[i].clear();nodes[i].clear();}<br>        for(int i=0;i&lt;n-1;++i){<br>            int a,b;<br>            scanf(“%d%d”,&amp;a,&amp;b);<br>            gr[a].push_back(b);<br>            gr[b].push_back(a);<br>        }<br>        dfs(s,-1,0);<br>        printf(“%d\\n”,solve());<br>    }<br>    return 0;<br>}**</p>\n</blockquote>\n","text":"【Link】 Network 【题解】 可将网络看成一棵树,将初始的VOD看做该树的根.距离该根k的叶节点可以忽略不计.其余的叶子结点记录在nodes数组表内,nodes[i]代表深度为i的叶子结点表.covered代表该叶子结点是第i个叶子结点是否可以使用VOD.gr代表邻接表","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"思维","slug":"LA/思维","count":2,"path":"api/categories/LA/思维.json"},{"name":"数据结构","slug":"LA/思维/数据结构","count":1,"path":"api/categories/LA/思维/数据结构.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"数据结构","slug":"数据结构","count":5,"path":"api/tags/数据结构.json"}]},{"title":"LA 3905","slug":"la-3905","date":"2017-04-05T09:18:51.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3905.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>区间扫描,  抽象成事件来做的区间扫描</strong> <strong>【题解】</strong> <strong>蓝书P45</strong> <strong><a href=\"http://blog.csdn.net/xl2015190026/article/details/52937814\" target=\"_blank\" rel=\"noopener\">另一个更详细的blog</a></strong> <strong>代码中难懂的部分都已经注释了.</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>//0&lt;x+a*t&lt;w</strong> <strong>//0&lt;x+a*t&lt;w,0&lt;y+b*t&lt;h,  t&gt;0</strong> <strong>//起始坐标:(x,y) 速度:(a,b)</strong> <strong>//x横坐标运动范围(0-w) y纵坐标运动范围(0-h)</strong> <strong>//题目给的公式 在时刻t坐标:p+tv=(x,y)+(t*a,t*b)</strong> <strong>//然后根据这个范围求出出现在镜框的范围内的时间区间,开区间</strong> <strong>//因为出现在镜框上不算进入射程.</strong> <strong>void update(int x,int a,int w,double &amp;L,double &amp;R){</strong> **    if(a==0){** **        if(x&lt;=0 || x&gt;=w) R=L-1;//无解,无法出现在镜框范围内** **    }else if(a&gt;0){** **        L=max(L,-(double)x/a);** **        R=min(R,(double)(w-x)/a);** **    }else{** **        L=max(L,(double)(w-x)/a);** **        R=min(R,-(double)x/a);** **    }** <strong>}</strong> <strong>const int maxn=100000+10;</strong> <strong>struct Event{</strong> **    double x;** **    int type;//状态,0为右端点,1为左端点** **    bool operator&lt;(const Event &amp;a)const{** **        return x&lt;a.x || (x==a.x &amp;&amp; type&gt;a.type);//先处理右端点** **    }** <strong>}events[maxn*2];</strong> <strong>int main(){</strong> **    int T;** **    scanf(“%d”,&amp;T);** **    while(T–){** **        int w,h,n,e=0;** **        scanf(“%d%d%d”,&amp;w,&amp;h,&amp;n);** **        for(int i=0;i&lt;n;++i){** **            int x,y,a,b;** **            scanf(“%d%d%d%d”,&amp;x,&amp;y,&amp;a,&amp;b);** **            //0&lt;x+a*t&lt;w,0&lt;y+b*t&lt;h,  t&gt;0** **            double L=0,R=1e9;//先开一个无穷大的区间** **            update(x,a,w,L,R);** **            update(y,b,h,L,R);** **            if(R&gt;L){//只把有效可进入镜框的点加入区间** **                events[e++]=(Event){L,0};** **                events[e++]=(Event){R,1};** **            }** **        }** **        //排序区间,可以画图看下.** **        sort(events,events+e);** **        int cnt=0,ans=0;** **        for(int i=0;i&lt;e;++i){** **            if(events[i].type==0)** **                cnt++,ans=max(ans,cnt);** **            else cnt–;** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 区间扫描,  抽象成事件来做的区间扫描 【题解】 蓝书P45 另一个更详细的blog 代码中难懂的部分都已经注释了. 【Code】#include&lt;bits/stdc++.h&gt; using namespace std; //0&lt;x+a*t&lt;w /","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"事件","slug":"LA/事件","count":1,"path":"api/categories/LA/事件.json"},{"name":"区间","slug":"LA/事件/区间","count":1,"path":"api/categories/LA/事件/区间.json"}],"tags":[{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"},{"name":"事件","slug":"事件","count":1,"path":"api/tags/事件.json"},{"name":"区间","slug":"区间","count":1,"path":"api/tags/区间.json"}]},{"title":"LA 4329","slug":"la-4329","date":"2017-06-21T04:08:50.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/la-4329.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVALive-4329\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-4329</a></strong> <strong>【thought】</strong> <strong>考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的.</strong> <strong>那么1 ~ (i-1)中有  (i-sm[i]-1)  个比A[i]能力大的,(i+1) ~ N 中有  (N-i-sl[i])  个比A[i]能力大的.</strong> <strong>根据乘法原理 对于第i个人做裁判有 sl[i]<em>(i-sm[i]-1)+sm[i]</em>(N-i-sl[i]) 中比赛可能,因为每个人做裁判,所以最后结果为每个人做裁判的情况和.</strong> <strong>考虑 T=1_19998+2_19997+3_19996+…+19998_1 爆int,故用long long 存.</strong> <strong>【Type】</strong> <strong>树状数组,lowbit()</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong> <strong>【溢出int测试】</strong> <strong><a href=\"https://github.com/834930269/Review_DataStructure/blob/master/Range-Tree/%E7%AC%AC%E4%B8%80%E6%AC%A1/practice/LA4329test.cpp\" target=\"_blank\" rel=\"noopener\">LA 4329.cpp</a></strong></p>\n","text":"【Link】 https://vjudge.net/problem/UVALive-4329 【thought】 考虑对于每第i个人做裁判,1 ~ (i-1)中有sm[i]个比A[i]能力小的,(i+1) ~ N 中有sl[i]个比A[i]能力小的. 那么1 ~ (i-1)中有 ","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"树状数组","slug":"LA/树状数组","count":1,"path":"api/categories/LA/树状数组.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":3,"path":"api/tags/树状数组.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"LA 4670","slug":"la-4670","date":"2018-03-11T06:59:12.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/la-4670.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Type-AC自动机\"><a href=\"#Type-AC自动机\" class=\"headerlink\" title=\"Type:AC自动机\"></a>Type:AC自动机</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一堆子串和一个主串</p>\n<blockquote>\n<p>问你在主串中出现次数最多的子串有哪些,最后结果按字典序排列</p>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int maxn=11000;\nconst int maxm=152;\nconst int maxt=1e6+6;\n\nint T,N,tot_len;\nchar str[maxm][80],tot[maxt];\n\nstruct AC_AutoMaton{\n    static const int sigma_size=26;\n\n    int ch[maxn][sigma_size];\n\n    int f[maxn];\n\n    int cnt[maxn],val[maxn];\n    bool vis[maxn][sigma_size];\n\n    int siz,root,max_time;\n\n    vector&lt;string&gt; ans;\n\n    int newNode(){\n        for(int i=0;i&lt;sigma_size;++i){\n            ch[siz][i]=0;\n        }\n        for(int i=0;i&lt;sigma_size;++i){\n            vis[siz][i]=false;\n        }\n        f[siz]=val[siz]=0;\n        return siz++;\n    }\n\n    void init(){\n        ans.clear();\n        for(int i=0;i&lt;maxn;++i) val[i]=cnt[i]=0;\n        siz=0;root=0;max_time=0;\n        newNode();\n    }\n\n    int ord(char c){\n        if(isupper(c))\n            c=tolower(c);\n        return (int)(c-&apos;a&apos;);\n    }\n\n    void insert(char *s,int v){\n        int u=root,n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            if(!ch[u][c]) ch[u][c]=newNode();\n            u=ch[u][c];\n       }\n       val[u]=v;\n    }\n\n    void getFail(){\n        queue&lt;int&gt; Q;\n        Q.push(root);\n        while(!Q.empty()){\n            int k=Q.front();\n            Q.pop();\n            for(int c=0;c&lt;sigma_size;++c){\n                if(ch[k][c]){\n                    f[ch[k][c]]=k?ch[f[k]][c]:0;\n                    Q.push(ch[k][c]);\n                }\n                else ch[k][c]=ch[f[k]][c];\n            }\n        }\n    }\n\n    void Find(char *s){\n        int u=0,n=tot_len;\n        for(int i=0;i&lt;n;++i){\n            int c=ord(s[i]);\n            ///下面这句加不加都一样\n            //while(u &amp;&amp; !ch[u][c]) u=f[u];\n            u=ch[u][c];\n\n            int p=u;\n            //cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;c&lt;&lt;endl;\n            ///while是用来判断子串的.这道题不需要加\n            while(p &amp;&amp; val[p]){\n                if(!vis[p][c]){\n                    cnt[val[p]]++;\n                    max_time=max(cnt[val[p]],max_time);\n                    p=f[p];\n                    vis[p][c]=true;\n                }\n            }\n        }\n    }\n\n    void print(){\n        printf(&quot;%d\\n&quot;,max_time);\n        for(int i=1;i&lt;=N;++i){\n            if(cnt[i]==max_time){\n                ans.push_back(str[i]);\n            }\n        }\n        sort(ans.begin(),ans.end());\n        for(int i=0;i&lt;ans.size();++i){\n            cout&lt;&lt;ans[i]&lt;&lt;endl;\n        }\n    }\n}aho;\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N){\n        aho.init();\n        for(int i=1;i&lt;=N;++i){\n            scanf(&quot;%s&quot;,str[i]);\n            aho.insert(str[i],i);\n        }\n        getchar();\n        aho.getFail();\n        tot_len=0;\n        //scanf(&quot;%[^\\n]&quot;,str);\n        gets(tot);\n        tot_len=strlen(tot);\n        //cout&lt;&lt;tot_len&lt;&lt;endl;\n        aho.Find(tot);\n        aho.print();\n    }\n    return 0;\n}</code></pre>","text":"Type:AC自动机题意给你一堆子串和一个主串问你在主串中出现次数最多的子串有哪些,最后结果按字典序排列Code#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=11000;const int maxm","link":"","raw":null,"photos":[],"categories":[{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/categories/AC自动机.json"},{"name":"LA","slug":"AC自动机/LA","count":1,"path":"api/categories/AC自动机/LA.json"},{"name":"字符串处理","slug":"AC自动机/LA/字符串处理","count":1,"path":"api/categories/AC自动机/LA/字符串处理.json"}],"tags":[{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"AC自动机","slug":"AC自动机","count":4,"path":"api/tags/AC自动机.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"POJ 1961","slug":"poj-1961","date":"2018-02-25T05:26:28.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-1961.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h1><p><a href=\"https://vjudge.net/problem/UVALive-3026\" title=\"https://vjudge.net/problem/UVALive-3026\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVALive-3026</a></p>\n<h1 id=\"Type-KMP-Next数组\"><a href=\"#Type-KMP-Next数组\" class=\"headerlink\" title=\"Type: KMP-Next数组\"></a>Type: KMP-Next数组</h1><h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><blockquote>\n<p>给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度</p>\n</blockquote>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><h2 id=\"前置\"><a href=\"#前置\" class=\"headerlink\" title=\"前置\"></a>前置</h2><h3 id=\"关于Next数组\"><a href=\"#关于Next数组\" class=\"headerlink\" title=\"关于Next数组\"></a>关于Next数组</h3><blockquote>\n<p>(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符进行再次匹配. (2) j=Next[k]表示第 j 个字符和第 k 个字符一样. (3) j=Next[k]表示前 j 个字符和后 j 个字符一样</p>\n<blockquote>\n<p>即 1<del>j-1 和 k-j+1</del>k 这两个子串相等</p>\n</blockquote>\n</blockquote>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><blockquote>\n<p>即我们求出该字符串的Next数组后我们可以判断当前 (i-Next[i]) 是否能被 i 整除.</p>\n<blockquote>\n<p>即 i%(i-Next[i]) 是否等于0.</p>\n<blockquote>\n<p>i-Next[i]为该子串的长度,如果可以整除则证明该子串为循环节,循环节长度为 i-Next[i] ,循环次数为 i/(i-Next[i]).</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h1><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1000000+10;\nchar ts[maxn];\nint n,kase=1;\nint Next[maxn];\nvoid getNext(){\n    int j=0,k=-1;\n    Next[0]=-1;\n    while(j&lt;n){\n        if(k==-1 || ts[j]==ts[k]) Next[++j]=++k;\n        else k=Next[k];\n    }\n}\nvoid print(){\n    for(int i=1;i&lt;=n;++i){\n        cout&lt;&lt;Next[i]&lt;&lt;&quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        if(!n)break;\n        scanf(&quot;%s&quot;,ts);\n        getNext();\n        //print();\n        printf(&quot;Test case #%d\\n&quot;,kase++);\n        for(int i=2;i&lt;=n;++i){\n            if(Next[i]&lt;=0) continue;\n            if(i%(i-Next[i])==0){\n                printf(&quot;%d %d\\n&quot;,i,i/(i-Next[i]));\n            }\n        }\n        printf(&quot;\\n&quot;);\n        getchar();\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVALive-3026Type: KMP-Next数组题意给你一个字符串,输出这个字符串中所有的周期子串最后一个字符的下标和周期长度题解前置关于Next数组(1) Next数组记录的是如果当前字符不匹配,跳到哪个字符","link":"","raw":null,"photos":[],"categories":[{"name":"KMP","slug":"KMP","count":2,"path":"api/categories/KMP.json"},{"name":"LA","slug":"KMP/LA","count":1,"path":"api/categories/KMP/LA.json"},{"name":"POJ","slug":"KMP/LA/POJ","count":1,"path":"api/categories/KMP/LA/POJ.json"},{"name":"字符串处理","slug":"KMP/LA/POJ/字符串处理","count":1,"path":"api/categories/KMP/LA/POJ/字符串处理.json"}],"tags":[{"name":"KMP","slug":"KMP","count":3,"path":"api/tags/KMP.json"},{"name":"字符串处理","slug":"字符串处理","count":7,"path":"api/tags/字符串处理.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]}]}