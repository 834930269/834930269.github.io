{"name":"模拟","slug":"模拟","count":9,"postlist":[{"title":"2017多校训练1 HDU 6034 Balala Power!","slug":"2017-hdu-6034-balala-power","date":"2017-07-27T15:41:01.000Z","updated":"2019-07-03T13:51:36.850Z","comments":true,"path":"api/articles/2017-hdu-6034-balala-power.json","excerpt":"","keywords":null,"cover":"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg","content":"<p>题目连接: :point_right:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6034\" title=\"Balala Power!\" target=\"_blank\" rel=\"noopener\">Balala Power!</a> <a href=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" title=\"Balala\" target=\"_blank\" rel=\"noopener\"><img src=\"http://acm.hdu.edu.cn/data/images/C642-1002-1.jpg\" alt=\"Balala\" title=\"Balala\"></a> 题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可以有前导0,规则是为0的字符不能位于len&gt;1的字符串的开头. 题解: 统计每个字符的总结果,排序,最大的字符赋值25,然后依次往下赋值.然后判断前导0,找到第一个可以为0的存在的字符,将它赋值为0,之后其他的左移一位.(出现前导0的情况表示26个字符都已经出现了). github: :point_right:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/1/1002.cpp\" title=\"1002.cpp\" target=\"_blank\" rel=\"noopener\">1002.cpp</a></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=1e5+5;\nconst int mod=1e9+7;\nstruct star{\n    int reg[100005];\n    bool vi;\n    int c;\n    bool operator &lt; (const star &amp;A)const{\n        for(int i=maxn-1;i&gt;=0;--i){\n            if(reg[i]&gt;A.reg[i]) return 1;\n            else if(reg[i]&lt;A.reg[i]) return 0;\n            else continue;\n        }\n    }\n}ch[30];\nchar str[100005];\nint Hash[30];///字符-权值映射\nlong long ans,fac[100005];\ninline void init(){\n    for(int i=0;i&lt;27;++i){\n        memset(ch[i].reg,0,sizeof(ch[i].reg));\n        ch[i].vi=true;\n        ch[i].c=0;\n    }\n    ans=0;\n}\nint main(){\n    int n,len,p,kase=0;\n    fac[0]=1;///预先处理26^i;\n    for(int i=1;i&lt;maxn;++i)\n        fac[i]=fac[i-1]*26%mod;\n    while(~scanf(&quot;%d&quot;,&amp;n)){\n        init();\n        for(int i=0;i&lt;n;++i){\n            scanf(&quot;%s&quot;,str);\n            len=strlen(str);\n            for(int j=0;j&lt;len;++j){\n                p=str[j]-&apos;a&apos;;\n                ch[p].reg[len-j-1]++;\n            }\n            if(len&gt;1)\n                ch[str[0]-&apos;a&apos;].vi=false;\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                if(ch[i].reg[j]&gt;=26){\n                    ch[i].reg[j+1]+=ch[i].reg[j]/26;\n                    ch[i].reg[j]%=26;\n                }\n            }\n            ch[i].c=i;\n        }\n        sort(ch,ch+26);\n        for(int i=0;i&lt;26;++i)\n            Hash[ch[i].c]=26-i-1;\n        for(int i=25;i&gt;=0;--i){///从最小的开始判断是否可以为0\n            if(ch[i].vi){\n                for(int j=25;j&gt;i;--j)\n                    Hash[ch[j].c]=Hash[ch[j-1].c];\n                Hash[ch[i].c]=0;\n                break;\n            }\n        }\n        for(int i=0;i&lt;26;++i){\n            for(int j=0;j&lt;maxn;++j){\n                ans=(ans+fac[j]*ch[i].reg[j]*Hash[ch[i].c]%mod)%mod;\n            }\n        }\n        printf(&quot;Case #%d: %lld\\n&quot;,++kase,ans);\n    }\n    return 0;\n}</code></pre>","text":"题目连接: :point_right:Balala Power!  [Figure]  题意: 把26个英文字母看成26进制中的一位,YI一对应起来,给你n个由26个字符组成的字符串,每个字符串代表一个26进制的数,求这n个26进制数的最大的和mod 1e9+7 的结果.注意,可","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]},{"title":"2017 Multi-University Training Contest - Team 9  1008","slug":"2017-multi-university-training-contest-team-9-1008","date":"2017-08-22T11:37:20.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/2017-multi-university-training-contest-team-9-1008.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6168\" title=\"HDU-6168 Numbers\" target=\"_blank\" rel=\"noopener\">HDU-6168 Numbers</a> github Code Link: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008.cpp\" title=\"1008.cpp\" target=\"_blank\" rel=\"noopener\">1008.cpp</a> Test Code: :earth_asia:<a href=\"https://github.com/834930269/Other_OJ/blob/master/Multi-University%20Training%20Contest/9/1008test.cpp\" title=\"1008test.cpp\" target=\"_blank\" rel=\"noopener\">1008test.cpp</a> 题解: 用map记录下每个数字出现的次数.然后对b进行排序,首先可以知道,排序后的数组,前两个数一定是a序列的前两个数.然后从这两个数开始拓展,a1+a2必在b中,所以在map中找到a1+a2的数量然后-1,之后把接下来的第一个数Push到a数组中,并且删除一个a1+a3和a2+a3,依次递推.知道a.size()到达sqrt(m/2)或者i&gt;=m为止,结束循环. Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn=200000;\n\nint c[maxn];\nint m,n;\nmap&lt;int,int&gt; d;\nvector&lt;int&gt; a;\nint main(){\n    while(~scanf(&quot;%d&quot;,&amp;m)){\n        d.clear();a.clear();\n        n=sqrt(m&lt;&lt;1);\n        for(int i=0;i&lt;m;++i){\n            scanf(&quot;%d&quot;,&amp;c[i]);\n            d[c[i]]++;\n        }\n        sort(c,c+m);\n        a.push_back(c[0]);a.push_back(c[1]);\n        d[c[1]]--;d[c[0]]--;\n        for(int i=1;i&lt;m &amp;&amp; a.size()&lt;n;++i){\n            int si=a.size()-1;\n            for(int j=0;j&lt;si;++j){\n                if(d.find(a[si]+a[j])!=d.end() &amp;&amp; d[a[si]+a[j]]&gt;0){\n                    d[a[si]+a[j]]--;\n         //           printf(&quot;IDone %d\\n&quot;,a[si-1]+a[j]);\n                }\n            }\n            while(d[c[i]]==0){\n                int no=c[i];\n                while(c[i]==no){\n                    ++i;\n                    if(i&gt;=m)break;\n                }\n                if(i&gt;=m)break;\n    //            printf(&quot;Done %d\\n&quot;,c[i]);\n            }\n            if(i&lt;m){\n                a.push_back(c[i]);\n         //       printf(&quot;Push %d\\n&quot;,c[i]);\n                d[c[i]]--;\n            }\n            --i;\n        }\n        printf(&quot;%d\\n&quot;,a.size());\n        printf(&quot;%d&quot;,a[0]);\n        for(int i=1;i&lt;a.size();++i){\n            printf(&quot; %d&quot;,a[i]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>Test Code:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint t[5]={3,7,6,9,10};\nvector&lt;int&gt; ans;\nint main(){\n     freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n     freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n     for(int i=0;i&lt;5;++i) ans.push_back(t[i]);\n     for(int i=0;i&lt;5;++i){\n        for(int j=i+1;j&lt;5;++j){\n            ans.push_back(t[i]+t[j]);\n        }\n     }\n     printf(&quot;%d\\n&quot;,ans.size());\n     for(int i=0;i&lt;ans.size();++i) printf(&quot;%d &quot;,ans[i]);\n    return 0;\n}</code></pre>","text":"类型:模拟 瞎搞,优化暴力.关键在于理解题意,我还是把它归在模拟吧. 题目连接: :earth_americas:HDU-6168 Numbers github Code Link: :earth_asia:1008.cpp Test Code: :earth_asia:1008","link":"","raw":null,"photos":[],"categories":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/categories/2017多校.json"},{"name":"模拟","slug":"2017多校/模拟","count":2,"path":"api/categories/2017多校/模拟.json"}],"tags":[{"name":"2017多校","slug":"2017多校","count":7,"path":"api/tags/2017多校.json"},{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"}]},{"title":"LA 2995","slug":"la-2995","date":"2017-04-04T06:41:40.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-2995.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【生词】</strong> <strong>small lightweight object 轻量级的对象(比较轻的物体)</strong> <strong>hold 控制,保留,支持,持有,保存,这里意为举起</strong> <strong>intelligence 智力,情报工作,情报机关,理解力</strong> <strong>determine 下决心,决定</strong> <strong>cardinal 主要的,基本的</strong> <strong>inferring 推理,猜想</strong> <strong>upper limited 上限,最大值</strong> <strong>assume 借取,篡夺,假定,假想</strong> <strong>form 形式,形状,构成</strong> <strong>lattice 晶格,格子,格架</strong> <strong>cubes 立方体</strong> <strong>weighs权衡,重量为</strong> <strong>gram 克/g</strong> <strong>is not necessarily 没必要/不一定</strong> <strong>separated 分隔,分开的</strong> <strong>corresponds 符合,一致,相应</strong> <strong>similar 类似的,相似的</strong> <strong>【Tip】</strong> <strong>这个模拟…额…有点蒙..效率起见,回头看,蓝书P15</strong> <strong>【Code】</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>#define REP(i,n) for(int i=0;i&lt;(n);++i)</strong> <strong>using namespace std;</strong> <strong>const int maxn =10;</strong> <strong>int n;</strong> <strong>char pos[maxn][maxn][maxn];</strong> <strong>char view[6][maxn][maxn];</strong> <strong>char read_char(){</strong> **    char ch;** **    for(;;){** **        ch=getchar();** **        if((ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’) || ch==’.’) return ch;** **    }** <strong>}</strong> <strong>//get函数表示第k个视图中,第i行j列,深度为len的单位立方体</strong> <strong>//在原立方体中的坐标(x,y,z)</strong> <strong>void get(int k,int i,int j,int len,int &amp;x,int &amp;y,int &amp;z){</strong> **    if(k==0){x=len;y=j;z=i;}** **    if(k==1){x=n-1-j;y=len;z=i;}** **    if(k==2){x=n-1-len;y=n-1-j;z=i;}** **    if(k==3){x=j;y=n-1-len;z=i;}** **    if(k==4){x=n-1-i;y=j;z=len;}** **    if(k==5){x=i;y=j;z=n-1-len;}** <strong>}</strong> <strong>int main(){</strong> **    while(~scanf(“%d”,&amp;n) &amp;&amp; n){** **        REP(i,n) REP(k,6) REP(j,n) view[k][i][j]=read_char();** **        REP(i,n) REP(j,n) REP(k,n) pos[i][j][k]=’#’;** **        REP(k,6) REP(i,n) REP(j,n) if(view[k][i][j]==’.’)** **            REP(p,n){** **                int x,y,z;** **                get(k,i,j,p,x,y,z);** **                pos[x][y][z]=’.’;** **            }** **        for(;;){** **            bool done=true;** **            REP(k,6) REP(i,n) REP(j,n) if(view[k][i][j]!=’.’){** **                REP(p,n){** **                    int x,y,z;** **                    get(k,i,j,p,x,y,z);** **                    if(pos[x][y][z]==’.’) continue;** **                    if(pos[x][y][z]==’#’) {** **                        pos[x][y][z]=view[k][i][j];** **                        break;** **                    }** **                    if(pos[x][y][z]==view[k][i][j]) break;** **                    pos[x][y][z]=’.’;** **                    done=false;** **                }** **            }** **            if(done) break;** **        }** **        int ans=0;** **        REP(i,n) REP(j,n) REP(k,n)** **            if(pos[i][j][k]!=’.’) ans++;** **        printf(“Maximum weight: %d gram(s)\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【生词】 small lightweight object 轻量级的对象(比较轻的物体) hold 控制,保留,支持,持有,保存,这里意为举起 intelligence 智力,情报工作,情报机关,理解力 determine 下决心,决定 cardinal 主要的,基本的 infe","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"模拟","slug":"POJ/模拟","count":1,"path":"api/categories/POJ/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"LA 3401","slug":"la-3401","date":"2017-04-04T08:44:39.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/la-3401.json","excerpt":"","keywords":null,"cover":null,"content":"<p>【生词】 identical 完全相同的事物,同一的,完全的 suitable 适当的,相配的 rotations 旋转 mirror 镜子,反射 Figure 3 图3 repainting 重新检测,重涂,重画 fewer 较少的,较少数 separate 分开,单独的</p>\n","text":"【生词】 identical 完全相同的事物,同一的,完全的 suitable 适当的,相配的 rotations 旋转 mirror 镜子,反射 Figure 3 图3 repainting 重新检测,重涂,重画 fewer 较少的,较少数 separate 分开,单独的","link":"","raw":null,"photos":[],"categories":[{"name":"LA","slug":"LA","count":7,"path":"api/categories/LA.json"},{"name":"模拟","slug":"LA/模拟","count":1,"path":"api/categories/LA/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"LA","slug":"LA","count":8,"path":"api/tags/LA.json"}]},{"title":"UVa 10795","slug":"uva-10795","date":"2017-07-09T13:06:29.000Z","updated":"2019-07-03T13:51:36.849Z","comments":true,"path":"api/articles/uva-10795.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【Link】</strong> <strong><a href=\"https://vjudge.net/problem/UVA-10795\" target=\"_blank\" rel=\"noopener\">A Different Task</a></strong> <strong>汉诺塔问题总结:</strong> <a href=\"http://blog.csdn.net/xueerfei008/article/details/9904681\" target=\"_blank\" rel=\"noopener\"><strong>杭电 汉诺塔问题总结</strong></a> <strong>【题解】</strong> <strong>大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标.</strong> <strong>f(P,i,final):已知各盘子的初始柱子编号数组为P,把盘子1,2,3,4…i全部移到柱子final所需的步数.</strong> <strong>参考局面等于中转态.即中转柱子下标为6-P[i]-finish[i].将前i-1个盘子移动到中转柱上.然后把盘子i移动到final柱子上,最后将i-1个盘子从中转态移动到final.</strong> <strong>【Code】</strong> <strong><a href=\"https://github.com/834930269/Algorithm_Lrj/blob/master/ch1/Uva%2010795.cpp\" target=\"_blank\" rel=\"noopener\">UVA 10795.cpp</a></strong></p>\n<blockquote>\n<p>**#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long LL;</p>\n<p>LL f(int* P,int i,int finaln){<br>    if(i==0) return 0;<br>    ///如果当前最大的这个号的起始盘子等于最终落脚盘子<br>    ///不用移动.所以f(P,i,final)=f(P,i-1,final)<br>    if(P[i]==finaln) return f(P,i-1,finaln);<br>    ///经典汉诺塔的结论,将前i-1个盘子从一个柱子移动到另一个柱子<br>    ///这个步骤需要2^(i-1)-1步.加上移动盘子i到最终盘子<br>    ///的那一步,一共需要2^(i-1)步.<br>    return f(P,i-1,1+2+3-P[i]-finaln)+(1LL&lt;&lt;(i-1));<br>}</p>\n<p>const int maxn=60+10;<br>int n,start[maxn],finish[maxn];</p>\n<p>int main(){<br>    int kase=0;<br>    while(scanf(“%d”,&amp;n)==1&amp;&amp;n){<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;start[i]);<br>        for(int i=1;i&lt;=n;++i)scanf(“%d”,&amp;finish[i]); ///结论:如果最大的盘子一开始就在最终的柱子上 ///则不用移动. ///找到号码最大的那几个不需要移动的盘子. int k=n; while(k&gt;=1&amp;&amp;start[k]==finish[k])k–;</p>\n<pre><code>    ///结论:由于移动的步数是对称的,即往回移动的步伐\n    ///和步数等于往前移动.\n    LL ans=0;\n    if(k&gt;=1){\n        int other=6-start\\[k\\]-finish\\[k\\];\n        ans=f(start,k-1,other)+f(finish,k-1,other)+1;\n    }\n    printf(&quot;Case %d: %lld\\\\n&quot;,++kase,ans);\n}\nreturn 0;</code></pre><p>}**</p>\n</blockquote>\n","text":"【Link】 A Different Task 汉诺塔问题总结: 杭电 汉诺塔问题总结 【题解】 大部分直接写在代码里,6-start[i]-final[i]=1+2+3-start[i]-final[i].因为柱子编号是1,2,3.所以这样减一下得到的是最终该盘所在柱子下标. ","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"模拟","slug":"UVa/思维/模拟","count":1,"path":"api/categories/UVa/思维/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]},{"title":"第14届浙江省赛By Tusimple","slug":"14zojby-tusimple","date":"2017-04-22T11:57:29.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/14zojby-tusimple.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【网赛链接】</strong> <strong><a href=\"http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=364\" target=\"_blank\" rel=\"noopener\">第14届浙江省赛By Tusimple</a></strong> <strong>【A】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int N,a1,T;</strong> <strong>int Kobayashi[4]={1,0,1,-1},Kscore;</strong> <strong>int Tohru[4]={0,1,1,-1},Tscore;</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        while(N–){** **            SI(T);** **            Kscore=0;** **            Tscore=0;** **            rep(i,T){** **                SI(a1);** **                Kscore+=Kobayashi[a1-1];** **                Tscore+=Tohru[a1-1];** **            }** **            if(Kscore&gt;Tscore)** **                puts(“Kobayashi”);** **            else if(Tscore&gt;Kscore)** **                puts(“Tohru”);** **            else** **                puts(“Draw”);** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【B】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>const int maxn=20000+10;</strong> <strong>int T,N,fk,Orz,flag,cnt;</strong> <strong>int score[maxn],scomp[maxn];</strong> <strong>int main(){</strong> **    while(~SI(T)){** **        while(T–){** **            fill(score,score+4000,0);** **            Orz=flag=0;** **            SI(N);** **            if(N&gt;13 || N&lt;10){** **                rep(i,N){** **                    SI(fk);** **                }** **                puts(“No”);continue;** **            }** **            rep(i,N){** **                SI(fk);** **                if(fk&lt;=0){** **                    flag=1;** **                }else{** **                    score[fk]++;** **                }** **                scomp[i]=fk;** **            }** **            if(flag){** **                puts(“No”);** **            }else{** **                if(score[1]&lt;2){** **                    puts(“No”);** **                    continue;** **                }else{** **                    sort(scomp,scomp+N);** **                    rez(i,1,N-2){** **                        if(scomp[i]-scomp[i-1]&gt;2){** **                            puts(“No”);** **                            flag=1;** **                            break;** **                        }** **                    }** **                    if(!flag) puts(“Yes”);** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>【C】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>int T,n,q,c;</strong> <strong>map&lt;string,int&gt; mp;</strong> <strong>map&lt;string,int&gt;::iterator ite;</strong> <strong>map&lt;int,vector<string> &gt; res;</string></strong> <strong>string st;</strong> <strong>inline int readt(int N){</strong> **    int ans=0,tit;** **    rep(i,N){** **        SI(tit);** **        ans+=(1&lt;&lt;N-i-1) &amp; (tit&lt;&lt;N-i-1);** **    }** **    return ans;** <strong>}</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        //测试数据可能出现重复的名字和情况,所以要初始化** **        mp.clear();** **        res.clear();** **        SII(n,q);** **        SI(c);** **        rep(i,c){** **            cin&gt;&gt;st;** **            mp[st]=0;** **        }** **        rep(i,q){** **            int nu;** **            SI(nu);** **            rep(j,nu){** **                cin&gt;&gt;st;** **                mp[st]+=(1&lt;&lt;q-i-1);** **            }** **        }** **        for(ite=mp.begin();ite!=mp.end();ite++){** **            res[ite-&gt;second].push_back(ite-&gt;first);** **        }** **        rep(i,n){** **            int index=readt(q);** **            if(res.find(index)==res.end()){** **                puts(“Let’s go to the library!!”);** **            }else{** **                vector<string>&amp; t=res[index];** **                if(t.size()&gt;1){** **                    puts(“Let’s go to the library!!”);** **                }else{** **                    cout&lt;&lt;t[0]&lt;&lt;”\\n”;** **                }** **            }** **        }** **    }** **    return 0;** <strong>}</strong></string></p>\n</blockquote>\n<p><strong>【D】</strong> <strong>因为样例用的是m=3…所以我就一直卡在z&gt;=3……然后比赛结束以后发现了…好亏啊</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%d”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>struct Star{</strong> **    int left,right;** **    bool operator&lt;(const Star MM) const{** **        return left&lt;MM.left;** **    }** <strong>}A[500],B[500];</strong> <strong>int n,m,x,y,T,s,e;</strong> <strong>int main(){</strong> **    SI(T);** **    while(T–){** **        SII(n,m);SII(x,y);** **        rep(i,x){** **            SII(s,e);** **            A[i].left=s;** **            A[i].right=e;** **        }** **        rep(i,y){** **            SII(s,e);** **            B[i].left=s;** **            B[i].right=e;** **        }** **        sort(A,A+x);** **        sort(B,B+y);** **        int ans=0;** **        rep(i,x){** **            s=A[i].left;** **            e=A[i].right;** **            int z=0;** **            rep(j,y){** **                if(B[j].left&gt;A[i].right) break;** **                z+=(min(B[j].right,A[i].right)-max(A[i].left,B[j].left)+1);** **                    if(z&gt;=m){** **                        ans+=z-m+1;** **                        z=0;** **                    }else{** **                        z=0;** **                    }** **            }** **        }** **        printf(“%d\\n”,ans);** **    }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【网赛链接】 第14届浙江省赛By Tusimple 【A】#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; #define ","link":"","raw":null,"photos":[],"categories":[{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/categories/ZOJ.json"},{"name":"位操作","slug":"ZOJ/位操作","count":1,"path":"api/categories/ZOJ/位操作.json"},{"name":"悬线法","slug":"ZOJ/位操作/悬线法","count":1,"path":"api/categories/ZOJ/位操作/悬线法.json"},{"name":"模拟","slug":"ZOJ/位操作/悬线法/模拟","count":1,"path":"api/categories/ZOJ/位操作/悬线法/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"悬线法","slug":"悬线法","count":3,"path":"api/tags/悬线法.json"},{"name":"位操作","slug":"位操作","count":3,"path":"api/tags/位操作.json"},{"name":"ZOJ","slug":"ZOJ","count":1,"path":"api/tags/ZOJ.json"}]},{"title":"ccf 2017前四题","slug":"ccf-2017-pre-f","date":"2017-08-19T05:25:33.000Z","updated":"2019-07-03T13:51:36.851Z","comments":true,"path":"api/articles/ccf-2017-pre-f.json","excerpt":"","keywords":null,"cover":null,"content":"<p>第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *<em>要登录和会员 *</em> <a href=\"http://118.190.20.162/home.page\" target=\"_blank\" rel=\"noopener\">http://118.190.20.162/home.page</a> github: :earth_africa:<a href=\"https://github.com/834930269/Other_OJ/tree/master/CCSP/2017-3\" title=\"CCF 2017-3 前四题\" target=\"_blank\" rel=\"noopener\">CCF 2017-3 前四题</a> 第一题:</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n    int N,K;\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;K)){\n        int ans=0,d,n=0;\n        for(int i=0;i&lt;N;++i){\n            scanf(&quot;%d&quot;,&amp;d);\n            n+=d;\n            if(n&gt;=K){\n                n=0;\n                ans++;\n            }\n        }\n        if(n)ans++;\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre><p>第二题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint N,M;\nint I,J;\n\nlist&lt;int&gt; li;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        li.clear();\n        for(int i=1;i&lt;=N;++i){\n            li.push_back(i);\n        }\n        for(int i=1;i&lt;=M;++i){\n            scanf(&quot;%d%d&quot;,&amp;I,&amp;J);\n            if(J==0)continue;\n            list&lt;int&gt;::iterator it,it2;\n            for(it=li.begin();*it!=I;it++){}\n            it2=it;\n            int flag=J&gt;0?1:-1;\n            J=abs(J)+(flag&gt;0?1:0);\n            while(J){\n                J--;\n                flag&gt;0?it++:it--;\n            }\n            li.insert(it,I);\n            li.erase(it2);\n        }\n        list&lt;int&gt;::iterator it;\n        it=li.begin();\n        printf(&quot;%d&quot;,*it);\n        it++;\n        for(;it!=li.end();it++){\n            printf(&quot; %d&quot;,*it);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}</code></pre><p>第三题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\n\n#define BUF_SS 101\n\nusing namespace std;\n\nchar buf[101];\nint pre=-1;\n\nint check_hl(int st){\n    char hr[100];\n    string tip;\n    int ind=st+1,cs=0,hs=0;\n    while(buf[ind]!=&apos;]&apos;){\n        if(buf[ind]==&apos;_&apos;){\n            tip+=&quot;&lt;em&gt;&quot;;\n            ind++;\n            while(buf[ind]!=&apos;_&apos;){\n                tip+=buf[ind];\n                ind++;\n            }\n            tip+=&quot;&lt;/em&gt;&quot;;\n            ind++;\n        }else{\n            tip+=buf[ind];\n            ind++;\n        }\n    }\n    ind+=2;\n    while(buf[ind]!=&apos;)&apos;){\n        hr[hs++]=buf[ind];\n        ind++;\n    }\n    hr[hs]=&apos;\\0&apos;;\n    printf(&quot;&lt;a href=\\&quot;%s\\&quot;&gt;&quot;,hr);\n    cout&lt;&lt;tip&lt;&lt;&quot;&lt;/a&gt;&quot;;\n    return ind-st;\n}\n\nint check_em(int st){\n    int ind=st+1;\n    printf(&quot;&lt;em&gt;&quot;);\n    while(buf[ind]!=&apos;_&apos;){\n        if(buf[ind]==&apos;[&apos;){\n            int ed=check_hl(ind);\n            ind+=(ed+1);\n        }else{\n            putchar(buf[ind]);\n            ind++;\n        }\n    }\n    printf(&quot;&lt;/em&gt;&quot;);\n    return ind-st;\n}\n\nvoid check_h(int sz){\n    int n,r=0;\n    char sts[20],ste[20];\n    while(buf[r]==&apos;#&apos;){\n        r++;\n    }\n    int s=r,e=sz-1;\n    sprintf(sts,&quot;&lt;h%d&gt;&quot;,r);\n    sprintf(ste,&quot;&lt;/h%d&gt;&quot;,r);\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;%s&quot;,sts);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;%s\\n&quot;,ste);\n}\n\nvoid check_u(int sz){\n    if(pre!=2)printf(&quot;&lt;ul&gt;\\n&quot;);\n    int s=1,e=sz-1;\n    for(;buf[s]==&apos; &apos;;s++){}\n    printf(&quot;&lt;li&gt;&quot;);\n    for(int i=s;buf[i]!=&apos;\\n&apos;;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n    printf(&quot;&lt;/li&gt;\\n&quot;);\n}\n\nvoid check_p(int sz){\n    if(pre!=3)printf(&quot;&lt;p&gt;&quot;);\n    if(pre==3)putchar(&apos;\\n&apos;);\n    for(int i=0;buf[i]!=&apos;\\n&apos; &amp;&amp; i&lt;sz;++i){\n        int ed=0;\n        if(buf[i]==&apos;_&apos;) ed=check_em(i);\n        else if(buf[i]==&apos;[&apos;) ed=check_hl(i);\n        else putchar(buf[i]);\n        i+=ed;\n    }\n}\n\nint main(){\n    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);\n    while(fgets(buf,BUF_SS,stdin)){\n        if(buf[0]==&apos;\\n&apos;){\n            if(pre==3){\n                printf(&quot;&lt;/p&gt;\\n&quot;);\n                pre=0;continue;\n            }else if(pre==2){\n                printf(&quot;&lt;/ul&gt;\\n&quot;);\n                pre=0;continue;\n            }\n            continue;\n        }\n        int sz=strlen(buf);\n        if(buf[0]==&apos;#&apos;) check_h(sz),pre=1;\n        else if(buf[0]==&apos;*&apos;) check_u(sz),pre=2;\n        else check_p(sz),pre=3;\n    }\n    if(pre==3)printf(&quot;&lt;/p&gt;\\n&quot;);\n    if(pre==2)printf(&quot;&lt;/ul&gt;\\n&quot;);\n    return 0;\n}</code></pre><p>写题的时候写了一组测试数据: In[1]:</p>\n<pre><code># Heading\n\n## Sub-heading\n\nParagraphs are separated\nby a blank line.\n\nText attributes _italic_.\n\nBullet list:\n\n*      apples\n* oranges\n* pears\n\nA _[NLJ6link616lins1](http://example.com)_.\n\n[NLJ6_link_616_lins_1](http://example.com)</code></pre><p>out[1]:</p>\n<pre><code>&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;h2&gt;Sub-heading&lt;/h2&gt;\n&lt;p&gt;Paragraphs are separated\nby a blank line.&lt;/p&gt;\n&lt;p&gt;Text attributes &lt;em&gt;italic&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Bullet list:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;apples&lt;/li&gt;\n&lt;li&gt;oranges&lt;/li&gt;\n&lt;li&gt;pears&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A &lt;em&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6link616lins1&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;NLJ6&lt;em&gt;link&lt;/em&gt;616&lt;em&gt;lins&lt;/em&gt;1&lt;/a&gt;&lt;/p&gt;</code></pre><p>第四题:</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAX_M=200000+10;\nconst int maxn=200000+10;\nint N,M;\nint A,B,C;\n\nstruct Edge{\n    int from,to,dist;\n};\nstruct HeapNode{\n    int d,from,to;\n    bool operator&lt;(const HeapNode&amp; rhs)const{\n        return d&gt;rhs.d;\n    }\n};\n\nstruct Kruskal{\n    int n,m;///点数和边数\n    vector&lt;Edge&gt; edges;///边表\n    vector&lt;int&gt; G[maxn];///每个节点出发的边编号\n    priority_queue&lt;HeapNode&gt; Q;\n\n    ///并查集\n    int fa[maxn];///父亲\n    int ra[maxn];///高度\n    ///init:初始化(点数)\n    ///find_Root:查找树的根\n    ///unite:合并x和y所属集合\n    ///same:判断x和y是否是同一个集合\n    void init(int n){\n        this-&gt;n=n;\n        for(int i=0;i&lt;n;++i){\n            fa[i]=i;\n            ra[i]=0;\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    int find_Root(int x){\n        if(fa[x]==x){\n            return x;\n        }else{\n            return fa[x]=find_Root(fa[x]);\n        }\n    }\n    void unite(int x,int y){\n        x=find_Root(x);\n        y=find_Root(y);\n        if(x==y) return;\n\n        if(ra[x]&lt;ra[y]){\n            fa[x]=y;\n        }else{\n            fa[y]=x;\n        }\n    }\n    bool same(int x,int y){\n        return find_Root(x)==find_Root(y);\n    }\n\n    void AddEdge(int from,int to,int dist){\n        edges.push_back((Edge){from,to,dist});\n        m=edges.size()-1;\n        G[from].push_back(m-1);\n        Q.push((HeapNode){dist,from,to});\n    }\n\n    int kruskal(){\n        HeapNode h;\n        while(!Q.empty()){\n            if(find_Root(N)==find_Root(1))break;\n            h=Q.top();Q.pop();\n            if(find_Root(h.from)==find_Root(h.to))continue;\n            unite(h.from,h.to);\n        }\n        printf(&quot;%d\\n&quot;,h. d);\n    }\n}K;\n\nint main(){\n    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)){\n        K.init(N);\n        for(int i=0;i&lt;M;++i){\n            scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);\n            K.AddEdge(A,B,C);\n        }\n        K.kruskal();\n    }\n    return 0;\n}</code></pre>","text":"第一题官网挂掉了.第五题感觉可以用最大流搞搞. 类型: 第一题:贪心 第二题:链表(我用STL里的list实现的) 第三题:中等模拟? 第四题:并查集+最小堆优化Kruskal 题目连接: *要登录和会员 * http://118.190.20.162/home.page git","link":"","raw":null,"photos":[],"categories":[{"name":"ccf","slug":"ccf","count":2,"path":"api/categories/ccf.json"},{"name":"kruskal","slug":"ccf/kruskal","count":1,"path":"api/categories/ccf/kruskal.json"},{"name":"并查集","slug":"ccf/kruskal/并查集","count":1,"path":"api/categories/ccf/kruskal/并查集.json"},{"name":"模拟","slug":"ccf/kruskal/并查集/模拟","count":1,"path":"api/categories/ccf/kruskal/并查集/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"并查集","slug":"并查集","count":5,"path":"api/tags/并查集.json"},{"name":"kruskal","slug":"kruskal","count":2,"path":"api/tags/kruskal.json"},{"name":"CCF","slug":"CCF","count":1,"path":"api/tags/CCF.json"}]},{"title":"第七届山东省ACM/ICPC H Memory Leak","slug":"qjsdaihacmicpc-h-memory-leak","date":"2017-04-18T12:25:42.000Z","updated":"2019-07-03T13:51:36.847Z","comments":true,"path":"api/articles/qjsdaihacmicpc-h-memory-leak.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>模拟,感受一下什么叫绝望吧…</strong> <strong>【Tip】</strong> <strong>F</strong>k!…..QNMD鲁棒性….QAQ** <strong>后记…发现自己的代码可以过…但是忘了关freopean..所以才WA…尴尬//= // =//</strong> <strong>【Code】</strong> <strong>鲁棒形比我好,一点的,代码.</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int T;</strong> <strong>char name[10010],stri[10010];</strong> <strong>int num;</strong> <strong>struct Star{</strong> **    char s[2000];** **    char contain[10010];** **    int ind;** **    bool has_end;** <strong>};</strong> <strong>Star S[10010];</strong> <strong>int main(){</strong> ** //   #ifndef DEF** ** //    freopen(“in.txt”,”r”,stdin);** ** //    freopen(“out.txt”,”w”,stdout);** ** //  #endif // DEF** **    scanf(“%d”,&amp;T);** **        while(T–){** **            char op[100],def[10100];** **            num=0;** **            while(scanf(“%s”,op)){** **                if(op[3]==’u’){** **                    scanf(“%<em>s”);*</em> **                    break;** **                }** **                if(op[3]==’r’){** **                    while(scanf(“%s”,def)){** **                        int flag=1,star_num=0,ind_num=0,len=strlen(def);** **                        for(int i=0;i&lt;len;++i){** **                            if(flag==1 &amp;&amp; def[i]!=’[‘){** **                                S[num].s[star_num++]=def[i];** **                            }** **                            if(def[i]==’[‘){** **                                S[num].s[star_num]=0;** **                                flag=2;** **                                continue;** **                            }** **                            if(flag==2 &amp;&amp; def[i]!=’]‘){** **                                ind_num=ind_num<em>10+(def[i]-‘0’);*</em> **                            }** **                            if(def[i]==’]‘){** **                                S[num].contain[0]=0;//初始化** **                                S[num].has_end=true;** **                                S[num].ind=ind_num;** **                                star_num=0;** **                                ind_num=0;** **                                num++;** **                                continue;** **                            }** **                        }** **                        if(def[len-1]==’;’) break;** **                    }** **                }** **                if(op[3]==’s’){** **                    scanf(“%s%<em>c”,name);*</em> **                    gets(stri);** **                    int index=num;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    int len=strlen(stri);** **                    if(len&gt;=S[index].ind){** **                        S[index].has_end=false;** **                        stri[S[index].ind]=0;//‘\\0’** **                    }else S[index].has_end=true;** **                    strcpy(S[index].contain,stri);** **                }** **                if(op[3]==’t’){** **                    scanf(“%s”,name);** **                    int index=num;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    for(int i=index;i&lt;num;++i){** **                        printf(“%s”,S[i].contain);** **                        if(S[i].has_end) break;** **                    }** **                    printf(“\\n”);** **                }** **            }** **        }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n<p><strong>我的代码</strong></p>\n<blockquote>\n<p><strong>#include&lt;bits/stdc++.h&gt;</strong> <strong>#define INF 0x3f3f3f3f</strong> <strong>using namespace std;</strong> <strong>int T;</strong> <strong>char name[10010],stri[10010];</strong> <strong>int num=0;</strong> <strong>struct Star{</strong> **    char s[2000];** **    char contain[10010];** **    int ind;** **    bool has_end;** <strong>};</strong> <strong>Star S[10010];</strong> <strong>int main(){</strong> <strong>//   #ifndef DEF  //&lt;-F</strong>k U** **  //   freopen(“in.txt”,”r”,stdin);** **  //   freopen(“out.txt”,”w”,stdout);** ** //  #endif // DEF** **    scanf(“%d”,&amp;T);** **        while(T–){** **            char op[10],def[10100];** **            num=0;** **            while(scanf(“%s”,op)){** **                scanf(“ “);** **                if(op[3]==’u’){** **                    scanf(“%<em>s”);*</em> **                    break;** **                }** **                if(op[3]==’r’){** **                    int flag=1,star_num=0,ind_num=0;** **                    gets(def);** **                    for(int i=0,start=0;def[i]!=’\\0’;++i){** **                        if(def[i]==’ ‘ || def[i]==’,’) continue;** **                        if(flag==1 &amp;&amp; def[i]!=’[‘){** **                            S[num].s[star_num++]=def[i];** **                        }else if(def[i]==’[‘){** **                            S[num].s[star_num]=0;** **                            flag=2;** **                        }else if(flag==2 &amp;&amp; def[i]!=’]‘){** **                            ind_num=ind_num<em>10+(def[i]-‘0’);*</em> **                        }else if(def[i]==’]‘){** **                            S[num].contain[0]=0;//初始化** **                            S[num].has_end=true;** **                            S[num].ind=ind_num;** **                            star_num=0;** **                            ind_num=0;** **                            num++;** **                            flag=1;** **                        }else if(def[i]==’;’)** **                            break;** **                    }** **                }** **                if(op[3]==’s’){** **                    scanf(“%s%<em>c”,name);*</em> **                    gets(stri);** **                    int index;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    int len=strlen(stri);** **                    if(len&gt;=S[index].ind){** **                        S[index].has_end=false;** **                        stri[S[index].ind]=0;//‘\\0’** **                    }else S[index].has_end=true;** **                    strcpy(S[index].contain,stri);** **                }** **                if(op[3]==’t’){** **                    scanf(“ “);** **                    gets(name);** **                    int index;** **                    for(int i=0;i&lt;num;++i){** **                        if(!strcmp(S[i].s,name))** **                            index=i;** **                    }** **                    for(int i=index;i&lt;num;++i){** **                        printf(“%s”,S[i].contain);** **                        if(S[i].has_end) break;** **                    }** **                    printf(“\\n”);** **                }** **            }** **        }** **    return 0;** <strong>}</strong></p>\n</blockquote>\n","text":"【类型】 模拟,感受一下什么叫绝望吧… 【Tip】 Fk!…..QNMD鲁棒性….QAQ** 后记…发现自己的代码可以过…但是忘了关freopean..所以才WA…尴尬//= // =// 【Code】 鲁棒形比我好,一点的,代码.#include&lt;bits/stdc++.","link":"","raw":null,"photos":[],"categories":[{"name":"Sdut","slug":"Sdut","count":11,"path":"api/categories/Sdut.json"},{"name":"模拟","slug":"Sdut/模拟","count":1,"path":"api/categories/Sdut/模拟.json"},{"name":"第七届ACM山东省赛","slug":"Sdut/模拟/第七届ACM山东省赛","count":1,"path":"api/categories/Sdut/模拟/第七届ACM山东省赛.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"sdut","slug":"sdut","count":11,"path":"api/tags/sdut.json"},{"name":"第七届ACM山东省赛","slug":"第七届ACM山东省赛","count":4,"path":"api/tags/第七届ACM山东省赛.json"}]},{"title":"VJ SWPU-ACM省赛集训赛ONE J Right turn","slug":"vj-swpu-acmne-j-right-turn","date":"2017-04-20T11:04:34.000Z","updated":"2019-07-03T13:51:36.848Z","comments":true,"path":"api/articles/vj-swpu-acmne-j-right-turn.json","excerpt":"","keywords":null,"cover":null,"content":"<p><strong>【类型】</strong> <strong>模拟</strong> <strong>【Tip】</strong> <strong>我的代码感觉上很对…然而莫名其妙总WA.然后把代码改成网上搜的题解的思路,A了…</strong> <strong>我一开始的思路是floyd判圈法,若会碰到同一个路障第二次,则一定无法逃出去.</strong> <strong>这个思路是错的,因为有可能在同一个点转的方向不同,所以如果经过同一个点两次有可能逃出去.</strong> <strong>但每个点最多只能经过三次,第四次时一定是一个圈.所以判断是否经过一个点四次就好了.依然是floyd判圈法.不过要判四次.</strong> <strong>然后成型代码如下.</strong> <strong>【WA Code1】</strong></p>\n<blockquote>\n<p>**`#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long ll;<br>const int INF = 0x3f3f3f3f;</p>\n<p>#define cle(a,val) memset(a,(val),sizeof(a))</p>\n<p>#define SI(N) scanf(“%lld”,&amp;(N))</p>\n<p>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</p>\n<p>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</p>\n<p>#define rep(i,b) for(int i=0;i&lt;(b);i++)</p>\n<p>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</p>\n<p>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)<br>const ll LINF = 0x3f3f3f3f3f3f3f3f;</p>\n<p>#define PU(x) puts(#x);</p>\n<p>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</p>\n<p>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</p>\n<p>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</p>\n<p>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</p>\n<p>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</p>\n<p>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}<br>const double EPS = 1e-9 ;<br>pair&lt;int,int&gt; node;<br>map&lt;pair&lt;int,int&gt;,bool&gt; mp;<br>map&lt;int,vector<int> &gt; EdgeX,EdgeY;<br>int N,X,Y,step;<br>int toward[4]={1,-2,-1,2},t=0;//右下左上</int></p>\n<p>bool floyd(){<br>    X=0,Y=0;<br>    while(1){<br>        if(toward[t]==1){<br>            vector<int>&amp; Just=EdgeY[Y];<br>            int si=Just.size(),flag=0;<br>            rep(i,si){<br>                if(Just[i]&gt;X){<br>                    if(mp[make_pair(Just[i],Y)]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(Just[i],Y)]=true;<br>                    flag=1;<br>                    X=Just[i]-1;<br>                    step++;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==-2){<br>            vector<int>&amp; Just=EdgeX[X];<br>            int si=Just.size(),flag=0;<br>            red(i,si-1,0){<br>                if(Just[i]&lt;Y){<br>                    if(mp[make_pair(X,Just[i])]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(X,Just[i])]=true;<br>                    Y=Just[i]+1;<br>                    step++;<br>                    flag=1;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==-1){<br>            vector<int>&amp; Just=EdgeY[Y];<br>            int si=Just.size(),flag=0;<br>            red(i,si-1,0){<br>                if(Just[i]&lt;X){<br>                    if(mp[make_pair(Just[i],Y)]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(Just[i],Y)]=true;<br>                    flag=1;<br>                    X=Just[i]+1;<br>                    step++;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }else if(toward[t]==2){<br>            vector<int>&amp; Just=EdgeX[X];<br>            int si=Just.size(),flag=0;<br>            rep(i,si){<br>                if(Just[i]&gt;Y){<br>                    if(mp[make_pair(X,Just[i])]) return false;<br>                    t=(t+1)%4;<br>                    mp[make_pair(X,Just[i])]=true;<br>                    Y=Just[i]-1;<br>                    step++;<br>                    flag=1;<br>                    break;<br>                }<br>            }<br>            if(!flag) return true;<br>        }<br>    }<br>}</int></int></int></int></p>\n<p>int main(){<br>    while(~SI(N)){<br>        t=0;<br>        step=0;<br>        mp.clear();<br>        EdgeX.clear();<br>        EdgeY.clear();<br>        rep(i,N){<br>            scanf(“%d%d”,&amp;node.first,&amp;node.second);<br>            mp[node]=false;<br>            EdgeX[node.first].push_back(node.second);<br>            EdgeY[node.second].push_back(node.first);<br>        }<br>        map&lt;int,vector<int> &gt;::iterator it;<br>        for(it=EdgeX.begin();it!=EdgeX.end();it++){<br>            vector<int>&amp; Just=it-&gt;second;<br>            sort(Just.begin(),Just.end());<br>        }<br>        for(it=EdgeY.begin();it!=EdgeY.end();it++){<br>            vector<int>&amp; Just=it-&gt;second;<br>            sort(Just.begin(),Just.end());<br>        }<br>        if(floyd()){<br>            printf(“%d\\n”,step);<br>        }else{<br>            printf(“-1\\n”);<br>        }<br>    }<br>    return 0;<br>}`** </int></int></int></p>\n</blockquote>\n<p><strong>【简单修改后AC代码】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>pair&lt;int,int&gt; node;</strong> <strong>map&lt;pair&lt;int,int&gt;,int&gt; mp;</strong> <strong>map&lt;int,vector<int> &gt; EdgeX,EdgeY;</int></strong> <strong>int N,X,Y,step;</strong> <strong>int toward[4]={1,-2,-1,2},t=0;//右下左上</strong> <strong>bool floyd(){</strong> **    X=0,Y=0;** **    while(1){** **        if(toward[t]==1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;X){** **                    if(mp[make_pair(Just[i],Y)]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(Just[i],Y)]++;** **                    flag=1;** **                    X=Just[i]-1;** **                    step++;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==-2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            red(i,si-1,0){** **                if(Just[i]&lt;Y){** **                    if(mp[make_pair(X,Just[i])]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(X,Just[i])]++;** **                    Y=Just[i]+1;** **                    step++;** **                    flag=1;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==-1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            red(i,si-1,0){** **                if(Just[i]&lt;X){** **                    if(mp[make_pair(Just[i],Y)]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(Just[i],Y)]++;** **                    flag=1;** **                    X=Just[i]+1;** **                    step++;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }else if(toward[t]==2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;Y){** **                    if(mp[make_pair(X,Just[i])]==3) return false;** **                    t=(t+1)%4;** **                    mp[make_pair(X,Just[i])]++;** **                    Y=Just[i]-1;** **                    step++;** **                    flag=1;** **                    break;** **                }** **            }** **            if(!flag) return true;** **        }** **    }** <strong>}</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        t=0;** **        step=0;** **        mp.clear();** **        EdgeX.clear();** **        EdgeY.clear();** **        rep(i,N){** **            scanf(“%d%d”,&amp;node.first,&amp;node.second);** **            mp[node]=0;** **            EdgeX[node.first].push_back(node.second);** **            EdgeY[node.second].push_back(node.first);** **        }** **        map&lt;int,vector<int> &gt;::iterator it;** **        for(it=EdgeX.begin();it!=EdgeX.end();it++){** **            vector<int>&amp; Just=it-&gt;second;** **            sort(Just.begin(),Just.end());** **        }** **        for(it=EdgeY.begin();it!=EdgeY.end();it++){** **            vector<int>&amp; Just=it-&gt;second;** **            sort(Just.begin(),Just.end());** **        }** **        if(floyd()){** **            printf(“%d\\n”,step);** **        }else{** **            printf(“-1\\n”);** **        }** **    }** **    return 0;** <strong>}</strong></int></int></int></int></int></int></int></p>\n</blockquote>\n<p><strong>【跟着题解AC Code】</strong></p>\n<blockquote>\n<p><strong>#include &lt;bits/stdc++.h&gt;</strong> <strong>using namespace std;</strong> <strong>typedef long long ll;</strong> <strong>const int INF = 0x3f3f3f3f;</strong> <strong>#define cle(a,val) memset(a,(val),sizeof(a))</strong> <strong>#define SI(N) scanf(“%lld”,&amp;(N))</strong> <strong>#define SII(N,M) scanf(“%d %d”,&amp;(N),&amp;(M))</strong> <strong>#define SIII(N,M,K) scanf(“%d %d %d”,&amp;(N),&amp;(M),&amp;(K))</strong> <strong>#define rep(i,b) for(int i=0;i&lt;(b);i++)</strong> <strong>#define rez(i,a,b) for(int i=(a);i&lt;=(b);i++)</strong> <strong>#define red(i,a,b) for(int i=(a);i&gt;=(b);i–)</strong> <strong>const ll LINF = 0x3f3f3f3f3f3f3f3f;</strong> <strong>#define PU(x) puts(#x);</strong> <strong>#define PI(A) cout&lt;&lt;(A)&lt;&lt;endl;</strong> <strong>#define DG(x) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;endl;</strong> <strong>#define DGG(x,y) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;endl;</strong> <strong>#define DGGG(x,y,z) cout&lt;&lt;#x&lt;&lt;”=”&lt;&lt;(x)&lt;&lt;” “&lt;&lt;#y&lt;&lt;”=”&lt;&lt;(y)&lt;&lt;” “&lt;&lt;#z&lt;&lt;”=”&lt;&lt;(z)&lt;&lt;endl;</strong> <strong>#define PIar(a,n) rep(i,n)cout&lt;&lt;a[i]&lt;&lt;” “;cout&lt;&lt;endl;</strong> <strong>#define PIarr(a,n,m) rep(aa,n){rep(bb, m)cout&lt;&lt;a[aa][bb]&lt;&lt;” “;cout&lt;&lt;endl;}</strong> <strong>const double EPS = 1e-9 ;</strong> <strong>pair&lt;int,int&gt; node;</strong> <strong>map&lt;pair&lt;int,int&gt;,bool&gt; mp;</strong> <strong>map&lt;int,vector<int> &gt; EdgeX,EdgeY;</int></strong> <strong>int N,X,Y,step;</strong> <strong>int toward[4]={1,-2,-1,2},t=0;//右下左上</strong> <strong>bool floyd(){</strong> **    X=0,Y=0;** **    while(step&lt;=4<em>N+1){*</em> **        int tmpx=-INF,tmpy=-INF;** **        if(toward[t]==1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size();** **            rep(i,si){** **                if(Just[i]&gt;X){** **                    tmpy=Y;** **                    if(tmpx!=-INF) tmpx=min(tmpx,Just[i]);** **                    else tmpx=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** **    //            if(mp[make_pair(tmpx,Y)]) return false;** **     //           mp[make_pair(tmpx,Y)]=true;** **                X=tmpx-1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==-2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&lt;Y){** **                    tmpx=X;** **                    flag=1;** **                    if(tmpy!=-INF) tmpy=max(tmpy,Just[i]);** **                    else tmpy=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** **  //              if(mp[make_pair(X,tmpy)]) return false;** ** //               mp[make_pair(X,tmpy)]=true;** **                Y=tmpy+1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==-1){** **            vector<int>&amp; Just=EdgeY[Y];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&lt;X){** **                    flag=1;** **                    tmpy=Y;** **                    if(tmpx!=-INF) tmpx=max(tmpx,Just[i]);** **                    else tmpx=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** ** //               if(mp[make_pair(tmpx,Y)]) return false;** ** //               mp[make_pair(tmpx,Y)]=true;** **                X=tmpx+1;** **                step++;** **                t=(t+1)%4;** **            }** **        }else if(toward[t]==2){** **            vector<int>&amp; Just=EdgeX[X];** **            int si=Just.size(),flag=0;** **            rep(i,si){** **                if(Just[i]&gt;Y){** **                    tmpx=X;** **                    flag=1;** **                    if(tmpy!=-INF) tmpy=min(tmpy,Just[i]);** **                    else tmpy=Just[i];** **                }** **            }** **            if (tmpx == -INF || tmpy == -INF) return true;** **            else{** ** //              if(mp[make_pair(X,tmpy)]) return false;** **  //              mp[make_pair(X,tmpy)]=true;** **                Y=tmpy-1;** **                step++;** **                t=(t+1)%4;** **            }** **        }** **    }** **    return false;** <strong>}</strong> <strong>int main(){</strong> **    while(~SI(N)){** **        t=0;** **        step=0;** **        mp.clear();** **        EdgeX.clear();** **        EdgeY.clear();** **        rep(i,N){** **            scanf(“%d%d”,&amp;node.first,&amp;node.second);** <strong>//            mp[node]=false;</strong> **            EdgeX[node.first].push_back(node.second);** **            EdgeY[node.second].push_back(node.first);** **        }** **        if(floyd()){** **            printf(“%d\\n”,step);** **        }else{** **            printf(“-1\\n”);** **        }** **    }** **    return 0;** <strong>}</strong></int></int></int></int></p>\n</blockquote>\n","text":"【类型】 模拟 【Tip】 我的代码感觉上很对…然而莫名其妙总WA.然后把代码改成网上搜的题解的思路,A了… 我一开始的思路是floyd判圈法,若会碰到同一个路障第二次,则一定无法逃出去. 这个思路是错的,因为有可能在同一个点转的方向不同,所以如果经过同一个点两次有可能逃出去. ","link":"","raw":null,"photos":[],"categories":[{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/categories/Floyd判圈法.json"},{"name":"VJ","slug":"Floyd判圈法/VJ","count":1,"path":"api/categories/Floyd判圈法/VJ.json"},{"name":"模拟","slug":"Floyd判圈法/VJ/模拟","count":1,"path":"api/categories/Floyd判圈法/VJ/模拟.json"}],"tags":[{"name":"模拟","slug":"模拟","count":9,"path":"api/tags/模拟.json"},{"name":"Floyd判圈法","slug":"Floyd判圈法","count":2,"path":"api/tags/Floyd判圈法.json"},{"name":"VJ","slug":"VJ","count":3,"path":"api/tags/VJ.json"}]}]}