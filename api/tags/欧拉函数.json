{"name":"欧拉函数","slug":"欧拉函数","count":7,"postlist":[{"title":"51nod 1040 最大公约数之和","slug":"51nod-1040-max-gcd-sum","date":"2018-03-04T14:51:10.000Z","updated":"2019-07-03T13:51:36.862Z","comments":true,"path":"api/articles/51nod-1040-max-gcd-sum.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"type欧拉函数gcd性质思维\">Type:欧拉函数,gcd性质,思维</span></h1><h1><span id=\"题目\">题目</span></h1><p>给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15</p>\n<h2><span id=\"input\">Input</span></h2><p>1个数N(N &lt;= 10^9)</p>\n<h2><span id=\"output\">Output</span></h2><p>公约数之和</p>\n<h2><span id=\"input示例\">Input示例</span></h2><p>6</p>\n<h2><span id=\"output示例\">Output示例</span></h2><p>15</p>\n<h2><span id=\"题解\">题解</span></h2><blockquote>\n<p>N&lt;=10^9,所以肯定无法暴力枚举 考虑我们要求 lambda(gcd(i,N) | i∈[1,N])</p>\n<blockquote>\n<p>我们可以知道: 对于每个数N,他的约数范围在[1<del>N]之间,即我们可以将问题转化为(设约数为Ni,1</del>N中约数为Ni个数为Mi):</p>\n<blockquote>\n<p>lambda(Ni*Mi)</p>\n</blockquote>\n<p>假设我们已经得到了Ni,问题就在于我们如何求出Mi 设i为1~N中任意数:</p>\n<blockquote>\n<p>(1) Mi=count(gcd(i,N)=Ni | i∈[1<del>N]) =count(gcd(i/Ni,N/Ni)=1 | i∈[1</del>N])</p>\n<blockquote>\n<p>即我们只需要求出1~N中与N/Ni互素的数的个数即可</p>\n<blockquote>\n<p>即 euler(N/Ni)</p>\n</blockquote>\n</blockquote>\n<p>(2) Mi=euler(N/Ni)</p>\n</blockquote>\n<p>ans=lambda(Ni*euler(N/Ni))</p>\n</blockquote>\n<p>然后有一个小性质,即 i*i&lt;=N时,我们枚举到sqrt(i)同时求出 N/i ,枚举完所有的 i 即枚举完所有 1~N 内 N 的约数.</p>\n</blockquote>\n<h2><span id=\"code\">Code</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nLL N;\n\nLL euler(LL n){\n    LL res=n,a=n;\n    for(LL i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            res=res/i*(i-1);\n            while(a%i==0)a/=i;\n        }\n    }\n    if(a&gt;1)res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    while(~scanf(&quot;%lld&quot;,&amp;N)){\n        LL ans=0;\n        for(LL i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                ans+=(i*euler(N/i));\n                if(i*i!=N){\n                    ans+=((N/i)*euler(i));\n                }\n            }\n        }\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"Type:欧拉函数,gcd性质,思维题目给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6 1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15Input1个数N(N &lt;= 10^9)Output公约数之和Input示例","link":"","raw":null,"photos":[],"categories":[{"name":"51nod","slug":"51nod","count":12,"path":"api/categories/51nod.json"},{"name":"思维","slug":"51nod/思维","count":1,"path":"api/categories/51nod/思维.json"},{"name":"数论","slug":"51nod/思维/数论","count":1,"path":"api/categories/51nod/思维/数论.json"},{"name":"欧拉函数","slug":"51nod/思维/数论/欧拉函数","count":1,"path":"api/categories/51nod/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"51nod","slug":"51nod","count":12,"path":"api/tags/51nod.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"AOJ NTL_1_D Euler's Phi Function & 欧拉函数相关","slug":"aoj-ntl-1-d-eulers-phi-function","date":"2017-11-25T07:35:20.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/aoj-ntl-1-d-eulers-phi-function.json","excerpt":"","keywords":null,"cover":"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg","content":"<p>欧拉函数: 提供1到N中与N互质的数的个数.</p>\n<h2><span id=\"定义和简单性质\">定义和简单性质</span></h2><p>欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. <strong>对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).</strong></p>\n<h3><span id=\"性质\">性质</span></h3><blockquote>\n<p>1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(q-1)</p>\n<blockquote>\n<p>欧拉函数是积性函数,但不是完全积性函数.</p>\n</blockquote>\n</blockquote>\n<p>证明： 函数的积性即： 若m,n互质,则φ(mn)=φ(m)φ(n).由“m,n互质”可知m,n无公因数,所以: φ(m)φ(n)=m(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)·n(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 其中p1,p2,p3…pn为m的质因数,p1’,p2’,p3’…pn’为n的质因数,而m,n无公因数,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 互不相同,所以: p1,p2,p3…pn,p1’,p2’,p3’…pn’ 均为mn的质因数且为mn质因数的全集,所以: φ(mn)=mn(1-1/p1)(1-1/p2)(1-1/p3)…(1-1/pn)(1-1/p1’)(1-1/p2’)(1-1/p3’)…(1-1/pn’) 所以: φ(mn)=φ(m)φ(n). 即φ(mn)=φ(n)*φ(m)只在(n,m)=1时成立(n与m互质).</p>\n<blockquote>\n<p>2.对于一个正整数N的素数幂分解N=P1^q1_P2^q2_…*Pn^qn.</p>\n</blockquote>\n<pre><code>则 φ(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn).</code></pre><blockquote>\n<p>3.除了N=2,φ(N)都是偶数. 4.设N为正整数,∑φ(d)=N (d|N)(d是N的质因数).</p>\n</blockquote>\n<p>根据性质二,我们可以在O(sqrt(n))的时间内暴力求出一个数的欧拉函数值. 如果我们要求1000000以内所有数的欧拉函数,怎么办. 上面的方法复杂度将高达O(N*sqrt(N)). 暴力方法:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int a[10]={2,10,100,1000,5,7,9,11,12,13};\n    for(int i=0;i&lt;10;++i)\n        cout&lt;&lt;euler(a[i])&lt;&lt;endl;\n    return 0;\n}</code></pre><p>结果: <a href=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://be-sunshine.cn/wp-content/uploads/2017/11/523.jpg\" alt></a> 我们可以将这个方法和筛法求素数的想法结合,试用筛法求出1~n内各个数字的euler(n). φ(n)=n_（1-1/p1)(1-1/p2)….(1-1/pk) 其中p1、p2…pk为n的所有素因子(这个素因子是由整数素分得来的)。 比如：φ(12)=12_(1-1/2)(1-1/3)=4。 比如求10以内所有数的φ值：</p>\n<blockquote>\n<p>1.设一数组phi[11]，赋初值phi[1]=1,phi[2]=2…phi[10]=10 2.然后从2开始循环</p>\n<blockquote>\n<p>把2的倍数的φ值<em>(1-1/2)，则phi[2]=2_1/2=1,phi[4]=4_1/2=2,phi[6]=6_1/2=3….； 再是3，3的倍数的φ值</em>(1-1/3)，则phi[3]=3_2/3=2,phi[6]=3*2/3=2，phi[9]=…..； 再5，再7…因为对每个素数都进行如此操作，因此任何一个n都得到了φ(n)=n*（1-1/p1)(1-1/p2)….(1-1/pk)的运算</p>\n</blockquote>\n</blockquote>\n<p>代码如下:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\n///筛法求euler(1)~euler(n)\nconst int maxn=101;\nint euler_1_n[maxn];\n\nvoid a_euler(){\n    euler_1_n[1]=1;\n    for(int i=2;i&lt;maxn;++i) euler_1_n[i]=i;\n    for(int i=2;i&lt;maxn;++i){\n        if(euler_1_n[i]==i){\n            for(int j=i;j&lt;maxn;j+=i){\n                euler_1_n[j]=euler_1_n[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nint main(){\n    a_euler();\n    for(int i=1;i&lt;101;++i)\n        cout&lt;&lt;euler_1_n[i]&lt;&lt;endl;\n\n    return 0;\n}</code></pre><h2><span id=\"aoj-ntl_1_d-eulers-phi-function\">AOJ NTL_1_D Euler’s Phi Function</span></h2><p>这道题数值范围是1e10,没超过int.而且只需要求一个数的euler. O(lgn)暴力即可.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\n///返回euler(n)\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;euler(n)&lt;&lt;endl;\n\n    return 0;\n}</code></pre>","text":"欧拉函数: 提供1到N中与N互质的数的个数.定义和简单性质欧拉函数用希腊字母φ(Phi)表示,φ(N)表示N的欧拉函数. 对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1).性质1.对于素数p,φ(p)=p-1,对于两个素数p,q φ（pq）=(p-1)*(","link":"","raw":null,"photos":[],"categories":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/categories/AOJ.json"},{"name":"数论","slug":"AOJ/数论","count":2,"path":"api/categories/AOJ/数论.json"},{"name":"欧拉函数","slug":"AOJ/数论/欧拉函数","count":1,"path":"api/categories/AOJ/数论/欧拉函数.json"}],"tags":[{"name":"AOJ","slug":"AOJ","count":5,"path":"api/tags/AOJ.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"}]},{"title":"HDU 2588 GCD","slug":"hdu-2588-gcd","date":"2017-11-25T11:45:09.000Z","updated":"2019-07-03T13:51:36.859Z","comments":true,"path":"api/articles/hdu-2588-gcd.json","excerpt":"","keywords":null,"cover":null,"content":"<p>类型: 数论-欧拉函数-折半枚举 原题连接: <a href=\"https://vjudge.net/problem/HDU-2588\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/HDU-2588</a></p>\n<blockquote>\n<p>题意</p>\n<blockquote>\n<p>输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.</p>\n</blockquote>\n<p>题解</p>\n<blockquote>\n<p>首先无法枚举X求GCD(X,N) 我们考虑 (X,N) = (q*d,b*d) 其中d是X,N的最大公约数. 可以知道 b&gt;=q 且 b与q互质①. 所以就转换成了对每个这样的d求 euler(b)(见①) 且 d&gt;=M 的个数. 也就转换成了枚举d求euler(b)之和.但是这仍是O(TNlgN)复杂度的. 所以我们采用折半枚举的做法,因为要枚举的是d,而d*b在sqrt(N)之后就变成了b*d了.所以我们可以只需要枚举sqrt(N)个数,将b,d都看做b即可.</p>\n</blockquote>\n</blockquote>\n<p>Code:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint euler(int n){\n    int res=n,a=n;\n    for(int i=2;i*i&lt;=a;++i){\n        if(a%i==0){\n            ///φ(N)=N*(1-1/P1)*(1-1/P2)...其中P是素因子\n            res=res/i*(i-1);//先进行除法方为了预防溢出\n            while(a%i==0) a/=i;\n        }\n    }\n    if(a&gt;1) res=res/a*(a-1);\n    return res;\n}\n\nint main(){\n    int T;\n    scanf(&quot;%d&quot;,&amp;T);\n    for(int i=0;i&lt;T;++i){\n        int ans=0;\n        int N,M;\n        scanf(&quot;%d%d&quot;,&amp;N,&amp;M);\n        for(int i=1;i*i&lt;=N;++i){\n            if(N%i==0){\n                if(i&gt;=M)\n                    ans+=euler(N/i);\n                if((N/i)!=i &amp;&amp; (N/i)&gt;=M)\n                ///如果==i且&gt;=M的话证明i&gt;=M,而不需要计算两次,所以排除掉\n                    ans+=euler(i);\n            }\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n    return 0;\n}</code></pre>","text":"类型: 数论-欧拉函数-折半枚举 原题连接: https://vjudge.net/problem/HDU-2588题意输入N,M,对于每个 X (1=&lt;X&lt;=N)判断是否 GCD(X,N)&gt;=M,输出有多少这样的X.题解首先无法枚举X求GCD(X,N) 我们考","link":"","raw":null,"photos":[],"categories":[{"name":"HDU","slug":"HDU","count":12,"path":"api/categories/HDU.json"},{"name":"数论","slug":"HDU/数论","count":1,"path":"api/categories/HDU/数论.json"},{"name":"欧拉函数","slug":"HDU/数论/欧拉函数","count":1,"path":"api/categories/HDU/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"HDU","slug":"HDU","count":14,"path":"api/tags/HDU.json"}]},{"title":"POJ 2407","slug":"poj-2407","date":"2018-02-12T09:09:54.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2407.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/POJ-2407\" title=\"https://vjudge.net/problem/POJ-2407\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2407</a></p>\n<h1><span id=\"type-欧拉函数\">Type: 欧拉函数</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>求小于n 且与n互质的数的个数</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>简单欧拉,但因为是十亿的数据量,所以不能预处理</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint phi(int n){\n    int ans=n;\n    for(int i=2;i*i&lt;=n;++i){\n        if(n%i==0){\n            ans=ans-ans/i;\n            while(n%i==0){\n                n/=i;\n            }\n        }\n    }\n    if(n&gt;1){\n        ans=ans-ans/n;\n    }\n    return ans;\n}\n\nint main(){\n    int n;\n    while(cin&gt;&gt;n&amp;&amp;n){\n        cout&lt;&lt;phi(n)&lt;&lt;endl;\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2407Type: 欧拉函数题意求小于n 且与n互质的数的个数题解简单欧拉,但因为是十亿的数据量,所以不能预处理Code#include&lt;cstdio&gt;#include&lt;algorithm&g","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 2478","slug":"poj-2478","date":"2018-02-12T09:44:15.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-2478.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/POJ-2478\" title=\"https://vjudge.net/problem/POJ-2478\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-2478</a></p>\n<h1><span id=\"type-欧拉函数\">Type: 欧拉函数</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5} 其中分子与分母互质.</p>\n<blockquote>\n<p>目标是求Fn中的最简分数有多少个</p>\n</blockquote>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>仔细观察会发现因为所有分数分子分母都是互素的 设n为分母,相同分母n的最简分数的个数就等于与n互质的数的个数. 分母从2开始计数</p>\n<blockquote>\n<p>答案就是2~n的phi(k)的和</p>\n<blockquote>\n<p>注意和斐波那契一样,Farey序列也会超过long long</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000000+100;\nLL phi[maxn];\nLL Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(LL i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(LL j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n;\n    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){\n        printf(&quot;%lld\\n&quot;,Farey[n]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-2478Type: 欧拉函数题意F2 = {1/2} F3 = {1/3, 1/2, 2/3} F4 = {1/4, 1/3, 1/2, 2/3, 3/4} F5 = {1/5, 1/4, 1/3, 2/5, ","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"POJ 3090","slug":"poj-3090","date":"2018-02-12T11:54:27.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/poj-3090.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/POJ-3090\" title=\"https://vjudge.net/problem/POJ-3090\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/POJ-3090</a></p>\n<h1><span id=\"type-欧拉函数\">Type: 欧拉函数</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原题转换成该范围内有多少个点的 x与y互质</p>\n<blockquote>\n<p>这个与poj2478这道题求法一样,有一点不同的是,(x,y)存在的同时也会存在(y,x) 并且会同时存在(1,0)(0,1)(1,1)这三个点,所以答案是</p>\n</blockquote>\n<p>Farey[n]*2+3</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1000+100;\nint phi[maxn];\nint Farey[maxn];\n\n\ninline void phi_table(){\n    memset(phi,0,sizeof(phi));\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]-phi[j]/i;\n            }\n        }\n    }\n}\n\ninline void init(){\n    phi_table();\n    memset(Farey,0,sizeof(Farey));\n    for(int i=2;i&lt;maxn;++i){\n        Farey[i]=Farey[i-1]+phi[i];\n    }\n}\n\nint main(){\n    init();\n    int n,kase=1,t;\n    scanf(&quot;%d&quot;,&amp;t);\n    while(t--){\n        scanf(&quot;%d&quot;,&amp;n);\n        printf(&quot;%d %d %d\\n&quot;,kase++,n,Farey[n]*2+3);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/POJ-3090Type: 欧拉函数题意第一象限的点(x,y),给定一个N,问你,(0,0)~(N,N)范围中有多少连接原点且连线上没有整数坐标的点?题解想到如果两个数互质,则他与原点的连线上,必然没有整数点. 然后原","link":"","raw":null,"photos":[],"categories":[{"name":"POJ","slug":"POJ","count":21,"path":"api/categories/POJ.json"},{"name":"数论","slug":"POJ/数论","count":3,"path":"api/categories/POJ/数论.json"},{"name":"欧拉函数","slug":"POJ/数论/欧拉函数","count":3,"path":"api/categories/POJ/数论/欧拉函数.json"}],"tags":[{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"POJ","slug":"POJ","count":22,"path":"api/tags/POJ.json"}]},{"title":"UVa 11426","slug":"uva-11426","date":"2018-02-12T08:37:59.000Z","updated":"2019-07-03T13:51:36.861Z","comments":true,"path":"api/articles/uva-11426.json","excerpt":"","keywords":null,"cover":null,"content":"<h1><span id=\"link\">Link</span></h1><p><a href=\"https://vjudge.net/problem/UVA-11426\" title=\"https://vjudge.net/problem/UVA-11426\" target=\"_blank\" rel=\"noopener\">https://vjudge.net/problem/UVA-11426</a></p>\n<h1><span id=\"type-数论欧拉函数递推思维\">Type: 数论,欧拉函数,递推,思维</span></h1><h1><span id=\"题意\">题意</span></h1><blockquote>\n<p>输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n∈[1,4000000]</p>\n</blockquote>\n<h1><span id=\"题解\">题解</span></h1><blockquote>\n<p>首先我们应该清楚</p>\n<blockquote>\n<p>4000000的数据,用暴力 - 对每个gcd求值相加复杂度是i*j*O(gcd) 你懂就行,这么大的复杂度肯定爆炸.</p>\n</blockquote>\n<p>所以我们第一想法肯定是预处理.</p>\n<blockquote>\n<p>我们设 f(n) 为 (1,n)+(2,n)+(3,n)+…+(n-1,n) 则 S(n)=f(1)+f(2)+…+f(n)</p>\n<blockquote>\n<p>通过这个公式我们就可以递推出所有的 S(n)</p>\n<blockquote>\n<p>S(n)=S(n-1)+f(n)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>然后我们的问题就转化成了求f(n)</p>\n<blockquote>\n<p>首先我们会自然地想到,与n互素的答案是1.即(k,n)的结果都是n的约数</p>\n<blockquote>\n<p>我们可以按照这个约数来进行分类, 用 g(n,i)表示满足gcd(x,n)=i 且 x\\&lt;n 的正整数x的个数 则: f(n)=Sum(i*g(n,i) | i是n的约数,g(n,i)是1~n中gcd(k,n)=i的k的个数)</p>\n<blockquote>\n<p>然后我们注意到: -gcd(x,n)=i -则gcd(x/i,n/i)=1 -即x/i与n/i互质</p>\n</blockquote>\n<p>然后我们就可以将 g(n,i) 看做1~n中与 n/i 互质的数的个数,即</p>\n</blockquote>\n<p>g(n,i) = phi(n/i) 然后我们预处理phi[maxn],预处理完以后处理f(n),这里如果用二重循环依然是接受不了的 所以我们沿用筛法的思想对f[maxn]数组进行预处理,遇到i 是 k 的约数时,直接f[k]+=(i*phi[n/i])</p>\n</blockquote>\n<p>最后预处理S[maxn]即可</p>\n</blockquote>\n<h1><span id=\"code\">Code</span></h1><pre><code>/*\n我们要求:\nG=Sigma(i=1~N) Sigma(j=i+1~N) GCD(i,j)\nN&lt;=4000000，这样的范围二次循环+GCD肯定是不行的\n所以我们考虑\nf(n)=Sigma(i=1~n-1) gcd(i,n)\n则\nG(n)=Sigma(i=1~n) f(i)\n=G(n-1)+f(n)\n所以我们的问题转换为如何求f(n)\n\n即k都是n的约数\n可以按照约数进行分类,用g(n,i)表示满足 (x,n)=i且x&lt;n的正整数x的个数\n则 f(n)=sum(i\\*g(n,i)|i是n的约数)\n\n再重提: g(n,i)代表满足(x,n)=i,且x&lt;n的正整数x的个数\n\n我们知道,如果 (a,n)=k\n则 (a/k,n/k)=1\n\n所以我们可以理解为g(n,i)代表的是x/i与n/i互质的数的个数\n即满足条件的x/i 有 phi(n/i)个\ng(n,i)=phi(n/i)\n*/\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long LL;\nconst int maxn=4000000+10;\nLL phi[maxn];\n\nLL f[maxn];\n\nLL g[maxn];\nvoid phi_table(){\n    for(int i=2;i&lt;maxn;++i) phi[i]=0;\n    phi[1]=1;\n    for(int i=2;i&lt;maxn;++i){\n        if(!phi[i]){\n            for(int j=i;j&lt;maxn;j+=i){\n                if(!phi[j]) phi[j]=j;\n                phi[j]=phi[j]/i*(i-1);\n            }\n        }\n    }\n}\n\nvoid init(){\n    phi_table();\n    memset(f,0,sizeof(f));\n    for(int i=1;i&lt;maxn;++i){\n        for(int j=i*2;j&lt;maxn;j+=i){\n            f[j]+=(i*phi[j/i]);\n        }\n    }\n    memset(g,0,sizeof(g));\n    for(int i=1;i&lt;maxn;++i) g[i]=g[i-1]+f[i];\n}\n\nint main(){\n    init();\n    int k;\n    while(~scanf(&quot;%d&quot;,&amp;k) &amp;&amp; k){\n        printf(&quot;%lld\\n&quot;,g[k]);\n    }\n    return 0;\n}</code></pre>","text":"Linkhttps://vjudge.net/problem/UVA-11426Type: 数论,欧拉函数,递推,思维题意输入正整数n,求gcd(1,2)+gcd(1,3)+gcd(2,3)+gcd(1,4)+…+gcd(n-1,n) 保证输出不超过long long 范围: n","link":"","raw":null,"photos":[],"categories":[{"name":"UVa","slug":"UVa","count":35,"path":"api/categories/UVa.json"},{"name":"思维","slug":"UVa/思维","count":4,"path":"api/categories/UVa/思维.json"},{"name":"数论","slug":"UVa/思维/数论","count":1,"path":"api/categories/UVa/思维/数论.json"},{"name":"欧拉函数","slug":"UVa/思维/数论/欧拉函数","count":1,"path":"api/categories/UVa/思维/数论/欧拉函数.json"}],"tags":[{"name":"思维","slug":"思维","count":17,"path":"api/tags/思维.json"},{"name":"数论","slug":"数论","count":28,"path":"api/tags/数论.json"},{"name":"欧拉函数","slug":"欧拉函数","count":7,"path":"api/tags/欧拉函数.json"},{"name":"UVa","slug":"UVa","count":39,"path":"api/tags/UVa.json"}]}]}